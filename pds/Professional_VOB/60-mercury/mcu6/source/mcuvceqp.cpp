/*****************************************************************************
   模块名      : mcu
   文件名      : mcuvceqp.cpp
   相关文件    : mcuvc.h
   文件实现功能: MCU业务交换函数
   作者        : 胡昌威
   版本        : V2.0  Copyright(C) 2001-2002 KDC, All rights reserved.
-----------------------------------------------------------------------------
   修改记录:
   日  期      版本        修改人      修改内容
   2003/08/06  2.0         胡昌威      创建
   2003/12/17  3.0         zmy         修该码流适配器部分
   2005/02/19  3.6         万春雷      级联修改、与3.5版本合并                                    
******************************************************************************/

/*lint -save -e427*/
/*lint -save -e527*/
/*lint -save -e529*/

#include "evmcumcs.h"
#include "evmcumt.h"
#include "evmcueqp.h"
#include "evmcu.h"
#include "evmcutest.h"
#include "mcuvc.h"
#include "mcsssn.h"
//#include "mcuerrcode.h"
#include "mtadpssn.h"

//#include "mpmanager.h"

// [9/8/2010 liuxu] 添加是否是会议录像的宏判断
// 功能：判断是否是会议录像
#define IS_RECORD_CONF(tMt) ((tMt.GetEqpId() == 0) ? TRUE : FALSE)  

/*------------------------------------------------------------------*/
/*                                Common                            */
/*------------------------------------------------------------------*/

/*====================================================================
    函数名      ：DaemonProcMcsMcuGetPeriEqpStatusReq
    功能        ：查询外设状态请求处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/20    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::DaemonProcMcsMcuGetPeriEqpStatusReq( const CMessage * pcMsg )
{
    CServMsg	cServMsg( pcMsg->content, pcMsg->length );
    TEqp		*ptEqp = ( TEqp * )cServMsg.GetMsgBody();
    TPeriEqpStatus	tEqpStatus;
    TPeriDcsStatus  tDcsStatus;
    
    /*
    //not belong to this MCU, nack
    if( !ptEqp->IsLocal() )
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong! The specified periequipment not belong to this MCU!\n" );
        cServMsg.SetErrorCode( ERR_MCU_VISIT_NONCONNEQP );
        SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
        return;
    }
    */

    //其他外设
    if ( MCS_MCU_GETPERIDCSSTATUS_REQ != pcMsg->event )
    {
        //ERR_MCU_WRONGEQP
        if (ptEqp->GetEqpId() == 0 || ptEqp->GetEqpId() > MAXNUM_MCU_PERIEQP)
        {
            ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong! The specified periequipment id.%d invaild!\n", ptEqp->GetEqpId());
            cServMsg.SetErrorCode(ERR_MCU_WRONGEQP);
            SendReplyBack(cServMsg, cServMsg.GetEventId() + 2);
            return;
        }
        
        //not online
        if( !g_cMcuVcApp.IsPeriEqpConnected( ptEqp->GetEqpId() ) )
        {
            memcpy( &tEqpStatus, ptEqp, sizeof( TEqp ) );
            tEqpStatus.m_byOnline = FALSE;
        }
        else
        {
			g_cMcuVcApp.GetPeriEqpStatus( ptEqp->GetEqpId(), &tEqpStatus );
        }
        
        //send ack
        cServMsg.SetMsgBody( ( u8 * )&tEqpStatus, sizeof( tEqpStatus ) );
        SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
    }
    //DCS
    else
    {
        //ERR_MCU_WRONGDCS
        if (ptEqp->GetEqpId() == 0 || ptEqp->GetEqpId() > MAXNUM_MCU_DCS)
        {
            ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong! The specified peri dcs id.%d invaild!\n", ptEqp->GetEqpId());
            cServMsg.SetErrorCode(ERR_MCU_WRONGEQP);
            SendReplyBack(cServMsg, cServMsg.GetEventId() + 2);
            return;
        }
        
        //not online
        if( !g_cMcuVcApp.IsPeriDcsConnected(ptEqp->GetEqpId()) )
        {
            memcpy( &tDcsStatus, ptEqp, sizeof( TEqp ) );
            tDcsStatus.m_byOnline = FALSE;
        }
        else
        {
            g_cMcuVcApp.GetPeriDcsStatus( ptEqp->GetEqpId(), &tDcsStatus );
        }
        
        //send ack
        cServMsg.SetMsgBody( ( u8 * )&tDcsStatus, sizeof( tDcsStatus ) );
        SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
    }
}

/*====================================================================
    函数名      DaemonProc8KEPeriEqpMcuStatusNotif
    功能        ：8000E外设状态上报
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    09/12/22				薛亮          创建
====================================================================*/
void CMcuVcInst::DaemonProc8KEPeriEqpMcuStatusNotif(const CMessage * pcMsg)
{
	CServMsg cServMsg(pcMsg->content, pcMsg->length);

//	T8KEPeriEqpStatus  tStatus = *(T8KEPeriEqpStatus *)cServMsg.GetMsgBody();

    TPeriEqpStatus tStatus = *(TPeriEqpStatus *)cServMsg.GetMsgBody();
    
    if (!tStatus.IsLocal() ||
        tStatus.GetEqpId() == 0 || tStatus.GetEqpId() > MAXNUM_MCU_PERIEQP)
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[PeriEqpStatusNotif]TPeriEqpStatus content error! GetMcuId() = %d GetEqpId() = %d\n",
			tStatus.GetMcuId(), tStatus.GetEqpId());
        return;
    }

    TEqp tEqp = (TEqp)tStatus;
	
    TPeriEqpStatus tOldStatus;
    memset(&tOldStatus, 0, sizeof(TPeriEqpStatus));
	
	BOOL32 bNotifNPlus = FALSE;

    u16 wEvent = pcMsg->event;
    switch (wEvent)
    {
    case VMP_MCU_VMPSTATUS_NOTIF:
        {
            // [12/21/2009 xliang]  业务自身维护vmp状态(m_tVMPParam, confidx, use status), 仅别名参考外设上报的
//			TPeriEqpStatus tStatus = *(TPeriEqpStatus *)cServMsg.GetMsgBody();

            g_cMcuVcApp.SetEqpAlias(tEqp.GetEqpId(), tStatus.GetAlias());
            g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tOldStatus);
			
            BOOL32 bIsFirstConnect = ( 0 == tOldStatus.m_byOnline ) ? TRUE : FALSE;
            tOldStatus.SetAlias( tStatus.GetAlias() );
            tEqp.SetConfIdx( ((TEqp)tOldStatus).GetConfIdx() );
            memcpy( &tOldStatus, &tEqp, sizeof(tEqp) );

#if defined(_8KH_)
			tOldStatus.m_tStatus.tVmp.m_bySubType = VMP_8KH; // [2/26/2010 xliang] 强赋子类型
#elif defined(_8KE_)
            tOldStatus.m_tStatus.tVmp.m_bySubType = VMP_8KE; // [2/26/2010 xliang] 强赋子类型
#elif defined(_8KI_)
            tOldStatus.m_tStatus.tVmp.m_bySubType = VMP_8KI; // 强赋子类型
#endif
            tOldStatus.m_tStatus.tVmp.m_byChlNum = MAXNUM_SDVMP_MEMBER;
			//tOldStatus.m_tStatus.tVmp.m_tVMPParam = tStatus.m_tStatus.tVmp.m_tVMPParam;
            //tOldStatus.m_tStatus.tVmp.m_byUseState = tStatus.m_tStatus.tVmp.m_byUseState;
            g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tOldStatus);
            if ( bIsFirstConnect )
            {
				bNotifNPlus = TRUE;
                g_cMcuVcApp.SetPeriEqpConnected(tEqp.GetEqpId(), TRUE);
				
                CServMsg cTempServMsg;
                cTempServMsg.SetMsgBody( (u8*)&tEqp, sizeof(tEqp) );
                g_cMcuVcApp.BroadcastToAllConf(MCU_VMPCONNECTED_NOTIF, cTempServMsg.GetServMsg(), cTempServMsg.GetServMsgLen());
            }
        }
        break;

	case MIXER_MCU_MIXERSTATUS_NOTIF:
		{
// 			TMixerGrpStatus tOldMixerGrpStatus;
// 			g_cMcuVcApp.GetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus);
// 			
// 			for (u8 byLoop = 0; byLoop < tStatus.m_tStatus.tMixer.m_byGrpNum; byLoop++)
// 			{
// 				tOldMixerGrpStatus = tOldStatus.m_tStatus.tMixer.m_atGrpStatus[byLoop];
// 				tStatus.m_tStatus.tMixer.m_atGrpStatus[byLoop].m_byGrpId = tOldMixerGrpStatus.m_byGrpId;
// 				tStatus.m_tStatus.tMixer.m_atGrpStatus[byLoop].m_byGrpMixDepth = tOldMixerGrpStatus.m_byGrpMixDepth;
// 				//tStatus.m_tStatus.tMixer.m_atGrpStatus[byLoop].m_byGrpState = tOldMixerGrpStatus.m_byGrpState;
// 				tStatus.m_tStatus.tMixer.m_atGrpStatus[byLoop].m_byConfId = tOldMixerGrpStatus.m_byConfId;
// 			}
// 			
// 			g_cMcuVcApp.SetPeriEqpStatus(tStatus.GetEqpId(), &tStatus);

//			g_cMcuVcApp.SetEqpAlias(tEqp.GetEqpId(), tStatus.GetAlias());
            
            g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tOldStatus);
            BOOL32 bIsFirstConnect = ( 0 == tOldStatus.m_byOnline ) ? TRUE : FALSE;
            
			tOldStatus.SetAlias( tStatus.GetAlias() );
            tEqp.SetConfIdx( ((TEqp)tOldStatus).GetConfIdx() );
            memcpy( &tOldStatus, &tEqp, sizeof(tEqp) );
            
            tOldStatus.m_tStatus.tMixer.m_byGrpNum = tStatus.m_tStatus.tMixer.m_byGrpNum;
			TMixerGrpStatus t8KEMixerGrpStatus;
			u8 byConfIdx = 0;
            for ( u8 byGrpIdx = 0; byGrpIdx < min(tOldStatus.m_tStatus.tMixer.m_byGrpNum,MAXNUM_MIXER_GROUP); byGrpIdx++ )
            {
// 				T8KEMixerGrpStatus t8KEMixerGrpStatus = tStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpIdx];
				t8KEMixerGrpStatus = tStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpIdx];
			//	if(TMixerGrpStatus::IDLE == t8KEMixerGrpStatus.m_byGrpState)
				tOldStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpIdx].m_byGrpState = t8KEMixerGrpStatus.m_byGrpState/*TMixerGrpStatus::READY*/; 
				byConfIdx = tOldStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpIdx].m_byConfId;
				//u8 byIsReserved = tOldStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpIdx].m_byIsReserved;
				tOldStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpIdx].m_byGrpId = t8KEMixerGrpStatus.m_byGrpId;
				tOldStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpIdx].m_byGrpMixDepth = t8KEMixerGrpStatus.m_byGrpMixDepth;
				tOldStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpIdx].m_byConfId = byConfIdx;
				tOldStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpIdx].m_byMixGrpChnNum = t8KEMixerGrpStatus.m_byMixGrpChnNum;
				//tOldStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpIdx].m_byIsReserved = byIsReserved;

                
            }
            g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tOldStatus);

            if ( bIsFirstConnect )
            {
                g_cMcuVcApp.SetPeriEqpConnected(tEqp.GetEqpId(), TRUE);
                
                CServMsg cTempServMsg;
                cTempServMsg.SetMsgBody( (u8*)&tEqp, sizeof(tEqp) );
                g_cMcuVcApp.BroadcastToAllConf(MCU_MIXERCONNECTED_NOTIF, cTempServMsg.GetServMsg(), cTempServMsg.GetServMsgLen());
            }           
		}
		break;

	case BAS_MCU_BASSTATUS_NOTIF:   
        {
			
            g_cMcuVcApp.SetEqpAlias(tEqp.GetEqpId(), tStatus.GetAlias());
            
            g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tOldStatus);
            BOOL32 bIsFirstConnect = ( 0 == tOldStatus.m_byOnline ) ? TRUE : FALSE;

			u8 byChnType = *(u8*)(cServMsg.GetMsgBody() + sizeof(TPeriEqpStatus));

			if (bIsFirstConnect)
			{
				//  [1/25/2011 chendaiwei]
				bNotifNPlus = TRUE;

				tOldStatus.SetAlias( tStatus.GetAlias() );
				tOldStatus.SetMcuEqp( (u8)tStatus.GetMcuId(), tStatus.GetEqpId(), tEqp.GetEqpType() );
#ifdef _8KE_
				tOldStatus.m_tStatus.tHdBas.SetEqpType(TYPE_8KE_BAS);
#endif

#ifdef _8KH_
				tOldStatus.m_tStatus.tHdBas.SetEqpType(TYPE_8KH_BAS);
#endif	



				tEqp.SetConfIdx( ((TEqp)tOldStatus).GetConfIdx() );				
				memcpy( &tOldStatus, &tEqp, sizeof(tEqp) );
			    tOldStatus.m_byOnline = tStatus.m_byOnline;
				

				

#ifdef _8KI_
				if( BAS_8KICHN0 == byChnType || 
					BAS_8KICHN1 == byChnType ||
					BAS_8KICHN2 == byChnType
					)
				{
					tOldStatus.m_tStatus.tHdBas.SetEqpType(TYPE_8KI_VID_BAS);
				}
				else if( BAS_8KIAUDCHN == byChnType )
				{
					tOldStatus.m_tStatus.tAudBas.SetEqpType(TYPE_8KI_AUD_BAS);
				}				
#endif


#ifdef _8KE_
				if ( NULL != tOldStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0) &&
					TBasBaseChnStatus::IDLE == tOldStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0)->GetStatus()
					)
				{		
					tOldStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0)->SetStatus(TBasBaseChnStatus::READY);
					tOldStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0)->SetEqp(tEqp);
					tOldStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0)->SetChnIdx(0);
					tOldStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0)->SetType(byChnType);
				}
#endif


#ifdef _8KH_
				if ( NULL != tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0) &&
					TBasBaseChnStatus::IDLE == tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->GetStatus()
					)
				{		
					tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->SetStatus(TBasBaseChnStatus::READY);
					tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->SetEqp(tEqp);
					tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->SetChnIdx(0);
					tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->SetType(byChnType);
				}
#endif	

#ifdef _8KI_
				if ( ( BAS_8KICHN0 == byChnType || 
						BAS_8KICHN1 == byChnType ||
						BAS_8KICHN2 == byChnType ) &&
						NULL != tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0) &&
					TBasBaseChnStatus::IDLE == tOldStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(0)->GetStatus()
					)
				{		
					tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->SetStatus(TBasBaseChnStatus::READY);
					tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->SetEqp(tEqp);
					tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->SetChnIdx(0);
					tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->SetType(byChnType);
				}
				if( BAS_8KIAUDCHN == byChnType )
				{
					u8 byChlIdx = *(u8*)(cServMsg.GetMsgBody() + sizeof(TPeriEqpStatus) + sizeof(u8));
					tOldStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChlIdx)->SetIsReserved(FALSE);
					tOldStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChlIdx)->SetStatus( TBasBaseChnStatus::READY );						
					tOldStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChlIdx)->ClrOutputAudParam();
					tOldStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChlIdx)->SetChnIdx(byChlIdx);
					
				}
#endif	
				//bas通道类型
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[DaemonProc8KEPeriEqpMcuStatusNotif] ChnType is %d!\n", byChnType);

			}
			else
			{
				//外设状态改变
#ifdef _8KE_
				if ( NULL !=tStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0) )
				{
					u8 byChnState = tStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0)->GetStatus();
					tOldStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(0)->SetStatus(byChnState);
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[DaemonProc8KEPeriEqpMcuStatusNotif] 8kebas<EqpId:%d>'s CurState:%d!\n", tStatus.GetEqpId(), byChnState);
				}
#endif	
				
#ifdef _8KH_
				if ( NULL !=tStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0) )
				{
					u8 byChnState = tStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->GetStatus();
					tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->SetStatus(byChnState);
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[DaemonProc8KEor8KHPeriEqpMcuStatusNotif] 8khbas<EqpId:%d>'s CurState:%d!\n", tStatus.GetEqpId(), byChnState);
				}
#endif	

#ifdef _8KI_
				

				if( ( BAS_8KICHN0 == byChnType || 
						BAS_8KICHN1 == byChnType ||
						BAS_8KICHN2 == byChnType ) &&
						NULL !=tStatus.m_tStatus.tHdBas.tStatus.t8kiBas.GetVidChnStatus(0) )
				{
					u8 byChnState = tStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->GetStatus();
					tOldStatus.m_tStatus.tHdBas.tStatus.t8khBas.GetVidChnStatus(0)->SetStatus(byChnState);
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[DaemonProc8KEor8KHPeriEqpMcuStatusNotif] 8kibas<EqpId:%d>'s CurState:%d!\n", tStatus.GetEqpId(), byChnState);
				}
				if( BAS_8KIAUDCHN == byChnType )
				{					
					u8 byChlIdx = *(u8*)(cServMsg.GetMsgBody() + sizeof(TPeriEqpStatus) + sizeof(u8));
					u8 byChnState = tStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChlIdx)->GetStatus();
					tOldStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChlIdx)->SetStatus( byChnState );					
					tOldStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChlIdx)->ClrOutputAudParam();
					tOldStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChlIdx)->SetIsReserved(FALSE);
					tOldStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_t8KIAudBasStatus.GetAudChnStatus(byChlIdx)->SetChnIdx(byChlIdx);
				}
#endif	
			}			
            g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tOldStatus);

			u8 byChlId = 0;
			if( BAS_8KIAUDCHN == byChnType )
			{
				byChlId = *(u8*)(cServMsg.GetMsgBody() + sizeof(TPeriEqpStatus) + sizeof(u8));
			}
			
			//添加结点
			g_cMcuVcApp.AddMcuBasChnlInfo(tEqp, 0);

            if ( bIsFirstConnect )
            {
                g_cMcuVcApp.SetPeriEqpConnected(tEqp.GetEqpId(), TRUE);
                
                CServMsg cTempServMsg;
                cTempServMsg.SetMsgBody( (u8*)&tEqp, sizeof(tEqp) );
                g_cMcuVcApp.BroadcastToAllConf(MCU_BASCONNECTED_NOTIF, cTempServMsg.GetServMsg(), cTempServMsg.GetServMsgLen());
            } 
        }
		break;

	default:
		break;
	}

	//status notification
    g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tOldStatus);
    cServMsg.SetMsgBody((u8 *)&tOldStatus, sizeof(tOldStatus));
    SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);


	if ( ( VMP_MCU_VMPSTATUS_NOTIF == pcMsg->event ||
		BAS_MCU_BASSTATUS_NOTIF == pcMsg->event ) &&
		g_cNPlusApp.GetLocalNPlusState() == MCU_NPLUS_MASTER_CONNECTED)
    {
		if ( bNotifNPlus )
        {
			//组织packed EqpCap数据[1/11/2012 chendaiwei]
			//按照目前pack方式，pack后Buffer最大值
			u8 abyBuffer[NPLUS_PACK_EXINFO_BUF_LEN] = {0};
			u16 wLen = 0;
			g_cNPlusApp.PackNplusExInfo(g_cNPlusApp.GetMcuEqpCapEx(),abyBuffer,wLen);			

			TNPlusEqpCap tEqpCap = g_cNPlusApp.GetMcuEqpCap();
			cServMsg.SetEventId(MCU_NPLUS_EQPCAP_NOTIF);
			cServMsg.SetMsgBody((u8 *)&tEqpCap, sizeof(tEqpCap));
			cServMsg.CatMsgBody((u8*)&abyBuffer[0],wLen);
			g_cNPlusApp.PostMsgToNPlusDaemon(VC_NPLUS_MSG_NOTIF, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
		}
    }
	
	//[2011/08/27/zhangli]8kebas状态通知
	if (BAS_MCU_BASSTATUS_NOTIF == pcMsg->event)
    {
		g_cMcuVcApp.BroadcastToAllConf(pcMsg->event, pcMsg->content, pcMsg->length);
    }
}

/*====================================================================
    函数名      ：DaemonProcPeriEqpMcuStatusNotif
    功能        ：外设状态上报
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/10    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::DaemonProcPeriEqpMcuStatusNotif(const CMessage * pcMsg)
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
    TPeriEqpStatus tStatus = *(TPeriEqpStatus *)cServMsg.GetMsgBody();

    if (!tStatus.IsLocal() ||
        tStatus.GetEqpId() == 0 || tStatus.GetEqpId() > MAXNUM_MCU_PERIEQP)
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[PeriEqpStatusNotif]TPeriEqpStatus content error! GetMcuId() = %d GetEqpId() = %d\n",
        tStatus.GetMcuId(), tStatus.GetEqpId());
        return;
    }

    TPeriEqpStatus tOldStatus;
    memset(&tOldStatus, 0, sizeof(TPeriEqpStatus));
 //   TPeriEqpStatus tNewHduStatus = tStatus;
	// 通知N+1备份机, zgc, 2008-04-07
	BOOL32 bNotifNPlus = FALSE;

    if (VMP_MCU_VMPSTATUS_NOTIF == pcMsg->event ||
        VMPTW_MCU_VMPTWSTATUS_NOTIF == pcMsg->event)
    {
		//alias //fixme-- zw
		if ( g_cMcuAgent.IsSVmp( tStatus.GetEqpId() ) )
		{				
			TEqpSvmpInfo tEqpSvmpInfo;
			g_cMcuAgent.GetEqpSvmpCfgById( tStatus.GetEqpId(), &tEqpSvmpInfo );
			
			tStatus.SetAlias( tEqpSvmpInfo.GetAlias() );
		}
		
        g_cMcuVcApp.GetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus);
        if (tOldStatus.IsNull())
        {
            g_cMcuVcApp.SetPeriEqpStatus(tStatus.GetEqpId(), &tStatus);
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP,  "VMP.%u sub type is:%u\n",tStatus.GetEqpId(),tStatus.m_tStatus.tVmp.m_bySubType);
			//ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP,  "VMP.%u Version is:%u\n", tStatus.GetEqpId(), tStatus.m_tStatus.tVmp.m_byBoardVer);
			// 通知N+1备份机, zgc, 2008-04-07
			bNotifNPlus = TRUE;
        }
        else
        {
			// 通知N+1备份机, zgc, 2008-04-07
			if ( tOldStatus.m_tStatus.tVmp.m_byChlNum != tStatus.m_tStatus.tVmp.m_byChlNum )
			{
				bNotifNPlus = TRUE;
			}
	
            tOldStatus.m_tStatus.tVmp.m_byChlNum = tStatus.m_tStatus.tVmp.m_byChlNum;
            tOldStatus.SetAlias(tStatus.GetAlias());

			tOldStatus.SetEqpType(tStatus.GetEqpType());// xliang [2/12/2009]确保eqptype值统一，解决HDVMP bug
			tOldStatus.m_tStatus.tVmp.m_bySubType = tStatus.m_tStatus.tVmp.m_bySubType;//子类型 
			tOldStatus.m_tStatus.tVmp.m_byBoardVer = tStatus.m_tStatus.tVmp.m_byBoardVer;	//A/B板区分
			tStatus = tOldStatus;
            g_cMcuVcApp.SetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus);

			ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP,  "VMP.%u sub type is:%u\n",tStatus.GetEqpId(),tStatus.m_tStatus.tVmp.m_bySubType);
			//ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "VMP.%u Version is:%u\n", tStatus.GetEqpId(), tStatus.m_tStatus.tVmp.m_byBoardVer);
        }
    }
    else if (TVWALL_MCU_STATUS_NOTIF == pcMsg->event)
    {
		
        u8 byMtConfIdx;
        g_cMcuVcApp.GetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus);
        for (u8 byLoop = 0; byLoop < min(tStatus.m_tStatus.tTvWall.byChnnlNum,MAXNUM_PERIEQP_CHNNL); byLoop++)
        {
            if (tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType != 0)
            {
				//zjj20090911 因为外设发来的状态会把下级终端转换成本地的下级mcu在本地的终端,
				//vcs会议中在电视墙中的终端的状态就会不对，所以这里不转换
						
				if( !tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop].IsLocal() ||
					TW_MEMBERTYPE_NULL != tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType
					/*
					TW_MEMBERTYPE_VCSSPEC == tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType ||
					TW_MEMBERTYPE_VCSAUTOSPEC == tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType ||
					TW_MEMBERTYPE_MCSSPEC     == tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType ||
					TW_MEMBERTYPE_CHAIRMAN    == tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType ||
					*/
					)
				{
					tStatus.m_tStatus.tTvWall.atVideoMt[byLoop] =
						tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop];
				}
                tStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType = 
                                tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType;

                byMtConfIdx = tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop].GetConfIdx();
                tStatus.m_tStatus.tTvWall.atVideoMt[byLoop].SetConfIdx(byMtConfIdx);

				
            }
			else
			{
				tStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType = 
                                tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType;
				tStatus.m_tStatus.tTvWall.atVideoMt[byLoop] = tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop];
				tStatus.m_tStatus.tTvWall.atVideoMt[byLoop].SetConfIdx( 
											tOldStatus.m_tStatus.tTvWall.atVideoMt[byLoop].GetConfIdx()
											);
			}

        }
        g_cMcuVcApp.SetPeriEqpStatus(tStatus.GetEqpId(), &tStatus);
    }
    else if (HDU_MCU_STATUS_NOTIF == pcMsg->event)    //4.6 jlb
    {
		u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(tStatus.GetEqpId()));
		if (0 == byHduChnNum)
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[DaemonProcPeriEqpMcuStatusNotif] GetHduChnNumAcd2Eqp failed!\n");
			return;
		}

        memset(&tOldStatus, 0, sizeof(tOldStatus));
        g_cMcuVcApp.GetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus);
        for(u8 byLoop = 0; byLoop < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byLoop++)
        {
			// [2013/03/11 chenbing] 如果当前为四风格则保存四风格的参数 
			if ( HDU_MODEFOUR_MAX_SUBCHNNUM == tStatus.m_tStatus.tHdu.GetChnMaxVmpMode(byLoop)
				&& HDUCHN_MODE_FOUR == tOldStatus.m_tStatus.tHdu.GetChnCurVmpMode(byLoop))
			{
				BOOL32 bIsMtInHduVmp = FALSE;
				for (u8 bySubChnId = 0; bySubChnId < HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnId++)
				{
					if (THduChnStatus::eIDLE == tOldStatus.m_tStatus.tHdu.GetChnStatus(byLoop, bySubChnId))
					{
						tOldStatus.m_tStatus.tHdu.SetChnStatus(byLoop, bySubChnId, THduChnStatus::eREADY);
					}
				}

				memcpy((void*)&tStatus.m_tStatus.tHdu, (void*)&tOldStatus.m_tStatus.tHdu, sizeof(THduStatus));
			}
			else
			{
				if (tOldStatus.m_tStatus.tHdu.atVideoMt[byLoop].byMemberType != 0)
				{
					tStatus.m_tStatus.tHdu.atVideoMt[byLoop] = tOldStatus.m_tStatus.tHdu.atVideoMt[byLoop];
				}
				tStatus.m_tStatus.tHdu.atHduChnStatus[byLoop] = tOldStatus.m_tStatus.tHdu.atHduChnStatus[byLoop];
				tStatus.m_tStatus.tHdu.atHduChnStatus[byLoop].SetChnIdx( byLoop );
				if (THduChnStatus::eIDLE == tOldStatus.m_tStatus.tHdu.GetChnStatus(byLoop))
				{
					tStatus.m_tStatus.tHdu.atHduChnStatus[byLoop].SetStatus(THduChnStatus::eREADY);	
				}
				// [2013/03/11 chenbing] 设置HDU最大支持的风格 
				tStatus.m_tStatus.tHdu.SetChnMaxVmpMode(byLoop, tStatus.m_tStatus.tHdu.GetChnMaxVmpMode(byLoop));
				//会议号存在，则保留
				if (0 != tOldStatus.m_tStatus.tHdu.GetConfIdx(byLoop))
				{
					tStatus.m_tStatus.tHdu.SetConfIdx(tOldStatus.m_tStatus.tHdu.GetConfIdx(byLoop), byLoop);
				}
			}
	    }
		tStatus.m_tStatus.tHdu.SetChnnlNum(tOldStatus.m_tStatus.tHdu.GetChnnlNum());
		
		if( tStatus.GetEqpType() == 13 || /*EQP_TYPE_HDU_H兼容*/
			tStatus.GetEqpType() == 14 || /*EQP_TYPE_HDU_L兼容*/
			tStatus.GetEqpType() == 15 || /*EQP_TYPE_HDU2兼容*/
			tStatus.GetEqpType() == 12 )  /*EQP_TYPE_HDU2_L兼容*/
		{
			tStatus.SetEqpType(EQP_TYPE_HDU);
		}

		g_cMcuVcApp.SetPeriEqpStatus(tStatus.GetEqpId(), &tStatus);
    }
    else if (MIXER_MCU_MIXERSTATUS_NOTIF == pcMsg->event)
    {
        TMixerGrpStatus tOldMixerGrpStatus;
        g_cMcuVcApp.GetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus);

        for (u8 byLoop = 0; byLoop < min(tStatus.m_tStatus.tMixer.m_byGrpNum,MAXNUM_MIXER_GROUP); byLoop++)
        {
            tOldMixerGrpStatus = tOldStatus.m_tStatus.tMixer.m_atGrpStatus[byLoop];
            tStatus.m_tStatus.tMixer.m_atGrpStatus[byLoop].m_byGrpId = tOldMixerGrpStatus.m_byGrpId;
            tStatus.m_tStatus.tMixer.m_atGrpStatus[byLoop].m_byGrpMixDepth = tOldMixerGrpStatus.m_byGrpMixDepth;
            tStatus.m_tStatus.tMixer.m_atGrpStatus[byLoop].m_byGrpState = tOldMixerGrpStatus.m_byGrpState;
            tStatus.m_tStatus.tMixer.m_atGrpStatus[byLoop].m_byConfId = tOldMixerGrpStatus.m_byConfId;
        }
		
		if(tStatus.GetEqpType() == 12) //原EQP_TYPE_EMIXER值为12，此处兼容V4R7以前EAPU版本[2/15/2012 chendaiwei]
		{
			tStatus.SetEqpType(EQP_TYPE_MIXER);
		}

        g_cMcuVcApp.SetPeriEqpStatus(tStatus.GetEqpId(), &tStatus);
    }
    else if (PRS_MCU_PRSSTATUS_NOTIF == pcMsg->event)
    {
        TPeriEqpStatus tOldPrsStatus;
        g_cMcuVcApp.GetPeriEqpStatus(tStatus.GetEqpId(), &tOldPrsStatus);

        // 顾振华 [6/14/2006] 恢复是否保留 IsReserved 字段。本字段归MCU管理，Prs不知情
        for (u8 byLoop = 0; byLoop < MAXNUM_PRS_CHNNL; byLoop ++)
        {
            tStatus.m_tStatus.tPrs.m_tPerChStatus[byLoop].  \
                SetReserved( tOldPrsStatus.m_tStatus.tPrs.m_tPerChStatus[byLoop].IsReserved() );
			//恢复每个通道服务的会议Idx, zgc, 2007/04/24
			tStatus.m_tStatus.tPrs.SetChnConfIdx( byLoop, tOldPrsStatus.m_tStatus.tPrs.GetChnConfIdx( byLoop ) );
        }

        g_cMcuVcApp.SetPeriEqpStatus(tStatus.GetEqpId(), &tStatus);
    }
	else if( REC_MCU_RECSTATUS_NOTIF == pcMsg->event )
	{
		TRecChnnlStatus tChlStatus;
		TRecChnnlStatus tOldChlStatus;
		g_cMcuVcApp.GetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus); 
		
		//  [5/17/2013 guodawei] 别名UTF8转换
#ifdef _UTF8
		if (g_cMcuVcApp.GetEqpCodeFormat(tStatus.GetEqpId()) == emenCoding_GBK)
		{
			s8 achUTF8Alias[MAXLEN_EQP_ALIAS] = {0};
			gb2312_to_utf8(tStatus.GetAlias(), achUTF8Alias, sizeof(achUTF8Alias) - 1);
			achUTF8Alias[MAXLEN_EQP_ALIAS - 1] = '\0';
			tStatus.SetAlias(achUTF8Alias);
		}
#endif
		//  [5/30/2013 guodawei] 录像通道
		for (u8 byIndex = 0; byIndex < tStatus.m_tStatus.tRecorder.GetRecChnnlNum(); byIndex++)
		{
			if (tStatus.m_tStatus.tRecorder.GetChnnlStatus(byIndex,TRecChnnlStatus::TYPE_RECORD, &tChlStatus ))
			{
#ifdef _UTF8
				if (g_cMcuVcApp.GetEqpCodeFormat(tStatus.GetEqpId()) == emenCoding_GBK)
				{
					s8 achUTF8RecordName[MAXLEN_RECORD_NAME] = {0};
					gb2312_to_utf8(tChlStatus.GetRecordName(), achUTF8RecordName, sizeof(achUTF8RecordName) - 1);
					achUTF8RecordName[MAXLEN_RECORD_NAME - 1] = '\0';
					tChlStatus.SetRecordName(achUTF8RecordName);
					tStatus.m_tStatus.tRecorder.SetChnnlStatus(byIndex, TRecChnnlStatus::TYPE_RECORD, &tChlStatus);
				}
#endif
			}
		}
		
		//  [5/30/2013 guodawei] 放像通道
		for( u8 byIdx = 0; byIdx < tStatus.m_tStatus.tRecorder.GetPlayChnnlNum(); byIdx++ )
		{
			if( tStatus.m_tStatus.tRecorder.GetChnnlStatus( byIdx,TRecChnnlStatus::TYPE_PLAY,&tChlStatus ) )
			{
				//  [5/17/2013 guodawei] 放像通道文件名UTF8转换
#ifdef _UTF8
				if (g_cMcuVcApp.GetEqpCodeFormat(tStatus.GetEqpId()) == emenCoding_GBK)
				{
					s8 achUTF8PlayName[MAXLEN_RECORD_NAME] = {0};
					gb2312_to_utf8(tChlStatus.GetRecordName(), achUTF8PlayName, sizeof(achUTF8PlayName) - 1);
					achUTF8PlayName[MAXLEN_RECORD_NAME - 1] = '\0';
					tChlStatus.SetRecordName(achUTF8PlayName);
					tStatus.m_tStatus.tRecorder.SetChnnlStatus(byIdx,TRecChnnlStatus::TYPE_PLAY,&tChlStatus);
				}
#endif
				if( tOldStatus.m_tStatus.tRecorder.GetChnnlStatus( byIdx,TRecChnnlStatus::TYPE_PLAY,&tOldChlStatus ) )
				{
					tChlStatus.m_tSrc = tOldChlStatus.m_tSrc;
					tStatus.m_tStatus.tRecorder.SetChnnlStatus(byIdx,TRecChnnlStatus::TYPE_PLAY,&tChlStatus);
				}			
			}
		}
		
		//  [5/30/2013 guodawei] 保存最新
		g_cMcuVcApp.SetPeriEqpStatus(tStatus.GetEqpId(), &tStatus);
	}
    else
    {
		if ( g_cMcuAgent.IsEqpBasAud( tStatus.GetEqpId() ) )
		{
			g_cMcuVcApp.GetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus);
			tOldStatus.SetMcuEqp( (u8)tStatus.GetMcuId(), tStatus.GetEqpId(), tStatus.GetEqpType() );
			tOldStatus.m_byOnline = tStatus.m_byOnline;
			tOldStatus.SetAlias( tStatus.GetAlias() );
			tOldStatus.m_tStatus.tAudBas.SetEqpType(TYPE_APU2_BAS);
			g_cMcuVcApp.SetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus);	
		}
        //[2011/09/01/zhangli]注册后，VPU状态改变为READY
        else 
		{
			if ( !g_cMcuAgent.IsEqpBasHD( tStatus.GetEqpId() ) )
			{
				//[2011/09/01/zhangli]设置VPU状态
				g_cMcuVcApp.GetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus);
				
				for (u8 byChnIdx = 0; byChnIdx < tStatus.m_tStatus.tBas.byChnNum; ++byChnIdx)
				{
					if (tOldStatus.m_tStatus.tBas.tChnnl[byChnIdx].IsReserved())
					{
					}
					
					if (TBasChnStatus::IDLE == tOldStatus.m_tStatus.tBas.tChnnl[byChnIdx].GetStatus()
						|| (TBasChnStatus::READY == tOldStatus.m_tStatus.tBas.tChnnl[byChnIdx].GetStatus()))
					{
						tStatus.m_tStatus.tBas.tChnnl[byChnIdx].SetStatus(TBasChnStatus::READY);
					}
				}
				
				g_cMcuVcApp.SetPeriEqpStatus(tStatus.GetEqpId(), &tStatus);
			}
			else
			{
				//高清适配器的状态通知只有EQP,是否在线和别名是有效的, zgc, 2008-09-03
				//TPeriEqpStatus tOldStatus;
				g_cMcuVcApp.GetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus);
				tOldStatus.SetMcuEqp( (u8)tStatus.GetMcuId(), tStatus.GetEqpId(), tStatus.GetEqpType() );
				tOldStatus.m_byOnline = tStatus.m_byOnline;
				tOldStatus.SetAlias( tStatus.GetAlias() );
				
				//还有mau类型
				if (tOldStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus()->IsReserved() ||
					tOldStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus()->IsReserved())
				{
					if (tOldStatus.m_tStatus.tHdBas.GetEqpType() != tStatus.m_tStatus.tHdBas.GetEqpType())
					{
						tOldStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus()->SetIsReserved(FALSE);
						tOldStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus()->SetIsReserved(FALSE);
					}
				}
				if (TBasBaseChnStatus::IDLE == tOldStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus()->GetStatus())
				{
					tOldStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus()->SetStatus(TBasBaseChnStatus::READY);
				}
				if (TBasBaseChnStatus::IDLE == tOldStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus()->GetStatus())
				{
					tOldStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus()->SetStatus(TBasBaseChnStatus::READY);
				}
				//当MCU回mau注册ack后，mau上报的状态有问题，重新读配置文件设置bas类型
#ifdef _8KI_
				tOldStatus.m_tStatus.tHdBas.SetEqpType(TYPE_MPU2_BASIC);
				g_cMcuVcApp.SetPeriEqpConnected( tStatus.GetEqpId(), TRUE );
#else	
				TEqpBasHDInfo tInfo;
				g_cMcuAgent.GetEqpBasHDCfg(tStatus.GetEqpId(), &tInfo);
				tOldStatus.m_tStatus.tHdBas.SetEqpType(tInfo.GetHDBasType());//tStatus.m_tStatus.tHdBas.GetEqpType());	
#endif
				
				g_cMcuVcApp.SetPeriEqpStatus(tStatus.GetEqpId(), &tOldStatus);
			}
		// 通知N+1备份机
		}
		
		bNotifNPlus = TRUE;
    }


    cServMsg.SetMsgBody((u8 *)&tStatus, sizeof(tStatus));


	SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);

	// zgc 2008-04-02 N+1模式下通知主mcu外设能力
    // zgc 2008-08-08 增加通知高清适配(目前暂时注销)
    if ( VMP_MCU_VMPSTATUS_NOTIF == pcMsg->event &&
		 BAS_MCU_BASSTATUS_NOTIF == pcMsg->event &&
         HDBAS_MCU_BASSTATUS_NOTIF == pcMsg->event && 
		g_cNPlusApp.GetLocalNPlusState() == MCU_NPLUS_MASTER_CONNECTED)
    {
		if ( bNotifNPlus )
        {
			TNPlusEqpCap tEqpCap = g_cNPlusApp.GetMcuEqpCap();
			
			//组织packed EqpCap数据[1/11/2012 chendaiwei]
			//按照目前pack方式，pack后Buffer最大值
			u8 abyBuffer[NPLUS_PACK_EXINFO_BUF_LEN] = {0};
			u16 wLen = 0;
			g_cNPlusApp.PackNplusExInfo(g_cNPlusApp.GetMcuEqpCapEx(),abyBuffer,wLen);

			cServMsg.SetEventId(MCU_NPLUS_EQPCAP_NOTIF);
			cServMsg.SetMsgBody((u8 *)&tEqpCap, sizeof(tEqpCap));
			cServMsg.CatMsgBody((u8*)&abyBuffer[0],wLen);
			g_cNPlusApp.PostMsgToNPlusDaemon(VC_NPLUS_MSG_NOTIF, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
		}
    }

    g_cMcuVcApp.BroadcastToAllConf(pcMsg->event, pcMsg->content, pcMsg->length);

    return;
}

/*====================================================================
    函数名      ：DaemonProcMcuEqpConnectedNotif
    功能        ：外设注册成功处理
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/10    1.0         LI Yi         创建
	10/02/25	4.6			薛亮		  整合8000E	
====================================================================*/
void CMcuVcInst::DaemonProcMcuEqpConnectedNotif(const CMessage * pcMsg)
{
	// [2/25/2010 xliang] notes：该函数处理MCU_EQPCONNECTED_NOTIF消息。这里并没有用编译宏分支进不同函数处理，
	// 因为8000E 会有8000A 的HDU的存在。
	// 这里用消息体进行区分。
	BOOL32 b8keEqp = TRUE;

    CServMsg cServMsg(pcMsg->content, pcMsg->length);

	if( cServMsg.GetMsgBodyLen() ==  sizeof(TPeriEqpRegReq) )
	{
		b8keEqp = FALSE;
	}

	// [2/25/2010 xliang] 8KE 外设处理---------------------------------------------------------------
	if(b8keEqp)
	{
		TEqpRegReq tRegReq = *(TEqpRegReq *)cServMsg.GetMsgBody();
		u32 dwMcuRecvIp = *(u32*)(cServMsg.GetMsgBody()+sizeof(TEqpRegReq));
		u16 wMcuStartPort = *(u16*)(cServMsg.GetMsgBody()+sizeof(TEqpRegReq)+sizeof(u32));
		u16 wEqpStartPort = *(u16*)(cServMsg.GetMsgBody()+sizeof(TEqpRegReq)+sizeof(u32)+sizeof(u16));

		TLogicalChannel tLogicalChannel;

		//not connected periequipment
		/*
		if (!tRegReq.IsLocal())
		{
			return;
		}
		*/

		//得到接收外设数据的Mp地址
		u32 dwRecvIpAddr = ntohl(dwMcuRecvIp);

		wEqpStartPort = ntohs(wEqpStartPort);
		wMcuStartPort = ntohs(wMcuStartPort);

		//设置前向视频通道
		tLogicalChannel.m_tRcvMediaChannel.SetIpAddr(tRegReq.GetEqpIpAddr());
		tLogicalChannel.m_tRcvMediaChannel.SetPort( wEqpStartPort );
		tLogicalChannel.m_tRcvMediaCtrlChannel.SetIpAddr(tRegReq.GetEqpIpAddr());
		tLogicalChannel.m_tRcvMediaCtrlChannel.SetPort(wEqpStartPort+1);
		tLogicalChannel.m_tSndMediaCtrlChannel.SetIpAddr(dwRecvIpAddr);	//设0交换时绑定用
		tLogicalChannel.m_tSndMediaCtrlChannel.SetPort(wEqpStartPort+1);
		g_cMcuVcApp.SetPeriEqpLogicChnnl(tRegReq.GetEqpId(), MODE_VIDEO,
										 0, &tLogicalChannel, TRUE);

		//设置前向音频通道
		//对于PRS而言，一个PRS可支持多个音视频通道(默认总共16个),
		//各通道接收端口统一为PRS起始接收端口，以通道号区分实际的接收端口
		if (EQP_TYPE_PRS == tRegReq.GetEqpType())
		{
			tLogicalChannel.m_tRcvMediaChannel.SetIpAddr( tRegReq.GetEqpIpAddr() );
			tLogicalChannel.m_tRcvMediaChannel.SetPort(wEqpStartPort);
			tLogicalChannel.m_tRcvMediaCtrlChannel.SetIpAddr( tRegReq.GetEqpIpAddr() );
			tLogicalChannel.m_tRcvMediaCtrlChannel.SetPort(wEqpStartPort+1);
			tLogicalChannel.m_tSndMediaCtrlChannel.SetIpAddr( dwRecvIpAddr );	//设0交换时绑定用
			tLogicalChannel.m_tSndMediaCtrlChannel.SetPort(wEqpStartPort+1);
		}
		else
		{
			tLogicalChannel.m_tRcvMediaChannel.SetIpAddr( tRegReq.GetEqpIpAddr() );
			tLogicalChannel.m_tRcvMediaChannel.SetPort(wEqpStartPort+2);
			tLogicalChannel.m_tRcvMediaCtrlChannel.SetIpAddr( tRegReq.GetEqpIpAddr() );
			tLogicalChannel.m_tRcvMediaCtrlChannel.SetPort(wEqpStartPort+3);
			tLogicalChannel.m_tSndMediaCtrlChannel.SetIpAddr( dwRecvIpAddr );	//设0交换时绑定用
			tLogicalChannel.m_tSndMediaCtrlChannel.SetPort(wEqpStartPort+3);
		}       

		g_cMcuVcApp.SetPeriEqpLogicChnnl(tRegReq.GetEqpId(), MODE_AUDIO,
										 0, &tLogicalChannel, TRUE);

		// [12/18/2009 xliang] 设置外设ip. 接口有隐患，废除之
		// 	u32 dwIpAddr = tRegReq.GetEqpIpAddr();
		//  g_cMcuVcApp.SetEqpIp(tRegReq.GetEqpId(), dwIpAddr);


		//设置连接状态
		//对VMP，bas，mixer特殊处理：连接状态等设置不再此处处理，而是等待VMP/MIXER/BAS 第一次上报状态后
		if ( tRegReq.GetEqpType() != EQP_TYPE_VMP &&
			 tRegReq.GetEqpType() != EQP_TYPE_BAS &&
			 tRegReq.GetEqpType() != EQP_TYPE_MIXER)
		{
			g_cMcuVcApp.SetPeriEqpConnected(tRegReq.GetEqpId(), TRUE);
			g_cMcuVcApp.SetEqpAlias(tRegReq.GetEqpId(), tRegReq.GetEqpAlias());
//			TEqp tEqp = (TEqp)tRegReq;
//			g_cMcuVcApp.SetEqp( tEqp.GetEqpId(), tEqp );
		}

		//通知所有会议
		switch(tRegReq.GetEqpType())
		{
			//这里对MIXER，VMP，bas进行如下流程，上线通知不由这里发给会议，而是在外设第一次上报状态是发送
			//其余外设暂不处理
		case EQP_TYPE_PRS:
			g_cMcuVcApp.BroadcastToAllConf(MCU_PRSCONNECTED_NOTIF, pcMsg->content, pcMsg->length);
			break;
		default:
			break;
		}
	

		return;
	}

	// [2/25/2010 xliang] 非8KE外设的流程-----------------------------
    TPeriEqpRegReq tRegReq = *(TPeriEqpRegReq *)cServMsg.GetMsgBody();
    TLogicalChannel tLogicalChannel;

    //not connected periequipment
    if ( !tRegReq.IsLocal() )
    {
        return;
    }

    //得到接收外设数据的Mp地址
    u32 dwRecvIpAddr;
    u32 dwEqpAddr;
    u16 wRecvPort;
    TEqp tEqp = (TEqp)tRegReq;
    g_cMpManager.GetSwitchInfo(tEqp, dwRecvIpAddr, wRecvPort, dwEqpAddr);
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL, "[DaemonProcMcuEqpConnectedNotif] MP RecvPort is %d\n",wRecvPort);

    //设置前向视频通道
    tLogicalChannel.m_tRcvMediaChannel.SetIpAddr(ntohl(tRegReq.GetPeriEqpIpAddr()));
    tLogicalChannel.m_tRcvMediaChannel.SetPort(tRegReq.GetStartPort());
    tLogicalChannel.m_tRcvMediaCtrlChannel.SetIpAddr(ntohl(tRegReq.GetPeriEqpIpAddr()));
    tLogicalChannel.m_tRcvMediaCtrlChannel.SetPort(tRegReq.GetStartPort() + 1);
    tLogicalChannel.m_tSndMediaCtrlChannel.SetIpAddr(dwRecvIpAddr);	//设0交换时绑定用
    tLogicalChannel.m_tSndMediaCtrlChannel.SetPort(tRegReq.GetStartPort() + 1);
    g_cMcuVcApp.SetPeriEqpLogicChnnl(tRegReq.GetEqpId(), MODE_VIDEO,
                                     tRegReq.GetChnnlNum(), &tLogicalChannel, TRUE);

    u32 dwIpAddr = tRegReq.GetPeriEqpIpAddr();
    g_cMcuVcApp.SetEqpIp(tRegReq.GetEqpId(), dwIpAddr);

    //设置前向音频通道
    //对于PRS而言，一个PRS可支持多个音视频通道(默认总共16个),
    //各通道接收端口统一为PRS起始接收端口，以通道号区分实际的接收端口
    if (EQP_TYPE_PRS == tRegReq.GetEqpType())
    {
        tLogicalChannel.m_tRcvMediaChannel.SetIpAddr( ntohl(tRegReq.GetPeriEqpIpAddr()) );
        tLogicalChannel.m_tRcvMediaChannel.SetPort( tRegReq.GetStartPort() );
        tLogicalChannel.m_tRcvMediaCtrlChannel.SetIpAddr( ntohl(tRegReq.GetPeriEqpIpAddr()) );
        tLogicalChannel.m_tRcvMediaCtrlChannel.SetPort( tRegReq.GetStartPort() + 1 );
        tLogicalChannel.m_tSndMediaCtrlChannel.SetIpAddr( dwRecvIpAddr );	//设0交换时绑定用
        tLogicalChannel.m_tSndMediaCtrlChannel.SetPort( tRegReq.GetStartPort() + 1 );
    }
    else
    {
        tLogicalChannel.m_tRcvMediaChannel.SetIpAddr( ntohl(tRegReq.GetPeriEqpIpAddr()) );
        tLogicalChannel.m_tRcvMediaChannel.SetPort( tRegReq.GetStartPort() + 2 );
        tLogicalChannel.m_tRcvMediaCtrlChannel.SetIpAddr( ntohl(tRegReq.GetPeriEqpIpAddr()) );
        tLogicalChannel.m_tRcvMediaCtrlChannel.SetPort( tRegReq.GetStartPort() + 3 );
        tLogicalChannel.m_tSndMediaCtrlChannel.SetIpAddr( dwRecvIpAddr );	//设0交换时绑定用
        tLogicalChannel.m_tSndMediaCtrlChannel.SetPort( tRegReq.GetStartPort() + 3 );
    }       
    g_cMcuVcApp.SetPeriEqpLogicChnnl(tRegReq.GetEqpId(), MODE_AUDIO,
                                     tRegReq.GetChnnlNum(), &tLogicalChannel, TRUE);

    //设置连接状态
    g_cMcuVcApp.SetPeriEqpConnected(tRegReq.GetEqpId(), TRUE);
    g_cMcuVcApp.SetEqpAlias(tRegReq.GetEqpId(), tRegReq.GetEqpAlias());

    //通知所有会议
    switch(tRegReq.GetEqpType())
    {
    case EQP_TYPE_MIXER:
		{
			TPeriEqpStatus tPeriEqpStatus;
			g_cMcuVcApp.GetPeriEqpStatus( tRegReq.GetEqpId(), &tPeriEqpStatus );
			if (tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byGrpState != TMixerGrpStatus::IDLE)
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[DaemonProcMcuEqpConnectedNotif]MIXER(%d) STATE(%d)\n",
				tRegReq.GetEqpId(),tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byGrpState);
			}
			else
			{
				tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byGrpState = TMixerGrpStatus::READY;
			}
			g_cMcuVcApp.SetPeriEqpStatus( tRegReq.GetEqpId(), &tPeriEqpStatus );
			g_cMcuVcApp.BroadcastToAllConf(MCU_MIXERCONNECTED_NOTIF, pcMsg->content, pcMsg->length);
			break;
		}
    case EQP_TYPE_BAS:
        g_cMcuVcApp.BroadcastToAllConf(MCU_BASCONNECTED_NOTIF, pcMsg->content, pcMsg->length);
        break;
    case EQP_TYPE_PRS:
        g_cMcuVcApp.BroadcastToAllConf(MCU_PRSCONNECTED_NOTIF, pcMsg->content, pcMsg->length);
        break;
    case EQP_TYPE_TVWALL:   //tvwall2
        g_cMcuVcApp.BroadcastToAllConf(MCU_TVWALLCONNECTED_NOTIF, pcMsg->content, pcMsg->length);
        break;
    case EQP_TYPE_RECORDER:
        g_cMcuVcApp.BroadcastToAllConf(MCU_RECCONNECTED_NOTIF, pcMsg->content, pcMsg->length);
        break;
    case EQP_TYPE_VMP:   //vmp
        g_cMcuVcApp.BroadcastToAllConf(MCU_VMPCONNECTED_NOTIF, pcMsg->content, pcMsg->length);
        break;
	case EQP_TYPE_HDU:    //4.6  新加 jlb
// 	case EQP_TYPE_HDU_H:
// 	case EQP_TYPE_HDU_L:
// 	case EQP_TYPE_HDU2:
// 	case EQP_TYPE_HDU2_L:
		g_cMcuVcApp.BroadcastToAllConf( MCU_HDUCONNECTED_NOTIF, pcMsg->content, pcMsg->length );
		break;
    case EQP_TYPE_VMPTW:   //vmptw
        g_cMcuVcApp.BroadcastToAllConf(MCU_VMPTWCONNECTED_NOTIF, pcMsg->content, pcMsg->length);
        break;
    default:
        break;
    }

    // xsl [11/29/2006] N+1模式下通知主mcu外设能力
    if (g_cNPlusApp.GetLocalNPlusState() == MCU_NPLUS_MASTER_CONNECTED)
    {
        TNPlusEqpCap tEqpCap = g_cNPlusApp.GetMcuEqpCap();
		//组织packed EqpCap数据[1/11/2012 chendaiwei]
		//按照目前pack方式，pack后Buffer最大值
		u8 abyBuffer[NPLUS_PACK_EXINFO_BUF_LEN] = {0};
		u16 wLen = 0;
		g_cNPlusApp.PackNplusExInfo(g_cNPlusApp.GetMcuEqpCapEx(),abyBuffer,wLen);

        cServMsg.SetEventId(MCU_NPLUS_EQPCAP_NOTIF);
        cServMsg.SetMsgBody((u8 *)&tEqpCap, sizeof(tEqpCap));
		cServMsg.CatMsgBody((u8*)&abyBuffer[0],wLen);
        g_cNPlusApp.PostMsgToNPlusDaemon(VC_NPLUS_MSG_NOTIF, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
    }

    // zbq[08/18/2009] 负载均衡的相关处理
    u8 byBandReserved = 0;
    u8 bySwitchMpId = 0;
    if (
        (EQP_TYPE_BAS == tRegReq.GetEqpType() &&
         g_cMcuAgent.IsEqpBasHD(tRegReq.GetEqpId()) &&
         g_cMcuVcApp.GetBandWidthReserved4HdBas())
         ||
        (EQP_TYPE_VMP == tRegReq.GetEqpType() &&
         g_cMcuAgent.IsSVmp(tRegReq.GetEqpId()) &&
         g_cMcuVcApp.GetBandWidthReserved4HdVmp())
       )
    {
        byBandReserved = g_cMcuVcApp.GetBandWidthReserved4HdBas();
        if (0 == byBandReserved)
        {
            return;
        }
        bySwitchMpId = g_cMcuVcApp.FindMp(dwRecvIpAddr);
        g_cMcuVcApp.m_atMpData[bySwitchMpId-1].m_wNetBandReserved += byBandReserved;

        //外设累加预留导致的“超负”，给出提示
        if (byBandReserved <= g_cMcuVcApp.m_atMpData[bySwitchMpId-1].m_wNetBandAllowed &&
            g_cMcuVcApp.m_atMpData[bySwitchMpId-1].m_wNetBandReserved >
            g_cMcuVcApp.m_atMpData[bySwitchMpId-1].m_wNetBandAllowed)
        {
            NotifyMcsAlarmInfo(0, ERR_MCU_MPRESERVEDBANDWIDTH_FULL);
        }
    }
    
    return;
}

/*====================================================================
    函数名      ：DaemonProcMcuEqpDisconnectedNotif
    功能        ：外设断链通知处理
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/10    1.0         LI Yi         创建
	04/03/27    3.0         胡昌威        修改
====================================================================*/
void CMcuVcInst::DaemonProcMcuEqpDisconnectedNotif( const CMessage * pcMsg )
{
	CServMsg cServMsg( pcMsg->content, pcMsg->length );
	TEqp	tEqp = *( TEqp * )cServMsg.GetMsgBody();
	TPeriEqpStatus	tStatus;

    if (0 == tEqp.GetEqpId() || MAXNUM_MCU_PERIEQP < tEqp.GetEqpId())
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[PeriEqpDisconnectedNotif]TPeriEqpStatus content error! GetEqpId() = %d\n",
                                tStatus.GetEqpId());
        return;
    }

	//清除信息
	if (EQP_TYPE_MIXER == tEqp.GetEqpType())
	{
		u8 byMixerSubtype = UNKONW_MIXER;
		if (g_cMcuAgent.GetMixerSubTypeByEqpId(tEqp.GetEqpId(),byMixerSubtype))
		{
			if (byMixerSubtype == EAPU_MIXER || byMixerSubtype == APU2_MIXER)
			{
				u8 byMixerRunBrdId =  0;
				TEqpMixerInfo tEqpMixerInfo;
				memset(&tEqpMixerInfo,0,sizeof(TEqpMixerInfo));
				g_cMcuAgent.GetEqpMixerCfg( tEqp.GetEqpId(), &tEqpMixerInfo );
				byMixerRunBrdId = tEqpMixerInfo.GetRunBrdId();
				TBoardInfo tBoardInfo;
				if (SUCCESS_AGENT == g_cMcuAgent.GetBrdCfgById(byMixerRunBrdId, &tBoardInfo))
				{
					u8 abyPeriId[MAXNUM_BRD_EQP];
					u8 byMixerNum = 0;
					memset(&abyPeriId[0],0,sizeof(abyPeriId));
					tBoardInfo.GetPeriId(&abyPeriId[0], &byMixerNum);
					for (u8 byMixIdIndex = 0; byMixIdIndex < byMixerNum ; byMixIdIndex++)
					{
						g_cMcuVcApp.SetPeriEqpConnected( abyPeriId[byMixIdIndex], FALSE );
					}
				}
				else
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[DaemonProcMcuEqpDisconnectedNotif]GetBrdCfgById(%d) Failed!,So Return!!\n",
                                byMixerRunBrdId);
				}
			} 
			else
			{
				g_cMcuVcApp.SetPeriEqpConnected( tEqp.GetEqpId(), FALSE );
			}
		} 
		else
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[PeriEqpDisconnectedNotif]GetMixerSubTypeByEqpId(%d) Failed!,So Return!!\n",
                                tStatus.GetEqpId());
			return;
		}

		//APU2混音器掉线时，对apu2适配器外设的online也置成false
		u8 byApu2BasEqpId = 0;
		if ( byMixerSubtype == APU2_MIXER &&
			 g_cMcuAgent.GetAPU2BasEqpIdByMixerId( tEqp.GetEqpId(),byApu2BasEqpId )
			)
		{
			g_cMcuVcApp.SetPeriEqpConnected( byApu2BasEqpId, FALSE );
		}
	} 
	else
	{
		g_cMcuVcApp.SetPeriEqpConnected( tEqp.GetEqpId(), FALSE );
		u8 byBrdid =0;
		if( tEqp.GetEqpType() ==  EQP_TYPE_BAS )
		{
			g_cMcuVcApp.SetBasOnLine(tEqp.GetEqpId(), FALSE);
		}
		if( BRD_TYPE_MPU2ECARD == g_cMcuAgent.GetMPU2TypeByEqpId(tEqp.GetEqpId(),byBrdid)  &&
			( tEqp.GetEqpType() ==  EQP_TYPE_BAS || tEqp.GetEqpType() ==  EQP_TYPE_VMP )
			)
		{			
			u8 byOtherEqpId = 0;
			if ( g_cMcuAgent.GetMpu2AnotherEqpId(tEqp.GetEqpId(),byOtherEqpId) )
			{
				if( tEqp.GetEqpType() ==  EQP_TYPE_BAS )
				{					
					g_cMcuVcApp.SetBasOnLine(byOtherEqpId, FALSE);
				}
				else if( tEqp.GetEqpType() ==  EQP_TYPE_VMP	)
				{
					g_cMcuVcApp.SetPeriEqpConnected( byOtherEqpId, FALSE );
				}
			}			
		}
	}

	//通知会控
	tStatus.SetMcuEqp( (u8)tEqp.GetMcuId(), tEqp.GetEqpId(), tEqp.GetEqpType() );
	tStatus.m_byOnline = FALSE;
	cServMsg.SetMsgBody( ( u8 * )&tStatus, sizeof( tStatus ) );
	SendMsgToAllMcs( MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg );

	if( EQP_TYPE_VMP == tEqp.GetEqpType() )
	{
		//tStatus.SetNull();
		//g_cMcuVcApp.SetPeriEqpStatus( tEqp.GetEqpId(), &tStatus );
	}

	//通知所有会议 
	switch( tEqp.GetEqpType() )
	{
	case EQP_TYPE_RECORDER:
		g_cMcuVcApp.BroadcastToAllConf( MCU_RECDISCONNECTED_NOTIF, pcMsg->content, pcMsg->length );
		break;
	case EQP_TYPE_BAS:
		g_cMcuVcApp.BroadcastToAllConf( MCU_BASDISCONNECTED_NOTIF, pcMsg->content, pcMsg->length );
		break;
	case EQP_TYPE_MIXER:
		g_cMcuVcApp.BroadcastToAllConf( MCU_MIXERDISCONNECTED_NOTIF, pcMsg->content, pcMsg->length );
		break;
	case EQP_TYPE_VMP:
	    g_cMcuVcApp.BroadcastToAllConf( MCU_VMPDISCONNECTED_NOTIF, pcMsg->content, pcMsg->length );
		break;    
	case EQP_TYPE_VMPTW:
		g_cMcuVcApp.BroadcastToAllConf( MCU_VMPTWDISCONNECTED_NOTIF, pcMsg->content, pcMsg->length );
		break;
	case EQP_TYPE_PRS:
		g_cMcuVcApp.BroadcastToAllConf( MCU_PRSDISCONNECTED_NOTIF, pcMsg->content, pcMsg->length );
		break;
	case EQP_TYPE_TVWALL:
		g_cMcuVcApp.BroadcastToAllConf( MCU_TVWALLDISCONNECTED_NOTIF, pcMsg->content, pcMsg->length );
		break;
	case EQP_TYPE_HDU:
// 	case EQP_TYPE_HDU_H:
//     case EQP_TYPE_HDU_L:
// 	case EQP_TYPE_HDU2:
// 	case EQP_TYPE_HDU2_L:
		g_cMcuVcApp.BroadcastToAllConf( MCU_HDUDISCONNECTED_NOTIF, pcMsg->content, pcMsg->length );
	    break;

	default:
		break;
	}
    
    // N+1模式下通知主mcu外设能力变更 [12/21/2006-zbq]
    if (g_cNPlusApp.GetLocalNPlusState() == MCU_NPLUS_MASTER_CONNECTED)
    {
        TNPlusEqpCap tEqpCap = g_cNPlusApp.GetMcuEqpCap();
		//组织packed EqpCap数据[1/11/2012 chendaiwei]
		//按照目前pack方式，pack后Buffer最大值
		u8 abyBuffer[NPLUS_PACK_EXINFO_BUF_LEN] = {0};
		u16 wLen = 0;
		g_cNPlusApp.PackNplusExInfo(g_cNPlusApp.GetMcuEqpCapEx(),abyBuffer,wLen);
        cServMsg.SetEventId(MCU_NPLUS_EQPCAP_NOTIF);
        cServMsg.SetMsgBody((u8 *)&tEqpCap, sizeof(tEqpCap));
		cServMsg.CatMsgBody((u8*)&abyBuffer[0],wLen);
        g_cNPlusApp.PostMsgToNPlusDaemon(VC_NPLUS_MSG_NOTIF, cServMsg.GetServMsg(), cServMsg.GetServMsgLen());
    }
}



/*------------------------------------------------------------------*/
/*                              Recorder                            */
/*------------------------------------------------------------------*/


/*====================================================================
    函数名      : GetMtRecordInfo
    功能        ：获取终端的录相机信息
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt, 录像终端
				  TEqp& tRecEqp, 录像外设(返回) 
				  u8& byRecChannel, 录像通道(返回)
    返回值说明  :成功返回TRUE，否则返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/07/13    4.6         陆昆朋           创建
====================================================================*/
BOOL32 CMcuVcInst::GetMtRecordInfo(const TMt &tMt, TEqp& tRecEqp, u8& byRecChannel )
{
	u8 byRecId = RECORDERID_MIN;
	TPeriEqpStatus tRecStatus;
	TRecChnnlStatus tStatus;
    while( byRecId >= RECORDERID_MIN && byRecId <= RECORDERID_MAX )
	{
		if (g_cMcuVcApp.IsPeriEqpValid(byRecId))
		{
			g_cMcuVcApp.GetPeriEqpStatus(byRecId, &tRecStatus);
            if (tRecStatus.m_byOnline == 1)
            {
                //u8 byTmpMtId = 0;
                //u8 byMtConfIdx = 0;
                u8 byRecChnNum = tRecStatus.m_tStatus.tRecorder.GetRecChnnlNum();
				if (0 == byRecChnNum)
				{
					byRecId++;
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[RemoveMtFormPeriInfo] byRecId just is zero!\n");
					continue;
				}
				for(u8 byLoop = 0; byLoop < byRecChnNum; byLoop++)
				{
					if(FALSE == tRecStatus.m_tStatus.tRecorder.GetChnnlStatus(byLoop, TRecChnnlStatus::TYPE_RECORD, &tStatus))
					{
						continue;
					}

					if (tStatus.m_tSrc == tMt)
					{
						memcpy(&tRecEqp, &tRecStatus, sizeof(tRecEqp));
						byRecChannel = byLoop;
						return TRUE;
					}
				}
			}
		}
		byRecId++;
	}

	// vrs新录播支持
	u8 byVrsRecMtId = GetVrsRecMtId(tMt);
	if (byVrsRecMtId != 0)
	{
		tRecEqp = m_ptMtTable->GetMt(byVrsRecMtId);
		byRecChannel = 0;
		return TRUE;
	}

	return FALSE;
}

/*====================================================================
    函数名      : RemoveMtFromRec
    功能        ：将录像机中的终端从录像机中删除
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt, 录像终端
				  TEqp& tRecEqp, 录像外设(返回) 
				  u8& byRecChannel, 录像通道(返回)
    返回值说明  :成功返回TRUE，否则返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/07/13    4.6         陆昆朋           创建
====================================================================*/
BOOL32 CMcuVcInst::RemoveMtFromRec(const TMt* ptMt, const BOOL32 bAllStop /*= FALSE*/)
{
	u8 byRecId = RECORDERID_MIN;
	TPeriEqpStatus tRecStatus;
	TRecChnnlStatus tStatus;

	TMtStatus tRecMtStatus;
	TEqp tEqp ;
	CServMsg	cServMsg;

	// 判断是不是mcu对象
	BOOL32 bSubMcu = ptMt != NULL && IsMcu(*ptMt) ? TRUE : FALSE;

    while( byRecId >= RECORDERID_MIN && byRecId <= RECORDERID_MAX )
	{
		if (g_cMcuVcApp.IsPeriEqpValid(byRecId))
		{
			g_cMcuVcApp.GetPeriEqpStatus(byRecId, &tRecStatus);
            if (tRecStatus.m_byOnline == 1)
            {
                //u8 byTmpMtId = 0;
                //u8 byMtConfIdx = 0;
                u8 byRecChnNum = tRecStatus.m_tStatus.tRecorder.GetRecChnnlNum();
				if (0 == byRecChnNum)
				{
					byRecId++;
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[RemoveMtFormPeriInfo] byRecId just is zero!\n");
					continue;
				}

				tEqp = (TEqp)tRecStatus;
				for(u8 byLoop = 0; byLoop < byRecChnNum; byLoop++)
				{
					if(FALSE == tRecStatus.m_tStatus.tRecorder.GetChnnlStatus(byLoop, TRecChnnlStatus::TYPE_RECORD, &tStatus))
					{
						continue;
					}

					if (tStatus.m_tSrc.IsNull())
					{
						continue;
					}

					if (tStatus.m_tSrc.GetConfIdx() != m_byConfIdx)
					{
						continue;
					}

					// [1/20/2011 liuxu] ptMt如果是mcu, 它所属在录像的终端也需要停止
					if (bAllStop 
						|| ( NULL != ptMt && tStatus.m_tSrc == *ptMt)
						|| (bSubMcu && NULL != ptMt && tStatus.m_tSrc.GetMcuId() == ptMt->GetMtId())
						|| (bSubMcu && NULL != ptMt && IsMtInMcu(*ptMt, tStatus.m_tSrc)))
					{
						//[2011/07/16/zhanlgi]整理录像机拆建RTP/RTCP交换
						AdjustMtRecSrcStream(MODE_BOTH, tEqp, byLoop, TMt(tStatus.m_tSrc), FALSE);
						AdjustMtRecSrcStream(MODE_SECVIDEO, tEqp, byLoop, TMt(tStatus.m_tSrc), FALSE);
						
						//置状态
						//m_ptMtTable->SetMtNoRecording(tRecMt.GetMtId());
						tRecMtStatus.m_tRecState.SetNoRecording();

						GetMtStatus(tStatus.m_tSrc, tRecMtStatus);
						if( !tRecMtStatus.m_tRecState.IsNoRecording() )
						{
							tRecMtStatus.m_tRecState.SetNoRecording();
							SetMtStatus(tStatus.m_tSrc, tRecMtStatus);
							// [9/14/2011 liuxu] 需要马上刷新界面, 因为如果被挂断时是mcu, 
							// 那它下级的终端信息将会马上被清除
							MtStatusChange((TMt*)&tStatus.m_tSrc, TRUE);
								
							cServMsg.SetMsgBody((u8 *)&tEqp, sizeof(tEqp));	//set TEqp
							cServMsg.SetChnIndex( byLoop );
							SendMsgToEqp( tEqp.GetEqpId(), MCU_REC_STOPREC_REQ, cServMsg );
						}

						//对于指定的终端，找到停止后就返回
						if (!bAllStop && !bSubMcu)
						{
							return TRUE;
						}
					}
				}
			}
		}

		byRecId++;
	}

	// vrs新录播支持
	for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
	{
		if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC
			&& m_ptMtTable->GetRecChlType(byMtId) == TRecChnnlStatus::TYPE_RECORD)
		{
			if (bAllStop
				|| ( NULL != ptMt && m_ptMtTable->GetRecSrc(byMtId) == *ptMt)
				|| (bSubMcu && m_ptMtTable->GetRecSrc(byMtId).GetMcuId() == ptMt->GetMtId())
				|| (bSubMcu && IsMtInMcu(*ptMt, m_ptMtTable->GetRecSrc(byMtId)))
				)
			{
				ReleaseVrsMt(byMtId, 0, !bAllStop);
			}
		}
	}

	return FALSE;
}

/*====================================================================
    函数名      PrepareDataForMtRec
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/05/27  4.7         倪志俊         创建
====================================================================*/
void CMcuVcInst::PrepareDataForMtRec(const TStartRecMsgInfo &tRecMsg, TStartRecData &tRecData)
{
	TMt tRecordMt = tRecMsg.m_tRecordMt;
	//动态载荷信息,取下级mcu的.
	TSimCapSet tSrcSCS;
	if( !tRecordMt.IsLocal() )
	{
		tSrcSCS = m_ptMtTable->GetSrcSCS( GetLocalMtFromOtherMcuMt(tRecordMt).GetMtId() );
	}
	else
	{
		tSrcSCS = m_ptMtTable->GetSrcSCS(tRecordMt.GetMtId());
	}

	TMediaEncrypt tEncrypt = m_tConf.GetMediaKey();
	if (MEDIA_TYPE_H264 == tSrcSCS.GetVideoMediaType() ||
		MEDIA_TYPE_H263PLUS == tSrcSCS.GetVideoMediaType() ||
		CONF_ENCRYPTMODE_NONE != tEncrypt.GetEncryptMode() ||
        m_tConf.GetCapSupportEx().IsVideoSupportFEC() )
	{
		tRecData.m_tDVPayload.SetRealPayLoad(tSrcSCS.GetVideoMediaType());
		tRecData.m_tDVPayload.SetActivePayload(GetActivePayload(m_tConf, tSrcSCS.GetVideoMediaType()));
	}
	else
	{
		tRecData.m_tDVPayload.SetRealPayLoad(tSrcSCS.GetVideoMediaType());
		tRecData.m_tDVPayload.SetActivePayload(tSrcSCS.GetVideoMediaType());
	}

	if (CONF_ENCRYPTMODE_NONE != tEncrypt.GetEncryptMode() ||
        // zbq [10/29/2007] 适应FEC支持其他格式
        m_tConf.GetCapSupportEx().IsAudioSupportFEC() )
	{
		tRecData.m_tDAPayload.SetRealPayLoad(tSrcSCS.GetAudioMediaType());
		tRecData.m_tDAPayload.SetActivePayload(GetActivePayload(m_tConf,  tSrcSCS.GetAudioMediaType()));
	}
	else
	{
		tRecData.m_tDAPayload.SetRealPayLoad(tSrcSCS.GetAudioMediaType());
		tRecData.m_tDAPayload.SetActivePayload(tSrcSCS.GetAudioMediaType());
	}

	//tDDVPayload 动态载荷信息
	if (tRecMsg.m_tRecPara.IsRecDStream())
	{
		u8 DStreamType = m_tConf.GetCapSupport().GetDStreamMediaType();
		
		if ( m_tConf.GetCapSupportEx().IsDDStreamCap() ) // 双双流时动态载荷设为0; jlb [2009/03/31]
		{
			tRecData.m_tDDVPayload.SetActivePayload( 0 );
		}
		else if (MEDIA_TYPE_H264 == DStreamType ||
			MEDIA_TYPE_H263PLUS == DStreamType ||
			CONF_ENCRYPTMODE_NONE != tEncrypt.GetEncryptMode() ||
			// zbq [10/29/2007] 适应FEC支持其他格式
			m_tConf.GetCapSupportEx().IsDVideoSupportFEC())
		{
			tRecData.m_tDDVPayload.SetActivePayload(GetActivePayload(m_tConf, DStreamType));
		}
		else
		{
			tRecData.m_tDDVPayload.SetActivePayload(DStreamType);
		}
		tRecData.m_tDDVPayload.SetRealPayLoad(DStreamType);
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "DoubleStreamSrc MediaType = %d\n", DStreamType);
    }

	//[nizhijun 2010/12/17] 多回传会议录像与终端录像的丢包重传支持
    //[liu lijiu][20100902]终端录像的PRS支持
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	if (tConfAttrb.IsResendLosePack())
	{	
		TLogicalChannel tLogicalChannel;
		u32 dwSwitchIp;
	    u16 wSwitchPort;
		// [pengjie 2010/10/14] 对于下级终端则取mcu的信息
		u8 byMtId;
		if( !tRecordMt.IsLocal() )
		{
			byMtId = GetLocalMtFromOtherMcuMt( tRecordMt ).GetMtId();
		}
		else
		{
			byMtId = tRecordMt.GetMtId();
		}
		// End
		
		//视频
		m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_VIDEO, &tLogicalChannel, FALSE);
		dwSwitchIp  = tLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
		wSwitchPort = tLogicalChannel.GetSndMediaCtrlChannel().GetPort();
		tRecData.m_tRtcpBack.SetVideoAddr(dwSwitchIp, wSwitchPort);
		
		//音频
		m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_AUDIO, &tLogicalChannel, FALSE);
		dwSwitchIp  = tLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
		wSwitchPort = tLogicalChannel.GetSndMediaCtrlChannel().GetPort();
		tRecData.m_tRtcpBack.SetAudioAddr(dwSwitchIp, wSwitchPort);
		
		//双流
		m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_SECVIDEO, &tLogicalChannel, FALSE);
		dwSwitchIp  = tLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
		wSwitchPort = tLogicalChannel.GetSndMediaCtrlChannel().GetPort();
		tRecData.m_tRtcpBack.SetDStreamAddr(dwSwitchIp, wSwitchPort);
	}
    //[liu lijiu][20100902] ends
	return;
}

/*====================================================================
    函数名      IsMtRecCheckPass
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/05/27  4.7         倪志俊         创建
====================================================================*/
BOOL32	CMcuVcInst::IsMtRecCheckPass(TStartRecMsgInfo & tRecMsg,u16* pwErrCode)
{
	TMt tRecordMt = tRecMsg.m_tRecordMt;
	if (!m_tConfAllMtInfo.MtJoinedConf(tRecordMt))
	{
		*pwErrCode = ERR_MCU_MT_NOTINCONF;
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, "[IsMtRecCheckPass]mt %d is not joined in conf\n", tRecordMt.GetMtId() );
		return FALSE;			
	}

	TMtStatus tRecMtStatus;
	GetMtStatus(tRecordMt, tRecMtStatus);
	if (!tRecMtStatus.m_tRecState.IsNoRecording())
	{
		*pwErrCode = ERR_MCU_MTRECORDING;
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, 
			"[IsMtRecCheckPass]mt %d is recording now\n", tRecordMt.GetMtId());
		return FALSE;
	}

	// xsl [7/20/2006] 卫星分散会议时需要判断回传通道数
	if (m_tConf.GetConfAttrb().IsSatDCastMode()
		&& IsMultiCastMt(tRecordMt.GetMtId())
		&& !IsSatMtSend(tRecordMt))
	{
		TMt tLocalRecordMt = GetLocalMtFromOtherMcuMt(tRecordMt);
		if (/*!tLocalRecordMt.IsNull() && IsOverSatCastChnnlNum(tLocalRecordMt.GetMtId())*/
			//IsSatMtOverConfDCastNum(tLocalRecordMt))
			!IsSatMtCanContinue(GetLocalMtFromOtherMcuMt(tRecordMt).GetMtId(),emStartRecord))
		{
			*pwErrCode = ERR_MCU_DCAST_OVERCHNNLNUM;
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_REC, "[IsMtRecCheckPass]over max upload mt num. nack!\n");   
			return FALSE;
		}
     }

	return TRUE;
}

/*====================================================================
    函数名      PrepareDataForConfRec
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/05/27  4.7         倪志俊         创建
====================================================================*/
void CMcuVcInst::PrepareDataForConfRec(const TStartRecMsgInfo & tRecMsg,TStartRecData &tRecData)
{
	//获取主流载荷
	u8 byConfVideoType;
	TVideoStreamCap tTempVidCapSet;
	if ( m_cRecAdaptMgr.GetRecVideoCapSet(MODE_VIDEO,tTempVidCapSet))
	{
		byConfVideoType = tTempVidCapSet.GetMediaType();
	}
	else
	{
		if (tRecMsg.m_tRecPara.IsRecMainVideo())
		{
			byConfVideoType = m_tConf.GetMainVideoMediaType();
		}
		else
		{
			byConfVideoType = m_tConf.GetSecVideoMediaType();
		}
	}

	TMediaEncrypt tEncrypt = m_tConf.GetMediaKey();
	//会议录像时，对于双格式的录主格式码流，若存在动态载荷，发生格式切换时可能存在误解码？？
	if (MEDIA_TYPE_H264 == byConfVideoType || 
		MEDIA_TYPE_H263PLUS == byConfVideoType || 
		CONF_ENCRYPTMODE_NONE != tEncrypt.GetEncryptMode() ||
		// zbq [10/29/2007] 适应FEC支持其他格式
		m_tConf.GetCapSupportEx().IsVideoSupportFEC())
	{
		tRecData.m_tDVPayload.SetRealPayLoad(byConfVideoType );
		tRecData.m_tDVPayload.SetActivePayload(GetActivePayload(m_tConf, byConfVideoType));
	}
	else
	{
		tRecData.m_tDVPayload.SetRealPayLoad(byConfVideoType);
		tRecData.m_tDVPayload.SetActivePayload(byConfVideoType);
	}

	//获取音频载荷
	u8 byConfAudioType;
	TAudioTypeDesc tTempAudCap;
	if ( m_cRecAdaptMgr.GetRecAudCapSet(tTempAudCap) )
	{
		byConfAudioType = tTempAudCap.GetAudioMediaType();
	}
	else
	{
		if (tRecMsg.m_tRecPara.IsRecMainAudio())
		{
			byConfAudioType = m_tConf.GetMainAudioMediaType();
		}
		else
		{
			byConfAudioType = m_tConf.GetSecAudioMediaType();
		}
	}
	
	if (CONF_ENCRYPTMODE_NONE != tEncrypt.GetEncryptMode() ||
		// zbq [10/29/2007] 适应FEC支持其他格式
		m_tConf.GetCapSupportEx().IsAudioSupportFEC() )
	{
		tRecData.m_tDAPayload.SetRealPayLoad(byConfAudioType);
		tRecData.m_tDAPayload.SetActivePayload(GetActivePayload(m_tConf, byConfAudioType));
	}
	else
	{
		tRecData.m_tDAPayload.SetRealPayLoad(byConfAudioType);
		tRecData.m_tDAPayload.SetActivePayload(byConfAudioType);
	}


	//获取双流载荷
	u8 byDStreamType;
	if ( m_cRecAdaptMgr.GetRecVideoCapSet(MODE_SECVIDEO,tTempVidCapSet) )
	{
		byDStreamType = tTempVidCapSet.GetMediaType();
		
		tRecData.m_tDDVPayload.SetRealPayLoad(byDStreamType);
		tRecData.m_tDDVPayload.SetActivePayload(GetActivePayload(m_tConf, byDStreamType));
	}
	else
	{
		if ( tRecMsg.m_tRecPara.IsRecDStream() )
		{
			byDStreamType = m_tConf.GetCapSupport().GetDStreamMediaType();
            
			if ( m_tConf.GetCapSupportEx().IsDDStreamCap() ) // 双双流时动态载荷设为0; jlb [2009/03/31]
			{
                tRecData.m_tDDVPayload.SetActivePayload( 0 );
			}
			else if (MEDIA_TYPE_H264 == byDStreamType ||
                MEDIA_TYPE_H263PLUS == byDStreamType ||
                CONF_ENCRYPTMODE_NONE != tEncrypt.GetEncryptMode() ||
                // zbq [10/29/2007] 适应FEC支持其他格式
                m_tConf.GetCapSupportEx().IsDVideoSupportFEC())
            {
                tRecData.m_tDDVPayload.SetActivePayload(GetActivePayload(m_tConf, byDStreamType));
            }
            else
            {
                tRecData.m_tDDVPayload.SetActivePayload(byDStreamType);
            }
            tRecData.m_tDDVPayload.SetRealPayLoad(byDStreamType);
		}
	}


	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	u8   byNeedPrs = tConfAttrb.IsResendLosePack();
    TRecRtcpBack tRtcpBack;
	if ( byNeedPrs )
	{
		u8 byChnnlNum;
		TLogicalChannel tLogicalChannel;
		u32 dwSwitchIp;
	    u16 wSwitchPort;
		//录像机在mp上音频RTCP的地址
		g_cMcuVcApp.GetPeriEqpLogicChnnl(tRecMsg.m_tRecEqp.GetEqpId(), MODE_AUDIO, &byChnnlNum, &tLogicalChannel, TRUE);
		dwSwitchIp  = tLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
		wSwitchPort = tLogicalChannel.GetSndMediaCtrlChannel().GetPort();
		tRecData.m_tRtcpBack.SetAudioAddr(dwSwitchIp, wSwitchPort);
		
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[PrepareDataForConfRec]wSwitchIP@wSwitchPort: %s@%d\n", StrOfIP(dwSwitchIp), wSwitchPort);
		
		//录像机在mp上视频RTCP的地址
		g_cMcuVcApp.GetPeriEqpLogicChnnl(tRecMsg.m_tRecEqp.GetEqpId(), MODE_VIDEO, &byChnnlNum, &tLogicalChannel, TRUE);
		dwSwitchIp  = tLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
		wSwitchPort = tLogicalChannel.GetSndMediaCtrlChannel().GetPort();
		tRecData.m_tRtcpBack.SetVideoAddr(dwSwitchIp, wSwitchPort);
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[PrepareDataForConfRec]dwSwitchIP@wSwitchPort: %s@%d\n", StrOfIP(dwSwitchIp), wSwitchPort);
		
		//录像机在mp上双流RTCP的地址
		if (m_tRecPara.IsRecDStream())
		{
			g_cMcuVcApp.GetPeriEqpLogicChnnl(tRecMsg.m_tRecEqp.GetEqpId(), MODE_VIDEO, &byChnnlNum, &tLogicalChannel, TRUE);
			dwSwitchIp  = tLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
			wSwitchPort = tLogicalChannel.GetSndMediaCtrlChannel().GetPort() + 4;
			tRecData.m_tRtcpBack.SetDStreamAddr(dwSwitchIp, wSwitchPort);		
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[PrepareDataForConfRec]dwSwitchIP@wSwitchPort: %s@%d\n", StrOfIP(dwSwitchIp), wSwitchPort);
		}
	}
}

/*====================================================================
    函数名      ：StartVrsRec
    功能        ：开启vrs新录播录像
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/11  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::StartVrsRec(const TStartRecMsgInfo &tRecMsg, u8 byRecState, BOOL32 bNeedPresetin)
{
	//本函数仅接受STATE_CALLING与STATE_RECREADY两个状态参数
	if(TRecChnnlStatus::STATE_CALLING != byRecState && TRecChnnlStatus::STATE_RECREADY != byRecState)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[StartVrsRec] RecState.%d is invalid, return!\n", 
			byRecState);
		return;
	}

	u8 byVrsRecMtId = GetVrsRecMtId(tRecMsg.m_tRecordMt);
	// MtId无效时，取到的ChnnlStatus为初始化信息
	TRecChnnlStatus tVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(byVrsRecMtId);
	u8 byVrsCurState = tVrsChlStatus.m_byState;
	
	CServMsg	cServMsg;
	//当前状态为IDLE参数状态必须为CALLING，当前状态为CALLING参数必须为READY，其余状态不做处理加异常打印
	switch(byVrsCurState)
	{
	case TRecChnnlStatus::STATE_IDLE:
		{
			if (byRecState != TRecChnnlStatus::STATE_CALLING)
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[StartVrsRec]VrsCurState is %d. New RecState.%d is invalid, return!\n", 
					byVrsCurState, byRecState);
				break;
			}
			TMtAlias tVrsRecAlias = tRecMsg.m_tVrsRecAlias;
			//添加录像实体
			u16 wMtDialRate = m_tConf.GetBitRate();//呼叫码率需要区分会议录像与终端录像，提供个接口？
			u8 byCallMode = CONF_CALLMODE_NONE;
			byVrsRecMtId = AddVrsMt(tVrsRecAlias, TRecChnnlStatus::TYPE_RECORD, tRecMsg.m_tRecordMt, wMtDialRate, byCallMode);
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "Mcu add vrsrec mt-%d DialBitRate-%d CallMode-%d aliasType-%d\n", 
				byVrsRecMtId, wMtDialRate, byCallMode, tVrsRecAlias.m_AliasType );
			if (byVrsRecMtId == 0 || byVrsRecMtId > MAXNUM_CONF_MT)
			{
				//未能成功添加新录播实体
				ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[StartVrsRec]No free Mtid for AddVrsMt(). return!\n");
				break;
			}

			TMt tVrsRecMt = m_ptMtTable->GetMt(byVrsRecMtId);
			//更新录像相关信息,呼叫成功后需根据这些信息发送开启消息
			m_ptMtTable->SetRecChlType(byVrsRecMtId, TRecChnnlStatus::TYPE_RECORD);
			m_ptMtTable->SetRecSrc(byVrsRecMtId, tRecMsg.m_tRecordMt);
			m_ptMtTable->SetRecordName(byVrsRecMtId, tRecMsg.m_aszRecName);
			if (IS_RECORD_CONF(tRecMsg.m_tRecordMt))
			{
				//会议录像时，记录会议录像相关信息，终端录像无需记录
				m_tRecEqp = tVrsRecMt;
				//m_tRecPara = tRecMsg.m_tRecPara; 此信息在解析开启消息时已更新
			}
			else
			{
				// 对vrs实体的终端状态设置是否发布，呼叫上线开启录像时需要
				TMtStatus tVrsStatus;
				GetMtStatus(tVrsRecMt, tVrsStatus);
				tVrsStatus.m_tRecState.SetRecPublish(tRecMsg.m_tRecPara.GetPublishMode() == PUBLISH_MODE_FIN);
				SetMtStatus(tVrsRecMt, tVrsStatus);
			}

			//呼叫录像实体
			cServMsg.SetConfId( m_tConf.GetConfId() );
			cServMsg.SetNoSrc();
			cServMsg.SetTimer( TIMESPACE_WAIT_AUTOINVITE );
			cServMsg.SetMsgBody( NULL, 0 );
			InviteUnjoinedMt(cServMsg, &tVrsRecMt);

			//状态更新为CALLING
			m_ptMtTable->SetRecChlState(byVrsRecMtId, TRecChnnlStatus::STATE_CALLING);
		}
		break;
	case TRecChnnlStatus::STATE_CALLING:
	case TRecChnnlStatus::STATE_RECREADY://针对下级终端录像，可能已是Ready
		{
			if (byRecState != TRecChnnlStatus::STATE_RECREADY)
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[StartVrsRec]VrsCurState is %d. New RecState.%d is invalid, return!\n", 
					byVrsCurState, byRecState);
				break;
			}
			TMt tVrsRecMt = m_ptMtTable->GetMt(byVrsRecMtId);
			// 发送开启录像消息，区分会议录像与终端录像
			if (IS_RECORD_CONF(tRecMsg.m_tRecordMt))
			{
				m_tRecEqp = tVrsRecMt;//更新会议录像设备，呼叫上线后会更新终端类型
				// 发送开启录像消息
				SendStartVrsRecReq(tRecMsg);
				//状态更新为READY
				m_ptMtTable->SetRecChlState(byVrsRecMtId, TRecChnnlStatus::STATE_RECREADY);
			}
			else
			{
				// 开启终端录像
				if (!tRecMsg.m_tRecordMt.IsLocal() && IsLocalAndSMcuSupMultSpy(tRecMsg.m_tRecordMt.GetMcuId()) && bNeedPresetin)
				{
					// 对下级多回传成员，先做级联多回传处理,暂不更新状态
					StartMtRec(tRecMsg);
				}
				else
				{
					// 不需要级联多回传处理，直接发送开启录像消息
					SendStartVrsRecReq(tRecMsg);
					//状态更新为READY
					m_ptMtTable->SetRecChlState(byVrsRecMtId, TRecChnnlStatus::STATE_RECREADY);
				}
			}
		}
		break;
	default:
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[StartVrsRec]VrsCurState is %d. New RecState.%d is invalid, return!\n", 
					byVrsCurState, byRecState);
		}
		break;
	}

	return;
}

/*====================================================================
    函数名      ：GetVrsRecMtId
    功能        ：通过录像终端匹配对应新录播实体MtId
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/11  4.7      yanghuaizhi        创建
====================================================================*/
u8 CMcuVcInst::GetVrsRecMtId(TMt tRecSrcMt)
{
	u8 byVrsRecMtId = 0;
	// 区分是会议录像还是终端录像
	if (IS_RECORD_CONF(tRecSrcMt))
	{
		// 会议录像从会议信息中获取会议录像MtId
		if (!m_tRecEqp.IsNull() && m_tRecEqp.GetType() != TYPE_MCUPERI 
			&& m_ptMtTable->GetRecChlType(m_tRecEqp.GetMtId()) == TRecChnnlStatus::TYPE_RECORD)
		{
			byVrsRecMtId = m_tRecEqp.GetMtId();
		}
	} 
	else
	{
		TMt tTmpSrcMt;
		// 终端录像遍历当前终端列表，找到录像源一致的vrs新录播id
		for( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId ++ )
		{
			if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
			{
				tTmpSrcMt = m_ptMtTable->GetRecSrc(byMtId);
				if (tTmpSrcMt.GetMcuId() == tRecSrcMt.GetMcuId()
					&& tTmpSrcMt.GetMtId() == tRecSrcMt.GetMtId())
				{
					byVrsRecMtId = byMtId;
					break;
				}
			}
		}
	}

	return byVrsRecMtId;
}

/*====================================================================
    函数名      ：PrepareStartRecMsgInfo
    功能        ：准备要开启vrs新录播的信息
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/11  4.7      yanghuaizhi        创建
====================================================================*/
BOOL32 CMcuVcInst::PrepareStartRecMsgInfo(TMt tVrsRecMt, TStartRecMsgInfo &tStartVrsMsgInfo)
{
	if (tVrsRecMt.GetMtType() != MT_TYPE_VRSREC)
	{
		return FALSE;
	}

	TRecChnnlStatus tVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(tVrsRecMt.GetMtId());
	if (tVrsChlStatus.m_byType != TRecChnnlStatus::TYPE_RECORD)
	{
		return FALSE;
	}
	
	tStartVrsMsgInfo.m_tRecordMt = tVrsChlStatus.m_tSrc;	//更新录像源
	tStartVrsMsgInfo.m_tRecEqp = tVrsRecMt;					// 标记vrs新录播
	memset(tStartVrsMsgInfo.m_aszRecName, 0, sizeof(tStartVrsMsgInfo.m_aszRecName));
	//memcpy(tStartVrsMsgInfo.m_aszRecName, tVrsChlStatus.GetRecordName(), MAXLEN_RECORD_NAME);
	m_ptMtTable->GetRecordName(tVrsRecMt.GetMtId(), tStartVrsMsgInfo.m_aszRecName, MAX_FILE_NAME_LEN);
	if (IS_RECORD_CONF(tVrsChlStatus.m_tSrc))
	{
		// 组织会议录像相关信息
		tStartVrsMsgInfo.m_tRecPara = m_tRecPara;
		tStartVrsMsgInfo.bIsRecAdaptConf = IsRecNeedAdapt();
	}
	else
	{
		// 组织终端录像相关信息
		TMt tLocalRecMt = GetLocalMtFromOtherMcuMt(tVrsChlStatus.m_tSrc);
		TRecStartPara tRecPara;
		tRecPara.Reset();
		// 从vrs实体的终端状态中获取录像是否发布
		TMtStatus tVrsMtStatus;
		GetMtStatus(tVrsRecMt, tVrsMtStatus);
		tRecPara.SetPublishMode(tVrsMtStatus.m_tRecState.IsRecPublish());
		tRecPara.SetIsRecMainVideo(TRUE);
		tRecPara.SetIsRecMainAudio(TRUE);
		tRecPara.SetIsRecDStream(TRUE);
		// vrs新录播按323实体呼叫，逻辑通道已开，无需再设置码率参数

		tStartVrsMsgInfo.m_tRecPara = tRecPara;
	}

	return TRUE;
}

/*====================================================================
    函数名      ：AddVrsMt
    功能        ：添加vrs新录播成员
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/11  4.7      yanghuaizhi        创建
====================================================================*/
u8 CMcuVcInst::AddVrsMt(TMtAlias &tMtAlias, u8 byType, TMt tSrc, u16 wMtDialRate, u8 byCallMode)
{
	u8 byMtId = 0;
	//新录播仅支持ip地址呼叫
    if( tMtAlias.m_AliasType != mtAliasTypeTransportAddress)
	{
		return 0;
	}
	//判断录放像模式
	if (byType != TRecChnnlStatus::TYPE_RECORD && byType != TRecChnnlStatus::TYPE_PLAY)
	{
		return 0;
	}
	
	if(wMtDialRate == 0 || wMtDialRate > m_tConf.GetBitRate())
	{
		wMtDialRate = m_tConf.GetBitRate();
	}       
	byMtId = m_ptMtTable->GetVrsRecMtIdByAlias(&tMtAlias, byType, tSrc);

	// 找到可替换MtId，判只要该Mtid未与会就可以直接使用
	if (byMtId > 0)
	{
		if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
		{
			if (m_ptMtTable->AddVrsRecChlbyMtId(byMtId))
			{
				return byMtId;
			}
		}
	}

	// 未找到可替换的MtId，分配一个新的给他
	byMtId = m_ptMtTable->AddMt( &tMtAlias, FALSE );
	if(byMtId > 0)
	{
		if (m_ptMtTable->AddVrsRecChlbyMtId(byMtId))
		{
			m_ptMtTable->SetDialAlias( byMtId, &tMtAlias );
			m_ptMtTable->SetDialBitrate( byMtId, wMtDialRate );
			
			
			m_ptMtTable->SetMcuId( byMtId, LOCAL_MCUIDX);
			m_ptMtTable->SetConfIdx( byMtId, m_byConfIdx );
			m_ptMtTable->SetCallMode( byMtId, byCallMode );
			m_ptMtTable->SetMtNoRecording(byMtId);
			
			m_tConfAllMtInfo.AddMt( byMtId );
			
			//设置终端状态
			TMtStatus tMtStatus;
			tMtStatus.SetTMt( m_ptMtTable->GetMt( byMtId ) );		
			m_ptMtTable->SetMtStatus( tMtStatus.GetMtId(), &tMtStatus );
		}
		else
		{
			m_ptMtTable->DelMt(byMtId);
			byMtId = 0;
		}
	} 

	return byMtId;
}

/*====================================================================
    函数名      ：ReleaseVrsMt
    功能        ：释放Vrs新录播所有信息，状态置为IDLE
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byVrsMtId 对应vrs实体Mtid
	              BOOL32 bMcsMsg 是否上报消息，默认上报，
				  结会时防止消息过多可不上报
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/11  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::ReleaseVrsMt(u8 byVrsMtId, u16 wErrorCode, BOOL32 bMcsMsg)
{
	// 判断该id是否是录放像实体，不是则返回
	TRecChnnlStatus tRecStatus = m_ptMtTable->GetRecChnnlStatus(byVrsMtId);
	if (tRecStatus.m_byType != TRecChnnlStatus::TYPE_RECORD 
		&& tRecStatus.m_byType != TRecChnnlStatus::TYPE_PLAY)
	{
		// 非录像非放像
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ReleaseVrsMt]VrsMt.%d is not Vrs recorder, return!\n", 
			byVrsMtId);
		return;
	}
	TMt tVrsMt = m_ptMtTable->GetMt(byVrsMtId);
	if (m_tConfAllMtInfo.MtJoinedConf(byVrsMtId) && tVrsMt.GetMtType() != MT_TYPE_VRSREC)
	{
		// 非vrs实体不做处理
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ReleaseVrsMt]VrsMt.%d is not Vrs recorder, return!\n", 
			byVrsMtId);
		return;
	}
	
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[ReleaseVrsMt]ReleaseVrsMt.%d\n", byVrsMtId);

	CServMsg cServMsg;
	if (bMcsMsg && wErrorCode > 0)
	{
		TEqp tEqp;
		u8 byChlType = m_ptMtTable->GetRecChlType(byVrsMtId);
		TMt tRecSrc = m_ptMtTable->GetRecSrc(byVrsMtId);
		cServMsg.SetMsgBody((u8*)&tEqp, sizeof(tEqp));//置空标识为新录播
		cServMsg.CatMsgBody(&byChlType, sizeof(byChlType));
		cServMsg.CatMsgBody((u8*)&tRecSrc, sizeof(tRecSrc));
		SendMsgToAllMcs(MCU_MCS_RECORDEREXCPT_NOTIF, cServMsg);
	}

	// 录像放像分开处理
	TRecProg tTmpProg;
	tTmpProg.SetCurProg(0);
	tTmpProg.SetTotalTime(0);
	BOOL32 bSendConfMsg = FALSE;//是否上报会议信息
	if (tRecStatus.m_byType == TRecChnnlStatus::TYPE_RECORD)
	{
		if (IS_RECORD_CONF(tRecStatus.m_tSrc))
		{
			if (m_tRecEqp.GetMtId() == tVrsMt.GetMtId())
			{
				if (IsRecNeedAdapt())//清m_cRecAdaptMgr
				{
					ResetRecAdptParam();
				}
				AdjustConfRecordSrcStream(MODE_BOTH, FALSE);
				AdjustConfRecordSrcStream(MODE_SECVIDEO, FALSE);
				
				//停止录像，如果是低速录像且录的是画面合成广播，画面合成的第一路码流要调回去
				if ( m_tRecPara.IsRecLowStream() && g_cMcuVcApp.IsBrdstVMP(m_tVmpEqp) )
				{
					u16 wMinMtReqBitrate = GetLeastMtReqBitrate( TRUE, m_tConf.GetMainVideoMediaType() );
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "Mt[%d] rec is low stream, and vmp is BrdSrc, the 1st chnl BitRate of vmp will be restored[%d]!\n", tVrsMt.GetMtId(), wMinMtReqBitrate);
					ChangeVmpBitRate(wMinMtReqBitrate);
				}
				//清会议相关录像信息
				m_tRecEqp.SetNull();
				m_tRecPara.Reset();
				m_tConf.m_tStatus.SetNoRecording();
				m_tConf.m_tStatus.SetRecProg(tTmpProg);
				//停止录像时，先挂载一遍适配参数，再刷新一次终端适配参数,告知适配器参数改变
				//这里是否要判断双流？？？
				StartBrdAdapt(MODE_VIDEO);

				bSendConfMsg = TRUE;
			}
		}
		else
		{
			TMt tMtSrc = tRecStatus.m_tSrc;
			if (m_tConfAllMtInfo.MtJoinedConf(byVrsMtId) && 
				(m_ptMtTable->GetRecChlState(byVrsMtId) == TRecChnnlStatus::STATE_RECORDING
				|| m_ptMtTable->GetRecChlState(byVrsMtId) == TRecChnnlStatus::STATE_RECPAUSE
				|| m_ptMtTable->GetRecChlState(byVrsMtId) == TRecChnnlStatus::STATE_RECREADY)
				)
			{
				// 只有正在录像中才需要释放多回传资源
				FreeRecvSpy(tMtSrc, MODE_BOTH);//清多回传资源
			}
			AdjustMtRecSrcStream(MODE_BOTH, tVrsMt, 0, tMtSrc, FALSE);
			if (!m_tDoubleStreamSrc.IsNull())
			{
				AdjustMtRecSrcStream(MODE_SECVIDEO, tVrsMt, 0, tMtSrc, FALSE);
			}
			//清终端录像状态
			TMtStatus tMtStatus;
			GetMtStatus(tMtSrc, tMtStatus);
			tMtStatus.m_tRecState.SetNoRecording();
			tMtStatus.m_tRecState.SetRecPublish(FALSE);
			SetMtStatus(tMtSrc, tMtStatus);
			if (bMcsMsg)
			{
				MtStatusChange( &tMtSrc );
			}
		}
	}
	else
	{
		if (m_tPlayEqp.GetMtId() == tVrsMt.GetMtId())
		{
			if (m_tConf.GetSpeaker() == m_tPlayEqp)
			{
				//是否为语音激励控制发言，是则恢复
                if (m_tConf.m_tStatus.IsVACing() && !m_tVacLastSpeaker.IsNull())
                {
                    ConfPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[ReleaseVrsMt]Vac speaker restored, speaker is: Mt%d\n",
						m_tVacLastSpeaker.GetMtId());
					
                    ChangeSpeaker(&m_tVacLastSpeaker,FALSE,TRUE,TRUE,TRUE);
                }
                else
                {
                    ChangeSpeaker(NULL);
                }
			}
			//清会议相关放像信息
			m_tPlayEqp.SetNull();
			m_tPlayEqpAttrib.Reset();
			m_tPlayFileMediaInfo.clear();
			m_tPlayFileHpAttrib.Reset();
			m_tConf.m_tStatus.SetNoPlaying();
			m_tConf.m_tStatus.SetPlayProg(tTmpProg);
			bSendConfMsg = TRUE;
		}
	}
	
	// 清vrs实体chnlStatus
	m_ptMtTable->ResetRecChnnlStatus(byVrsMtId);
	
	// 直接从会议中清除该Vrs实体
	RemoveMt(tVrsMt, TRUE, TRUE);

	//通知所有会控
	if (bSendConfMsg && bMcsMsg)
	{
		cServMsg.SetMsgBody( ( u8 * )&m_tConf, sizeof( m_tConf ) );
		if(m_tConf.HasConfExInfo())
		{
			u8 abyConfInfExBuf[CONFINFO_EX_BUFFER_LENGTH] = {0};
			u16 wPackDataLen = 0;
			PackConfInfoEx(m_tConfEx,abyConfInfExBuf,wPackDataLen);
			cServMsg.CatMsgBody(abyConfInfExBuf, wPackDataLen);
		}
		SendMsgToAllMcs( MCU_MCS_CONFINFO_NOTIF, cServMsg );
	}

	return;
}

/*====================================================================
    函数名      ：CheckVrsMtCapSet
    功能        ：新录播能力比较,返回修改后的共同能力集，用于vrs开通道
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt tMt vrs实体
	              TMultiCapSupport &tCapSupport 共同能力集
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/11  4.7      yanghuaizhi        创建
====================================================================*/
BOOL32 CMcuVcInst::CheckVrsMtCapSet(TMt tMt, TMultiCapSupport &tCapSupport)
{
	if (!tMt.IsNull() && tMt.GetType() == TYPE_MT && tMt.GetMtType() == MT_TYPE_VRSREC )
	{
		//正常vrs终端
	}
	else
	{
		// 非vrs终端
		return TRUE;
	}

	TRecChnnlStatus tVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(tMt.GetMtId());
	TVideoStreamCap tVidStrCap, tDSVidCap;
	TAudioStreamCap tAudStrCap;
	TSimCapSet tVrsMainCapSet = tCapSupport.GetMainSimCapSet();//主格式共同能力
	TSimCapSet tVrsSecCapSet = tCapSupport.GetSecondSimCapSet();//辅格式共同能力
	TDStreamCap tVrsDSVidStrCap = tCapSupport.GetDStreamCapSet();//双流共同能力
	TAudioTypeDesc tVrsAudDesc(tCapSupport.GetMainAudioType(), tCapSupport.GetMainAudioTrackNum());
	TSimCapSet tTmpCap;
	TDStreamCap tDStrCap;
	if (tVrsChlStatus.m_byType == TRecChnnlStatus::TYPE_RECORD)
	{
		//录像实体
		if (IS_RECORD_CONF(tVrsChlStatus.m_tSrc))
		{
			// 会议录像
			// 1.判断主流视频能力
			m_cRecAdaptMgr.GetRecVideoCapSet(MODE_VIDEO, tVidStrCap);
			if (tVidStrCap.GetMediaType() == MEDIA_TYPE_NULL)
			{
				tVidStrCap = m_tConf.GetMainSimCapSet().GetVideoCap();
			}
			tTmpCap.SetVideoCap(tVidStrCap);
			if (tVrsMainCapSet.GetVideoMediaType() == tTmpCap.GetVideoMediaType())
			{
				if (tVrsMainCapSet < tTmpCap)
				{
					// 主格式共同能力集小
					return FALSE;
				}
				tVrsMainCapSet.SetVideoCap(tVidStrCap);
				tCapSupport.SetMainSimCapSet(tVrsMainCapSet);
			}
			else if (tVrsSecCapSet.GetVideoMediaType() == tTmpCap.GetVideoMediaType())
			{
				if (tVrsSecCapSet < tTmpCap)
				{
					// 副格式共同能力集小
					return FALSE;
				}
				// 将其更新到主能力中，辅能力置空
				tVrsMainCapSet.SetVideoCap(tVidStrCap);
				tCapSupport.SetMainSimCapSet(tVrsMainCapSet);
				tCapSupport.SetSecVideoType(MEDIA_TYPE_NULL);
			}
			else
			{
				return FALSE;
			}
			//2.判断双流视频能力
			m_cRecAdaptMgr.GetRecVideoCapSet(MODE_SECVIDEO, tDSVidCap);
			if (tDSVidCap.GetMediaType() != MEDIA_TYPE_NULL)
			{
				memcpy(&tDStrCap, &tDSVidCap, sizeof(tDSVidCap));
				tDStrCap.SetSupportH239(tVrsDSVidStrCap.IsSupportH239());
				if (tVrsDSVidStrCap.GetMediaType() == tDStrCap.GetMediaType())
				{
					if (tVrsDSVidStrCap < tDStrCap)
					{
						// 比适配双流能力小
						return FALSE;
					}
					tCapSupport.SetSecComDStreamCapSet(tDStrCap);
				}
				else
				{
					return FALSE;
				}
			}

			//3.判音频能力,会议音频能力全存在m_tConfEx中，音频能力只判非空，默认认为录像机音频能力没问题
			if (tVrsAudDesc.GetAudioMediaType() == MEDIA_TYPE_NULL)
			{
				//无音频能力
				return FALSE;
			}
			else
			{
				if (m_cRecAdaptMgr.GetRecAudCapSet(tVrsAudDesc))
				{
					tCapSupport.SetMainAudioType(tVrsAudDesc.GetAudioMediaType());
					tCapSupport.SetMainAudioTrackNum(tVrsAudDesc.GetAudioTrackNum());
				}
			}
		}
		else
		{
			// 终端录像，与终端能力比较
			TMt tLocalSrcMt = GetLocalMtFromOtherMcuMt(tVrsChlStatus.m_tSrc);
			tTmpCap = GetMtSimCapSetByMode(tLocalSrcMt.GetMtId());
			TVideoStreamCap tTmpVidCap;
			if (tVrsMainCapSet.GetVideoMediaType() == tTmpCap.GetVideoMediaType())
			{
				if (tVrsMainCapSet < tTmpCap)
				{
					// 主格式共同能力集小
					return FALSE;
				}
				tTmpVidCap = tTmpCap.GetVideoCap();
				tVrsSecCapSet.SetVideoCap(tTmpVidCap);
				tCapSupport.SetMainSimCapSet(tVrsSecCapSet);
			}
			else if (tVrsSecCapSet.GetVideoMediaType() == tTmpCap.GetVideoMediaType())
			{
				if (tVrsSecCapSet < tTmpCap)
				{
					// 副格式共同能力集小
					return FALSE;
				}
				// 将其更新到主能力中，辅能力置空
				tTmpVidCap = tTmpCap.GetVideoCap();
				tVrsMainCapSet.SetVideoCap(tTmpVidCap);
				tCapSupport.SetMainSimCapSet(tVrsMainCapSet);
				tCapSupport.SetSecVideoType(MEDIA_TYPE_NULL);
			}
			else
			{
				return FALSE;
			}
			// 双流能力判断,取录像终端共同能力比较
			TMultiCapSupport tSrcMtCapSupport;
			m_ptMtTable->GetMtCapSupport(tLocalSrcMt.GetMtId(), &tSrcMtCapSupport);
			tDStrCap = tSrcMtCapSupport.GetDStreamCapSet();
			m_cRecAdaptMgr.GetRecVideoCapSet(MODE_SECVIDEO, tDSVidCap);
			if (tDStrCap.GetMediaType() != MEDIA_TYPE_NULL)
			{
				if (tVrsDSVidStrCap.GetMediaType() == tDStrCap.GetMediaType())
				{
					if (tVrsDSVidStrCap < tDStrCap)
					{
						// 比适配双流能力小
						return FALSE;
					}
					tCapSupport.SetSecComDStreamCapSet(tDStrCap);
				}
				else
				{
					return FALSE;
				}
			}

			// 音频判非空
			if (tVrsAudDesc.GetAudioMediaType() == MEDIA_TYPE_NULL)
			{
				//无音频能力
				return FALSE;
			}
			else
			{
				// 按终端能力更新vrs音频共同能力
				TLogicalChannel tLogicalChannel;
				if (m_ptMtTable->GetMtLogicChnnl( tLocalSrcMt.GetMtId(), LOGCHL_AUDIO, &tLogicalChannel, FALSE ))
				{
					tCapSupport.SetMainAudioType(tLogicalChannel.GetChannelType());
					tCapSupport.SetMainAudioTrackNum(tLogicalChannel.GetAudioTrackNum());
				}
			}
		}
	}

	return TRUE;
}

/*====================================================================
    函数名      ：SendStartRecReq
    功能        ：发送开启vrs新录播录像请求
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/11  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::SendStartVrsRecReq(const TStartRecMsgInfo &tStartRecMsg)
{
	TMt tRecMt = tStartRecMsg.m_tRecordMt;
	TMt tVrsRecMt = tStartRecMsg.m_tRecEqp;
	if (tVrsRecMt.GetMtType() != MT_TYPE_VRSREC)
	{
		return;
	}

	tRecMt.SetConfIdx(m_byConfIdx);
	s8 abyFileAlias[KDV_NAME_MAX_LENGTH+1];
	memset(abyFileAlias, 0, sizeof(abyFileAlias));
	memcpy(abyFileAlias, tStartRecMsg.m_aszRecName, KDV_NAME_MAX_LENGTH-1);
	u8 byPublishMode = tStartRecMsg.m_tRecPara.IsVrsPublish(); //是否发布
	u8 byLiveMode = tStartRecMsg.m_tRecPara.IsVrsLive(); //是否直播

	// MCU_REC_STARTREC_REQ消息,VRS新录播消息内容：
	// TMt(标识是否会议录像，会议录像mtid为0，否则为终端录像)+TEqp(标识录像设备)+用户组Id(u32)+录像文件名（129*s8）+ 发布方式（u8）+ 是否直播（u8）
	TEqp tEqp;//空外设，标识为vrs新录播
	CServMsg cServMsg;
    cServMsg.SetMsgBody((u8 *)&tRecMt, sizeof(TMt));
	cServMsg.CatMsgBody((u8 *)&tEqp, sizeof(TEqp));
	cServMsg.CatMsgBody((u8 *)abyFileAlias, sizeof(abyFileAlias));
	cServMsg.CatMsgBody(&byPublishMode, sizeof(byPublishMode));
	cServMsg.CatMsgBody(&byLiveMode, sizeof(byLiveMode));

	SendMsgToMt(tVrsRecMt.GetMtId(), MCU_REC_STARTREC_REQ, cServMsg);
}

/*====================================================================
    函数名      ：ProcRecMcuVrsRecChnnlStatusNotif
    功能        ：vrs新录播状态上报处理
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::ProcRecMcuVrsRecChnnlStatusNotif(CServMsg &cServMsg)
{
	TMt	tVrsRec = m_ptMtTable->GetMt( cServMsg.GetSrcMtId() );
	if (tVrsRec.IsNull() || tVrsRec.GetMtType() != MT_TYPE_VRSREC)
	{
		// 非vrs新录播，不做处理
		ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ProcRecMcuVrsRecChnnlStatusNotif] VrsRec Mt(mcuid.%d, mtid.%d) is invalid!\n",
				tVrsRec.GetMcuId(), tVrsRec.GetMtId() );
		return;
	}
	if (m_ptMtTable->GetRecChlType(tVrsRec.GetMtId()) != TRecChnnlStatus::TYPE_RECORD)
	{
		// 非录像实体，不做此处理
		ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ProcRecMcuVrsRecChnnlStatusNotif] VrsRec Mt(mcuid.%d, mtid.%d) recchltype.%d is not TYPE_RECORD!\n",
			tVrsRec.GetMcuId(), tVrsRec.GetMtId(), m_ptMtTable->GetRecChlType(tVrsRec.GetMtId()));
		return;
	}
	//REC_MCU_RECORDCHNSTATUS_NOTIF消息体为TMt+TEqp+TRecChnnlStatus
    TRecChnnlStatus tVrsChnnlStatus = *(TRecChnnlStatus *)(cServMsg.GetMsgBody() + sizeof(TMt) + sizeof(TEqp));
	TRecChnnlStatus tCurVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(tVrsRec.GetMtId());
	
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcRecMcuVrsRecChnnlStatusNotif] VrsRec Mt(mcuid.%d, mtid.%d), change channel state from %s to %s!\n",
		tVrsRec.GetMcuId(), tVrsRec.GetMtId(), tCurVrsChlStatus.GetStatusStr(tCurVrsChlStatus.m_byState), tVrsChnnlStatus.GetStatusStr(tVrsChnnlStatus.m_byState));

	TMt tRecSrc = tCurVrsChlStatus.m_tSrc;
	BOOL32 bRecordConf = IS_RECORD_CONF(tRecSrc);
	TMtStatus tRecMtStatus;
	if (!bRecordConf)
	{
		GetMtStatus(tRecSrc, tRecMtStatus);
	}
	// 状态更新处理
	BOOL32 bNeedMsg2Mcs = FALSE;
	switch (tCurVrsChlStatus.m_byState)
	{
	case TRecChnnlStatus::STATE_IDLE :
	case TRecChnnlStatus::STATE_CALLING :
		// IDLE与CALLING状态时，不接受vrs实体发来的状态信息
		break;
	case TRecChnnlStatus::STATE_RECREADY :
		{
			// RECREADY状态下，接受vrs发来的开启成功STATE_RECORDING状态上报
			if (tVrsChnnlStatus.m_byState == TRecChnnlStatus::STATE_RECORDING)
			{
				// 执行录像开启成功处理
				if (bRecordConf)
				{
					// 更新会议录像信息
					m_tRecEqp = tVrsRec;
					m_tConf.m_tStatus.SetRecording();
					
					//整理录像机拆建RTP/RTCP交换
					AdjustConfRecordSrcStream(MODE_BOTH, TRUE);
					AdjustConfRecordSrcStream(MODE_SECVIDEO, TRUE);
					//开始录像，如果是低速录像且录的是画面合成广播，画面合成的第一路码流要出低速
					if ( m_tRecPara.IsRecLowStream() && g_cMcuVcApp.IsBrdstVMP(m_tVmpEqp) )
					{
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "Mt[%d] rec is low stream, and vmp is BrdSrc, the 1st chnl of vmp will be SecBitRate[%d]!\n", tVrsRec.GetMtId(), m_tConf.GetSecBitRate());
						ChangeVmpBitRate(m_tConf.GetSecBitRate());
					}
				}
				else
				{
					//被录像终端已不在会议，停止终端录像
					if (!m_tConfAllMtInfo.MtJoinedConf(tRecSrc))
					{
						ReleaseVrsMt(tVrsRec.GetMtId());
						return;
					}

					// 更新终端录像信息
					tRecMtStatus.m_tRecState.SetRecording();

					AdjustMtRecSrcStream(MODE_BOTH, tVrsRec, 0, tRecSrc, TRUE);
					if (!m_tDoubleStreamSrc.IsNull())
					{
						AdjustMtRecSrcStream(MODE_SECVIDEO, tVrsRec, 0, tRecSrc, TRUE);
					}
					
					if (tRecSrc.IsLocal())
					{
						//通知本级终端开始发送
						NotifyMtSend(tRecSrc.GetMtId());
					}
					else if (!IsLocalAndSMcuSupMultSpy(tRecSrc.GetMcuId()))
					{
						//请求下级终端回传码流
						OnMMcuSetIn( tRecSrc, 0, SWITCH_MODE_SELECT );
					}
				}

				//请求双流源关键帧
				if (!m_tDoubleStreamSrc.IsNull() 
					&& m_tDoubleStreamSrc.GetType() == TYPE_MT
					&& ((bRecordConf && m_tRecPara.IsRecDStream()) || !bRecordConf))
				{
					NotifyFastUpdate(m_tDoubleStreamSrc, MODE_SECVIDEO);
				}

				// 状态转变
				m_ptMtTable->SetRecChlState(tVrsRec.GetMtId(), tVrsChnnlStatus.m_byState);

				bNeedMsg2Mcs = TRUE;
			}
			else
			{
				// 其它状态，加打印
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcRecMcuVrsRecChnnlStatusNotif] VrsRec channel state is invalid!\n");
			}
		}
		break;
	case TRecChnnlStatus::STATE_RECORDING :
		{
			// RECORDING状态下，接受vrs发来的暂停STATE_RECPAUSE状态上报
			if (tVrsChnnlStatus.m_byState == TRecChnnlStatus::STATE_RECPAUSE)
			{
				m_ptMtTable->SetRecChlState(tVrsRec.GetMtId(), TRecChnnlStatus::STATE_RECPAUSE);
				// 执行暂停录像处理
				if(bRecordConf)
				{
					if (!m_tConf.m_tStatus.IsRecPauseByInternal())
					{
						m_tConf.m_tStatus.SetRecPause();
					}
				}
				else
				{
					tRecMtStatus.m_tRecState.SetRecPause();
				}
				// 状态转变
				m_ptMtTable->SetRecChlState(tVrsRec.GetMtId(), tVrsChnnlStatus.m_byState);

				bNeedMsg2Mcs = TRUE;
			}
			else
			{
				// 其它状态，加打印
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcRecMcuVrsRecChnnlStatusNotif] VrsRec channel state is invalid!\n");
			}
		}
		break;
	case TRecChnnlStatus::STATE_RECPAUSE :
		{
			// RECPAUSE状态下，接受vrs发来的恢复录像STATE_RECORDING状态上报
			if (tVrsChnnlStatus.m_byState == TRecChnnlStatus::STATE_RECORDING)
			{
				// 执行恢复录像处理
				TMt tSrc;
				if (bRecordConf)
				{
					m_tConf.m_tStatus.SetRecording();
					u8  byRecChnIdx = 0;
					u8  byBasChnId  = 0;
					IsRecordSrcBas(MODE_VIDEO, tSrc, byBasChnId, byRecChnIdx);
				}
				else
				{
					tRecMtStatus.m_tRecState.SetRecording();
					tSrc = tRecSrc;
				}
				
				if (!tSrc.IsNull() && tSrc.GetType() == TYPE_MT)
				{
					NotifyFastUpdate(tSrc, MODE_VIDEO);
				}

				//请求双流源关键帧
				if (!m_tDoubleStreamSrc.IsNull() 
					&& m_tDoubleStreamSrc.GetType() == TYPE_MT
					&& ((bRecordConf && m_tRecPara.IsRecDStream()) || !bRecordConf))
				{
					NotifyFastUpdate(m_tDoubleStreamSrc, MODE_SECVIDEO);
				}
				// 状态转变
				m_ptMtTable->SetRecChlState(tVrsRec.GetMtId(), tVrsChnnlStatus.m_byState);

				bNeedMsg2Mcs = TRUE;
			}
			else
			{
				// 其它状态，加打印
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcRecMcuVrsRecChnnlStatusNotif] VrsRec channel state is invalid!\n");
			}
		}
		break;
	default :
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcRecMcuVrsRecChnnlStatusNotif] VrsRec Mt(mcuid.%d, mtid.%d) current channel state.%d is invalid!\n",
			tVrsRec.GetMcuId(), tVrsRec.GetMtId(), tCurVrsChlStatus.m_byState);
		break;
	}

	if (bNeedMsg2Mcs)
	{
		// 上报vrs通道状态MCU_MCS_RECORDCHNSTATUS_NOTIF消息体：(tmtalias(录播服务器) + TRecChnnlStatus)*个数
		TMtAlias tVrsDailAlias;
		tCurVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(tVrsRec.GetMtId());
		if (m_ptMtTable->GetDialAlias(tVrsRec.GetMtId(), &tVrsDailAlias))
		{
			cServMsg.SetMsgBody((u8*)&tVrsDailAlias, sizeof(tVrsDailAlias));
			cServMsg.CatMsgBody((u8*)&tCurVrsChlStatus, sizeof(tCurVrsChlStatus));
			SendMsgToAllMcs(MCU_MCS_RECORDCHNSTATUS_NOTIF, cServMsg);
		}
	}

}

/*====================================================================
    函数名      ：ProcRecMcuVrsPlayChnnlStatusNotif
    功能        ：vrs新录播放像状态上报处理
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::ProcRecMcuVrsPlayChnnlStatusNotif(const CMessage * pcMsg)
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
	TMt	tVrsRec = m_ptMtTable->GetMt( cServMsg.GetSrcMtId() );
	if (tVrsRec.IsNull() || tVrsRec.GetMtType() != MT_TYPE_VRSREC)
	{
		// 非vrs新录播，不做处理
		ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ProcRecMcuVrsRecChnnlStatusNotif] VrsRec Mt(mcuid.%d, mtid.%d) is invalid!\n",
			tVrsRec.GetMcuId(), tVrsRec.GetMtId() );
		return;
	}
	if (m_ptMtTable->GetRecChlType(tVrsRec.GetMtId()) != TRecChnnlStatus::TYPE_RECORD)
	{
		// 非录像实体，不做此处理
		ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ProcRecMcuVrsRecChnnlStatusNotif] VrsRec Mt(mcuid.%d, mtid.%d) recchltype.%d is not TYPE_RECORD!\n",
			tVrsRec.GetMcuId(), tVrsRec.GetMtId(), m_ptMtTable->GetRecChlType(tVrsRec.GetMtId()));
		return;
	}
	//REC_MCU_PLAYCHNSTATUS_NOTIF消息体为TEqp+TRecChnnlStatus
    TRecChnnlStatus tVrsChnnlStatus = *(TRecChnnlStatus *)(cServMsg.GetMsgBody() + sizeof(TEqp));
	TRecChnnlStatus tCurVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(tVrsRec.GetMtId());

	
	// 状态更新处理
	BOOL32 bNeedMsg2Mcs = FALSE;
	switch (tCurVrsChlStatus.m_byState)
	{
	case TRecChnnlStatus::STATE_IDLE :
	case TRecChnnlStatus::STATE_CALLING :
		// IDLE/CALLING状态时，不接受vrs实体发来的状态信息
		break;
	case TRecChnnlStatus::STATE_PLAYREADY :
		{
			//READY状态接受PLAYING状态上报
			if (tVrsChnnlStatus.m_byState == TRecChnnlStatus::STATE_PLAYING)
			{
				m_tConf.m_tStatus.SetPlaying();
				m_ptMtTable->SetRecChlState(tVrsRec.GetMtId(), TRecChnnlStatus::STATE_PLAYING);
				bNeedMsg2Mcs = TRUE;
			}
		}
		break;
	case TRecChnnlStatus::STATE_PLAYING :
		{
			// 接受暂停状态上报
			if (tVrsChnnlStatus.m_byState == TRecChnnlStatus::STATE_PLAYPAUSE)
			{
				//暂停放像
				m_tConf.m_tStatus.SetPlayPause();
				m_ptMtTable->SetRecChlState(tVrsRec.GetMtId(), TRecChnnlStatus::STATE_PLAYPAUSE);
				bNeedMsg2Mcs = TRUE;
			}
		}
		break;
	case TRecChnnlStatus::STATE_PLAYPAUSE:
		{
			// 接受恢复放像状态上报
			if (tVrsChnnlStatus.m_byState == TRecChnnlStatus::STATE_PLAYING)
			{
				//恢复放像
				m_tConf.m_tStatus.SetPlaying();
				m_ptMtTable->SetRecChlState(tVrsRec.GetMtId(), TRecChnnlStatus::STATE_PLAYING);
				bNeedMsg2Mcs = TRUE;
			}
		}
		break;
	default:
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcRecMcuVrsPlayChnnlStatusNotif] VrsRec Mt(mcuid.%d, mtid.%d) current channel state.%d is invalid!\n",
			tVrsRec.GetMcuId(), tVrsRec.GetMtId(), tCurVrsChlStatus.m_byState);
		break;
	}
	
	if (bNeedMsg2Mcs)
	{
		// 上报会议状态
		ConfModeChange();
		// 上报vrs通道状态MCU_MCS_RECORDCHNSTATUS_NOTIF消息体：(tmtalias(录播服务器) + TRecChnnlStatus)*个数
		TMtAlias tVrsDailAlias;
		tCurVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(tVrsRec.GetMtId());
		if (m_ptMtTable->GetDialAlias(tVrsRec.GetMtId(), &tVrsDailAlias))
		{
			cServMsg.SetMsgBody((u8*)&tVrsDailAlias, sizeof(tVrsDailAlias));
			cServMsg.CatMsgBody((u8*)&tCurVrsChlStatus, sizeof(tCurVrsChlStatus));
			SendMsgToAllMcs(MCU_MCS_RECORDCHNSTATUS_NOTIF, cServMsg);
		}
	}
}

/*====================================================================
    函数名      ：PrintVrsInfo
    功能        ：打印当前vrs信息
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::PrintVrsInfo(void)
{
	for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId ++)
	{
		if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
		{
			StaticLog("VrsMtId.%d  ", byMtId);
			m_ptMtTable->GetRecChnnlStatus(byMtId).print();
		}
	}

	return;
}

/*====================================================================
    函数名      ：IsVrsRecMt
    功能        ：是否是vrs新录播实体
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt tMt
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
BOOL32 CMcuVcInst::IsVrsRecMt(const TMt &tMt)
{
	if (!tMt.IsNull() && tMt.GetType() == TYPE_MT && tMt.GetMtType() == MT_TYPE_VRSREC)
	{
		return TRUE;
	}

	return FALSE;
}

/*====================================================================
    函数名      ：ProcMcsMcuCloseListRecordCmd
    功能        ：会控关闭文件列表（用于挂断vrs新录播实体）
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuCloseListRecordCmd(const CMessage * pcMsg)
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
	//判是新录播才做处理
	TEqp tEqp = *(TEqp *)cServMsg.GetMsgBody();
	if (!tEqp.IsNull())
	{
		return;
	}

	if (m_tPlayEqpAttrib.GetListRecordSrcSsnId() != 0
		&& m_tPlayEqpAttrib.GetListRecordSrcSsnId() == cServMsg.GetSrcSsnId())
	{
		if (m_tPlayEqp.GetType() == TYPE_MT && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC)
		{
			if (m_ptMtTable->GetRecChlState(m_tPlayEqp.GetMtId()) != TRecChnnlStatus::STATE_IDLE
				&& m_ptMtTable->GetRecChlState(m_tPlayEqp.GetMtId()) != TRecChnnlStatus::STATE_CALLING)
			{
				ReleaseVrsMt(m_tPlayEqp.GetMtId(), 0, FALSE);
			}
		}
	}
	
}

/*====================================================================
    函数名      ：StartSwitchToRecorder
    功能        ：给录像机建交换，支持录像机外设与vrs新录播
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt tSrc, u16 wSrcChnnl, TEqp tRec,
				  u8 byDstChnnl, u8 byMode, u8 bySwitchMode,
				  BOOL32 bStopBeforeStart
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
BOOL32 CMcuVcInst::StartSwitchToRecorder(TMt tSrc, u16 wSrcChnnl, TEqp tRec, 
									   u8 byDstChnnl, u8 byMode, u8 bySwitchMode,
									   BOOL32 bStopBeforeStart, BOOL32 bAddRtcp)
{
	if (tRec.GetType() == TYPE_MT && tRec.GetMtType() == MT_TYPE_VRSREC)
	{
		// 新录播建交换处理
		TSwitchGrp tSwitchGrp;
		tSwitchGrp.SetSrcChnl((u8)wSrcChnnl);
		tSwitchGrp.SetDstMtNum(1);
		TMt tMt = m_ptMtTable->GetMt(tRec.GetMtId());
		tSwitchGrp.SetDstMt(&tMt);
		StartSwitchToAll( tSrc, 1, &tSwitchGrp, byMode,bySwitchMode );
	}
	else
	{
		// 录像机外设建交换处理
		return StartSwitchToPeriEqp(tSrc, wSrcChnnl, tRec.GetEqpId(), byDstChnnl, byMode, 
			bySwitchMode, FALSE, bStopBeforeStart, FALSE, bAddRtcp);
	}

	return TRUE;
}

/*====================================================================
    函数名      ：StopSwitchToRecorder
    功能        ：拆到录像机的交换，支持录像机外设与vrs新录播
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt tSrc, u16 wSrcChnnl, TEqp tRec,
				  u8 byDstChnnl, u8 byMode, u8 bySwitchMode,
				  BOOL32 bStopBeforeStart
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::StopSwitchToRecorder(TEqp tRec, u8 byDstChnnl, BOOL32 bMsg, u8 byMode)
{
	if (tRec.GetType() == TYPE_MT && tRec.GetMtType() == MT_TYPE_VRSREC)
	{
		// 新录播建交换处理
	}
	else
	{
		// 录像机外设建交换处理
		StopSwitchToPeriEqp(tRec.GetEqpId(), byDstChnnl, bMsg, byMode);
	}
	
	return;
}

/*====================================================================
    函数名      ：GetVrsCallAliasByVrsCfgId
    功能        ：根据vrs配置id获得其呼叫信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byVrsId, TMtAlias &tVrsAlias
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
BOOL32 CMcuVcInst::GetVrsCallAliasByVrsCfgId(u8 byVrsId, TMtAlias &tVrsAlias)
{
	if (byVrsId <= RECORDERID_MAX || byVrsId > RECORDERID_MAX + MAX_PRIEQP_NUM)
	{
		return FALSE;
	}

	// 获得真实索引id
	byVrsId -= RECORDERID_MAX;
	TEqpVrsRecCfgInfo atVrsRecInfo[MAXNUM_PERIEQP];
	u8 byVrsRecNum = 0;
	u16 wRet = g_cMcuAgent.ReadVrsRecTable(&byVrsRecNum, atVrsRecInfo);
	if (SUCCESS_AGENT == wRet)
	{
		if (byVrsRecNum <= MAXNUM_PERIEQP)
		{
			for (u8 byIdx = 0; byIdx < byVrsRecNum; byIdx++)
			{
				if (atVrsRecInfo[byIdx].GetVrsId() == byVrsId)
				{
					// 找到指定vrs录播服务器
					tVrsAlias = atVrsRecInfo[byIdx].GetVrsCallAlias();
					return TRUE;
				}
			}
		}
	}   

	// 未找到返回FALSE
	return FALSE;
}

/*====================================================================
    函数名      ：ProcMcsMcuGetRecChnnlStatusCmd
    功能        ：查询录像机状态
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuGetRecChnnlStatusCmd(const CMessage * pcMsg)
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	u8 byGetAll = *(u8 *)cServMsg.GetMsgBody();
	u8 byChlType = *(u8 *)(cServMsg.GetMsgBody() + sizeof(u8));
	TMt tRecSrc = *(TMt *)(cServMsg.GetMsgBody() + sizeof(u8) + sizeof(u8));

	TMtAlias tVrsDialAlias;
	TRecChnnlStatus tVrsChlStatus;
	BOOL32 bSendMsg = FALSE;
	if (byGetAll == TRUE)
	{
		// 上报所有vrs通道状态
		TMt tTmpMt;
		cServMsg.SetMsgBody();
		for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId ++)
		{
			tTmpMt = m_ptMtTable->GetMt(byMtId);
			if (tTmpMt.IsNull() || tTmpMt.GetMtType() != MT_TYPE_VRSREC)
			{
				continue;
			}
			if (!m_tConfAllMtInfo.MtJoinedConf(tTmpMt.GetMtId()))
			{
				// 未与会的不上报
				continue;
			}
			m_ptMtTable->GetDialAlias(byMtId, &tVrsDialAlias);
			tVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(byMtId);
			cServMsg.CatMsgBody((u8*)&tVrsDialAlias, sizeof(tVrsDialAlias));
			cServMsg.CatMsgBody((u8*)&tVrsChlStatus, sizeof(tVrsChlStatus));
			bSendMsg = TRUE;
		}

		if (bSendMsg)
		{
			SendMsgToAllMcs(MCU_MCS_RECORDCHNSTATUS_NOTIF, cServMsg);
		}
		return;
	}

	if (byChlType == TRecChnnlStatus::TYPE_RECORD)
	{
		TEqp tRecorder;
		u8 byRecChannel;
		GetMtRecordInfo(tRecSrc, tRecorder, byRecChannel);
		if (!tRecorder.IsNull() && tRecorder.GetMtType() == MT_TYPE_VRSREC
			&& m_tConfAllMtInfo.MtJoinedConf(tRecorder.GetMtId()))
		{
			m_ptMtTable->GetDialAlias(tRecorder.GetMtId(), &tVrsDialAlias);
			tVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(tRecorder.GetMtId());
			bSendMsg = TRUE;
		}
	}
	else if (byChlType == TRecChnnlStatus::TYPE_PLAY)
	{
		if (!m_tPlayEqp.IsNull() && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC
			&& m_tConfAllMtInfo.MtJoinedConf(m_tPlayEqp.GetMtId()))
		{
			m_ptMtTable->GetDialAlias(m_tPlayEqp.GetMtId(), &tVrsDialAlias);
			tVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(m_tPlayEqp.GetMtId());
			bSendMsg = TRUE;
		}
	}

	if (bSendMsg)
	{
		cServMsg.SetMsgBody((u8*)&tVrsDialAlias, sizeof(tVrsDialAlias));
		cServMsg.CatMsgBody((u8*)&tVrsChlStatus, sizeof(tVrsChlStatus));
		SendMsgToAllMcs(MCU_MCS_RECORDCHNSTATUS_NOTIF, cServMsg);
	}

	return;
}

/*====================================================================
    函数名      ：ProcGetVrsListRecord
    功能        ：查询录像机状态
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMtAlias &tMtAlias, vrs呼叫信息
				  TMt tVrs, vrs对应实体
				  u8 byListType, 查询列表类型0无效1分组列表2文件列表
				  u32 dwGroupId, 分组id
				  u32 dwPageNo, 第几页
				  u32 dwPageNum 单页个数
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::ProcGetVrsListRecord(TMtAlias &tMtAlias, TMt tVrs, u8 byListType, u32 dwGroupId, u32 dwPageNo, u32 dwListNum)
{
	if (!tVrs.IsNull() && tVrs.GetMtType() != MT_TYPE_VRSREC)
	{
		// 非vrs实体不做处理
		ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ProcGetVrsListRecord] tVrs(%d,%d) is invalid! Mttype.%d\n", 
			tVrs.GetMcuId(), tVrs.GetMtId(), tVrs.GetMtType());
		return;
	}
	//状态判断，此处理只接受IDLE,CALLING,READY三种状态下执行
	u8 byVrsMtId = tVrs.GetMtId();
	TRecChnnlStatus tVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(tVrs.GetMtId());

	// 判当前是否有vrs放像实体，有则加判tMtAlias是否一致，不一致则需要挂断旧vrs放像实体
	if (!m_tPlayEqp.IsNull() && m_tPlayEqp.GetType() == TYPE_MT && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC)
	{
		TMtAlias tCurVrsAlias;
		m_ptMtTable->GetDialAlias(m_tPlayEqp.GetMtId(), &tCurVrsAlias);
		if( tMtAlias.m_tTransportAddr.GetIpAddr() != 0 && tCurVrsAlias.m_tTransportAddr.GetIpAddr() != 0
			&& tCurVrsAlias.m_tTransportAddr.GetIpAddr() != tMtAlias.m_tTransportAddr.GetIpAddr())
		{
			tCurVrsAlias.Print();
			ReleaseVrsMt(m_tPlayEqp.GetMtId());//先清除旧放像源，再执行呼叫新放像源
		}
	}

	tMtAlias.Print();
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ProcGetVrsListRecord] tVrs(%d,%d) byListType.%d dwGroupId.%d dwPageNo.%d dwListNum.%d\n", 
		tVrs.GetMcuId(), tVrs.GetMtId(), byListType, dwGroupId, dwPageNo, dwListNum);

	u8 byVrsCurState = tVrsChlStatus.m_byState;
	CServMsg cServMsg;
	switch (byVrsCurState)
	{
	case TRecChnnlStatus::STATE_IDLE:
		{
			//添加放像实体
			u16 wMtDialRate = m_tConf.GetBitRate();
			u8 byCallMode = CONF_CALLMODE_NONE;
			TMt tSrc;// 放像设备tsrc为空
			byVrsMtId = AddVrsMt(tMtAlias, TRecChnnlStatus::TYPE_PLAY, tSrc, wMtDialRate, byCallMode);
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "Mcu add vrsrec mt-%d DialBitRate-%d CallMode-%d aliasType-%d\n", 
				byVrsMtId, wMtDialRate, byCallMode, tMtAlias.m_AliasType );
			if (byVrsMtId == 0 || byVrsMtId > MAXNUM_CONF_MT)
			{
				//未能成功添加新录播实体
				ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[StartVrsRec]No free Mtid for AddVrsMt(). return!\n");
				break;
			}
			
			if (m_tPlayEqpAttrib.GetListRecordSrcSsnId() == 0)
			{
				// 记录mcs的srcssnid
				m_tPlayEqpAttrib.SetListRecordSrcSsnId(cServMsg.GetSrcSsnId());
			}

			//更新请求放像列表相关信息，呼叫成功后做后续处理
			TMt tVrsMt = m_ptMtTable->GetMt(byVrsMtId);
			m_tPlayEqp = tVrsMt;
			m_tPlayEqpAttrib.SetReqType(byListType);
			m_tPlayEqpAttrib.SetGroupId(dwGroupId);
			m_tPlayEqpAttrib.SetPageNo(dwPageNo);
			m_tPlayEqpAttrib.SetListNum(dwListNum);
			
			//呼叫放像实体
			cServMsg.SetConfId( m_tConf.GetConfId() );
			cServMsg.SetNoSrc();
			cServMsg.SetTimer( TIMESPACE_WAIT_AUTOINVITE );
			cServMsg.SetMsgBody( NULL, 0 );
			InviteUnjoinedMt(cServMsg, &tVrsMt);

			//状态更新为CALLING
			m_ptMtTable->SetRecChlType(byVrsMtId, TRecChnnlStatus::TYPE_PLAY);
			m_ptMtTable->SetRecChlState(byVrsMtId, TRecChnnlStatus::STATE_CALLING);
		}
		break;
	case TRecChnnlStatus::STATE_CALLING:
	case TRecChnnlStatus::STATE_PLAYREADY:
		{
			// 判当前请求类型
			if (byListType != TPlayEqpAttrib::TYPE_FILELIST)
			{
				//请求类型不正确
				ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ProcGetVrsListRecord]ReqType.%d is invalid. return!\n", byListType);
				break;
			}
			if (tVrsChlStatus.m_byType != TRecChnnlStatus::TYPE_PLAY)
			{
				// 通道类型不正确
				ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ProcGetVrsListRecord]Vrs chlType.%d is invalid. return!\n", tVrsChlStatus.m_byType);
				break;
			}

			//MCU_REC_LISTALLRECORD_REQ消息体为TEqp + u8（列表类型定义0无效1分组列表2文件列表） + 文件组Id（u32） + u32第几页 + u32单页个数
			TEqp tEqp;
			dwGroupId = htonl(dwGroupId);//转为网络序
			dwPageNo = htonl(dwPageNo);
			dwListNum = htonl(dwListNum);
			cServMsg.SetMsgBody((u8*)&tEqp, sizeof(tEqp));
			cServMsg.CatMsgBody((u8*)&dwGroupId, sizeof(dwGroupId));
			cServMsg.CatMsgBody((u8*)&dwPageNo, sizeof(dwPageNo));
			cServMsg.CatMsgBody((u8*)&dwListNum, sizeof(dwListNum));

			SendMsgToMt(byVrsMtId, MCU_REC_LISTALLRECORD_REQ, cServMsg);
			
			//状态更新为CALLING
			m_ptMtTable->SetRecChlState(byVrsMtId, TRecChnnlStatus::STATE_PLAYREADY);
		}
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ProcGetVrsListRecord]VrsCurState is %d. Listrecord requestion is invalid, return!\n", 
					byVrsCurState);
		break;
	}
}

/*====================================================================
    函数名      ：ProcVrsMcuListAllRecNotif
    功能        ：vrs放像列表上报，包含分组列表与文件列表
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::ProcVrsMcuListAllRecNotif(const CMessage * pcMsg)
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TMt tVrsMt = m_ptMtTable->GetMt(cServMsg.GetSrcMtId());
	if (tVrsMt.IsNull() || tVrsMt.GetMtType() != MT_TYPE_VRSREC)
	{
		// 参数不正确
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ProcVrsMcuListAllRecNotif]VrsMt Mtid.%d is invalid, return!\n", 
			tVrsMt.GetMtId());
		return;
	}

	//vrs新录播上报文件列表
	SendMsgToAllMcs(MCU_MCS_LISTALLRECORD_NOTIF, cServMsg);

	return;
}

/*====================================================================
    函数名      ：ProcMcsMcuStartVrsPlayReq
    功能        ：开启vrs放像请求
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuStartVrsPlayReq(const CMessage * pcMsg)
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
	TPlayEqpAttrib tPlayAttrib;
	// MCS_MCU_STARTPLAY_REQ消息内容：TEqp(标识录像设备) + u8(是否双流放像) + 录像名(0结尾字符串,固定大小129字节) 
	// + tMtalias(新录播alias) + 播放文件的文件ID(u32)
	u8 *pbyBuf = cServMsg.GetMsgBody();
	TEqp tRecEqp = *(TEqp*)pbyBuf;
	pbyBuf += sizeof(tRecEqp);
	if (!tRecEqp.IsNull())
	{
		// 外设不为空，不是vrs新录播，不做处理
		return;
	}
	tPlayAttrib.SetDStreamPlay(*pbyBuf);
	pbyBuf++;
	tPlayAttrib.SetRecName((s8*)pbyBuf);
	pbyBuf += MAXLEN_ALIAS+1;
	TMtAlias tVrsAlias = *(TMtAlias*) pbyBuf;
	pbyBuf += sizeof(tVrsAlias);
	u32 dwFileId = *(u32*) pbyBuf;
	dwFileId = ntohl(dwFileId);
	tPlayAttrib.SetFileId(dwFileId);//播放文件的文件ID(u32)

	// 如果当前已在放像，Nack
	if (!m_tPlayEqp.IsNull() && m_tConf.m_tStatus.IsPlaying())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,  "[ProcMcsMcuStartVrsPlayReq] Recorder is playing in conf!\n", 
			m_tPlayEqp.GetMcuId(), m_tPlayEqp.GetMtId());
		cServMsg.SetErrorCode( ERR_MCU_CONFPLAYING );
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
		return;
	}
	
	SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );

	StartVrsPlay(tVrsAlias, tPlayAttrib);

	return;
}

/*====================================================================
    函数名      ：StartVrsPlay
    功能        ：开启vrs放像,包含呼叫处理
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/10/15  4.7      yanghuaizhi        创建
====================================================================*/
void CMcuVcInst::StartVrsPlay(TMtAlias &tMtAlias, TPlayEqpAttrib tPlayAttrib)
{
	// 参数判断
	if (tMtAlias.m_AliasType != mtAliasTypeTransportAddress)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,  "[StartVrsPlay] tMtAlias AliasType.%d is invalid!\n", 
			tMtAlias.m_AliasType);
		return;
	}
	
	// 判当前是否有vrs放像实体，有则加判tMtAlias是否一致，不一致则需要挂断旧vrs放像实体
	if (!m_tPlayEqp.IsNull() && m_tPlayEqp.GetType() == TYPE_MT && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC)
	{
		TMtAlias tCurVrsAlias;
		m_ptMtTable->GetDialAlias(m_tPlayEqp.GetMtId(), &tCurVrsAlias);
		if( tMtAlias.m_tTransportAddr.GetIpAddr() != 0 && tCurVrsAlias.m_tTransportAddr.GetIpAddr() != 0
			&& tCurVrsAlias.m_tTransportAddr.GetIpAddr() != tMtAlias.m_tTransportAddr.GetIpAddr())
		{
			tCurVrsAlias.Print();
			ReleaseVrsMt(m_tPlayEqp.GetMtId());//先清除旧放像源，再执行呼叫新放像源
		}
	}

	u8 byVrsMtId = 0;
	if (!m_tPlayEqp.IsNull() && m_ptMtTable->GetMtType(m_tPlayEqp.GetMtId()) == MT_TYPE_VRSREC)
	{
		byVrsMtId = m_tPlayEqp.GetMtId();
	}
	TRecChnnlStatus tVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(byVrsMtId);
	u8 byVrsCurState = tVrsChlStatus.m_byState;
	
	tMtAlias.Print();
	tPlayAttrib.Print();

	CServMsg	cServMsg;
	//本处理仅支持IDLE/CALLING/READY三种状态，其余状态不做处理加异常打印
	switch (byVrsCurState)
	{
	case TRecChnnlStatus::STATE_IDLE :
		{
			//添加放像实体
			u16 wMtDialRate = m_tConf.GetBitRate();
			u8 byCallMode = CONF_CALLMODE_NONE;
			TMt tSrc;// 放像设备tsrc为空
			byVrsMtId = AddVrsMt(tMtAlias, TRecChnnlStatus::TYPE_PLAY, tSrc, wMtDialRate, byCallMode);
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_CONF, "Mcu add vrsrec mt-%d DialBitRate-%d CallMode-%d aliasType-%d\n", 
				byVrsMtId, wMtDialRate, byCallMode, tMtAlias.m_AliasType );
			if (byVrsMtId == 0 || byVrsMtId > MAXNUM_CONF_MT)
			{
				//未能成功添加新录播实体
				ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[StartVrsRec]No free Mtid for AddVrsMt(). return!\n");
				break;
			}
			
			//更新请求放像列表相关信息，呼叫成功后做后续处理
			TMt tVrsMt = m_ptMtTable->GetMt(byVrsMtId);
			m_tPlayEqp = tVrsMt;
			m_tPlayEqpAttrib = tPlayAttrib;
			m_tPlayEqpAttrib.SetReqType(TPlayEqpAttrib::TYPE_STARTPLAY);
			
			//呼叫放像实体
			cServMsg.SetConfId( m_tConf.GetConfId() );
			cServMsg.SetNoSrc();
			cServMsg.SetTimer( TIMESPACE_WAIT_AUTOINVITE );
			cServMsg.SetMsgBody( NULL, 0 );
			InviteUnjoinedMt(cServMsg, &tVrsMt);
			
			//状态更新为CALLING
			m_ptMtTable->SetRecChlType(byVrsMtId, TRecChnnlStatus::TYPE_PLAY);
			m_ptMtTable->SetRecChlState(byVrsMtId, TRecChnnlStatus::STATE_CALLING);
		}
		break;
	case TRecChnnlStatus::STATE_CALLING:
	case TRecChnnlStatus::STATE_PLAYREADY:
		{
			// 判当前请求类型
			u8 byReqType = m_tPlayEqpAttrib.GetReqType();
			if (byReqType != TPlayEqpAttrib::TYPE_STARTPLAY)
			{
				//请求类型不正确
				ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[StartVrsPlay]ReqType.%d is invalid. return!\n", byReqType);
				break;
			}
			if (tVrsChlStatus.m_byType != TRecChnnlStatus::TYPE_PLAY)
			{
				// 通道类型不正确
				ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[StartVrsPlay]Vrs chlType.%d is invalid. return!\n", tVrsChlStatus.m_byType);
				break;
			}

			//组织开启放像消息
			//消息内容：TEqp(标识录像设备) + 播放文件的文件ID(u32)
			TEqp tEqp;
			s8 *pVrsPlayData = NULL;
			u16 wVrsPlayDataLen = 0;
			u8 byEncryptMode = m_tConf.GetMediaKey().GetEncryptMode() != CONF_ENCRYPTMODE_NONE;//加密放像是否从会议信息取
			u32 dwFileId = htonl(tPlayAttrib.GetFileId());
			cServMsg.SetMsgBody((u8*)&tEqp, sizeof(tEqp));
			cServMsg.CatMsgBody((u8*)&dwFileId, sizeof(dwFileId));

			SendMsgToMt(byVrsMtId, MCU_REC_STARTPLAY_REQ, cServMsg);

			//状态更新为READY
			m_ptMtTable->SetRecChlState(byVrsMtId, TRecChnnlStatus::STATE_PLAYREADY);
		}
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[StartVrsPlay]VrsCurState is %d. Listrecord requestion is invalid, return!\n", 
					byVrsCurState);
		break;
	}
}

/*====================================================================
    函数名      StartConfRec
    功能        ：开启会议录像
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/05/27  4.7         倪志俊         创建
====================================================================*/
void CMcuVcInst::StartConfRec(const TStartRecMsgInfo &tRecMsg)
{
	//1.准备参数
	TStartRecData tRecData;
	PrepareDataForConfRec(tRecMsg,tRecData);

	//2.发送开启录像请求
	SendStartRecReq(tRecMsg,tRecData);
	return;
}


/*====================================================================
    函数名      StartMtRec
    功能        ：开启终端录像
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/05/27  4.7         倪志俊         创建
====================================================================*/
void CMcuVcInst::StartMtRec(const TStartRecMsgInfo &tRecMsg,BOOL32 bIsNeedPreSetIn/* = TRUE*/,const TSpyRecInfo *ptSpyRecInfo /*= NULL*/)
{
	//是否需要presetin额外处理
	TMt tRecordMt = tRecMsg.m_tRecordMt;
	if ( bIsNeedPreSetIn && !tRecordMt.IsLocal() && IsLocalAndSMcuSupMultSpy(tRecordMt.GetMcuId()) )
	{
		TPreSetInReq tSpySrcInitInfo;
		tSpySrcInitInfo.m_tSpyMtInfo.SetSpyMt( tRecordMt );
		tSpySrcInitInfo.m_tSpyInfo.m_tSpyRecInfo.m_tRec = tRecMsg.m_tRecEqp;
		tSpySrcInitInfo.m_bySpyMode = MODE_BOTH;
		tSpySrcInitInfo.SetEvId(MCS_MCU_STARTREC_REQ);
		//tSpySrcInitInfo.m_dwEvId = MCS_MCU_STARTREC_REQ;
		tSpySrcInitInfo.m_tSpyInfo.m_tSpyRecInfo.m_tRecPara = tRecMsg.m_tRecPara;
		tSpySrcInitInfo.m_tSpyInfo.m_tSpyRecInfo.m_byRecMode = 1; // 终端录像
		tSpySrcInitInfo.m_tSpyInfo.m_tSpyRecInfo.m_wSerialNO = tRecMsg.m_wSerialNO; // 当前mcs的消息流水号
		TMcsRegInfo tMcRegInfo;
		if (g_cMcuVcApp.GetMcsRegInfo(tRecMsg.m_bySrcSsnId, &tMcRegInfo))
		{
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyRecInfo.SetMcIp(tMcRegInfo.GetMcsIpAddr());
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyRecInfo.SetMcSSRC(tMcRegInfo.GetMcsSSRC());
		}				
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[StartMtRec] McsIp.%s, McSSrc.%x!\n", 
			StrOfIP(tSpySrcInitInfo.m_tSpyInfo.m_tSpyRecInfo.GetMcIp()),
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyRecInfo.GetMcSSRC());
		
		memcpy(tSpySrcInitInfo.m_tSpyInfo.m_tSpyRecInfo.m_szRecFullName, tRecMsg.m_aszRecName, strlen(tRecMsg.m_aszRecName));
		
		// [pengjie 2010/9/13] 填目的端能力
		TMt tLocalRecordMt = GetLocalMtFromOtherMcuMt( tRecordMt );
		TSimCapSet tSimCapSet = GetMtSimCapSetByMode( tLocalRecordMt.GetMtId() );	
		//zjl20101116 如果当前终端已回传则能力集要与已回传目的能力集取小
		
		if(!GetMinSpyDstCapSet(tRecordMt, tSimCapSet))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_SPY, "[StartMtRec] Get Mt(mcuid.%d, mtid.%d) SimCapSet Failed!\n",
				tLocalRecordMt.GetMcuId(), tLocalRecordMt.GetMtId() );
			
			return;
		}
		
		tSpySrcInitInfo.m_tSpyMtInfo.SetSimCapset( tSimCapSet );
		// End
		
		OnMMcuPreSetIn( tSpySrcInitInfo );
		return;
	}


	//1.准备参数
	TStartRecData tRecData;
	PrepareDataForMtRec(tRecMsg,tRecData);

	//2.发送开启录像请求
	SendStartRecReq(tRecMsg, tRecData, ptSpyRecInfo);
	return;
}


/*====================================================================
    函数名      IsConfRecCheckPass
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/05/27  4.7         倪志俊         创建
====================================================================*/
BOOL32 CMcuVcInst::IsConfRecCheckPass(TStartRecMsgInfo & tRecMsg, u16* pwErrCode)
{		
	if ( pwErrCode == NULL )
	{
		ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[IsConfRecCheckPass]pwErrCode is NULL\n");
		return FALSE;
	}

	if (!m_tConf.m_tStatus.IsNoRecording())
	{
		*pwErrCode=ERR_MCU_CONFRECORDING;
		ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[IsConfRecCheckPass]conference is recording!\n");
		return FALSE;
	}

	if ( m_tConfEx.IsDoubleAACLCConf()&&
		!IsRecNeedAdapt(MODE_AUDIO)
		)
	{
		*pwErrCode=ERR_MCU_AACLC_CONF_NEED_RECADPAT;
		ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[IsConfRecCheckPass]AAClc conference need aud adapt!\n");
		return FALSE;
	}
	
#ifdef _MINIMCU_
	if ( ISTRUE(m_byIsDoubleMediaConf) && tRecMsg.m_tRecPara.IsRecLowStream() )
	{
		*pwErrCode = ERR_MCU_RECLOWNOSUPPORT;
		ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[IsConfRecCheckPass]conference not support record low stream!\n");
		return FALSE;
	}
#endif

	if (tRecMsg.bIsRecAdaptConf && !InitRecAdptParam())
	{
		// 释放保存的自定义格式
		ResetRecAdptParam();	
		*pwErrCode = ERR_MCU_GETIDLELBASCHN_FAILED;
		ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[IsConfRecCheckPass]Get Idle Bas Chnn failed,rec req nacked!\n");
		return FALSE;
	}
	return TRUE;
}

/*====================================================================
    函数名      SendStartRecReq
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/05/27  4.7         倪志俊         创建
====================================================================*/
void CMcuVcInst::SendStartRecReq(const TStartRecMsgInfo &tStartRecMsg, const TStartRecData &tRecData,const TSpyRecInfo *ptSpyRecInfo/* = NULL*/)
{
	TMt tRecMt = tStartRecMsg.m_tRecordMt;
	tRecMt.SetConfIdx(m_byConfIdx);

	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	u8 byNeedPrs		   = tConfAttrb.IsResendLosePack();
	TMediaEncrypt tEncrypt = m_tConf.GetMediaKey();

	// [pengjie 2010/9/17] 这里即使是单回传也要使用非local的录像源信息给下级
	CServMsg cServMsg;
	cServMsg.SetEventId(MCS_MCU_STARTREC_REQ);
	cServMsg.SetSerialNO(tStartRecMsg.m_wSerialNO);
	if ( ptSpyRecInfo != NULL )
	{
		cServMsg.SetSerialNO(ptSpyRecInfo->m_wSerialNO); // 当前mcs的消息流水号
		u16 wMcIns = g_cMcuVcApp.GetMcIns(ptSpyRecInfo->GetMcIp(), 
			ptSpyRecInfo->GetMcSSRC(),
			m_tConf.GetConfSource());
		if (0 == wMcIns)
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[SendStartRecReq] GetMcIns from McIp.%s McSSrc.%x failed!\n", 
				StrOfIP(ptSpyRecInfo->GetMcIp()),
				ptSpyRecInfo->GetMcSSRC());
		}
		else
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[SendStartRecReq]  GetMcIns Success McIns.%d from McIp.%s McSSrc.%x!\n", 
				wMcIns, StrOfIP(ptSpyRecInfo->GetMcIp()),
				ptSpyRecInfo->GetMcSSRC());
			cServMsg.SetSrcSsnId((u8)wMcIns);
		}
	}
	else
	{
		cServMsg.SetSrcSsnId( tStartRecMsg.m_bySrcSsnId );
	}

    cServMsg.SetMsgBody((u8 *)&tRecMt, sizeof(TMt));
	cServMsg.CatMsgBody((u8 *)&tStartRecMsg.m_tRecEqp, sizeof(TEqp));
	cServMsg.CatMsgBody((u8 *)&tStartRecMsg.m_tRecPara, sizeof(TRecStartPara));
	cServMsg.CatMsgBody((u8 *)&byNeedPrs, sizeof(u8));
	cServMsg.CatMsgBody((u8 *)&tRecData.m_tRtcpBack, sizeof(TRecRtcpBack));
	cServMsg.CatMsgBody((u8 *)&tEncrypt, sizeof(tEncrypt));     //video encrypt
	cServMsg.CatMsgBody((u8 *)&tRecData.m_tDVPayload,sizeof(TDoublePayload)); //video payload
	cServMsg.CatMsgBody((u8 *)&tEncrypt, sizeof(tEncrypt));     //audio encrypt
	cServMsg.CatMsgBody((u8 *)&tRecData.m_tDAPayload, sizeof(TDoublePayload)); //audio payload
	cServMsg.CatMsgBody((u8 *)&tEncrypt, sizeof(tEncrypt));     //double video encrypt
	cServMsg.CatMsgBody((u8 *)&tRecData.m_tDDVPayload, sizeof(TDoublePayload)); //double video payload

     // MCU前向纠错, zgc, 2007-09-28
    TCapSupportEx tCapSupportEx = m_tConf.GetCapSupportEx();
	cServMsg.CatMsgBody((u8 *)&tCapSupportEx, sizeof(tCapSupportEx));
	
	s8 aszGBKRecName[MAX_FILE_NAME_LEN] = {0};
	strncpy(aszGBKRecName,tStartRecMsg.m_aszRecName,strlen(tStartRecMsg.m_aszRecName));
	u16 wRecNameLen = strlen(aszGBKRecName) + 1;

	//  [5/17/2013 guodawei] 开启录像文件名GBK转换
#ifdef _UTF8
	if (g_cMcuVcApp.GetEqpCodeFormat(tStartRecMsg.m_tRecEqp.GetMtId()) == emenCoding_GBK)
	{
		//UTF8-GBK转换
		memset(aszGBKRecName, 0, sizeof(aszGBKRecName));
		u16 wRet = utf8_to_gb2312(tStartRecMsg.m_aszRecName, aszGBKRecName, sizeof(aszGBKRecName) - 1);
		wRecNameLen = strlen(aszGBKRecName) + 1;
	}
#endif
	wRecNameLen = htons(wRecNameLen);
	cServMsg.CatMsgBody((u8 *)&wRecNameLen, sizeof(u16));
	cServMsg.CatMsgBody((u8 *)aszGBKRecName, strlen(aszGBKRecName) + 1);

    // zbq[11/12/2007] 高盛OEM录像机扩展支持
    u16 wConfInfoLen = htons(sizeof(TConfInfo));
    cServMsg.CatMsgBody((u8 *)&wConfInfoLen, sizeof(u16));
    cServMsg.CatMsgBody((u8 *)&m_tConf, sizeof(TConfInfo));

	//[2012/11/1 zhangli]录多路主视频的相关信息
	u8 byVideoNum = 0;		//=0不支持，=1支持一路，后面依次填上TMediaEncrypt+TDoublePayload+prs信息
	cServMsg.CatMsgBody((u8 *)&byVideoNum, sizeof(u8));
	
	//录多路主音频的相关信息
	u8 byAudioNum = 0;
	cServMsg.CatMsgBody((u8 *)&byAudioNum, sizeof(u8));
		
	//[2012/11/1 zhangli]音频双声道信息，现在会议中单声道和双声道只可能存在一种，因此从会议中取
	/*终端点播(MTC操作)时，无法播放aaclc/aacld双声道音频，因为终端不知道是单声道还是双声道，导致默认开了单声道的解码器
	而无法播放。asf头信息中包含声道、采样率、比特率等信息，但是这些信息都是录像机侧默认写死的。另外，对于aac格式的音频，
	码流前7字节是adts头信息，adts头包含音频声道、采样率信息。在终端解码时，adts头是不必要的，但是录像后用mediaplayer
	播放时必须有此信息。在我们的码流中，aaclc是没有adts的，因此在写asf文件时都写了默认值。现在加上TAudioTypeDesc信息
	就是为了让aaclc正确写asf头和adts*/
	//目前的录像机，对于AACLC格式的必须得提供TAudioTypeDesc，其他格式不需要TAudioTypeDesc
	u8 byAudioTypeLen =0;
	TAudioTypeDesc tRecAudDecDesc;
	if ( IS_RECORD_CONF(tRecMt) )
	{
		if (  m_cRecAdaptMgr.GetRecAudCapSet(tRecAudDecDesc) )
		{
			if ( tRecAudDecDesc.GetAudioMediaType() == MEDIA_TYPE_AACLC )
			{
				byAudioTypeLen = sizeof(TAudioTypeDesc);
			}
		}
		else
		{
			//会议录像，录的是优选主格式
			if ( m_tConfEx.GetMainAudioTypeDesc().GetAudioMediaType() == MEDIA_TYPE_AACLC )
			{
				tRecAudDecDesc = m_tConfEx.GetMainAudioTypeDesc();
				byAudioTypeLen = sizeof(TAudioTypeDesc);
			}
		}	
	}
	else
	{	
		TMt tlocalMt = GetLocalMtFromOtherMcuMt(tStartRecMsg.m_tRecordMt);
		TLogicalChannel tAudLgcChn;
		if ( m_ptMtTable->GetMtLogicChnnl(tlocalMt.GetMtId(), LOGCHL_AUDIO, &tAudLgcChn, FALSE) &&
			tAudLgcChn.GetChannelType() == MEDIA_TYPE_AACLC
			)
		{
			byAudioTypeLen = sizeof(TAudioTypeDesc);
			tRecAudDecDesc.SetAudioMediaType( tAudLgcChn.GetChannelType() );
			tRecAudDecDesc.SetAudioTrackNum( tAudLgcChn.GetAudioTrackNum() );
		}
		else
		{
			ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[StartRec]GetMtLogicChnnl for mt:%d falied\n",tlocalMt.GetMtId() );
		}

	}
	cServMsg.CatMsgBody((u8 *)&byAudioTypeLen, sizeof(u8));
	if ( byAudioTypeLen > 0 )
	{
		cServMsg.CatMsgBody((u8 *)&tRecAudDecDesc, sizeof(TAudioTypeDesc));
	}
	SendMsgToEqp(tStartRecMsg.m_tRecEqp.GetEqpId(), MCU_REC_STARTREC_REQ, cServMsg);
}

/*====================================================================
    函数名      UnPackStartRecMsg
    功能        ：解析录像消息
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    2013/05/27  4.7         倪志俊         创建
====================================================================*/
BOOL32 CMcuVcInst::UnPackStartRecMsg(CServMsg &cServMsg, TStartRecMsgInfo &tRecMsg,u16* pwErrCode)
{
	if ( pwErrCode == NULL )
	{
		return FALSE;
	}
	
	tRecMsg.m_wSerialNO = cServMsg.GetSerialNO();
	tRecMsg.m_bySrcSsnId = cServMsg.GetSrcSsnId();

	//MCS_MCU_STARTREC_REQ消息内容：支持vrs新录播
	//TMt(标识是否会议录像，会议录像mtid为0，否则为终端录像)+TEqp(标识录像设备,如果为空表示新录播设备，最后带上新录播设备别名，否则为老录播设备) 
    //+ TRecStartPara(录像基本参数)+录像名(以0结尾，固定大小128字节)+ TSimCapSet主流适配录像参数+TVideoStreamCap(双流适配录像参数)+ TAudioTypeDesc(音频适配录像参数)
    //+ tMtalias(新录播alias) + 用户组Id(u32)，用户组Id为0表示发布到未分组中
	u8* pbyBuf = cServMsg.GetMsgBody();
	//TMt(标识是否会议录像，会议录像mtid为0，否则为终端录像)
	tRecMsg.m_tRecordMt = *(TMt *)pbyBuf;				//终端录像需要有该终端，会议录像为空
	pbyBuf += sizeof(TMt);
	//TEqp(标识录像设备,如果为空表示新录播设备，最后带上新录播设备别名，否则为老录播设备) 
	tRecMsg.m_tRecEqp   = *(TEqp *)pbyBuf; //录像机外设
	pbyBuf += sizeof(TEqp);

	BOOL32 bIsVrsRec = tRecMsg.m_tRecEqp.IsNull();//是否是vrs新录播
	//判断外设是否合法,新录播不判
	u8   byEqpType;
    u32  dwIpAddress;
	if (!bIsVrsRec)
	{
		g_cMcuAgent.GetPeriInfo(tRecMsg.m_tRecEqp.GetEqpId(), &dwIpAddress, &byEqpType);
		if (byEqpType != EQP_TYPE_RECORDER || !g_cMcuVcApp.IsPeriEqpConnected(tRecMsg.m_tRecEqp.GetEqpId()))
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[ProcMcsMcuStartRecReq]recorder is invalid or offline now!\n");		
			*pwErrCode = ERR_MCU_WRONGEQP;
			return FALSE;
		}
	}

	//TRecStartPara(录像基本参数)
	TRecStartPara tRecPara = *(TRecStartPara *)pbyBuf;
	pbyBuf += sizeof(TRecStartPara);
	tRecPara.SetBitRate(m_tConf.GetBitRate()); //将会议码率告诉录像机
    tRecPara.SetSecBitRate(GetDoubleStreamVideoBitrate(m_tConf.GetBitRate(), FALSE));
	tRecPara.SetIsRecMainVideo(TRUE);	
    tRecPara.SetIsRecMainAudio(TRUE);
	tRecMsg.m_tRecPara = tRecPara;

	if (bIsVrsRec)
	{
		//录像名(以0结尾).vrs新录播按129字节解析
		strncpy(tRecMsg.m_aszRecName, (s8 *)pbyBuf, KDV_NAME_MAX_LENGTH+1);
		pbyBuf += (KDV_NAME_MAX_LENGTH+1);
	}
	else
	{
		//录像名(以0结尾).录像机外设按128字节解析
		strncpy(tRecMsg.m_aszRecName, (s8 *)pbyBuf, KDV_NAME_MAX_LENGTH);
		pbyBuf += KDV_NAME_MAX_LENGTH;
	}
	
	//TSimCapSet主流适配录像参数
	TSimCapSet tSimCapSet;
	tSimCapSet = *(TSimCapSet *)pbyBuf;
	pbyBuf += sizeof(tSimCapSet);

	//TVideoStreamCap(双流适配录像参数)
	TVideoStreamCap tSecCapSet;
#ifndef _8KI_
	tSecCapSet = *(TVideoStreamCap *)pbyBuf;				
#else
	emProfileAttrb emProfile = emHpAttrb;
	if( IsConfHasBpCapOrBpExCap(m_tConf,m_tConfEx) )
	{
		emProfile = emBpAttrb;
	}
	if( Is8KINeedDsAdaptH264SXGA( m_tConf ) )
	{
		tSecCapSet.SetMediaType( MEDIA_TYPE_H264 );
		tSecCapSet.SetResolution( VIDEO_FORMAT_SXGA );
		tSecCapSet.SetUserDefFrameRate( 20 );					
		tSecCapSet.SetH264ProfileAttrb( emProfile );					
	}
	else
	{
		if( IsConfDoubleDual(m_tConf) )
		{
			tSecCapSet.SetMediaType( m_tConf.GetCapSupportEx().GetSecDSType() );
			tSecCapSet.SetResolution( m_tConf.GetCapSupportEx().GetSecDSRes() );
			tSecCapSet.SetFrameRate( m_tConf.GetCapSupportEx().GetSecDSFrmRate() );
		}
		else
		{				
			if( m_tConfEx.IsDSSupportCapEx( VIDEO_FORMAT_XGA,5 ) )
			{
				tSecCapSet.SetMediaType( MEDIA_TYPE_H264 );
				tSecCapSet.SetResolution( VIDEO_FORMAT_XGA );
				tSecCapSet.SetUserDefFrameRate( 5 );
				tSecCapSet.SetH264ProfileAttrb( emProfile );
			}											
		}					
	}
#endif
	pbyBuf += sizeof(tSecCapSet);

	//TAudioTypeDesc(音频适配录像参数)
	TAudioTypeDesc tAudCapSet;
	tAudCapSet = *(TAudioTypeDesc *)pbyBuf;
	pbyBuf += sizeof(tAudCapSet);

	//tMtalias(新录播alias)
	tRecMsg.m_tVrsRecAlias = *(TMtAlias *)pbyBuf;
	pbyBuf += sizeof(TMtAlias);

	if (bIsVrsRec && tRecMsg.m_tVrsRecAlias.IsNull())
	{
		// 新录播时，未获得正确的呼叫信息，返回
		ConfPrint(LOG_LVL_WARNING, MID_MCU_REC, "[ProcMcsMcuStartRecReq]vrs recorder is invalid!\n");		
		*pwErrCode = ERR_MCU_WRONGEQP;
		return FALSE;
	}

	//会议录像适配解析
	if ( IS_RECORD_CONF(tRecMsg.m_tRecordMt) )
	{
		if (tRecPara.IsRecLowStream())
		{
			tRecPara.SetBitRate(m_tConf.GetSecBitRate());
			tRecPara.SetSecBitRate(GetDoubleStreamVideoBitrate(m_tConf.GetSecBitRate(), FALSE));
			tRecMsg.m_tRecPara = tRecPara;
		}		
	
		TVideoStreamCap tMainCapSet = tSimCapSet.GetVideoCap();
		m_cRecAdaptMgr.SetRecVideoCapSet(MODE_VIDEO,tMainCapSet);
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[UnPackStartRecMsg]Rec Adapt Main VidParam：Vid=%d, Res=%d,ProType=%d,FrameRate=%d,BiteRate=%d\n", 	
			tMainCapSet.GetMediaType(),
			tMainCapSet.GetResolution(),
			tMainCapSet.GetH264ProfileAttrb(),
			tMainCapSet.GetUserDefFrameRate(),
			tMainCapSet.GetMaxBitRate()			
			);
/*
				TVideoStreamCap tSecCapSet;
#ifndef _8KI_
				tSecCapSet = *(TVideoStreamCap *)(cServMsg.GetMsgBody() + wUsedSize+ sizeof(TSimCapSet) );				
#else
				emProfileAttrb emProfile = emHpAttrb;
				if( IsConfHasBpCapOrBpExCap(m_tConf,m_tConfEx) )
				{
					emProfile = emBpAttrb;
				}
				if( Is8KINeedDsAdaptH264SXGA( m_tConf ) )
				{
					tSecCapSet.SetMediaType( MEDIA_TYPE_H264 );
					tSecCapSet.SetResolution( VIDEO_FORMAT_SXGA );
					tSecCapSet.SetUserDefFrameRate( 20 );					
					tSecCapSet.SetH264ProfileAttrb( emProfile );					
				}
				else
				{
					if( IsConfDoubleDual(m_tConf) )
					{
						tSecCapSet.SetMediaType( m_tConf.GetCapSupportEx().GetSecDSType() );
						tSecCapSet.SetResolution( m_tConf.GetCapSupportEx().GetSecDSRes() );
						tSecCapSet.SetFrameRate( m_tConf.GetCapSupportEx().GetSecDSFrmRate() );
					}
					else
					{				
						if( m_tConfEx.IsDSSupportCapEx( VIDEO_FORMAT_XGA,5 ) )
						{
							tSecCapSet.SetMediaType( MEDIA_TYPE_H264 );
							tSecCapSet.SetResolution( VIDEO_FORMAT_XGA );
							tSecCapSet.SetUserDefFrameRate( 5 );
							tSecCapSet.SetH264ProfileAttrb( emProfile );
						}											
					}					
				}
#endif
				m_cRecAdaptMgr.SetRecVideoCapSet(MODE_SECVIDEO,tSecCapSet);
				
				TAudioTypeDesc tAudCapSet;
				tAudCapSet = *(TAudioTypeDesc *)(cServMsg.GetMsgBody() + wUsedSize+ sizeof(TSimCapSet) + sizeof(TVideoStreamCap) );
				m_cRecAdaptMgr.SetRecAudCapSet(tAudCapSet);
				
				
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[UnPackStartRecMsg]Rec Adapt sec VidParam：Vid=%d, Res=%d,ProType=%d,FrameRate=%d,BiteRate=%d\n", 	
					tSecCapSet.GetMediaType(),
					tSecCapSet.GetResolution(),
					tSecCapSet.GetH264ProfileAttrb(),
					tSecCapSet.GetUserDefFrameRate(),
					tSecCapSet.GetMaxBitRate()			
					);
				
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[UnPackStartRecMsg]Rec Adapt AudParam：Aud=%d, TrackNum=%d\n", 	
					tAudCapSet.GetAudioMediaType(),
					tAudCapSet.GetAudioTrackNum()
					);
			}
			tRecMsg.bIsRecAdaptConf = TRUE;
		}
*/
		m_cRecAdaptMgr.SetRecVideoCapSet(MODE_SECVIDEO,tSecCapSet);
		m_cRecAdaptMgr.SetRecAudCapSet(tAudCapSet);
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[UnPackStartRecMsg]Rec Adapt sec VidParam：Vid=%d, Res=%d,ProType=%d,FrameRate=%d,BiteRate=%d\n", 	
			tSecCapSet.GetMediaType(),
			tSecCapSet.GetResolution(),
			tSecCapSet.GetH264ProfileAttrb(),
			tSecCapSet.GetUserDefFrameRate(),
			tSecCapSet.GetMaxBitRate()			
			);
		
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "[UnPackStartRecMsg]Rec Adapt AudParam：Aud=%d, TrackNum=%d\n", 	
			tAudCapSet.GetAudioMediaType(),
			tAudCapSet.GetAudioTrackNum()
			);
		
		tRecMsg.bIsRecAdaptConf = TRUE;
		// 更新录像参数
		m_tRecPara = tRecPara;
	}
	else
	{
		TMt tLocalRecMt = GetLocalMtFromOtherMcuMt(tRecMsg.m_tRecordMt);
		u16 wMtBiteRate  = m_ptMtTable->GetDialBitrate( tLocalRecMt.GetMtId() ); 
		TSimCapSet tMVSrcCap = m_ptMtTable->GetSrcSCS(tLocalRecMt.GetMtId());
		wMtBiteRate += GetAudioBitrate( tMVSrcCap.GetAudioMediaType() );
		wMtBiteRate -= GetMaxAudioBiterate(m_tConfEx);
		tRecPara.SetBitRate(wMtBiteRate);
		tRecPara.SetSecBitRate(GetDoubleStreamVideoBitrate(wMtBiteRate, FALSE));
		tRecMsg.m_tRecPara = tRecPara;

	}
	return TRUE;
}

/*====================================================================
    函数名      ：ProcMcsMcuStartRecReq
    功能        ：开始会议录像处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/13    1.0         LI Yi         创建
	2013/05/27  4.7			倪志俊		  重新整理
====================================================================*/
void CMcuVcInst::ProcMcsMcuStartRecReq(const CMessage * pcMsg)
{
	if ( CurState() != STATE_ONGOING )
	{
		ConfPrint(LOG_LVL_ERROR, MID_PUB_ALWAYS, "[ProcMcsMcuStartRecReq]wrong message %u(%s) received in state %u!\n",
			    pcMsg->event, ::OspEventDesc(pcMsg->event), CurState());
		return;
	}

	u16 wErrorCode = 0;

	//1.解析消息
	CServMsg cServMsg(pcMsg->content, pcMsg->length);
	TStartRecMsgInfo tStartRecMsg;
	if ( !UnPackStartRecMsg(cServMsg,tStartRecMsg,&wErrorCode) )
	{
		cServMsg.SetErrorCode( wErrorCode );
		cServMsg.SetMsgBody((u8*)&tStartRecMsg.m_tRecordMt, sizeof(TMt));
		cServMsg.CatMsgBody((u8*)&tStartRecMsg.m_tRecEqp, sizeof(TEqp) );
		SendReplyBack(cServMsg, cServMsg.GetEventId() + 2);
		return;
	}

	// vrs新录播录像支持
	if (tStartRecMsg.m_tRecEqp.IsNull())
	{
		//tStartRecMsg.m_tVrsRecAlias.m_tTransportAddr.SetNetSeqIpAddr(984748204);//测试用ip
		//外设为空标识为新录播,进行新录播实体呼叫
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
		StartVrsRec(tStartRecMsg, TRecChnnlStatus::STATE_CALLING);
		return;
	}

	//2.会议录像与终端录像区分
	BOOL32 bRecordConf = IS_RECORD_CONF(tStartRecMsg.m_tRecordMt);   
	if (  bRecordConf )
	{
		//2.1 会议录像校验
		if ( IsConfRecCheckPass(tStartRecMsg,&wErrorCode) )
		{	
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
		}
		else
		{
			cServMsg.SetErrorCode( wErrorCode );
			cServMsg.SetMsgBody((u8*)&tStartRecMsg.m_tRecordMt, sizeof(TMt));
			cServMsg.CatMsgBody((u8*)&tStartRecMsg.m_tRecEqp, sizeof(TEqp) );
			SendReplyBack(cServMsg, cServMsg.GetEventId() + 2);
			return;
		}
		
		//2.2 开启会议录像
		StartConfRec(tStartRecMsg);
	}
	else
	{
		//2.1 终端录像校验
		if ( IsMtRecCheckPass(tStartRecMsg,&wErrorCode) )
		{
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
		}
		else
		{
			cServMsg.SetErrorCode( wErrorCode );
			cServMsg.SetMsgBody((u8*)&tStartRecMsg.m_tRecordMt, sizeof(TMt));
			cServMsg.CatMsgBody((u8*)&tStartRecMsg.m_tRecEqp, sizeof(TEqp) );
			SendReplyBack(cServMsg, cServMsg.GetEventId() + 2);
			return;
		}	
		
		//2.2 开启终端录像
		StartMtRec(tStartRecMsg);
	}
	return;
}

/*====================================================================
    函数名      ：ProcMcsMcuPauseRecReq
    功能        ：暂停会议录像处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/14    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuPauseRecReq( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TMt			tMt = *( TMt* )cServMsg.GetMsgBody();
	TEqp		tRecorder;
	u8			byRecChannl;
	// [9/6/2010 liuxu] 判断是否是会议录像
	BOOL32		bRecConf = IS_RECORD_CONF(tMt) /*tMt.GetMcuId() == 0*/;

	switch( CurState() )
	{
	case STATE_ONGOING:
	
		if( bRecConf )
		{	
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "request to pause confrec!\n" );

			if( !m_tConf.m_tStatus.IsRecording() )
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "confrec is not recording!\n" );
				cServMsg.SetErrorCode( ERR_MCU_CONFNOTRECORDING );
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;
			}
			tRecorder = m_tRecEqp;
			byRecChannl = m_byRecChnnl;
		}
		else
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "request to pause record mt%d-%d.\n", tMt.GetMcuId(), tMt.GetMtId() );
			
			TMtStatus tRecMtStatus;
			GetMtStatus(tMt, tRecMtStatus);

			if( !tRecMtStatus.m_tRecState.IsRecording())
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "request to pause record mt%d-%d.\n", tMt.GetMcuId(), tMt.GetMtId() );
				cServMsg.SetErrorCode( ERR_MCU_MTNOTRECORDING );
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;				
			}	
			GetMtRecordInfo( tMt, tRecorder, byRecChannl );

			if( 0 == tRecorder.GetEqpId() )
			{
				ConfPrint(LOG_LVL_WARNING, MID_PUB_ALWAYS, "The Mt %d is use record with Eqp id = 0, check program.\n",  tMt.GetMtId() );
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;
			}		
		}

		// 新录播支持
		if (tRecorder.GetType() == TYPE_MT && tRecorder.GetMtType() == MT_TYPE_VRSREC)
		{
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
			// 给vrs新录播发送暂停录像,让其看自己
			NotifyMtReceive(tRecorder, tRecorder.GetMtId());
		}
		else
		{
			//send it to recorder
			cServMsg.SetChnIndex( byRecChannl );
			cServMsg.SetMsgBody( (u8*)&tMt, sizeof( tMt ) );
			cServMsg.CatMsgBody( (u8*)&tRecorder, sizeof( tRecorder ) );
			SendMsgToEqp( tRecorder.GetEqpId(), MCU_REC_PAUSEREC_REQ, cServMsg );
		}

		break;

	default:
		ConfPrint(LOG_LVL_WARNING, MID_PUB_ALWAYS, "wrong message %u(%s) received in state %u!\n",
			    pcMsg->event, ::OspEventDesc(pcMsg->event), CurState());
		break;
	}
}

/*====================================================================
    函数名      ：ProcMcsMcuResumeRecReq
    功能        ：恢复会议录像处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/14    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuResumeRecReq( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TMt			tMt = *( TMt* )cServMsg.GetMsgBody();	
	TEqp		tRecorder;
	u8			byRecChannl;
	// [9/6/2010 liuxu] 判断是否是会议录像
	BOOL32		bRecConf = IS_RECORD_CONF(tMt) /*tMt.GetMcuId() == 0*/;


	switch( CurState() )
	{
	case STATE_ONGOING:
	
		if( bRecConf )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "request to resume confrec!\n" );
			
			if( !m_tConf.m_tStatus.IsRecPause() )
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_REC, "confrec is not recording now!\n" );
				cServMsg.SetErrorCode( ERR_MCU_CONFNOTRECPAUSE );
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;
			}
			tRecorder   = m_tRecEqp;
			byRecChannl = m_byRecChnnl;
		}
		else
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "request to resume mtrec%d-%d.\n", tMt.GetMcuId(), tMt.GetMtId() );
			TMtStatus tRecMtStatus;
			GetMtStatus(tMt, tRecMtStatus);
			
			if( !tRecMtStatus.m_tRecState.IsRecPause())
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_REC, "The Mt %d is not recording pause !\n", tMt.GetMtId() );
				cServMsg.SetErrorCode( ERR_MCU_MTNOTRECPAUSE );
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;				
			}	
			GetMtRecordInfo( tMt, tRecorder, byRecChannl );

			if( 0 == tRecorder.GetEqpId() )
			{
				ConfPrint(LOG_LVL_WARNING, MID_PUB_ALWAYS, "Mt %d is use record with Eqp id = 0, check program.\n",  tMt.GetMtId() );
				
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;
			}		
		}
		
		// 新录播支持
		if (tRecorder.GetType() == TYPE_MT && tRecorder.GetMtType() == MT_TYPE_VRSREC)
		{
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
			// 给vrs新录播发送恢复录像
			TMt tRecSrc;
			if (bRecConf)
			{
				// 会议录像
				tRecSrc = GetVidBrdSrc();
				if (tRecSrc.IsNull())
				{
					// 如果当前广播源为空，必须给一个非空的终端告知vrs恢复录像
					tRecSrc.SetMtType(TYPE_MT);
					tRecSrc.SetMcuId(LOCAL_MCUIDX);
					tRecSrc.SetMtId(MAXNUM_CONF_MT);
				}
			}
			else
			{
				// 终端录像
				tRecSrc = m_ptMtTable->GetRecSrc(tRecorder.GetMtId());
			}
			NotifyMtReceive(tRecSrc, tRecorder.GetMtId());
		}
		else
		{
			//send it to recorder
			cServMsg.SetChnIndex( byRecChannl );
			cServMsg.SetMsgBody( (u8*)&tMt, sizeof( tMt ) );
			cServMsg.CatMsgBody( (u8*)&tRecorder, sizeof( tRecorder ) );
			SendMsgToEqp( tRecorder.GetEqpId(), MCU_REC_RESUMEREC_REQ, cServMsg );
		}

		break;

	default:
		ConfPrint(LOG_LVL_WARNING, MID_PUB_ALWAYS, "wrong message %u(%s) received in state %u!\n",
			    pcMsg->event, ::OspEventDesc(pcMsg->event), CurState());

		break;
	}
}

/*====================================================================
    函数名      ：ProcMcsMcuStopRecReq
    功能        ：停止会议录像处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/16    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuStopRecReq( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TMt			tMt = *( TMt* )cServMsg.GetMsgBody();
	TEqp		tRecorder;
	u8			byRecChannl;
	// [9/6/2010 liuxu] 判断是否是会以录像
	BOOL32		bRecConf = IS_RECORD_CONF(tMt) /*tMt.GetMcuId() == 0*/;


	switch( CurState() )
	{
	case STATE_ONGOING:
	
		if( bRecConf )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, "request to stop confrec!\n" );

			if( m_tConf.m_tStatus.IsNoRecording() )
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_REC, "confrec is not in recording state!\n" );
				cServMsg.SetErrorCode( ERR_MCU_CONFNOTRECORDING );
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;
			}
			tRecorder = m_tRecEqp;
			byRecChannl = m_byRecChnnl;
		}
		else
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, 
				"mtrec%d-%d is not in recording state!\n", tMt.GetMcuId(), tMt.GetMtId());

		
			TMtStatus tRecMtStatus;
			GetMtStatus(tMt, tRecMtStatus);

			if(tRecMtStatus.m_tRecState.IsNoRecording())
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "CMcuVcInst: The Mt %d is not recording  !\n", tMt.GetMtId() );
				cServMsg.SetErrorCode( ERR_MCU_MTNOTRECORDING );
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;				
			}

			GetMtRecordInfo( tMt, tRecorder, byRecChannl );

			if( 0 == tRecorder.GetEqpId() )
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: The Mt %d is use record with Eqp id = 0, check program.\n",  tMt.GetMtId() );
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;
			}		
		}
		
		// 新录播支持
		if (tRecorder.GetType() == TYPE_MT && tRecorder.GetMtType() == MT_TYPE_VRSREC)
		{
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
			// 新录播停止录像直接挂断vrs新录播实体即可
			ReleaseVrsMt(tRecorder.GetMtId());
		}
		else
		{
			//send it to recorder
			cServMsg.SetChnIndex( byRecChannl );
			cServMsg.SetMsgBody( (u8*)&tMt, sizeof( tMt ) );
			cServMsg.CatMsgBody( (u8*)&tRecorder, sizeof( tRecorder ) );
			SendMsgToEqp( tRecorder.GetEqpId(), MCU_REC_STOPREC_REQ, cServMsg );
		}

		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}

}

/*====================================================================
    函数名      ：ProcVcctrlMcuChangeRecModeReq
    功能        ：改变会议录像模式请求
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/11/28    1.0         JQL         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuChangeRecModeReq( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TMt			tMt = *( TMt* )cServMsg.GetMsgBody();
	u8			byMode = *( u8* )( cServMsg.GetMsgBody() + sizeof( TMt ) );
	
	TEqp		tRecEqp;
	u8			byRecChannel;
	// [9/6/2010 liuxu] 判断是否是会以录像
	BOOL32      bRecordConf = IS_RECORD_CONF(tMt) /*tMt.GetMcuId() == 0*/;
				

	switch( CurState() )
	{
	case STATE_ONGOING:
		if( bRecordConf )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "CMcuVcInst: Received request to change recording mode conference now! Channel is %u\n", 
				m_byRecChnnl );

			//not recording now, Nack
			if( m_tConf.m_tStatus.IsNoRecording() )
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,  "CMcuVcInst: This conference is not recording now!\n" );
				cServMsg.SetErrorCode( ERR_MCU_CONFNOTRECORDING );
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;
			}
			tRecEqp = m_tRecEqp;
			byRecChannel = m_byRecChnnl;

		}
		else
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "CMcuVcInst: Received request to change recording mode Mcu%d-Mt%d now!\n", tMt.GetMcuId(), tMt.GetMtId() );

			TMtStatus tRecMtStatus;
			GetMtStatus(tMt, tRecMtStatus);
			
			//not recording now, Nack
			if(tRecMtStatus.m_tRecState.IsNoRecording())
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,  "CMcuVcInst: The Mt %d is not in recording state!\n", tMt.GetMtId() );
				cServMsg.SetErrorCode( ERR_MCU_MTNOTRECORDING );
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;
			}

			GetMtRecordInfo( tMt, tRecEqp, byRecChannel );
			if( 0 == tRecEqp.GetEqpId() )
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: The Mt %d is use record with Eqp id = 0, check program.\n",  tMt.GetMtId() );
				SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
				return;
			}		
			
		}

		cServMsg.SetChnIndex( byRecChannel );
		cServMsg.SetMsgBody( (u8*)&tMt, sizeof( tMt ) );
		cServMsg.CatMsgBody( (u8*)&tRecEqp, sizeof( tRecEqp ) );
		cServMsg.CatMsgBody( (u8*)&byMode, sizeof( byMode ) );
		SendMsgToEqp( tRecEqp.GetEqpId(), MCU_REC_CHANGERECMODE_REQ, cServMsg );

		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}

}

/*====================================================================
    函数名      ：ProcMcsMcuListAllRecordReq
    功能        ：查询录像机记录处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/02/12    3.0         胡昌威         创建
    06/08/22    4.0         顾振华         调整策略
====================================================================*/
void CMcuVcInst::ProcMcsMcuListAllRecordReq( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TEqp		tEqp = *( TEqp* )cServMsg.GetMsgBody();
		
	// 区分kdv录像机与vrs新录播消息内容
	if (!tEqp.IsNull())
	{
		//判断外设是否合法与已连接
		if( !g_cMcuVcApp.IsPeriEqpValid( tEqp.GetEqpId() ) || 
			!g_cMcuVcApp.IsPeriEqpConnected( tEqp.GetEqpId() ) )
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,  "CMcuVcInst: This MCU's recorder is invalid or offline now!\n" );
			cServMsg.SetErrorCode( ERR_MCU_WRONGEQP );
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
			return;
		}
		
		//发送给录像机
		cServMsg.SetMsgBody( ( u8 * )&tEqp, sizeof( tEqp ) );
		
		// 把组ID打包给录像机
		u8 byUsrGrpId = CMcsSsn::GetUserGroup( cServMsg.GetSrcSsnId() );
		cServMsg.CatMsgBody( (u8*)&byUsrGrpId, sizeof(u8) );

		SendMsgToEqp( tEqp.GetEqpId(), MCU_REC_LISTALLRECORD_REQ, cServMsg );
		return;
	}

	// vrs新录播相关处理
	//MCS_MCU_LISTALLRECORD_REQ消息体：  TEqp + TMtAlias（新录播）+ 第几页（u32）+ 单页个数（u32） + 文件组Id（u32）
	u8* pbyBuf = cServMsg.GetMsgBody() + sizeof(tEqp);
	TMtAlias tVrsAlias = *(TMtAlias *)pbyBuf;
	pbyBuf += sizeof(TMtAlias);
	u32 dwPageNo = *(u32 *)pbyBuf;
	dwPageNo = ntohl(dwPageNo); //网络序转主机序
	pbyBuf += sizeof(dwPageNo);
	u32 dwListNum = *(u32 *)pbyBuf;
	dwListNum = ntohl(dwListNum);
	pbyBuf += sizeof(dwListNum);
	u32 dwGroupId = *(u32 *)pbyBuf;
	dwGroupId = ntohl(dwGroupId);
	pbyBuf += sizeof(dwGroupId);

	// 判断呼叫信息，目前只支持ip呼叫
	if (tVrsAlias.m_AliasType != mtAliasTypeTransportAddress)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,  "[ProcMcsMcuListAllRecordReq]Vrs Recorder only support AliasTypeTransportAddress! current aliastype is %d.\n", tVrsAlias.m_AliasType);
		cServMsg.SetErrorCode( ERR_MCU_WRONGEQP );
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
		return;
	}
	// 会议正在放像，返回nack
	if (!m_tPlayEqp.IsNull() && !m_tConf.m_tStatus.IsNoPlaying())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,  "[ProcMcsMcuListAllRecordReq] Recorder(%d,%d) is playing in conf!\n", 
			m_tPlayEqp.GetMcuId(), m_tPlayEqp.GetMtId());
		cServMsg.SetErrorCode( ERR_MCU_CONFPLAYING );
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
		return;
	}
	// 必须为会议Instance处理
	if (GetInsID() == CInstance::DAEMON)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcMcsMcuListAllRecordReq] invalid instance id :%d\n", GetInsID());
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
		return;
	}

	SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );

	TMt tVrsMt;//开启时未分配真实Mtid
	u8 byListType = TPlayEqpAttrib::TYPE_FILELIST;//请求文件列表
	ProcGetVrsListRecord(tVrsAlias, tVrsMt, byListType, dwGroupId, dwPageNo, dwListNum);

    /*
    // 顾振华 [7/20/2006] 支持树形目录
    CConfId cConfId = cServMsg.GetConfId();
    u8 byConfMsg = 0;
    u8 byUsrGrpId = CMcsSsn::GetUserGroup( cServMsg.GetSrcSsnId() );

    if (!cConfId.IsNull())
    {
        // 会议请求
        byConfMsg = 1;
        cServMsg.CatMsgBody( (u8*)&byConfMsg, sizeof(u8) );
        // 把组ID打包给录像机
        cServMsg.CatMsgBody( (u8*)&byUsrGrpId, sizeof(u8) );

        // 如果CConfId 非Null，带上该会议的名字给录像机
        LPCSTR lpszName = NULL;
        if ( g_cMcuVcApp.GetConfNameByConfId(cConfId, lpszName) != 0)
        {
            s8 szConfName[MAXLEN_CONFNAME] = {0};
            strncpy( szConfName, lpszName, MAXLEN_CONFNAME-1 );
            cServMsg.CatMsgBody( (u8*)szConfName, MAXLEN_CONFNAME);
        }
        else
        {
            ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcMcsMcuListAllRecordReq] Cannot find conf name for confid: ");
            cConfId.Print();
        }
        
    }
    else
    {
        // guzh [8/22/2006] 非会议请求
        byConfMsg = 0;
        cServMsg.CatMsgBody( (u8*)&byConfMsg, sizeof(u8) );
        
        // 把组ID打包给录像机
        cServMsg.CatMsgBody( (u8*)&byUsrGrpId, sizeof(u8) );

        if (byUsrGrpId == USRGRPID_SADMIN)
        {
            // 如果是超级管理员，则不需要包含任何会议名
        }
        else
        {
            // 否则整理打包本用户组的所有会议包括模版(可能为空)
            s8 aszConfNameBuf[MAXNUM_MCU_CONF+MAXNUM_MCU_TEMPLATE][MAXLEN_CONFNAME] = {0};
            u8 byConfNum = 0;
    
            TConfMapData tMapData;
            CMcuVcInst* pcInst = NULL;
            TTemplateInfo tTemInfo;
            u8 byIndex;
            for ( byIndex = MIN_CONFIDX; byIndex <= MAX_CONFIDX; byIndex++)
            {
                tMapData = g_cMcuVcApp.GetConfMapData( byIndex );
                if (tMapData.IsValidConf())
                {
                    pcInst = g_cMcuVcApp.GetConfInstHandle(byIndex);
                    if (pcInst == NULL)
                    {
                        continue;
                    }
                    if (pcInst->m_tConf.GetUsrGrpId() == byUsrGrpId ||
                        pcInst->m_tConf.GetUsrGrpId() == USRGRPID_INVALID)  // 终端创会都能看到
                    {
                        strncpy( aszConfNameBuf[byConfNum], pcInst->m_tConf.GetConfName(), MAXLEN_CONFNAME-1 );
                        byConfNum ++;
                    }
                }
                else if (tMapData.IsTemUsed())
                {
                    g_cMcuVcApp.GetTemplate(byIndex, tTemInfo);
                    if (tTemInfo.IsEmpty())
                    {
                        continue;
                    }
                    if (tTemInfo.m_tConfInfo.GetUsrGrpId() == byUsrGrpId ||
                        tTemInfo.m_tConfInfo.GetUsrGrpId() == USRGRPID_INVALID)
                    {
                        // 检查是否已经有同名会议，若无，则添加
                        LPCSTR lpszName = tTemInfo.m_tConfInfo.GetConfName();
                        CConfId cConfId = g_cMcuVcApp.GetConfIdByName( lpszName, FALSE );
                        if (cConfId.IsNull())
                        {
                            strncpy( aszConfNameBuf[byConfNum], lpszName, MAXLEN_CONFNAME-1 );
                            byConfNum ++;
                        }
                    }
                }
            }
            for ( byIndex = 0; byIndex < byConfNum; byIndex ++ )
            {
                cServMsg.CatMsgBody( (u8*)aszConfNameBuf[byIndex], MAXLEN_CONFNAME);    
            }
        }
    }
    */
	

}

/*====================================================================
    函数名      ：ProcRecMcuListAllRecNotif
    功能        ：录像记录通知
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/02/12    3.0         胡昌威         创建
    06/07/24    4.0         顾振华         R3多级目录支持
====================================================================*/
void CMcuVcInst::ProcRecMcuListAllRecNotif( const CMessage * pcMsg )
{
    // guzh [8/22/2006] 改变策略，业务侧不在此进行过滤，而在向录像机请求时

    CServMsg cServMsg( pcMsg->content, pcMsg->length );
    cServMsg.SetNullConfId();

	//  [5/17/2013 guodawei] 文件名完整性过滤及UTF8转换
#ifdef _UTF8
	TEqp tRecEqp = *(TEqp *)cServMsg.GetMsgBody();
	if (g_cMcuVcApp.GetEqpCodeFormat(tRecEqp.GetEqpId()) == emenCoding_GBK)
	{
		s8 *lpMsgBody = (s8 *)cServMsg.GetMsgBody();
		u16 wMsgLen = 0;

		lpMsgBody += sizeof(TEqp);
		wMsgLen += sizeof(TEqp);

		TRecFileListNotify *ptRecNotify = NULL;
		TRecListNewNotify tRecNewNotify;

		if (wMsgLen < cServMsg.GetMsgBodyLen())
		{
			ptRecNotify = (TRecFileListNotify *)lpMsgBody;
			tRecNewNotify.SetListSize(ptRecNotify->GetListSize());
			tRecNewNotify.SetStartIdx(ptRecNotify->GetStartIdx());
			tRecNewNotify.SetEndIdx(ptRecNotify->GetEndIdx());

			u8 byIdx = 0;	/*新上报文件计数*/
			u8 byListNum = ptRecNotify->GetEndIdx() - ptRecNotify->GetStartIdx() + 1;

			s8 achFileName[KDV_NAME_MAX_LENGTH + 1] = {0};
			s8 achUTF8FileName[MAXLEN_FILENAME_LEN] = {0};
			BOOL32 bNeedChgFormat = FALSE;
			u8 byFileNameLen = 0;

			for (u8 byLoop = 0; byLoop < byListNum; byLoop ++)
			{
				//判断文件名(GBK)是否完整
				memset(achFileName, 0, sizeof(achFileName));
				memset(achUTF8FileName, 0, sizeof(achUTF8FileName));
				memcpy(achFileName, ptRecNotify->achFileName[byLoop], sizeof(achFileName) - 1);
				byFileNameLen = strlen(achFileName);
				bNeedChgFormat = FALSE;

				//'.asf'结尾才算完整文件名
				if (0 == memcmp(&achFileName[byFileNameLen - 4], ".asf", strlen(".asf")))
				{
					bNeedChgFormat = TRUE;
				}

				//完整文件名才保存
				if (bNeedChgFormat == TRUE)
				{
					gb2312_to_utf8(achFileName, achUTF8FileName, sizeof(achUTF8FileName) - 1);

					memcpy(tRecNewNotify.achFileName[byIdx], achUTF8FileName, sizeof(achUTF8FileName));
					tRecNewNotify.abyStatus[byIdx] = ptRecNotify->abyStatus[byLoop];
					byIdx ++;
				}
			}
		}
		
		cServMsg.SetMsgBody((u8 *)&tRecEqp, sizeof(TEqp));
		cServMsg.CatMsgBody((u8 *)&tRecNewNotify, sizeof(tRecNewNotify));
	}
#endif

    SendMsgToMcs( cServMsg.GetSrcSsnId(), MCU_MCS_LISTALLRECORD_NOTIF, cServMsg );
}

/*====================================================================
    函数名      ：ProcMcsMcuDeleteRecordReq
    功能        ：处理会控到MCU的删除文件请求
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/09/22    4.0         libo          创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuDeleteRecordReq( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TEqp		tEqp = *( TEqp* )cServMsg.GetMsgBody();
		
	//判断外设是否合法与已连接
	if( !g_cMcuVcApp.IsPeriEqpValid( tEqp.GetEqpId() ) || 
		!g_cMcuVcApp.IsPeriEqpConnected( tEqp.GetEqpId() ) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,  "CMcuVcInst: This MCU's recorder is invalid or offline now!\n" );
		cServMsg.SetErrorCode( ERR_MCU_WRONGEQP );
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
		return;
	}

	//  [5/17/2013 guodawei] 文件名GBK转换
#ifdef _UTF8
	if (g_cMcuVcApp.GetEqpCodeFormat(tEqp.GetEqpId()) == emenCoding_GBK)
	{
		s8* lpMsgBody = (s8 *)cServMsg.GetMsgBody();
		lpMsgBody += sizeof(TEqp);
		
		s8 achFileName[MAX_FILE_NAME_LEN] = {0};
		strncpy(achFileName, lpMsgBody, sizeof(achFileName) - 1);
	
		s8 achGBKFileName[MAX_FILE_NAME_LEN] = {0};
		//UTF8-GBK转换
		utf8_to_gb2312(achFileName, achGBKFileName, sizeof(achGBKFileName) - 1);

		cServMsg.SetMsgBody((u8 *)&tEqp, sizeof(TEqp));
		cServMsg.CatMsgBody((u8 *)achGBKFileName, strlen(achGBKFileName) + 1);
	}
#endif

	//发送给录像机
	SendMsgToEqp( tEqp.GetEqpId(), MCU_REC_DELETERECORD_REQ, cServMsg );

}

/*====================================================================
    函数名      ：ProcMcsMcuRenameRecordReq
    功能        ：处理会控到MCU的更改文件名请求
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/09/22    4.0         libo          创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuRenameRecordReq(const CMessage * pcMsg)
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
    TEqp     tEqp = *(TEqp *)cServMsg.GetMsgBody();

    //判断外设是否合法与已连接
    if (!g_cMcuVcApp.IsPeriEqpValid(tEqp.GetEqpId()) || 
        !g_cMcuVcApp.IsPeriEqpConnected(tEqp.GetEqpId()))
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: This MCU's recorder is invalid or offline now!\n");
        cServMsg.SetErrorCode(ERR_MCU_WRONGEQP);
        SendReplyBack(cServMsg, cServMsg.GetEventId() + 2);
        return;
    }
	
	//  [5/16/2013 guodawei] 文件名GBK转换
#ifdef _UTF8
	if (g_cMcuVcApp.GetEqpCodeFormat(tEqp.GetEqpId()) == emenCoding_GBK)
	{
		s8 *lpMsgBody = (s8 *)cServMsg.GetMsgBody();
		lpMsgBody += sizeof(TEqp);
		
		u8 byOldNameLen = *(u8 *)lpMsgBody;
		s8 achOldName[MAX_FILE_NAME_LEN] = {0};
		memcpy(achOldName, lpMsgBody + sizeof(u8), byOldNameLen);
		
		lpMsgBody += sizeof(u8) + byOldNameLen;
		
		u8 byNewNameLen = *(u8*)lpMsgBody;
		s8 achNewName[MAX_FILE_NAME_LEN] = {0};
		memcpy(achNewName, lpMsgBody + sizeof(u8), byNewNameLen);
		
		s8 achGBKOldName[MAX_FILE_NAME_LEN] = {0};
		s8 achGBKNewName[MAX_FILE_NAME_LEN] = {0};
		
		//UTF8-GBK编码转换
		u16 wRet = 0;
		wRet = utf8_to_gb2312(achOldName, achGBKOldName, sizeof(achGBKOldName) - 1);
		byOldNameLen = strlen(achGBKOldName) + 1;
		
		wRet = utf8_to_gb2312(achNewName, achGBKNewName, sizeof(achGBKNewName) - 1);
		byNewNameLen = strlen(achGBKNewName) + 1;
		
		cServMsg.SetMsgBody((u8 *)&tEqp, sizeof(tEqp));
		cServMsg.CatMsgBody((u8 *)&byOldNameLen, sizeof(u8));
		cServMsg.CatMsgBody((u8 *)achGBKOldName, byOldNameLen);
		cServMsg.CatMsgBody((u8 *)&byNewNameLen, sizeof(u8));
		cServMsg.CatMsgBody((u8 *)achGBKNewName, byNewNameLen);
	}
#endif
	
    //发送给录像机
    SendMsgToEqp(tEqp.GetEqpId(), MCU_REC_RENAMERECORD_REQ, cServMsg);
}

/*====================================================================
    函数名      ：ProcVcctrlMcuPublishRecReq
    功能        ：处理会控到MCU的录像发布处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/04    1.0         JQL         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuPublishRecReq( const CMessage * pcMsg )
{

	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TEqp	*	ptEqp      = ( TEqp* )cServMsg.GetMsgBody();
		
	//判断外设是否合法与已连接
	if( !g_cMcuVcApp.IsPeriEqpValid( ptEqp->GetEqpId() ) || 
		!g_cMcuVcApp.IsPeriEqpConnected( ptEqp->GetEqpId() ) )
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP,  "CMcuVcInst: This MCU's recorder is invalid or offline now!\n" );
		cServMsg.SetErrorCode( ERR_MCU_WRONGEQP );
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
		return;
	}

	if( !g_cMcuVcApp.IsPeriEqpConnected( ptEqp->GetEqpId() ) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Eqp %d-%d doesnot connect yet.\n" );
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
		return;
	}

	//  [5/17/2013 guodawei] 文件名GBK转换
#ifdef _UTF8
	if (g_cMcuVcApp.GetEqpCodeFormat(ptEqp->GetEqpId()) == emenCoding_GBK)
	{
		s8* lpMsgBody = (s8 *)cServMsg.GetMsgBody();
		lpMsgBody += sizeof(TEqp);
		
		u8 byPublicLevel = *(u8 *)lpMsgBody;
		lpMsgBody += sizeof(u8);
		
		s8 achFileName[MAX_FILE_NAME_LEN] = {0};
		strncpy(achFileName, lpMsgBody, sizeof(achFileName) - 1);
		s8 achGBKFileName[MAX_FILE_NAME_LEN] = {0};

		//UTF8-GBK转换
		utf8_to_gb2312(achFileName, achGBKFileName, sizeof(achGBKFileName) - 1);

		cServMsg.SetMsgBody((u8 *)ptEqp, sizeof(TEqp));
		cServMsg.CatMsgBody((u8 *)&byPublicLevel, sizeof(u8));
		cServMsg.CatMsgBody((u8 *)achGBKFileName, strlen(achGBKFileName) + 1);
	}
#endif

	SendMsgToEqp( ptEqp->GetEqpId(), MCU_REC_PUBLISHREC_REQ, cServMsg );

}

void CMcuVcInst::ProcMcsMcuCancelPublishRecReq( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TEqp		tEqp = *( TEqp* )cServMsg.GetMsgBody();
		
	//判断外设是否合法与已连接
	if( !g_cMcuVcApp.IsPeriEqpValid( tEqp.GetEqpId() ) || 
		!g_cMcuVcApp.IsPeriEqpConnected( tEqp.GetEqpId() ) )
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP,  "CMcuVcInst: This MCU's recorder is invalid or offline now!\n" );
		cServMsg.SetErrorCode( ERR_MCU_WRONGEQP );
		SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
		return;
	}

	//  [5/17/2013 guodawei] 文件名GBK转换
#ifdef _UTF8
	if (g_cMcuVcApp.GetEqpCodeFormat(tEqp.GetEqpId()) == emenCoding_GBK)
	{
		s8* lpMsgBody = (s8 *)cServMsg.GetMsgBody();
		lpMsgBody += sizeof(TEqp);

		s8 achFileName[MAX_FILE_NAME_LEN] = {0};
		strncpy(achFileName, lpMsgBody, sizeof(achFileName) - 1);
	
		s8 achGBKFileName[MAX_FILE_NAME_LEN] = {0};
		//UTF8-GBK转换
		utf8_to_gb2312(achFileName, achGBKFileName, sizeof(achGBKFileName) - 1);

		cServMsg.SetMsgBody((u8 *)&tEqp, sizeof(TEqp));
		cServMsg.CatMsgBody((u8 *)achGBKFileName, strlen(achGBKFileName) + 1);
	}
#endif

	//发送给录像机
	SendMsgToEqp( tEqp.GetEqpId(), MCU_REC_CANCELPUBLISHREC_REQ, cServMsg );
	
}

/*====================================================================
    函数名      ：ProcMcsMcuStartPlayReq
    功能        ：开始会议放像处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/09/28    4.0         libo          创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuStartPlayReq(const CMessage * pcMsg)
{
    CServMsg cTempServMsg(pcMsg->content, pcMsg->length);
    CServMsg cServMsg(pcMsg->content, pcMsg->length);

	// vrs新录播支持
	TEqp tPlayEqp = *(TEqp *)cServMsg.GetMsgBody();
	if (tPlayEqp.IsNull())
	{
		// 开启vrs新录播
		ProcMcsMcuStartVrsPlayReq(pcMsg);
		return;
	}

    TRecProg tRecProg;

    memset(&tRecProg, 0, sizeof(TRecProg));

    u8 byIsDStreamPlay = *(u8 *)(cTempServMsg.GetMsgBody() + sizeof(TEqp));

    m_tPlayEqpAttrib.SetDStreamPlay(byIsDStreamPlay);

	//20130824_老录相机不支持多音频会议放像，兼容做nack尝试处理，这里先把一些信息存储一下，nack后处理
	TEqp tEqp = *((TEqp*)cTempServMsg.GetMsgBody());
	m_tPlayEqpAttrib.SetEqp( tEqp );

    cServMsg.SetMsgBody((u8 *)cTempServMsg.GetMsgBody(), sizeof(TEqp));
    cServMsg.CatMsgBody((u8 *)&tRecProg, sizeof(TRecProg));

    s8 szRecName[MAX_FILE_NAME_LEN] = {0};
    strncpy(szRecName, (s8 *)(cTempServMsg.GetMsgBody() + sizeof(u8) + sizeof(TEqp)), MAX_FILE_NAME_LEN - 1);    
    cServMsg.CatMsgBody((u8 *)szRecName, strlen(szRecName) + 1);

	m_tPlayEqpAttrib.SetNackTryNum(0);
	m_tPlayEqpAttrib.SetRecName( szRecName );

    StartPlayReq(cServMsg);
}

/*====================================================================
    函数名      ：StartPlayReq
    功能        ：开始会议放像处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：CServMsg &cServMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/09/28    4.0         libo          创建
====================================================================*/
void CMcuVcInst::StartPlayReq(CServMsg &cServMsg,u8 byNackTryNum /*=0*/)
{
    CServMsg cTempMsg;
    TEqp tEqp = *(TEqp *)cServMsg.GetMsgBody();

    TMediaEncrypt tEncrypt = m_tConf.GetMediaKey();
    u8 byConfVideoType = m_tConf.GetMainVideoMediaType();
    u8 byConfAudioType = m_tConf.GetMainAudioMediaType();

	// 双流格式
	u8 byDStreamMediaType = m_tConf.GetCapSupport().GetDStreamMediaType();

    TDoublePayload tDVPayload, tSndDVPayload;
    TDoublePayload tDAPayload, tSndDAPayload;
  
    tSndDVPayload.SetRealPayLoad(m_tConf.GetSecVideoMediaType());
    tSndDAPayload.SetRealPayLoad(m_tConf.GetSecAudioMediaType());

	TCapSupportEx tCapSupportEx;
	u16 wFileInfoLen = 0;

	//[liu lijiu][2010/11/03]录像机PRS支持
	u8 byIsDstream = 0;
	u8 byIsNeedPrs = 0;
	
    TCapSupport tCapSupport;
	TConfAttrb tConfAttrb;

    switch (CurState())
    {
    case STATE_ONGOING:
		{
				 //判断外设是否合法与已连接
			if (!g_cMcuVcApp.IsPeriEqpValid(tEqp.GetEqpId()) || 
				!g_cMcuVcApp.IsPeriEqpConnected(tEqp.GetEqpId()))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: This MCU's recorder is invalid or offline now!\n");
				cServMsg.SetErrorCode(ERR_MCU_WRONGEQP);
				cServMsg.SetMsgBody((u8*)&tEqp, sizeof(TEqp));
				SendReplyBack(cServMsg, cServMsg.GetEventId() + 2);
				return;
			}

			//正在录像,NACK
			if (!m_tConf.m_tStatus.IsNoPlaying())
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: This conference is playing now!\n");
				cServMsg.SetErrorCode( ERR_MCU_CONFPLAYING);
				cServMsg.SetMsgBody((u8*)&tEqp, sizeof(TEqp));
				SendReplyBack(cServMsg, cServMsg.GetEventId() + 2);
				return;
			}

			//发往录像机
			cTempMsg.SetMsgBody(cServMsg.GetMsgBody() + sizeof(TEqp), cServMsg.GetMsgBodyLen() - sizeof(TEqp));
			tEqp.SetMcuEqp( (u8)LOCAL_MCUID, tEqp.GetEqpId(), EQP_TYPE_RECORDER);

			if (MEDIA_TYPE_H264 == byConfVideoType || 
				MEDIA_TYPE_H263PLUS == byConfVideoType || 
				CONF_ENCRYPTMODE_NONE != tEncrypt.GetEncryptMode() ||
				// zbq [10/29/2007] 适应FEC支持其他格式
				m_tConf.GetCapSupportEx().IsVideoSupportFEC())
			{
				tDVPayload.SetRealPayLoad(byConfVideoType);
				tDVPayload.SetActivePayload(GetActivePayload(m_tConf, byConfVideoType));
			}
			else
			{
				tDVPayload.SetRealPayLoad(byConfVideoType);
				tDVPayload.SetActivePayload(byConfVideoType);
			}

			u8 byConfAudChnlNum = 0;
			//获得会议是否多格式会议，多格式会议给放像机的mediatype传NULL
			//单格式会议，还是需要传相关mediatype和声道数
			TAudioTypeDesc atAudDesc[MAXNUM_CONF_AUDIOTYPE];
			u8 byConfAudNum= m_tConfEx.GetAudioTypeDesc(atAudDesc);
			if ( byConfAudNum >1 )
			{
				tDAPayload.SetRealPayLoad(MEDIA_TYPE_NULL);
				tDAPayload.SetRealPayLoad(MEDIA_TYPE_NULL);
			}
			else
			{
				tDAPayload.SetRealPayLoad( atAudDesc[0].GetAudioMediaType() );
				tDAPayload.SetActivePayload( atAudDesc[0].GetAudioMediaType() );
				
				if (CONF_ENCRYPTMODE_NONE != tEncrypt.GetEncryptMode() ||
					m_tConf.GetCapSupportEx().IsAudioSupportFEC() 
				   )
				{
					tDAPayload.SetActivePayload( GetActivePayload( m_tConf, atAudDesc[0].GetAudioMediaType() ) );
				}

				byConfAudChnlNum = atAudDesc[0].GetAudioTrackNum();
			
			}

			//文件格式可能与主格式并不相同，需rplib对其进行格式判别，不符合则拒绝!!!
			cServMsg.SetMsgBody((u8 *)&tEqp, sizeof(tEqp));
			cServMsg.CatMsgBody((u8 *)&tEncrypt, sizeof(tEncrypt));     //video
			cServMsg.CatMsgBody((u8 *)&tDVPayload, sizeof(tDVPayload)); //video
			cServMsg.CatMsgBody((u8 *)&tEncrypt, sizeof(tEncrypt));     //audio
			cServMsg.CatMsgBody((u8 *)&tDAPayload, sizeof(tDAPayload)); //audio
			cServMsg.CatMsgBody((u8 *)&tSndDVPayload, sizeof(tSndDVPayload));
			cServMsg.CatMsgBody((u8 *)&tSndDAPayload, sizeof(tSndDAPayload));
			cServMsg.CatMsgBody(&byDStreamMediaType, sizeof(byDStreamMediaType)); //DStream, zgc, 2007-08-23

			// MCU前向纠错
			tCapSupportEx = m_tConf.GetCapSupportEx();
			cServMsg.CatMsgBody((u8*)&tCapSupportEx, sizeof(tCapSupportEx));
			
			//文件信息总长度
			wFileInfoLen = cTempMsg.GetMsgBodyLen();
			
			//开始进度＋放像文件名
			//  [5/17/2013 guodawei] 文件名GBK转换及字长改变
#ifdef _UTF8
			if (g_cMcuVcApp.GetEqpCodeFormat(tEqp.GetEqpId()) == emenCoding_GBK)
			{
				TRecProg tRecProg;
				s8 *lpTempMsg = (s8 *)cTempMsg.GetMsgBody();
				tRecProg = *(TRecProg*)lpTempMsg;
				lpTempMsg += sizeof(tRecProg);

				s8 achFileName[MAX_FILE_NAME_LEN] = {0};
				strncpy(achFileName, lpTempMsg, sizeof(achFileName) - 1);

				s8 achGBKFileName[MAX_FILE_NAME_LEN] = {0};
				utf8_to_gb2312(achFileName, achGBKFileName, sizeof(achGBKFileName) - 1);

				wFileInfoLen = sizeof(tRecProg) + strlen(achGBKFileName) + 1;
				wFileInfoLen = htons(wFileInfoLen);
				cServMsg.CatMsgBody((u8*)&wFileInfoLen, sizeof(u16));
				cServMsg.CatMsgBody((u8 *)&tRecProg, sizeof(tRecProg));
				cServMsg.CatMsgBody((u8 *)achGBKFileName, strlen(achGBKFileName) + 1);
			}
			else
			{
				wFileInfoLen = htons(wFileInfoLen);
				cServMsg.CatMsgBody((u8*)&wFileInfoLen, sizeof(u16));
				cServMsg.CatMsgBody(cTempMsg.GetMsgBody(), cTempMsg.GetMsgBodyLen());
			}
#else
			wFileInfoLen = htons(wFileInfoLen);
			cServMsg.CatMsgBody((u8*)&wFileInfoLen, sizeof(u16));
			cServMsg.CatMsgBody(cTempMsg.GetMsgBody(), cTempMsg.GetMsgBodyLen());
#endif

			tCapSupport = m_tConf.GetCapSupport();
			//增加绑定通知会议能力集
			cServMsg.CatMsgBody((u8*)&tCapSupport, sizeof(TCapSupport));

			//[liu lijiu][20101101]放像机PRS支持
			tConfAttrb = m_tConf.GetConfAttrb();
			if(tConfAttrb.IsResendLosePack())
			{
				byIsNeedPrs = 1;
			}
			cServMsg.CatMsgBody((u8*)&byIsNeedPrs, sizeof(u8));//是否支持丢包重传

			if(m_tPlayEqpAttrib.IsDStreamPlay())
			{
				byIsDstream = 1;
			}
			cServMsg.CatMsgBody((u8*)&byIsDstream, sizeof(u8));//放像机是否播放双流
			cServMsg.CatMsgBody((u8*)&byConfAudChnlNum, sizeof(u8));
			

			//20130510 zhouyiliang 给录像机带上会议支持的音频格式
			//消息体：u8(会议勾选的音频格式个数)+TAudioTypeDesc*个数
			TAudioTypeDesc atAduioTypeDesc[MAXNUM_CONF_AUDIOTYPE];
			u8 byAudioTypeNum = m_tConfEx.GetAudioTypeDesc(atAduioTypeDesc);
			
			cServMsg.CatMsgBody((u8*)&byAudioTypeNum,sizeof(u8));
			cServMsg.CatMsgBody((u8*)atAduioTypeDesc,sizeof(TAudioTypeDesc)*byAudioTypeNum);

			SendMsgToEqp(tEqp.GetEqpId(), MCU_REC_STARTPLAY_REQ, cServMsg);
		}
        break;

    default:
        break;
    }
}

/*====================================================================
    函数名      ：ProcMcsMcuPausePlayReq
    功能        ：暂停会议放像处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/14    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuPausePlayReq( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );

	switch( CurState() )
	{
	case STATE_ONGOING:
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "CMcuVcInst: Received request to pause playing conference now! Channel is %u\n", 
			m_byPlayChnnl );

		//not playing now, Nack
		if( !m_tConf.m_tStatus.IsPlaying() )
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP,  "CMcuVcInst: This conference is not playing now!\n" );
			cServMsg.SetErrorCode( ERR_MCU_CONFNOTPLAYING );
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
			return;
		}

		// 新录播放像支持
		if (m_tPlayEqp.GetType() == TYPE_MT && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC)
		{
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
			// 通知vrs新录播暂停发送码流 flowcontrol 0
			TLogicalChannel tLogicalChannel;
			if ( m_ptMtTable->GetMtLogicChnnl(m_tPlayEqp.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
			{
				tLogicalChannel.SetFlowControl(0);
				cServMsg.SetMsgBody((u8 *)&tLogicalChannel, sizeof(tLogicalChannel));
				SendMsgToMt(m_tPlayEqp.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
				ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MT2,"[ProcMcsMcuPausePlayReq] adjust VrsPlayMt sendBandwith to 0!\n");
			} 
		}
		else
		{
			//send it to recorder
			cServMsg.SetMsgBody( ( u8 * )&m_tPlayEqp, sizeof( m_tPlayEqp ) );	//set TEqp
			cServMsg.SetChnIndex( m_byPlayChnnl );
			SendMsgToEqp( m_tPlayEqp.GetEqpId(), MCU_REC_PAUSEPLAY_REQ, cServMsg );
		}


		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ：ProcMcsMcuResumePlayReq
    功能        ：恢复会议放像处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/14    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuResumePlayReq( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );

	switch( CurState() )
	{
	case STATE_ONGOING:
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "CMcuVcInst: Received request to resume recording conference now! Channel is %u\n", 
			m_byPlayChnnl );

		//not pausing now, Nack
		if( !m_tConf.m_tStatus.IsPlayPause() )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "CMcuVcInst: This conference is not play paused now!\n" );
			cServMsg.SetErrorCode( ERR_MCU_CONFNOTPLAYPAUSE );
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
			return;
		}
		
		// if speaker is not rec player, change it
		if (!(m_tConf.GetSpeaker() == m_tPlayEqp))
		{
			ChangeSpeaker(&m_tPlayEqp);
		}


		// 新录播放像支持
		if (m_tPlayEqp.GetType() == TYPE_MT && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC)
		{
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
			// 通知vrs新录播暂停发送码流 flowcontrol 非0
			TLogicalChannel tLogicalChannel;
			if ( m_ptMtTable->GetMtLogicChnnl(m_tPlayEqp.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
			{
				tLogicalChannel.SetFlowControl(m_tPlayEqpAttrib.GetMStremBR());
				cServMsg.SetMsgBody((u8 *)&tLogicalChannel, sizeof(tLogicalChannel));
				SendMsgToMt(m_tPlayEqp.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
				ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MT2,"[ProcMcsMcuPausePlayReq] adjust VrsPlayMt sendBandwith to 0!\n");
			} 
		}
		else
		{
			//send it to recorder
			cServMsg.SetMsgBody( ( u8 * )&m_tPlayEqp, sizeof( m_tPlayEqp ) );	//set TEqp
			cServMsg.SetChnIndex( m_byPlayChnnl );
			SendMsgToEqp( m_tPlayEqp.GetEqpId(), MCU_REC_RESUMEPLAY_REQ, cServMsg );
		}


		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}



/*====================================================================
    函数名      ：ProcMcsMcuStopPlayReq
    功能        ：停止会议放像处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/16    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuStopPlayReq( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );

	switch( CurState() )
	{
	case STATE_ONGOING:
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "CMcuVcInst: Received request to stop playing conference now! Channel is %u\n", 
			m_byPlayChnnl );
		
		// vrs新录播支持
		if (m_tPlayEqp.GetType() == TYPE_MT && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC)
		{
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
			// vrs新录播存在请求列表后直接关掉文件列表情况，界面会补发停放像消息，需挂断放像实体，不判当前会议放像状态
			// 释放vrs放像实体
			ReleaseVrsMt(m_tPlayEqp.GetMtId());
			return;
		}
		//not playing now, Nack
		else if( m_tConf.m_tStatus.IsNoPlaying() )
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP,  "CMcuVcInst: This conference is not playing now!\n" );
			cServMsg.SetErrorCode( ERR_MCU_CONFNOTPLAYING );
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
			return;
		}

		//send it to recorder
		cServMsg.SetMsgBody( ( u8 * )&m_tPlayEqp, sizeof( m_tPlayEqp ) );	//set TEqp
		cServMsg.SetChnIndex( m_byPlayChnnl );
		SendMsgToEqp( m_tPlayEqp.GetEqpId(), MCU_REC_STOPPLAY_REQ, cServMsg );

		//会议状态改变和改变发言人收到信道改变通知后再处理！！！
        // 清放像文件格式记录, zgc, 2008-08-28
        m_tPlayFileMediaInfo.clear();

		// [pengjie 2010/2/26] 停止会议放像，清除令牌环拥有者，这里因为是外设,不必通知
		ClearH239TokenOwnerInfo(NULL);
		KillTimer( MCUVC_NOTIFYMCUH239TOKEN_TIMER );
		
		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*=============================================================================
  函 数 名： ProcMcsMcuGetRecPlayProgCmd
  功    能： 会控查询录放相进度
  算法实现： 
  全局变量： 
  参    数： const CMessage * pcMsg
  返 回 值： void 
=============================================================================*/
void CMcuVcInst::ProcMcsMcuGetRecPlayProgCmd( const CMessage * pcMsg )
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);

    switch( CurState() )
    {
    case STATE_ONGOING:
        {
            //获取录相进度
            if (MCS_MCU_GETRECPROG_CMD == pcMsg->event)
            {
                TMt tMt = *(TMt *)cServMsg.GetMsgBody();
                TEqp tRecEqp;
                u8  byRecChnnl;
                
                //会议录相
                if(tMt.IsNull())
                {
                    if (m_tConf.m_tStatus.IsNoRecording())
                    {
                        return;
                    }

                    tRecEqp = m_tRecEqp;
                    byRecChnnl = m_byRecChnnl;
                }
                //终端录相
                else
                {
					TMtStatus tRecMtStatus;
					GetMtStatus(tMt, tRecMtStatus);
					
					if(tRecMtStatus.m_tRecState.IsNoRecording())
					{
                        return;
					}

                    if(!GetMtRecordInfo(tMt, tRecEqp, byRecChnnl))
                    {
                        return;
                    }
                }               
				
				// 新录播支持
				if (tRecEqp.GetType() == TYPE_MT && tRecEqp.GetMtType() == MT_TYPE_VRSREC)
				{
					SendMsgToMt(tRecEqp.GetMtId(), MCU_REC_GETRECPROG_CMD, cServMsg);
				}
				else
				{
					cServMsg.SetChnIndex(byRecChnnl);
					SendMsgToEqp(tRecEqp.GetEqpId(), MCU_REC_GETRECPROG_CMD, cServMsg);
				}
            }
            //获取放相进度
            else
            {
                if (m_tConf.m_tStatus.IsNoPlaying())
                {
                    return;
                }                

				// 新录播支持
				if (m_tPlayEqp.GetType() == TYPE_MT && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC)
				{
					SendMsgToMt(m_tPlayEqp.GetMtId(), MCU_REC_GETPLAYPROG_CMD, cServMsg);
				}
				else
				{
					cServMsg.SetChnIndex( m_byPlayChnnl );
					SendMsgToEqp( m_tPlayEqp.GetEqpId(), MCU_REC_GETPLAYPROG_CMD, cServMsg );
				}
            }
        }
        break;

    default:
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcMcsMcuGetRecPlayProgCmd] Wrong message %u(%s) received in state %u!\n", 
                pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
        break;
    }

    return;
}

/*====================================================================
    函数名      ：ProcMcsMcuSeekReq
    功能        ：会议放像调整处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/20    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuSeekReq( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length ), cTempMsg;
	u16		wEv = 0;

	switch( CurState() )
	{
	case STATE_ONGOING:
		switch( pcMsg->event )
		{
		case MCS_MCU_FFPLAY_REQ:
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "CMcuVcInst: Received request to fast forward now! Channel is %u\n", 
				m_byPlayChnnl );
			wEv = MCU_REC_FFPLAY_REQ;
			break;
		case MCS_MCU_FBPLAY_REQ:
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "CMcuVcInst: Received request to fast backward now! Channel is %u\n", 
				m_byPlayChnnl );
			wEv = MCU_REC_FBPLAY_REQ;
			break;
		case MCS_MCU_SEEK_REQ:
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "CMcuVcInst: Received request to seek now! Channel is %u\n", 
				m_byPlayChnnl );
			wEv = MCU_REC_SEEK_REQ;
			break;
		default:
			return;
		}

		//not playing now, Nack
		if( m_tConf.m_tStatus.IsNoPlaying() )
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP,  "CMcuVcInst: This conference is not playing now!\n" );
			cServMsg.SetErrorCode( ERR_MCU_CONFNOTPLAYING );
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
			return;
		}

		//send it to recorder
		cTempMsg.SetMsgBody( cServMsg.GetMsgBody() + sizeof( TEqp ), cServMsg.GetMsgBodyLen() - sizeof( TEqp ) );

		// 新录播支持
		if (m_tPlayEqp.GetType() == TYPE_MT && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC)
		{
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
			//send it to vrs recorder
			TEqp tNullEqp;//vrs外设识别为空
			cServMsg.SetMsgBody( ( u8 * )&tNullEqp, sizeof( tNullEqp ) );	//set TEqp
			cServMsg.CatMsgBody( cTempMsg.GetMsgBody(), cTempMsg.GetMsgBodyLen() );	
			SendMsgToMt(m_tPlayEqp.GetMtId(), wEv, cServMsg);
		}
		else
		{
			//send it to recorder
			cServMsg.SetMsgBody( ( u8 * )&m_tPlayEqp, sizeof( m_tPlayEqp ) );	//set TEqp
			cServMsg.CatMsgBody( cTempMsg.GetMsgBody(), cTempMsg.GetMsgBodyLen() );	//set record name
			cServMsg.SetChnIndex( m_byPlayChnnl );
			SendMsgToEqp( m_tPlayEqp.GetEqpId(), wEv, cServMsg );
		}

		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*=============================================================================
函 数 名： ProcRecPlayWaitMpAckTimer
功    能： 等待放像交换建立定时器超时
算法实现： 
全局变量： 
参    数： const CMessage * pcMsg
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/3/26   4.0			周广程                  创建
=============================================================================*/
void CMcuVcInst::ProcRecPlayWaitMpAckTimer( void )
{
	KillTimer( MCUVC_RECPLAY_WAITMPACK_TIMER );
	CServMsg cServMsg;
	m_tConf.m_tStatus.SetPlaying();
	if (m_tPlayEqp.GetType() == TYPE_MT && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC)
	{
		m_ptMtTable->SetRecChlState(m_tPlayEqp.GetMtId(), TRecChnnlStatus::STATE_PLAYING);
		// 通知vrs新录播发送码流 flowcontrol
		TLogicalChannel tLogicalChannel;
		if ( m_ptMtTable->GetMtLogicChnnl(m_tPlayEqp.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
		{
			u16 wMStremBR = m_tPlayEqpAttrib.GetMStremBR();
			tLogicalChannel.SetFlowControl(wMStremBR);//如何获取合适的码率
			cServMsg.SetMsgBody((u8 *)&tLogicalChannel, sizeof(tLogicalChannel));
			SendMsgToMt(m_tPlayEqp.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cServMsg);
			ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MT2,"[ProcRecPlayWaitMpAckTimer] adjust VrsPlayMt sendBandwith to %d!\n", wMStremBR);
		} 
	}
	else
	{
		cServMsg.SetChnIndex( m_byPlayChnnl );
		SendMsgToEqp( m_tPlayEqp.GetEqpId() , MCU_EQP_SWITCHSTART_NOTIF, cServMsg);
	}
}

/*====================================================================
    函数名      ：DaemonProcRecMcuChnnlStatusNotif
    功能        ：录像机信道状态通知处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/18    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::DaemonProcRecMcuChnnlStatusNotif(const CMessage * pcMsg)
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
    TEqp *ptEqp;
    TRecChnnlStatus *ptChnnlStatus;
    CConfId cConfId = cServMsg.GetConfId();
    u8 byChnnl = cServMsg.GetChnIndex();
    TPeriEqpStatus tRecStatus;

	//录像和放像状态通知
    if (pcMsg->event == REC_MCU_RECORDCHNSTATUS_NOTIF)
    {
        ptEqp = (TEqp *)(cServMsg.GetMsgBody() + sizeof(TMt));
        ptChnnlStatus = (TRecChnnlStatus *)(cServMsg.GetMsgBody() + sizeof(TEqp) + sizeof(TMt));	
    }
    else
    {
        ptEqp = (TEqp *)cServMsg.GetMsgBody();
        ptChnnlStatus = (TRecChnnlStatus *)(cServMsg.GetMsgBody() + sizeof(TEqp));
    }

	//  [5/17/2013 guodawei] 通道状态文件名UTF8转换
#ifdef _UTF8
	if (g_cMcuVcApp.GetEqpCodeFormat(ptEqp->GetEqpId()) == emenCoding_GBK)
	{
		s8 achRecordName[MAXLEN_RECORD_NAME] = {0};
		s8 achUTF8RecordName[MAXLEN_RECORD_NAME] = {0};

		strncpy(achRecordName, ptChnnlStatus->GetRecordName(), sizeof(achRecordName) - 1);
		gb2312_to_utf8(achRecordName, achUTF8RecordName, sizeof(achUTF8RecordName) - 1);

		ptChnnlStatus->SetRecordName(achUTF8RecordName);
	}
#endif

    //save to periequipment status
    if (!g_cMcuVcApp.GetPeriEqpStatus(ptEqp->GetEqpId(), &tRecStatus))
    {
        return;
    }

	if( REC_MCU_PLAYCHNSTATUS_NOTIF  == pcMsg->event )
	{
		TRecChnnlStatus tRecChlStatus;
		if( tRecStatus.m_tStatus.tRecorder.GetChnnlStatus( byChnnl, ptChnnlStatus->m_byType,&tRecChlStatus ) )
		{
			ptChnnlStatus->m_tSrc = tRecChlStatus.m_tSrc;
		}
	}
    tRecStatus.m_tStatus.tRecorder.SetChnnlStatus(byChnnl, ptChnnlStatus->m_byType, ptChnnlStatus);
    g_cMcuVcApp.SetPeriEqpStatus(ptEqp->GetEqpId(), &tRecStatus);

    //analyze conference id and forward it to conference
    if (0 != g_cMcuVcApp.GetConfIdx(cConfId))
    {
        g_cMcuVcApp.SendMsgToConf(cConfId, pcMsg->event, pcMsg->content, pcMsg->length);

		//zjj20121120 录放像状态改变发送外设状态给界面,界面可以显示录放像文件名	
		cServMsg.SetMsgBody( (u8*)&tRecStatus,sizeof(tRecStatus) );
		SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
    }
}

/*====================================================================
    函数名      ：DaemonProcRecMcuProgNotif
    功能        ：录像机信道进度通知处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/20    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::DaemonProcRecMcuProgNotif( const CMessage * pcMsg )
{
    CServMsg	cServMsg( pcMsg->content, pcMsg->length);
    u8          * pbyMsgBody  =  cServMsg.GetMsgBody();   
    //TMt         * ptMt  = NULL;
    TEqp		* ptEqp = NULL;
    TRecProg	* ptRecProg = NULL;
    TRecChnnlStatus		tChnnlStatus;
    CConfId		cConfId = cServMsg.GetConfId();
    u8			byChnnl = cServMsg.GetChnIndex(), byChnnlType;
    TPeriEqpStatus	tRecStatus;

    //save to periequipment status
    if (pcMsg->event == REC_MCU_PLAYPROG_NOTIF)
    {
        byChnnlType = TRecChnnlStatus::TYPE_PLAY;
    }
    else
    {
        byChnnlType = TRecChnnlStatus::TYPE_RECORD;

        //ptMt = (TMt*)pbyMsgBody;
        pbyMsgBody  += sizeof(TMt);
    }

    ptEqp       = (TEqp*)pbyMsgBody;
    pbyMsgBody += sizeof(TEqp);

    ptRecProg   = (TRecProg *)pbyMsgBody;

    if (!g_cMcuVcApp.GetPeriEqpStatus(ptEqp->GetEqpId(), &tRecStatus))
    {
        return;
    }

    if (!tRecStatus.m_tStatus.tRecorder.GetChnnlStatus(byChnnl, byChnnlType, &tChnnlStatus))
    {
        return;
    }
    tChnnlStatus.m_tProg = *ptRecProg;
    tRecStatus.m_tStatus.tRecorder.SetChnnlStatus(byChnnl, byChnnlType, &tChnnlStatus);
    g_cMcuVcApp.SetPeriEqpStatus(ptEqp->GetEqpId(), &tRecStatus);

	//analyze conference id and forward it to conference
    if (0 != g_cMcuVcApp.GetConfIdx(cConfId))
    {
        g_cMcuVcApp.SendMsgToConf(cConfId, pcMsg->event, pcMsg->content, pcMsg->length);
    }
}

void CMcuVcInst::DaemonProcAgtSvcE1BandWidthNotif( const CMessage *pcMsg )  
{
    //虚端口带宽
    u16 wBandWidthEachPort[MAXNUM_E1PORT];
    memset(wBandWidthEachPort, 0,  sizeof(wBandWidthEachPort));
    memcpy( wBandWidthEachPort, pcMsg->content, sizeof(wBandWidthEachPort));
    
    //虚端口配置E1对数
    u8 byPortE1Num[MAXNUM_E1PORT];
    memset(byPortE1Num, 0, sizeof(byPortE1Num));
    memcpy( byPortE1Num, pcMsg->content + sizeof(wBandWidthEachPort), sizeof(byPortE1Num));
    
    //本端Dri2 ip地址
    u32 dwDri2Ip = *(u32*)(pcMsg->content + sizeof(wBandWidthEachPort) + sizeof(byPortE1Num));
    dwDri2Ip = ntohl(dwDri2Ip);
    
    TDri2E1Cfg tDri2E1Cfg[MAXNUM_SUB_MCU];
    g_cMcuVcApp.GetDri2E1CfgTable(tDri2E1Cfg);
    
    for ( u8 byCfgIndx = 0; byCfgIndx < MAXNUM_SUB_MCU; byCfgIndx++)
    {
        u32 dwCfgDriIp = tDri2E1Cfg[byCfgIndx].GetDriIp();
        u8 byCfgPortNO = tDri2E1Cfg[byCfgIndx].GetPortNO();
		u16 dwRealBandWidth = 0;
        if (dwCfgDriIp == dwDri2Ip )
        {
			if( wBandWidthEachPort[byCfgPortNO] > byPortE1Num[byCfgPortNO]*1920 )
			{
				dwRealBandWidth = byPortE1Num[byCfgPortNO]*1920;
				
				ConfPrint(LOG_LVL_ERROR,MID_MCU_MT2, "[DaemonProcAgtSvcE1BandWidthNotif]\tport = %d, E1Num = %d, RealBandWidth<%d > %d>ConfigedBandwidth, error!Adjust RealBandwith to Configed Bandwidth\n", 
				byCfgPortNO, byPortE1Num[byCfgPortNO],wBandWidthEachPort[byCfgPortNO],byPortE1Num[byCfgPortNO]*1920);
			}
			else
			{
				dwRealBandWidth = wBandWidthEachPort[byCfgPortNO];
			}
            
            g_cMcuVcApp.SaveRealBandwidth( dwRealBandWidth, byCfgIndx, byPortE1Num[byCfgPortNO] );
        }
        else
        {
            continue;
        }
    }
    
    ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MT2,"[DaemonProcAgtSvcE1BandWidthNotif]receive Dri2(IP.0x%x) E1 BandWidth Notify :\n", dwDri2Ip);
    for( u8 byInx = 0; byInx < MAXNUM_E1PORT; byInx++ )
    {
        ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MT2, "\tport = %d, BandWidth = %d, E1Num = %d\n", 
            byInx, wBandWidthEachPort[byInx], byPortE1Num[byInx]);
    }
    
    OspPost( MAKEIID(AID_MCU_VC, CInstance::EACH), pcMsg->event, pcMsg->content, pcMsg->length );
}

/*====================================================================
    函数名      ：ProcRecMcuPlayChnnlStatusNotif
    功能        ：录像机放像信道改变处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/19    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcRecMcuPlayChnnlStatusNotif( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TEqp		*ptEqp = ( TEqp * )cServMsg.GetMsgBody();
	TRecChnnlStatus		* ptChnnlStatus = ( TRecChnnlStatus * )( cServMsg.GetMsgBody() + sizeof( TEqp ) );
	//CConfId		cConfId = cServMsg.GetConfId();
	//u8			byChnnl = cServMsg.GetChnIndex();

	switch( CurState() )
	{
	case STATE_ONGOING:
		
		switch( ptChnnlStatus->m_byState )
		{
		case TRecChnnlStatus::STATE_PLAYREADY:	//停止放像
            //change speaker if it's recorder
            if( m_tConf.GetSpeaker() == *ptEqp )
            {
                //是否为语音激励控制发言，是则恢复
                if (m_tConf.m_tStatus.IsVACing() && !m_tVacLastSpeaker.IsNull())
                {
                    ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "Vac speaker restored, speaker is: Mt%d\n",
                                   m_tVacLastSpeaker.GetMtId());

                    ChangeSpeaker(&m_tVacLastSpeaker,FALSE,TRUE,TRUE,TRUE);
                }
                else
                {
                    ChangeSpeaker(NULL);
                }

				// xliang [8/19/2008] modify A:此部分逻辑移出该if外，见"modify B"处，
				//放在此处会引起如下bug：即通过拖发言人而触发停放像的情景下，前面这个if是进不来的
				//这就会导致如果是双流放像的话，暂停后拖发言人会停不掉双流
// 				 if (TYPE_MCUPERI == m_tDoubleStreamSrc.GetType())
// 				 {
// 					 StopDoubleStream(FALSE, TRUE);
// 				 }
            }

			// xliang [8/19/2008] modify B 改进判断，更加严格
			//if (TYPE_MCUPERI == m_tDoubleStreamSrc.GetType())
			if(m_tDoubleStreamSrc == *ptEqp) 
			{
				StopDoubleStream(FALSE, TRUE);
			}
			//change status
			m_byPlayChnnl = 0;
			memset( &m_tPlayEqp, 0, sizeof( m_tPlayEqp ) );
            m_tPlayEqpAttrib.Reset();
			m_tConf.m_tStatus.SetNoPlaying();

			break;
		case TRecChnnlStatus::STATE_PLAYING:		//开始放像或恢复放像
		
			//change speaker if it's not speaker now			
//			if( m_tConf.m_tStatus.IsNoPlaying() )
//			{
//				m_byPlayChnnl = byChnnl;
//				m_tPlayEqp = *ptEqp;
//				m_tPlayEqp.SetConfIdx( m_byConfIdx );
//				ChangeSpeaker( &m_tPlayEqp );
//			}
			m_tConf.m_tStatus.SetPlaying();

			break;
		// zgc, 2007-02-27, 会议放像关键帧延迟问题
		case TRecChnnlStatus::STATE_PLAYREADYPLAY:	//准备开始放像
//			m_tConf.m_tStatus.SetPlayReady();
			break;
		// zgc, 2007-02-27, end
			
		case TRecChnnlStatus::STATE_PLAYPAUSE:		//暂停放像
			//change status
			m_tConf.m_tStatus.SetPlayPause();
			break;
		case TRecChnnlStatus::STATE_FF:				//快进
			//change status
			m_tConf.m_tStatus.SetPlayFF();
			break;
		case TRecChnnlStatus::STATE_FB:				//快退
			//change status
			m_tConf.m_tStatus.SetPlayFB();
			break;
		default:
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong channel state %u!\n", ptChnnlStatus->m_byState );
			break;
		}

		ConfModeChange();
		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ：ProcRecMcuRecChnnlStatusNotif
    功能        ：录像机录像信道改变处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/19    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcRecMcuRecChnnlStatusNotif(const CMessage * pcMsg)
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);

	//新录播支持
	TMt tVrsMt = m_ptMtTable->GetMt( cServMsg.GetSrcMtId() );
	if (!tVrsMt.IsNull() && tVrsMt.GetMtType() == MT_TYPE_VRSREC)
	{
		// 走vrs新录播逻辑
		ProcRecMcuVrsRecChnnlStatusNotif(cServMsg);
		return;
	}

    TMt      tRecMt = *(TMt *)cServMsg.GetMsgBody();
    TEqp    *ptEqp  = (TEqp *)(cServMsg.GetMsgBody() + sizeof(TMt));
	/*lint -save -e740*/
    TRecChnnlStatus *ptChnnlStatus = (TRecChnnlStatus *)(ptEqp + 1);
	/*lint -restore*/
    //CConfId  cConfId = cServMsg.GetConfId();
    u8       byChnnl = cServMsg.GetChnIndex();
    //u8       bySrcChnnl = 0;
    BOOL32   bRecordConf = (tRecMt.GetEqpId() == 0);
	
	TMtStatus tRecMtStatus;
	if (NULL == ptEqp)
	{
		StaticLog("Null pointer err!\n");
		return;
	}

	if (!bRecordConf)
	{
		GetMtStatus(tRecMt, tRecMtStatus);
	}
	
	switch (CurState())
	{
	case STATE_ONGOING:
		{
			switch( ptChnnlStatus->m_byState )
			{
			case TRecChnnlStatus::STATE_RECREADY:	//停止录像
				{
					// [10/29/2010 liuxu][add]自定义录像相关
					if (bRecordConf && IsRecNeedAdapt())
					{
						ResetRecAdptParam();
					}
					
					//[2011/07/16/zhanlgi]整理录像机拆建RTP/RTCP交换
					if (bRecordConf)
					{
						AdjustConfRecordSrcStream(MODE_BOTH, FALSE);
						AdjustConfRecordSrcStream(MODE_SECVIDEO, FALSE);
					}
					else
					{
						AdjustMtRecSrcStream(MODE_BOTH, *ptEqp, byChnnl, tRecMt, FALSE);
						if (!m_tDoubleStreamSrc.IsNull())
						{
							AdjustMtRecSrcStream(MODE_SECVIDEO, *ptEqp, byChnnl, tRecMt, FALSE);
						}
					}
					
					if (bRecordConf)
					{
						m_byRecChnnl = 0;
						memset( &m_tRecEqp, 0, sizeof( m_tRecEqp ) );
						m_tConf.m_tStatus.SetNoRecording();
						//停止录像，如果是低速录像且录的是画面合成广播，画面合成的第一路码流要调回去
						if ( m_tRecPara.IsRecLowStream() && g_cMcuVcApp.IsBrdstVMP(m_tVmpEqp) )
						{
							u16 wMinMtReqBitrate = GetLeastMtReqBitrate( TRUE, m_tConf.GetMainVideoMediaType() );
							ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "Mt[%d] rec is low stream, and vmp is BrdSrc, the 1st chnl BitRate of vmp will be restored[%d]!\n", tRecMt.GetMtId(), wMinMtReqBitrate);
							ChangeVmpBitRate(wMinMtReqBitrate);
						}
						m_tRecPara.Reset();
						
						//停止录像时，先挂载一遍适配参数，再刷新一次终端适配参数,告知适配器参数改变
						//这里是否要判断双流？？？
						StartBrdAdapt(MODE_VIDEO);
					}
					else
					{
						//置状态
						tRecMtStatus.m_tRecState.SetNoRecording();
						FreeRecvSpy(tRecMt, MODE_BOTH);
					}
				}
				break;
			case TRecChnnlStatus::STATE_RECORDING:	//开始或恢复录像
				{
					BOOL32 bIsNoRecording = FALSE;

					//保存参数
					if (bRecordConf)
					{
						bIsNoRecording = m_tConf.m_tStatus.IsNoRecording();
						m_byRecChnnl = byChnnl;
						m_tRecEqp = *ptEqp;
						
						BOOL32 bSkipeFrame = (ptChnnlStatus->m_byRecMode == REC_MODE_SKIPFRAME) ? TRUE:FALSE;
						m_tConf.m_tStatus.m_tConfMode.SetRecSkipFrame(bSkipeFrame);
						m_tConf.m_tStatus.SetRecording();
					}
					else
					{
						bIsNoRecording = tRecMtStatus.m_tRecState.IsNoRecording();
						
						tRecMtStatus.m_tRecState.SetRecording();
						BOOL32 bSkipeFrame = (ptChnnlStatus->m_byRecMode == REC_MODE_SKIPFRAME) ? TRUE:FALSE;
						tRecMtStatus.m_tRecState.SetRecSkipFrame(bSkipeFrame);
						tRecMtStatus.m_tRecState.SetRecChannel(byChnnl);
					}
					
					//恢复录像时不需重建交换
					if (bIsNoRecording)
					{	
						if (!bRecordConf)
						{
							//被录像终端已不在会议，停止终端录像
							if (!m_tConfAllMtInfo.MtJoinedConf(tRecMt))
							{
								CServMsg cTempServMsg;
								cTempServMsg.SetConfId(m_tConf.GetConfId());
								cTempServMsg.SetMsgBody((u8 *)ptEqp, sizeof(*ptEqp));	//set TEqp
								cTempServMsg.SetChnIndex(byChnnl);
								SendMsgToEqp(ptEqp->GetEqpId(), MCU_REC_STOPREC_REQ, cTempServMsg);
							}
						}

						//[2011/07/16/zhanlgi]整理录像机拆建RTP/RTCP交换
						if (bRecordConf)
						{
							AdjustConfRecordSrcStream(MODE_BOTH, TRUE);
							AdjustConfRecordSrcStream(MODE_SECVIDEO, TRUE);
							//开始录像，如果是低速录像且录的是画面合成广播，画面合成的第一路码流要出低速
							if ( m_tRecPara.IsRecLowStream() && g_cMcuVcApp.IsBrdstVMP(m_tVmpEqp) )
							{
								ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "Mt[%d] rec is low stream, and vmp is BrdSrc, the 1st chnl of vmp will be SecBitRate[%d]!\n", tRecMt.GetMtId(), m_tConf.GetSecBitRate());
								ChangeVmpBitRate(m_tConf.GetSecBitRate());
							}
						}
						else
						{
							AdjustMtRecSrcStream(MODE_BOTH, *ptEqp, byChnnl, tRecMt, TRUE);
							if (!m_tDoubleStreamSrc.IsNull())
							{
								AdjustMtRecSrcStream(MODE_SECVIDEO, *ptEqp, byChnnl, tRecMt, TRUE);
							}
						}

						if (!bRecordConf)
						{
							if (tRecMt.IsLocal())
							{
								//通知本级终端开始发送
								NotifyMtSend(tRecMt.GetMtId());
							}
							else if (!IsLocalAndSMcuSupMultSpy(tRecMt.GetMcuId()))
							{
								//请求下级终端回传码流
								OnMMcuSetIn( tRecMt, 0, SWITCH_MODE_SELECT );
							}
						}
					}
					else
					{
						//恢复录象向终端请求关键帧
						TMt tSrc;
						if (bRecordConf)
						{
							u8  byRecChnIdx = 0;
							u8  byBasChnId  = 0;
							IsRecordSrcBas(MODE_VIDEO, tSrc, byBasChnId, byRecChnIdx);
						}
						else
						{
							tSrc = tRecMt;
						}
						
						if (!tSrc.IsNull() && tSrc.GetType() == TYPE_MT)
						{
							NotifyFastUpdate(tSrc, MODE_VIDEO);
						}
					}
					
					
					//请求双流源关键帧
					if (!m_tDoubleStreamSrc.IsNull() 
						&& m_tDoubleStreamSrc.GetType() == TYPE_MT
						&& ((bRecordConf && m_tRecPara.IsRecDStream()) || !bRecordConf))
					{
						NotifyFastUpdate(m_tDoubleStreamSrc, MODE_SECVIDEO);
					}
				}
				
				break;
			case TRecChnnlStatus::STATE_RECPAUSE:	//暂停录像				
				{
					// [pengjie 2010/9/29] 如果是会议内部逻辑触发的暂停了录像，这里不让界面感知
					if(bRecordConf)
					{
						if (!m_tConf.m_tStatus.IsRecPauseByInternal())
						{
							m_tConf.m_tStatus.SetRecPause();
						}
					}
					else
					{
						tRecMtStatus.m_tRecState.SetRecPause();
					}
				}
			
				break;
			default:
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "Unexcept State Recevied In RecordMtNotify.\n" );
				break;
			}

			if (bRecordConf)
			{			
				ConfModeChange();	
			}
			else
			{
				// [pengjie 2010/9/20] 这里上报真实的录像源信息
				SetMtStatus(tRecMt, tRecMtStatus);
				MtStatusChange(&tRecMt, TRUE);			
			}
		}
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}


// 	switch (CurState())
// 	{
// 	case STATE_ONGOING:
// 		
// 		if ( bRecordConf )
// 		{			
// 			switch( ptChnnlStatus->m_byState )
// 			{
// 			case TRecChnnlStatus::STATE_RECREADY:	//停止录像
// 				{      
// 					// [10/29/2010 liuxu][add]
// 					// 自定义录像相关
// 					if (IsRecNeedAdapt())
// 					{
// 						ResetRecAdptParam();
// 					}// Over
// 
// 					//[2011/07/16/zhanlgi]整理录像机拆建RTP/RTCP交换
// 					AdjustRecordSrcStream(*ptEqp, tRecMt, byChnnl, TRUE, FALSE, MODE_NONE);
// 
// 					//change status
// 					m_byRecChnnl = 0;
// 					memset( &m_tRecEqp, 0, sizeof( m_tRecEqp ) );
// 					TRecStartPara tOldRecParam = m_tRecPara;
// 					m_tRecPara.Reset();
// 					m_tConf.m_tStatus.SetNoRecording();
// 					
// 					//停止录像时，先挂载一遍适配参数，再刷新一次终端适配参数,告知适配器参数改变
// 					//这里是否要判断双流？？？
// 					StartBrdAdapt(MODE_VIDEO);
// 				}
// 				break;
// 			case TRecChnnlStatus::STATE_RECORDING:	//开始或恢复录像
// 				
//                 //保存参数
//                 m_byRecChnnl = byChnnl;
//                 m_tRecEqp = *ptEqp;
// 				
//                 //change status
//                 if (ptChnnlStatus->m_byRecMode == REC_MODE_SKIPFRAME)
//                 {
//                     m_tConf.m_tStatus.m_tConfMode.SetRecSkipFrame(TRUE);
//                 }
//                 else
//                 {
//                     m_tConf.m_tStatus.m_tConfMode.SetRecSkipFrame(FALSE);
//                 }
// 				
// 				//恢复录像时不需重建交换
// 				if (m_tConf.m_tStatus.IsNoRecording())
// 				{
// 					//[2011/07/16/zhanlgi]整理录像机拆建RTP/RTCP交换
// 					AdjustRecordSrcStream(*ptEqp, tRecMt, byChnnl, TRUE, TRUE, MODE_NONE);
// 
//                     //请求双流源关键帧
//                     if ( m_tRecPara.IsRecDStream() && 
// 						!m_tDoubleStreamSrc.IsNull() && m_tDoubleStreamSrc.GetType() == TYPE_MT )
//                     {
//                         NotifyFastUpdate(m_tDoubleStreamSrc, MODE_SECVIDEO);
//                     }
// 				}
// 				else
// 				{
// 					//恢复录象向终端请求关键帧, zgc, 2008-07-17
// 					TMt tSrc;
// 					u8  byRecChnIdx = 0;
// 					u8  byBasChnId  = 0;
// 					BOOL32 bNeedBas = IsRecordSrcBas(MODE_VIDEO, tSrc, byBasChnId, byRecChnIdx);
// 					if ( !tSrc.IsNull() && tSrc.GetType() == TYPE_MT)
// 					{         
// 						// [pengjie 2010/4/2] 多回传请求关键帧支持
// 						TMt tMtSpeaker = m_tConf.GetSpeaker();
// 						if( !tMtSpeaker.IsNull() && m_cSMcuSpyMana.IsMtInSpyMember( tMtSpeaker, MODE_VIDEO ) )
// 						{
// 							NotifyFastUpdate(tMtSpeaker, MODE_VIDEO);
// 						}
// 						else
// 						{
// 							NotifyFastUpdate(tSrc, MODE_VIDEO);
// 						}
// 						
// 					}
// 					if ( m_tRecPara.IsRecDStream() && 
// 						!m_tDoubleStreamSrc.IsNull() && 
// 						m_tDoubleStreamSrc.GetType() == TYPE_MT )
// 					{
// 						NotifyFastUpdate(m_tDoubleStreamSrc, MODE_SECVIDEO);
// 					}
// 				}
// 				
// 				m_tConf.m_tStatus.SetRecording();
// 				break;
// 							  
// 			case TRecChnnlStatus::STATE_RECPAUSE:	//暂停录像	
// 				//change status
// 				// [pengjie 2010/9/29] 如果是会议内部逻辑触发的暂停了录像，这里不让界面感知
// 				//m_tConf.m_tStatus.SetRecPause();
// 				if( !m_tConf.m_tStatus.IsRecPauseByInternal() )
// 				{
// 					m_tConf.m_tStatus.SetRecPause();
// 				}
// 				// End
// 
// 				break;	
// 			}
// 			ConfModeChange();	
// 			
// 		}
//         //终端录像
// 		else
// 		{
// 			TMt tLocalMt = GetLocalMtFromOtherMcuMt(tRecMt);
// 			
// 			TMtStatus tRecMtStatus;
// 
// 			// [pengjie 2010/9/20] 这里上报真实的录像源信息
// 			GetMtStatus(tRecMt, tRecMtStatus);
// 			// End
//             
//             switch (ptChnnlStatus->m_byState)
//             {
//             case TRecChnnlStatus::STATE_RECREADY:	//停止录像
// 				{
// 					//[2011/07/16/zhanlgi]整理录像机拆建RTP/RTCP交换
// 					AdjustRecordSrcStream(*ptEqp, tRecMt, byChnnl, FALSE, FALSE, MODE_NONE);
// 
// 					//置状态
// 					tRecMtStatus.m_tRecState.SetNoRecording();
// 					
// 					FreeRecvSpy(tRecMt, MODE_BOTH);
// 				}
//                 break;
//             case TRecChnnlStatus::STATE_RECORDING:	//开始或恢复录像
//                 
//                 //开始录像，设置终端状态，向录像机发送码流
//                 if (tRecMtStatus.m_tRecState.IsNoRecording())
//                 {
//                     //被录像终端已不在会议，停止终端录像
//                     if (!m_tConfAllMtInfo.MtJoinedConf(tRecMt))
//                     {
//                         CServMsg cServMsg;
//                         cServMsg.SetConfId(m_tConf.GetConfId());
//                         cServMsg.SetMsgBody((u8 *)ptEqp, sizeof(*ptEqp));	//set TEqp
//                         cServMsg.SetChnIndex(byChnnl);
//                         SendMsgToEqp(ptEqp->GetEqpId(), MCU_REC_STOPREC_REQ, cServMsg);
//                     }
// 
// 					//[2011/07/16/zhanlgi]整理录像机拆建RTP/RTCP交换
// 					AdjustRecordSrcStream(*ptEqp, tRecMt, byChnnl, FALSE, TRUE, MODE_NONE);
// 
// 					// [9/20/2010 liuxu]修改结束
// 					
//                     if ( tRecMt.IsLocal() )
//                     {
//                         //通知本级终端开始发送
//                         NotifyMtSend(tRecMt.GetMtId());
//                     }
//                     else
//                     {
// 						if (!IsLocalAndSMcuSupMultSpy(tRecMt.GetMcuId()))
// 						{
// 			    			//请求下级终端回传码流
// 		                   OnMMcuSetIn( tRecMt, 0, SWITCH_MODE_SELECT );
// 						}
//                     }					
// 				}
//                 else
//                 {
//                     //恢复录象向终端请求关键帧, zgc, 2008-07-17                    
//                     if ( tRecMt.GetType() == TYPE_MT)
//                     {                                   
//                         NotifyFastUpdate(tRecMt, MODE_VIDEO);
//                     }
//                     if ( m_tRecPara.IsRecDStream() && 
//                         !m_tDoubleStreamSrc.IsNull() && 
//                         m_tDoubleStreamSrc.GetType() == TYPE_MT )
//                     {
//                         NotifyFastUpdate(m_tDoubleStreamSrc, MODE_SECVIDEO);
//                     }
//                 }
// 				
//                 //重置为录像状态
// 				tRecMtStatus.m_tRecState.SetRecording();
// 				
//                 if (ptChnnlStatus->m_byRecMode == REC_MODE_SKIPFRAME)
//                 {
// 					tRecMtStatus.m_tRecState.SetRecSkipFrame(TRUE);
//                 }
//                 else
//                 {
// 					tRecMtStatus.m_tRecState.SetRecSkipFrame(FALSE);
//                 }
// 				
// 				break;
// 				
// 			case TRecChnnlStatus::STATE_RECPAUSE:	//暂停录像	
// 				
//                 //置状态
// 				tRecMtStatus.m_tRecState.SetRecPause();
// 				break;
// 				
// 			default:
// 				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "Unexcept State Recevied In RecordMtNotify.\n" );
// 				return;
// 			}
// 			
// 			//设置外设状态
// 			// [pengjie 2010/9/20] 这里上报真实的录像源信息
// 			SetMtStatus(tRecMt, tRecMtStatus);
// 			MtStatusChange(&tRecMt, TRUE);
// 			// End
// 			
// 			if( tRecMtStatus.m_tRecState.IsNoRecording() )
// 			{
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "Mt %d rec state change, new state: IsNoRecording!\n", tRecMt.GetMtId() );
// 			}
// 			else if( tRecMtStatus.m_tRecState.IsRecording() )
// 			{
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "Mt %d rec state change, new state: IsRecording!\n", tRecMt.GetMtId());
// 			}
// 			else if( tRecMtStatus.m_tRecState.IsRecPause() )
// 			{
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "Mt %d rec state change, new state: IsRecPause!\n", tRecMt.GetMtId());
// 			}
// 			else if( tRecMtStatus.m_tRecState.IsRecSkipFrame() )
// 			{
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "Mt %d rec state change, new state: IsRecSkipFrame!\n",tRecMt.GetMtId());
// 			}
// 			
// 		}
// 		break;		
// 		
// 	default:
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
// 			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
// 		break;
// 	}
}

/*====================================================================
    函数名      ：ProcRecMcuProgNotif
    功能        ：录像机进度通知处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/20    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcRecMcuProgNotif( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TRecProg	* ptRecProg = NULL;
    TEqp        tEqp;
    TMt         tMt;
	u16         wMcEvent = 0;
    
	switch( CurState() )
	{
	case STATE_ONGOING:
		if( pcMsg->event == REC_MCU_PLAYPROG_NOTIF )
		{
			ptRecProg = ( TRecProg * )( cServMsg.GetMsgBody() + sizeof( TEqp ) );
			m_tConf.m_tStatus.m_tPlayProg = *ptRecProg;
			wMcEvent = MCU_MCS_PLAYPROG_NOTIF;
			if (m_tPlayEqp.GetType() == TYPE_MT && m_tPlayEqp.GetMtType() == MT_TYPE_VRSREC)
			{
				// 新录播支持，更新当前进度
				m_ptMtTable->SetRecProg(m_tPlayEqp.GetMtId(), *ptRecProg);
			}
		}
		else
		{
		    tMt  = *( TMt* )cServMsg.GetMsgBody();
            tEqp = *( TMt* )( cServMsg.GetMsgBody() + sizeof( TMt ) );
			ptRecProg = ( TRecProg * )( cServMsg.GetMsgBody() + sizeof( TMt ) + sizeof( TEqp ) );
			
			TEqp tRecorder;
			u8 byRecChannl;
			GetMtRecordInfo( tMt, tRecorder, byRecChannl );
			BOOL32 bIsVrsRec = tRecorder.GetType() == TYPE_MT && tRecorder.GetMtType() == MT_TYPE_VRSREC;
			// [9/6/2010 liuxu] 这里是否与是不是会以录像有关？ 不用mcuid == 0 判断，而用EqpId判断
			// if( tMt.GetMcuId() == 0 )
			if( IS_RECORD_CONF(tMt) )
			{
				m_tConf.m_tStatus.m_tRecProg = *ptRecProg;	
				if (bIsVrsRec)
				{
					// 更新当前进度
					m_ptMtTable->SetRecProg(tRecorder.GetMtId(), *ptRecProg);
				}
			}
			else
			{
				// 新录播支持
				if (bIsVrsRec)
				{
					//重新构造 cServMsg
					tEqp.SetNull();//外设信息置空区分为vrs新录播
					cServMsg.SetMsgBody( (u8*)&tMt,  sizeof(TMt) );
					cServMsg.CatMsgBody( (u8*)&tEqp, sizeof(TEqp) );
					cServMsg.CatMsgBody( (u8*)ptRecProg, sizeof(TRecProg) );

					// 更新当前进度
					m_ptMtTable->SetRecProg(tRecorder.GetMtId(), *ptRecProg);
				}
				else
				{
					//重新构造 cServMsg
					cServMsg.SetMsgBody( (u8*)&tMt,  sizeof(TMt) );
					cServMsg.CatMsgBody( (u8*)&tEqp, sizeof(TEqp) );
					cServMsg.CatMsgBody( (u8*)ptRecProg, sizeof(TRecProg) );
					TPeriEqpStatus tRecStatus;
					TRecChnnlStatus tRecChanStatus;
					g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tRecStatus);
					
					tRecStatus.m_tStatus.tRecorder.GetChnnlStatus(
						cServMsg.GetChnIndex(),
						TRecChnnlStatus::TYPE_RECORD,
						&tRecChanStatus);
					
					tRecChanStatus.m_tProg = *ptRecProg;
					
					tRecStatus.m_tStatus.tRecorder.SetChnnlStatus(
						cServMsg.GetChnIndex(), 
						TRecChnnlStatus::TYPE_RECORD,
						&tRecChanStatus);
					g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tRecStatus);
				}
			}
			wMcEvent = MCU_MCS_RECPROG_NOTIF;
		}

    	SendMsgToAllMcs( wMcEvent, cServMsg );
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			             pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ProcRecMCUNeedIFrameCmd
    功能        ：录像机请求关键帧
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	08/12/18    4.0         江乐斌          创建
====================================================================*/
void CMcuVcInst::ProcRecMcuNeedIFrameCmd(const CMessage * pcMsg)
{	
	CServMsg cServMsg(pcMsg->content, pcMsg->length);
	
    TMt tSrcMt;
    TEqp tBasSrc;
    u8 byRecInChnIdx = 0;
	u8 byBasChnId    = 0;

	BOOL32 bMainStreamNeedIframe = 0;
	BOOL32 bDStreamNeedIframe = 0;

	u8 abyNeedIframeStream[MAX_STREAM_NUM] = {0};
	//zjj20120823 老录像机不带消息体，默认主双流都请求，否则按消息体来判断
	if( cServMsg.GetMsgBodyLen() >= sizeof(abyNeedIframeStream) )
	{
		memcpy(abyNeedIframeStream,cServMsg.GetMsgBody(),MAX_STREAM_NUM);
		bMainStreamNeedIframe = abyNeedIframeStream[1];//是否主流在请求关键帧
		bDStreamNeedIframe = abyNeedIframeStream[2];//是否双流在请求关键帧
	}
	else
	{
		bMainStreamNeedIframe = 1;
		bDStreamNeedIframe = 1;
	}
	
	//现在录像机最大支持5路码流，从0开始：第0路音频，1路主流，2路双流，3路音频，4路视频
	//BOOL32 bMainStreamNeedIframe = abyNeedIframeStream[1];//是否主流在请求关键帧
	//BOOL32 bDStreamNeedIframe = abyNeedIframeStream[2];//是否双流在请求关键帧	

	BOOL32 bIsRecordConf = TRUE;		//是否会议录像
	u8 byEqpId = cServMsg.GetSrcSsnId();	//录像机ID
	u8 byChnnlId = cServMsg.GetChnIndex();	//录像所用通道
	TPeriEqpStatus tRecStatus;
	TRecChnnlStatus tRecChnlStatus;

	ConfPrint(LOG_LVL_DETAIL,MID_MCU_REC,"[ProcRecMcuNeedIFrameCmd]rec status:eqpid:%d,chn-%d,MainStream-%d,DStreamNeedIframe-%d\n",
			 byEqpId,byChnnlId,bMainStreamNeedIframe,bDStreamNeedIframe
		     );
	if (g_cMcuVcApp.IsPeriEqpValid(byEqpId))
	{
		g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tRecStatus);
		if (tRecStatus.m_byOnline == 1)
		{
			if(TRUE == tRecStatus.m_tStatus.tRecorder.GetChnnlStatus(byChnnlId, TRecChnnlStatus::TYPE_RECORD, &tRecChnlStatus))
			{
				if ( tRecChnlStatus.m_tSrc.IsNull() )
				{
					bIsRecordConf = TRUE;
				}
				else
				{
					bIsRecordConf = FALSE;
				}
			}
			else
			{
				ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[ProcRecMcuNeedIFrameCmd]tRec:%d GetChnnlStatus failed!\n",byEqpId);
				return ;
			}
		}
		else
		{
			ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[ProcRecMcuNeedIFrameCmd]tRec:%d isn't online!\n",byEqpId);
			return ;
		}
	}
	else
	{
		ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[ProcRecMcuNeedIFrameCmd]g_cMcuVcApp.IsPeriEqpValid:%d failed!\n",byEqpId);
		return ;
	}

	ConfPrint(LOG_LVL_DETAIL,MID_MCU_REC,"[ProcRecMcuNeedIFrameCmd]bIsRecordConf:%d\n",bIsRecordConf);
    switch(CurState())
    {
    case STATE_ONGOING:
		{			
			//主流请求关键帧
			if ( bMainStreamNeedIframe )
			{
				//会议录像
				if ( bIsRecordConf )
				{
					BOOL32 bIsRecSrcBas = IsRecordSrcBas(MODE_VIDEO, tBasSrc, byBasChnId, byRecInChnIdx);
					if( g_cMcuVcApp.GetVMPMode(m_tVmpEqp) != CONF_VMPMODE_NONE
						&& g_cMcuVcApp.IsBrdstVMP(m_tVmpEqp) && !bIsRecSrcBas )
					{
						//[nizhijun 2012/06/29] 录像机适配录像，如果源是VMP，不走BAS，直接收VMP的相关码流。
						/*tSrcMt = m_tVmpEqp;
						if ( IsRecNeedAdapt(MODE_VIDEO) )
						{
							TVideoStreamCap tTempVidCap;
							m_cRecAdaptMgr.GetRecVideoCapSet( MODE_VIDEO, tTempVidCap );
							byRecInChnIdx = GetVmpOutChnnlByRes(m_tVmpEqp.GetEqpId(),
								tTempVidCap.GetResolution(),
								tTempVidCap.GetMediaType(),
								tTempVidCap.GetUserDefFrameRate(),
								tTempVidCap.GetH264ProfileAttrb()
								);
							ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_REC,"[ProcRecMcuNeedIFrameCmd]vmp byRecInIdx:%d\n",byRecInChnIdx);
						}
						else
						{
							TVideoStreamCap tStrCap = m_tConf.GetMainSimCapSet().GetVideoCap();
							byRecInChnIdx = GetVmpOutChnnlByRes(m_tVmpEqp.GetEqpId(),
								tStrCap.GetResolution(), 
								tStrCap.GetMediaType(),
								tStrCap.GetUserDefFrameRate(),
								tStrCap.GetH264ProfileAttrb());
						}*/
						
						NotifyEqpFastUpdate(tBasSrc, byRecInChnIdx);
					}
					else if (bIsRecSrcBas)
					{
						//录像机会定时请求三次，此处不定时
						NotifyEqpFastUpdate(tBasSrc, byBasChnId, FALSE);
					}
					else 
					{
						if(!GetVidBrdSrc().IsNull())
						{
							tSrcMt = GetVidBrdSrc();
							NotifyFastUpdate(tSrcMt, MODE_VIDEO);
						}
						else
						{
							ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[ProcRecMcuNeedIFrameCmd]VidBrdSrc is NULL!\n");
						}		
					}
				}
				//终端录像
				else
				{
					NotifyFastUpdate(tRecChnlStatus.m_tSrc, MODE_VIDEO);
					ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_REC,"[ProcRecMcuNeedIFrameCmd]mtrecord vid fastupdate to:%d-%d\n",
						tRecChnlStatus.m_tSrc.GetMcuId(),tRecChnlStatus.m_tSrc.GetMtId()
						);
				}
			}
			
			//双流请求关键帧
			if ( bDStreamNeedIframe )
			{	
				//会议录像
				if ( bIsRecordConf )
				{
					if ( IsRecordSrcBas(MODE_SECVIDEO, tBasSrc, byBasChnId, byRecInChnIdx) ) 
					{
						//录像机会定时请求三次，此处不定时
						NotifyEqpFastUpdate(tBasSrc, byBasChnId, FALSE);
					}
					// [pengjie 2010/4/28] Modify 如果是任意人发双流，要求双流源编关键帧
					else if( !m_tDoubleStreamSrc.IsNull() && m_tConf.m_tStatus.IsRecording() && m_tRecPara.IsRecDStream() )
					{
						NotifyFastUpdate( m_tDoubleStreamSrc, MODE_SECVIDEO );
					}
					else
					{
						ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[ProcRecMcuNeedIFrameCmd]m_tDoubleStreamSrc is NULL!\n");
					}
				}
				//终端录像
				else
				{
					NotifyFastUpdate(tRecChnlStatus.m_tSrc, MODE_SECVIDEO);
					ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_REC,"[ProcRecMcuNeedIFrameCmd]mtrecord secvid fastupdate to:%d-%d\n",
						tRecChnlStatus.m_tSrc.GetMcuId(),tRecChnlStatus.m_tSrc.GetMtId()
						);
				}	
			}
		}
		break;
	default:
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcRecMCUNeedIFrameCmd]Wrong message %u(%s) received in state %u!\n", 
				pcMsg->event, ::OspEventDesc(pcMsg->event), CurState());
			break;
    }
	return;
}

/*====================================================================
    函数名      ：ProcMcuRecConnectedNotif
    功能        ：录像机上电通知
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	05/09/28    4.0         libo          创建
====================================================================*/
void CMcuVcInst::ProcMcuRecConnectedNotif(const CMessage * pcMsg)
{
    if (STATE_ONGOING != CurState())
    {
        return;
    }

    CServMsg cServMsg(pcMsg->content, pcMsg->length);

    TEqp tEqp;
    TPeriEqpStatus tRecStatus;
    TRecChnnlStatus tRecChanStatus;
    TPeriEqpRegReq tRegReq = *(TPeriEqpRegReq *)cServMsg.GetMsgBody();
    
    if (tRegReq.GetEqpId() != m_tPlayEqp.GetEqpId() ||
        EQP_CHANNO_INVALID == m_byPlayChnnl)
    {
        return;
    }

    // 放像恢复
    tEqp.SetMcuEqp((u8)tRegReq.GetMcuId(), tRegReq.GetEqpId(), tRegReq.GetEqpType());

    g_cMcuVcApp.GetPeriEqpStatus(tRegReq.GetEqpId(), &tRecStatus);

    tRecStatus.m_tStatus.tRecorder.GetChnnlStatus(m_byPlayChnnl,
                                                  TRecChnnlStatus::TYPE_PLAY,
                                                  &tRecChanStatus);

    cServMsg.SetMsgBody((u8 *)&tEqp, sizeof(TEqp));
    cServMsg.CatMsgBody((u8 *)&tRecChanStatus.m_tProg, sizeof(TRecProg));
    cServMsg.CatMsgBody((u8 *)tRecChanStatus.GetRecordName(), strlen(tRecChanStatus.GetRecordName()));

    StartPlayReq(cServMsg);

    return;
}

/*====================================================================
    函数名      ：ProcMcuRecDisconnectedNotif
    功能        ：录像机断链处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    02/08/26    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcMcuRecDisconnectedNotif( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TEqp	tEqp = *( TEqp * )cServMsg.GetMsgBody();

	switch( CurState() )
	{
	case STATE_ONGOING:
		{
			//停止会议录像交换
			if( !m_tConf.m_tStatus.IsNoRecording() && (m_tRecEqp == tEqp) )
			{
				if (IsRecNeedAdapt())
				{
					ResetRecAdptParam();
				}

				//[2011/07/16/zhanlgi]整理录像机拆建RTP/RTCP交换
				AdjustConfRecordSrcStream(MODE_BOTH, FALSE);
				AdjustConfRecordSrcStream(MODE_SECVIDEO, FALSE);
				
				m_byRecChnnl = 0;
				memset( &m_tRecEqp, 0, sizeof( m_tRecEqp ) );
				m_tConf.m_tStatus.SetNoRecording();
				ConfModeChange( );
				log( LOGLVL_IMPORTANT, "CMcuVcInst: Conferece %s recording state cancelled due to MCU%u's VOD%u disconnected!\n", 
					m_tConf.GetConfName(), tEqp.GetMcuId(), tEqp.GetEqpId() );
			}

			cServMsg.SetConfId( m_tConf.GetConfId() );

			//判断是否是发言外设
			if( !m_tConf.m_tStatus.IsNoPlaying() && (m_tPlayEqp==tEqp) )
			{
				//change status
				//m_byPlayChnnl = 0;
				//memset( &m_tPlayEqp, 0, sizeof( m_tPlayEqp ) );
				m_tConf.m_tStatus.SetNoPlaying();
				ConfModeChange();
            
				if (TYPE_MCUPERI      == m_tDoubleStreamSrc.GetType() &&
					EQP_TYPE_RECORDER == m_tDoubleStreamSrc.GetEqpType())
				{
					StopDoubleStream(FALSE, TRUE);
				}

				//change speaker
				ChangeSpeaker( NULL );
			}

			// [9/17/2010 liuxu] 此处是lukunpeng为适应多回传删除
			/*
			//终端录像
			for( byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++ )
			{				
				
				if( m_tConfAllMtInfo.MtJoinedConf( byMtId ) && !m_ptMtTable->IsMtNoRecording( byMtId ) )
				{
					TEqp tRecEqp;
					u8   byRecChn;
					TMtStatus tMtStatus;

					GetMtRecordInfo( byMtId ,tRecEqp,byRecChn );

					//终端录像的录像机是断链的录像机
					if ( tRecEqp == tEqp )
					{
						StopSwitchToPeriEqp( tRecEqp.GetEqpId(),byRecChn);                    
						m_ptMtTable->SetMtNoRecording(byMtId);
						MtStatusChange(byMtId, TRUE);
					}				
				}
			}
			*/

			TPeriEqpStatus tRecStatus;
			TRecChnnlStatus tStatus;
			if (g_cMcuVcApp.IsPeriEqpValid(tEqp.GetEqpId()))
			{
				// [9/17/2010 liuxu] 删除状态获取，并将在线状态设为false
				g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tRecStatus);
				g_cMcuVcApp.SetPeriEqpConnected( tEqp.GetEqpId(), FALSE );

				// [9/17/2010 liuxu] 录像机外设掉线时就已经设置为0了，故此处判断它是否在线有误
				//if (tRecStatus.m_byOnline == 1)
				{
					u8 byRecChnNum = tRecStatus.m_tStatus.tRecorder.GetRecChnnlNum();
					for(u8 byLoop = 0; byLoop < byRecChnNum; byLoop++)
					{
						if(TRUE == tRecStatus.m_tStatus.tRecorder.GetChnnlStatus(byLoop, TRecChnnlStatus::TYPE_RECORD, &tStatus))
						{
							//如果此通道有终端，且此终端是本会议的，停止向此外设发送码流
							if (!tStatus.m_tSrc.IsNull() && tStatus.m_tSrc.GetConfIdx() == m_byConfIdx)
							{
								//[2011/07/16/zhanlgi]整理录像机拆建RTP/RTCP交换
								AdjustMtRecSrcStream(MODE_BOTH, tEqp, byLoop, TMt(tStatus.m_tSrc), FALSE);
								AdjustMtRecSrcStream(MODE_SECVIDEO, tEqp, byLoop, TMt(tStatus.m_tSrc), FALSE);

								// [9/17/2010 liuxu] 更变终端录像状态，并发送终端状态改变通知
								SetMtRecording(tStatus.m_tSrc, FALSE);
								MtStatusChange((TMt*)&tStatus.m_tSrc, TRUE);
								// [11/23/2010 liuxu]释放下级终端的回传资源
								FreeRecvSpy(tStatus.m_tSrc, MODE_BOTH);
							}
						}
					}
				}
			}
		}	
		break;

	case STATE_SCHEDULED:
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ：ProcRecMcuResp
    功能        ：处理录像机给MCU的回应消息
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/09/23    4.0         libo          创建
====================================================================*/
void CMcuVcInst::ProcRecMcuResp(const CMessage * pcMsg)
{
    if (STATE_ONGOING != CurState())
    {
        return;
    }

    CServMsg cServMsg(pcMsg->content, pcMsg->length);
    TEqp tEqp = *(TEqp *)cServMsg.GetMsgBody();
	//CConfId	cConfId = cServMsg.GetConfId();
	u8 byChnnl = cServMsg.GetChnIndex();
	BOOL32 bIsVrsRec = FALSE;
	TMt	tVrsMt = m_ptMtTable->GetMt( cServMsg.GetSrcMtId() );
	if (tEqp.IsNull() && tVrsMt.GetMtType() == MT_TYPE_VRSREC)
	{
		bIsVrsRec = TRUE;
	}

    switch(pcMsg->event)
    {
    case REC_MCU_STARTPLAY_ACK:
        {
			if (bIsVrsRec)
			{
				// vrs新录播放像，vrs会来开逻辑通道
				break;
			}
            TPlayFileAttrib tPlayFileAttrib;
            tPlayFileAttrib = *(TPlayFileAttrib *)(cServMsg.GetMsgBody() + sizeof(TEqp));
            m_tPlayEqpAttrib.SetFileType(tPlayFileAttrib.GetFileType());
            m_tPlayEqpAttrib.SetAudioType(tPlayFileAttrib.GetAudioType());
            m_tPlayEqpAttrib.SetVideoType(tPlayFileAttrib.GetVideoType());
            m_tPlayEqpAttrib.SetDVideoType(tPlayFileAttrib.GetDVideoType());            
            
            
            // zgc, 2008-08-28, 记录放像文件媒体信息
            if ( cServMsg.GetMsgBodyLen() > sizeof(TEqp) + sizeof(TPlayFileAttrib) )
            {
                m_tPlayFileMediaInfo = *(TPlayFileMediaInfo *)( cServMsg.GetMsgBody() + sizeof(TEqp) + sizeof(TPlayFileAttrib) );
                u8 byType = 0;
                u16 wWidth = 0;
                u16 wHeight = 0;
                m_tPlayFileMediaInfo.GetVideo( byType, wWidth, wHeight );
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ProcRecMcuResp]PlayFileMediaInfo: Type.%d, Width.%d, Height.%d\n", 
                            byType, wWidth, wHeight );

				// [liu lijiu][2010/11/08]放像机的起始端信息
			    if( cServMsg.GetMsgBodyLen() > sizeof(TEqp) + sizeof(TPlayFileAttrib) + sizeof(TPlayFileMediaInfo))
				{
					TLogicalChannel tLogicalChannel;
					TTransportAddr tPlayRtcpAddr;
					u32 dwPlyStartIp;
					u16 wPlyStartPort;
					tPlayRtcpAddr = *(TTransportAddr*)( cServMsg.GetMsgBody() + sizeof(TEqp) + sizeof(TPlayFileAttrib) + sizeof(TPlayFileMediaInfo));
					dwPlyStartIp = tPlayRtcpAddr.GetIpAddr();
					wPlyStartPort = tPlayRtcpAddr.GetPort();
					tLogicalChannel.m_tRcvMediaChannel.SetIpAddr(dwPlyStartIp);
					tLogicalChannel.m_tRcvMediaChannel.SetPort( wPlyStartPort);
					tLogicalChannel.m_tRcvMediaCtrlChannel.SetIpAddr(dwPlyStartIp);
					tLogicalChannel.m_tRcvMediaCtrlChannel.SetPort(wPlyStartPort+1);
					tLogicalChannel.m_tSndMediaCtrlChannel.SetIpAddr(0);	//设0交换时绑定用
					tLogicalChannel.m_tSndMediaCtrlChannel.SetPort(wPlyStartPort+1);
					g_cMcuVcApp.SetPeriEqpLogicChnnl(tEqp.GetEqpId(), MODE_VIDEO,
										               0, &tLogicalChannel, FALSE);

					//zhouyiliang 20120223 放像文件的hp/bp信息加在后面
					 if( cServMsg.GetMsgBodyLen() > sizeof(TEqp) + sizeof(TPlayFileAttrib) + sizeof(TPlayFileMediaInfo) + sizeof(TTransportAddr))
					 {
						m_tPlayFileHpAttrib = *(TPlayFileHpAttrib*)( cServMsg.GetMsgBody() + sizeof(TEqp) + \
							sizeof(TPlayFileAttrib) + sizeof(TPlayFileMediaInfo)+sizeof(TTransportAddr));
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ProcRecMcuResp]m_tPlayFileHpAttrib: FirstVideHp:%d,SecVideHp:%d\n", 
                            m_tPlayFileHpAttrib.GetFirstVideHpAttrib(),m_tPlayFileHpAttrib.GetSecVideHpAttrib() );
					 
						u32 dwTempByteNum = sizeof(TEqp) + sizeof(TPlayFileAttrib) + sizeof(TPlayFileMediaInfo) +\
											sizeof(TTransportAddr) + sizeof(TPlayFileHpAttrib);

						if ( cServMsg.GetMsgBodyLen() > dwTempByteNum  )
						{
							u8 byAudTrackNum = *(u8*)( cServMsg.GetMsgBody()+sizeof(TEqp)+sizeof(TPlayFileAttrib)+\
								sizeof(TPlayFileMediaInfo)+sizeof(TTransportAddr) + sizeof(TPlayFileHpAttrib ) );
							m_tPlayEqpAttrib.SetAudTrackNum( byAudTrackNum );
							ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ProcRecMcuResp]m_tPlayEqpAttrib byAudTrackNum:%d\n",byAudTrackNum);
						}
						else
						{
							m_tPlayEqpAttrib.SetAudTrackNum(1);	//老版本设置声道数为1
							ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[ProcRecMcuResp] Receive old version recorder REC_MCU_STARTPLAY_ACK\n");
						}
					 }
					 else
					 {
						 m_tPlayEqpAttrib.SetAudTrackNum(1);	//老版本设置声道数为1
						ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[ProcRecMcuResp] Receive old version recorder REC_MCU_STARTPLAY_ACK\n");
					 }
				}
				else
				{
					m_tPlayEqpAttrib.SetAudTrackNum(1);	//老版本设置声道数为1
					ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[ProcRecMcuResp] Receive old version recorder REC_MCU_STARTPLAY_ACK\n");
				}

			}
            else
            {
				m_tPlayEqpAttrib.SetAudTrackNum(1);	//老版本设置声道数为1
                ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP,  "[ProcRecMcuResp] Receive old version recorder REC_MCU_STARTPLAY_ACK\n" );
            }

			TPeriEqpStatus tRecStatus;    
			if( g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tRecStatus) )
			{
				TRecChnnlStatus tChlStatus;
				if( tRecStatus.m_tStatus.tRecorder.GetChnnlStatus( byChnnl,TRecChnnlStatus::TYPE_PLAY,&tChlStatus ) )
				{
					tChlStatus.m_tSrc.SetNull();
					tChlStatus.m_tSrc.SetConfIdx( m_byConfIdx );
					tChlStatus.m_tSrc.SetMtId(0);
					tRecStatus.m_tStatus.tRecorder.SetChnnlStatus( byChnnl,TRecChnnlStatus::TYPE_PLAY,&tChlStatus );
					g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tRecStatus);
				}
			}

            
			// [10/20/2010 liuxu]修改: 将录像机开始双流的操作移到ChangeSpeaker后
			// 原因: 如果在这里打开放像机的双流通道,那么如果发言人开启了双流源, 会导致m_tDoubleStreamSrc在
			// StartDoubleStream里被修改成录像机,这样导致原有的双流通道不能被正常关闭.
			// 另外还有一个方案: 可以在changespeaker里关闭旧发言人的双流源时,将m_tDoubleStreamSrc给为旧发言人的Tmt
			// 可以解决此问题.
// 			
// 			if (m_tPlayEqpAttrib.GetDVideoType() == m_tConf.GetDStreamMediaType()
// 				||( m_tConf.GetCapSupportEx().IsDDStreamCap()
// 				&& ( MEDIA_TYPE_H264 == m_tPlayEqpAttrib.GetDVideoType() 
// 				|| MEDIA_TYPE_H263PLUS == m_tPlayEqpAttrib.GetDVideoType()
// 				)
// 				)
// 				)
// 			{
// 				if (m_tPlayEqpAttrib.IsDStreamPlay() && m_tPlayEqpAttrib.IsDStreamFile())
// 				{
// 					TLogicalChannel tLogicChnnl;
// 					tLogicChnnl.SetChannelType(m_tPlayEqpAttrib.GetDVideoType());
// 					tLogicChnnl.SetSupportH239(m_tConf.GetCapSupport().IsDStreamSupportH239());
// 					
// 					tEqp.SetConfIdx(m_byConfIdx);
// 					
// 					// [9/19/2010 liuxu]临时添加
// 					m_byPlayChnnl = byChnnl;
// 					m_tPlayEqp = tEqp;
// 					m_tPlayEqp.SetConfIdx( m_byConfIdx );
// 					
// 					StartDoubleStream(tEqp, tLogicChnnl);
// 				}
//             }

			//连续播放刷新交换 临时支持 稍后加入标识恢复状态机完备性			
			//change speaker if it's not speaker now			
			//if( m_tConf.m_tStatus.IsNoPlaying() )
			{
				
				// [10/20/2010 liuxu] 将上述开启双流源的代码移到这里
				if ( m_tPlayEqpAttrib.GetDVideoType() == m_tConf.GetDStreamMediaType() ||
					 ( 
					   m_tConf.GetCapSupportEx().IsDDStreamCap() && 
					   ( 
					     MEDIA_TYPE_H264 == m_tPlayEqpAttrib.GetDVideoType() || 
					     MEDIA_TYPE_H263PLUS == m_tPlayEqpAttrib.GetDVideoType()
					   )
					 )
				   )
				{
					if (m_tPlayEqpAttrib.IsDStreamPlay() && m_tPlayEqpAttrib.IsDStreamFile())
					{
						TLogicalChannel tLogicChnnl;
						tLogicChnnl.SetChannelType(m_tPlayEqpAttrib.GetDVideoType());
						tLogicChnnl.SetSupportH239(m_tConf.GetCapSupport().IsDStreamSupportH239());
						
						tEqp.SetConfIdx(m_byConfIdx);
						
						// [9/19/2010 liuxu]临时添加
						m_byPlayChnnl = byChnnl;
						m_tPlayEqp = tEqp;
						m_tPlayEqp.SetConfIdx( m_byConfIdx );
						
						StartDoubleStream(tEqp, tLogicChnnl);
					}
				}
				// [10/20/2010 liuxu] 代码移动结束

				//[nizhijun 2012/05/17] Bug00087831 原先双流开启放在后面，会导致RTCP交换建立时存在时序问题
				//双流在changespeaker后调用，导致主流视频交换建立时使用会议码率做为源能力，如会议存在其他终端发双流，某接收终端码率下降，需要过适配
				//随后建立过适配的RTP和RTCP交换，然后发送changeprssrc改变广播主流音频双流三路码流源的消息给PRS
				//等prs回ACK后，StartDoubleStream已经走完，会议双流源已经为录像机，导致prs回ACK处理RTCP交换时，使用IsNeedApt认为不需要适配，建立了广播RTCP交换
				//至此，该接收终端收适配码流而建立广播的RTCP交换，故丢包时失败
				//现在提前双流后，不需要过适配收码流，故不存在问题。
				//对于当初刘旭描述的那个BUG，测试了下，目前应该是不存在的
				m_byPlayChnnl = byChnnl;
				m_tPlayEqp = tEqp;
				m_tPlayEqp.SetConfIdx( m_byConfIdx );
				ChangeSpeaker( &m_tPlayEqp,FALSE,TRUE,TRUE,TRUE);


                //zbq [09/05/2007] 录像机双流放象，此处才可以建桥
                if ( m_tDoubleStreamSrc == tEqp )
                {
                    g_cMpManager.SetSwitchBridge(tEqp, byChnnl, MODE_SECVIDEO);
                }

				// xliang [8/26/2009] 在交换定时里面setplay,而在此处setplayReady。这期间是不允许MT拖成发言人的
				m_tConf.m_tStatus.SetPlayReady();

				// 开启等待交换建立定时器, zgc, 2008-03-27
				SetTimer( MCUVC_RECPLAY_WAITMPACK_TIMER, TIMESPACE_WAIT_PLAY_SWITCHOK );
			}
        }
	
		//SendMsgToEqp( m_tPlayEqp.GetEqpId() , MCU_EQP_SWITCHSTART_NOTIF, cServMsg);
        //给mcs开始放相的ack
        SendReplyBack(cServMsg, cServMsg.GetEventId() + 1);
    	break;
    case REC_MCU_STARTREC_ACK:
    case REC_MCU_STOPREC_ACK:
        {
			// 针对vrs收到开启ack后即可做状态切换，建交换
			if (bIsVrsRec)
			{
				TRecChnnlStatus tVrsChlStatus = m_ptMtTable->GetRecChnnlStatus(tVrsMt.GetMtId());
				if (tVrsChlStatus.m_byState == TRecChnnlStatus::STATE_RECREADY)
				{
					tVrsChlStatus.m_byState = TRecChnnlStatus::STATE_RECORDING;
					cServMsg.SetMsgBody((u8*)&tVrsChlStatus, sizeof(tVrsChlStatus));
					ProcRecMcuVrsRecChnnlStatusNotif(cServMsg);
				}
			}

			// 旧录像机有记录mcs的eventid和srcssnid，做后续回复处理，vrs不需要
			if (cServMsg.GetSrcSsnId() != 0)
			{
				// guzh [9/8/2006] 开始/停止录像成功，需要分析错误码
				SendReplyBack(cServMsg, cServMsg.GetEventId() + 1);

				u16 wError = cServMsg.GetErrorCode();
				if (wError != 0)
				{
					NotifyMcsAlarmInfo( cServMsg.GetSrcSsnId(), wError );
				}
			}
        }
        break;
    default:
        break;
    }


    return;
}

/*------------------------------------------------------------------*/
/*                                 BAS                              */
/*------------------------------------------------------------------*/

/*====================================================================
    函数名      : DaemonProBasChnnlStatusNotif
    功能        ：码流适配器通道状态通知
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/18    3.0         zmy           Create
	2010/07/19  4.6			周嘉麟		  重写
====================================================================*/
void CMcuVcInst::DaemonProBasChnnlStatusNotif(const CMessage *pcMsg)
{
	CServMsg cServMsg(pcMsg->content, pcMsg->length);
    u8 byChnIdx  = cServMsg.GetChnIndex();
	u8 byEqpId   = *(u8*)cServMsg.GetMsgBody();
	//CConfId cConfId = cServMsg.GetConfId();
	TBasChnStatus tChnStatus = *(TBasChnStatus*)(cServMsg.GetMsgBody() + sizeof(u8));
	
	TPeriEqpStatus tBasStatus;
    if (!g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tBasStatus))
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[DaemonProBasChnnlStatusNotif] GetPeriEqpStatus failed!\n");
        return;
    }

	//添加结点
	g_cMcuVcApp.AddMcuBasChnlInfo(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);

	//更新通道状态
// 	TBasChnStatus tOldStatus = tBasStatus.m_tStatus.tBas.tChnnl[byChnIdx];
//     BOOL32 bReserved = tOldStatus.IsReserved();
//     tBasStatus.m_tStatus.tBas.tChnnl[byChnIdx] = tChnStatus;
//     tBasStatus.m_tStatus.tBas.tChnnl[byChnIdx].SetReserved(bReserved);
// 	g_cMcuVcApp.SetPeriEqpStatus(byEqpId, &tBasStatus);
// 
//     ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[DaemonProBasChnnlStatusNotif]Bas--<EqpId:%d, ChnId:%d, ChnType:%d>\n", byEqpId, byChnIdx, tChnStatus.GetChannelType());
// 
// 	//通告界面 
//     cServMsg.SetMsgBody((u8 *)&tBasStatus, sizeof(tBasStatus));
    SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);

	//转发给所有会议
    if ( tChnStatus.GetStatus() == TBasChnStatus::READY )
    {
        g_cMcuVcApp.BroadcastToAllConf(pcMsg->event, pcMsg->content, pcMsg->length);
    }
	return;
	
	
// 	CServMsg cServMsg(pcMsg->content, pcMsg->length);
//     u8  byChnIdx;
//     u8  byEqpId;
//     u8 *pbyMsgBody;
//     TBasChnStatus *ptChnStatus;
//     TPeriEqpStatus tEqpStatus;
// 
//     pbyMsgBody  = (u8 *)cServMsg.GetMsgBody();
//     byEqpId     = *pbyMsgBody;
//     pbyMsgBody += sizeof(u8);
//     ptChnStatus = (TBasChnStatus*)pbyMsgBody;
// 
//     //save to periequipment status
//     if (!g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tEqpStatus))
//     {
//         return;
//     }
// 
//     // xsl [9/29/2006] reserved字段为mcu上层概念
//     BOOL32 bReserved = tEqpStatus.m_tStatus.tBas.tChnnl[byChnIdx].IsReserved();
//     tEqpStatus.m_tStatus.tBas.tChnnl[byChnIdx] = *ptChnStatus;
//     tEqpStatus.m_tStatus.tBas.tChnnl[byChnIdx].SetReserved(bReserved);
// 
//     ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[Bas ChanIdx.%d]GetChannelType() = %d\n", byChnIdx, ptChnStatus->GetChannelType());
// 
//     g_cMcuVcApp.SetPeriEqpStatus(byEqpId, &tEqpStatus);
// 
//     //analyze conference id and forward it to conference
//     cServMsg.SetMsgBody((u8 *)&tEqpStatus, sizeof(tEqpStatus));
//     SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);

//    return;
}

/*=============================================================================
 函 数 名： DaemonProcHDBasChnnlStatusNotif 
 功    能： 
 算法实现： 
 全局变量： 
 参    数： const CMessage * pcMsg
 返 回 值： void 
 ----------------------------------------------------------------------
 修改记录    ：
 日  期		版本		修改人		走读人    修改内容
 2008/8/8   4.0		    周广程                  创建
 2009/5/2   4.6		    张宝卿                  兼容mpu
=============================================================================*/
void CMcuVcInst::DaemonProcHDBasChnnlStatusNotif( const CMessage * pcMsg )
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
    
    //CConfId cConfId = cServMsg.GetConfId();
    u8  byChnIdx = cServMsg.GetChnIndex();
    u8  byChnType = *(u8*)cServMsg.GetMsgBody();;
    
    THDBasVidChnStatus tVidChnStatus;
    memset(&tVidChnStatus, 0, sizeof(tVidChnStatus));
    memcpy( &tVidChnStatus, cServMsg.GetMsgBody() + sizeof(u8), sizeof(THDBasVidChnStatus) );
    
    TBasBaseChnStatus tChnStatus = (TBasBaseChnStatus)tVidChnStatus;
    u8 byEqpId = tVidChnStatus.GetEqpId();
    u8 byStatus = tVidChnStatus.GetStatus();

	//如果外设上报状态是RUNNING，那么如果主控侧状态是waitstart就置成running，否则依旧使用原来状态
	if ( byStatus == TBasBaseChnStatus::RUNING )
	{
		if ( g_cMcuVcApp.GetBasChnStatus( tVidChnStatus.GetEqp(), tVidChnStatus.GetChnIdx() ) != BASCHN_STATE_WAITSTART  )
		{
			if ( g_cMcuVcApp.GetBasChnStatus( tVidChnStatus.GetEqp(), tVidChnStatus.GetChnIdx() ) == BASCHN_STATE_READY )
			{
				tVidChnStatus.SetStatus(TBasBaseChnStatus::READY );
			}
			else if ( g_cMcuVcApp.GetBasChnStatus( tVidChnStatus.GetEqp(), tVidChnStatus.GetChnIdx() ) == BASCHN_STATE_RUNNING )
			{
				tVidChnStatus.SetStatus(TBasBaseChnStatus::RUNING );
			}
			else 
			{
				tVidChnStatus.SetStatus(TBasBaseChnStatus::IDLE );
			}
		}
	}

    TPeriEqpStatus tEqpStatus;
	if ( !g_cMcuVcApp.GetPeriEqpStatus( byEqpId, &tEqpStatus ) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[DaemonProcHDBasChnnlStatusNotif] GetPeriEqpStatus failed byEqpId.%d!\n", byEqpId );
		return ;
	}
    
	//对于mpu2的通道，需要先保存通道类型,以便添加通道时进行区分设置
	if ( TYPE_MPU2_BASIC == tEqpStatus.m_tStatus.tHdBas.GetEqpType() ||
		 TYPE_MPU2_ENHANCED == tEqpStatus.m_tStatus.tHdBas.GetEqpType()
		)
	{
		tEqpStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnIdx)->SetType(byChnType);
		g_cMcuVcApp.SetPeriEqpStatus(byEqpId,&tEqpStatus);
	}

	g_cMcuVcApp.AddMcuBasChnlInfo(tVidChnStatus.GetEqp(), byChnIdx);

    switch (byChnType)
    {
    case HDBAS_CHNTYPE_MAU_MV:
        {
			if ( NULL == tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus(byChnIdx) )
			{
				break;
			}
            THDBasVidChnStatus tMVStatus = *tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus();
            BOOL32 bIsReserved = tMVStatus.IsReserved();
            BOOL32 bIsTmpReserved = tMVStatus.IsTempReserved();
            
            tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetVidChnStatus(tVidChnStatus);
            
            if ( bIsReserved )
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus()->SetIsReserved( TRUE );
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetVidChnStatus(tMVStatus);
            }
            else if ( bIsTmpReserved )
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus()->SetIsTempReserved( TRUE );
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetVidChnStatus(tMVStatus);
            }
            else
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus()->UnReserved();
            }
            g_cMcuVcApp.SetPeriEqpStatus( byEqpId, &tEqpStatus );
			g_cMcuVcApp.SendPeriEqpStatusToMcs(byEqpId);
        }
    	break;

    case HDBAS_CHNTYPE_MAU_DS:
        {
			if ( NULL == tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus(byChnIdx) )
			{
				break;
			}
            THDBasDVidChnStatus tDSStatus = *tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus();
            BOOL32 bIsReserved = tDSStatus.IsReserved();
            BOOL32 bIsTmpReserved = tDSStatus.IsTempReserved();
            
            tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetDVidChnStatus(tVidChnStatus);
            
            if ( bIsReserved )
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus()->SetIsReserved( TRUE );
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetDVidChnStatus(tDSStatus);
            }
            else if ( bIsTmpReserved )
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus()->SetIsTempReserved( TRUE );
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.SetDVidChnStatus(tDSStatus);
            }
            else
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetDVidChnStatus()->UnReserved();
            }
            g_cMcuVcApp.SetPeriEqpStatus( byEqpId, &tEqpStatus );
			g_cMcuVcApp.SendPeriEqpStatusToMcs(byEqpId);
        }
        break;

    case HDBAS_CHNTYPE_MPU:
        {
            if (byChnIdx >= MAXNUM_MPU_CHN)
            {
                break;
            }
				
			if ( NULL == tEqpStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnIdx) )
			{
				break;
			}

            THDBasVidChnStatus tMVStatus = *tEqpStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnIdx);
            BOOL32 bIsReserved = tMVStatus.IsReserved();
            BOOL32 bIsTmpReserved = tMVStatus.IsTempReserved();
            
            tEqpStatus.m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tVidChnStatus, byChnIdx);
            
            if ( bIsReserved )
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnIdx)->SetIsReserved( TRUE );
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tMVStatus, byChnIdx);
            }
            else if ( bIsTmpReserved )
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnIdx)->SetIsTempReserved( TRUE );
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMpuBas.SetVidChnStatus(tMVStatus, byChnIdx);
            }
            else
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus(byChnIdx)->UnReserved();
            }
            g_cMcuVcApp.SetPeriEqpStatus( byEqpId, &tEqpStatus );
			g_cMcuVcApp.SendPeriEqpStatusToMcs(byEqpId);
        }
        break;
	case MPU2_BAS_CHN_MV:
	case MPU2_BAS_CHN_DS:
	case MPU2_BAS_CHN_SEL:
		{
			if (byChnIdx >= MAXNUM_MPU2_EHANCED_CHN)
            {
                break;
            }

			if ( NULL == tEqpStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnIdx) )
			{
				break;
			}

            THDBasVidChnStatus tMVStatus = *tEqpStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnIdx);
            BOOL32 bIsReserved = tMVStatus.IsReserved();
            BOOL32 bIsTmpReserved = tMVStatus.IsTempReserved();
            
            tEqpStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.SetVidChnStatus(tVidChnStatus, byChnIdx);
            
            if ( bIsReserved )
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnIdx)->SetIsReserved( TRUE );
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.SetVidChnStatus(tMVStatus, byChnIdx);
            }
            else if ( bIsTmpReserved )
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnIdx)->SetIsTempReserved( TRUE );
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.SetVidChnStatus(tMVStatus, byChnIdx);
            }
            else
            {
                tEqpStatus.m_tStatus.tHdBas.tStatus.tMpu2Bas.GetVidChnStatus(byChnIdx)->UnReserved();
            }
            g_cMcuVcApp.SetPeriEqpStatus( byEqpId, &tEqpStatus );
			g_cMcuVcApp.SendPeriEqpStatusToMcs(byEqpId);
		}
		break;
    default:
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[DaemonProcHDBasChnnlStatusNotif] unexpected chnType.%d!\n", byChnType );
        break;
    }

    //转发给所有会议
    if ( tChnStatus.GetStatus() == TBasBaseChnStatus::READY )
    {
        g_cMcuVcApp.BroadcastToAllConf(pcMsg->event, pcMsg->content, pcMsg->length);
    }

    ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[DaemonProcHDBasChnnlStatusNotif] EqpId.%d, ChnIdx.%d, ChnType.%d, ChnStatus.%d\n" ,
             byEqpId, byChnIdx, byChnType, byStatus );
    return;
}

/*====================================================================
函数名      : DaemonProcAudBasChnnlStatusNotif
功能        ：码流适配器通道状态通知
算法实现    ：
引用全局变量：
输入参数说明：const CMessage * pcMsg, 传入的消息
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/05  4.7.2       倪志俊           创建
====================================================================*/
void CMcuVcInst::DaemonProcAudBasChnnlStatusNotif (const CMessage *pcMsg)
{
    CServMsg cServMsg(pcMsg->content,pcMsg->length);
    u8 byChnIdx  = cServMsg.GetChnIndex();
    u8 byChnType  = *(u8*)cServMsg.GetMsgBody();
    TAudBasChnStatus tAudChnStatus = *(TAudBasChnStatus*)(cServMsg.GetMsgBody() + sizeof(u8));
    u8 byEqpId = tAudChnStatus.GetEqpId();
	
	if ( byChnIdx >= MAXNUM_APU2_BASCHN )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[DaemonProcAudBasChnnlStatusNotif] byEqpId:%d byChnIdx:%d is wrong!\n",byEqpId, byChnIdx);
        return ;
	}

    if ( byChnType != TYPE_APU2_BAS )
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[DaemonProcAudBasChnnlStatusNotif] byChnType:%d is wrong!\n",byChnType);
        return ;
    }

	TPeriEqpStatus tCurEqpStatus;
	if ( !g_cMcuVcApp.GetPeriEqpStatus( byEqpId, &tCurEqpStatus ) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[DaemonProcAudBasChnnlStatusNotif] GetPeriEqpStatus failed byEqpId.%d!\n", byEqpId );
		return ;
	}

	if( g_cMcuVcApp.GetBasChnStatus( g_cMcuVcApp.GetEqp(byEqpId), byChnIdx ) != BASCHN_STATE_READY &&
		g_cMcuVcApp.GetBasChnStatus( g_cMcuVcApp.GetEqp(byEqpId), byChnIdx ) != BASCHN_STATE_INVALIED )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[DaemonProcAudBasChnnlStatusNotif] byEqpId.%d not in ready stat.%d!\n", byEqpId, 
			g_cMcuVcApp.GetBasChnStatus( g_cMcuVcApp.GetEqp(byEqpId), byChnIdx )
			);
		return;
	}
	
	if ( tAudChnStatus.GetStatus() == TBasBaseChnStatus::READY  )
	{
		BOOL32 bIsReserved = tCurEqpStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnIdx)->IsReserved();
		if ( !bIsReserved )
		{
			tCurEqpStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.SetAudChnStatus(tAudChnStatus,byChnIdx);
		}
		tCurEqpStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnIdx)->SetIsReserved(bIsReserved);
		tCurEqpStatus.m_tStatus.tAudBas.m_tAudBasStaus.m_tApu2BasChnStatus.GetAudChnStatus(byChnIdx)->SetStatus( TBasBaseChnStatus::READY );
		g_cMcuVcApp.SetPeriEqpStatus(byEqpId,&tCurEqpStatus);
	}

    //添加结点
    g_cMcuVcApp.AddMcuBasChnlInfo(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
	
    //界面更新下参数
    SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
    
    //转发给所有会议
    if ( tAudChnStatus.GetStatus() == TBasBaseChnStatus::READY )
    {
        g_cMcuVcApp.BroadcastToAllConf(pcMsg->event, pcMsg->content, pcMsg->length);
    }
    return;
}


/*=============================================================================
    函 数 名： DaemonProcHduMcuChnnlStatusNotif
    功    能： 
    算法实现： 
    全局变量： 
    参    数： const CMessage * pcMsg
    返 回 值： void 
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2009/1/13   4.6		    张宝卿                  创建
=============================================================================*/
void CMcuVcInst::DaemonProcHduMcuChnnlStatusNotif(const CMessage * pcMsg)
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);

    THduChnStatus * const ptChnnlStatus = (THduChnStatus *)cServMsg.GetMsgBody();

	if (ptChnnlStatus == NULL)
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[DaemonProcHduMcuChnnlStatusNotif]ptChnnlStatus == NULL,so return!\n");
		return;
	}
	const u8 bFirstNotif = *(u8*)(cServMsg.GetMsgBody() + sizeof(THduChnStatus));

	TEqp tEqp  = ptChnnlStatus->GetEqp();
	if(tEqp.GetEqpType() == 13 || //原定义，兼容老版本HDU版本卡#define EQP_TYPE_HDU_H 13
		tEqp.GetEqpType() == 14 || //原定义，兼容老版本HDU版本卡#define EQP_TYPE_HDU_L 14
		tEqp.GetEqpType() == 15 || //原定义，兼容老版本HDU版本卡#define EQP_TYPE_HDU2 15
		tEqp.GetEqpType() == 12)  //原定义，兼容老版本HDU版本卡#define EQP_TYPE_HDU2_L 12
	{
		tEqp.SetEqpType(EQP_TYPE_HDU);
		ptChnnlStatus->SetEqp(tEqp);
	}

    const u8 byChnnl = ptChnnlStatus->GetChnIdx();
	//2013/03/11 chenbing
	const u8 byHduSubChnId =  *(u8*)(cServMsg.GetMsgBody() + sizeof(THduChnStatus) + sizeof(u8));

	if (byChnnl  >= MAXNUM_HDU_CHANNEL)
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[DaemonProcHduMcuChnnlStatusNotif]byChnnl(%d) >= MAXNUM_HDU_CHANNEL(%d),so return!\n",
			byChnnl,MAXNUM_HDU_CHANNEL);
		return;
	}
    TPeriEqpStatus tHduStatus;
    if (!g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId(), &tHduStatus))
    {
		ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[DaemonProcHduMcuChnnlStatusNotif]:GetPeriEqpStatus failure!\n");
        return;
    }
	ptChnnlStatus->SetSchemeIdx(tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnnl].GetSchemeIdx());

	//[nizhijun 2010/10/28]HDU断线重连后，收到通道状态刷新的时间晚于MCU主控调度HDU状态，
	//故如果MCU主控侧状态已经是RUNNING状态，则改为RUNNING
// 	if (THduChnStatus::eRUNNING == tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnnl, byHduSubChnId))
// 	{
// 		ptChnnlStatus->SetStatus(THduChnStatus::eRUNNING);
// 	}

	if ( bFirstNotif )
	{
		//HDU第一次上线依Mcu默认设置的音量命令HDU改变音量
        u8 bOldMute = tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnnl].GetIsMute();
		u8 byOldVolume = tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnnl].GetVolume();

		// [2013/03/11 chenbing]  Mcu的状态不再获取Hdu上报的状态
// 		u8 byOldConfId = tHduStatus.m_tStatus.tHdu.GetConfIdx(byChnnl, byHduSubChnId);
// 		u8 byHduStatus = tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnnl, byHduSubChnId);
// 		memcpy((void*)&tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnnl], (void*)ptChnnlStatus, sizeof(THduChnStatus));
// 		tHduStatus.m_tStatus.tHdu.SetConfIdx(byOldConfId, byChnnl, byHduSubChnId);
// 		tHduStatus.m_tStatus.tHdu.SetChnStatus(byChnnl, byHduSubChnId, byHduStatus);
// 	    tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnnl].SetIsMute( bOldMute );
// 		tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnnl].SetVolume( byOldVolume );

		THduVolumeInfo tHduVolumeInfo;
		tHduVolumeInfo.SetIsMute( bOldMute );
		tHduVolumeInfo.SetVolume( byOldVolume );
		tHduVolumeInfo.SetChnlIdx( byChnnl );
		cServMsg.SetMsgBody( (u8*)&tHduVolumeInfo, sizeof(tHduVolumeInfo) );
		SendMsgToEqp( tEqp.GetEqpId(), MCU_HDU_CHANGEVOLUME_CMD, cServMsg );
	}
	else
	{
		// [2013/03/11 chenbing]  Mcu的状态不再获取Hdu上报的状态
// 		u8 byOldConfId = tHduStatus.m_tStatus.tHdu.GetConfIdx(byChnnl, byHduSubChnId);
// 		u8 byHduStatus = tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnnl, byHduSubChnId);
//		memcpy((void*)&tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnnl], (void*)ptChnnlStatus, sizeof(THduChnStatus));
		//只保存外设改变的静音状态或音量状态,Mcu的状态不能依赖HDU上报的状态改变
		tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnnl].SetIsMute( ptChnnlStatus->GetIsMute() );
 		tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnnl].SetVolume( ptChnnlStatus->GetVolume() );
	}

	g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tHduStatus);
	g_cMcuVcApp.BroadcastToAllConf( pcMsg->event, pcMsg->content, pcMsg->length );

	// [7/12/2011 liuxu] 通知会控hdu通道状态
	cServMsg.SetMsgBody((u8*)&tHduStatus, sizeof(TPeriEqpStatus));
	SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);

    return;
}

/*====================================================================
    函数名      ：ProcBasMcuRsp
    功能        ：码率适配器开始适配应答处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
   2010-06-30   4.6         周嘉麟		   创建
====================================================================*/
//modify bas 2
void CMcuVcInst::ProcBasMcuRsp(const CMessage *pcMsg)
{
	CServMsg cServMsg(pcMsg->content, pcMsg->length);
	cServMsg.SetEventId( pcMsg->event );
	u8 byChnId = cServMsg.GetChnIndex();
    TEqp tEqp  = *(TEqp *)cServMsg.GetMsgBody();
	
	u8 byGrpType = GetBasGrpType(tEqp, byChnId);
	if (0 == byGrpType)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasMcuRsp] GetGrpType failed!\n");
		return;
	}
	
	switch (byGrpType)
	{
	case CHN_ADPMODE_BRD:
		ProBasMcuBrdAdpRsp(cServMsg);
		break;
	case CHN_ADPMODE_SEL:
		ProBasMcuSelAdpRsp(cServMsg);
		break;
	default:
		break;
	}
	return;
}

/*=============================================================================
函 数 名： ProBasMcuBrdAdpRsp
功    能： 
算法实现： 
全局变量： 
参    数： const CMessage * pcMsg
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		  版本		修改人		走读人    修改内容
2010/07/13    4.6		周嘉麟                  创建
=============================================================================*/
void CMcuVcInst::ProBasMcuBrdAdpRsp(CServMsg &cServMsg)
{
	u8 byChnId = cServMsg.GetChnIndex();
    TEqp tEqp  = *(TEqp *)cServMsg.GetMsgBody();
	tEqp.SetConfIdx(m_byConfIdx);
	
	//取消定时器
	u32 dwTimerId = MCUVC_WAITHDVIDBASRSP_TIMER + GetBasPosition(tEqp, byChnId);
	KillTimer(dwTimerId);
	
	switch (cServMsg.GetEventId())
	{
	case BAS_MCU_STARTADAPT_ACK:
	case HDBAS_MCU_STARTADAPT_ACK:
	case BAS_MCU_CHANGEAUDPARAM_ACK:
		{
			if ( g_cMcuVcApp.GetBasChnStatus(tEqp, byChnId) == BASCHN_STATE_WAITSTART )
			{
				g_cMcuVcApp.UpdateBasChnStatus(tEqp, byChnId, BASCHN_STATE_RUNNING);
				StartBasSwitch(tEqp, byChnId);
			}
			else if ( cServMsg.GetEventId() == BAS_MCU_CHANGEAUDPARAM_ACK &&
				      g_cMcuVcApp.GetBasChnStatus(tEqp, byChnId) == BASCHN_STATE_RUNNING 
					  )
			{
				ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[ProBasMcuBrdAdpRsp]rcv BAS_MCU_CHANGEAUDPARAM_ACK\n");
				StartBasSwitch(tEqp, byChnId);
			}
			else
			{	
				ConfPrint(LOG_LVL_WARNING,MID_MCU_BAS,"[ProBasMcuBrdAdpRsp]tEqp:%d,byChnId:%d status:%d is error!\n",
						  tEqp.GetEqpId(), byChnId,g_cMcuVcApp.GetBasChnStatus(tEqp, byChnId)
						  );
			}
		}
		break;
	case BAS_MCU_STARTADAPT_NACK:
	case HDBAS_MCU_STARTADAPT_NACK:
	case BAS_MCU_CHANGEAUDPARAM_NACK:
		{
			StopBasAdapt(tEqp, byChnId);
		}
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProBasMcuBrdAdpRsp] unexpected Message!\n");
		break;
	}
	return;
}

/*=============================================================================
函 数 名： ProBasMcuSelAdpRsp
功    能： 
算法实现： 
全局变量： 
参    数： const CMessage * pcMsg
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		  版本		修改人		走读人    修改内容
2010/07/13    4.0		周嘉麟                  创建
=============================================================================*/
void CMcuVcInst::ProBasMcuSelAdpRsp(CServMsg &cServMsg)
{
	u8 byChnId = cServMsg.GetChnIndex();
    TEqp tEqp  = *(TEqp *)cServMsg.GetMsgBody();
	tEqp.SetConfIdx(m_byConfIdx);
	
	//取消定时器
	u32 dwTimerId = MCUVC_WAITHDVIDBASRSP_TIMER + GetBasPosition(tEqp, byChnId);
	KillTimer(dwTimerId);

	switch (cServMsg.GetEventId())
	{
	case BAS_MCU_STARTADAPT_ACK:
	case HDBAS_MCU_STARTADAPT_ACK:
	case BAS_MCU_CHANGEAUDPARAM_ACK:
		{
			g_cMcuVcApp.UpdateBasChnStatus(tEqp, byChnId, BASCHN_STATE_RUNNING);
			TMt tSrc = GetBasChnSrc(tEqp, byChnId);
			if(tSrc.IsNull())
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProBasMcuSelAdpRsp]GetChnSrc failed!\n");
				return;
			}
			u8 byMediaMode = GetBasChnMode(tEqp, byChnId);
			if (MODE_NONE == byMediaMode || MODE_BOTH == byMediaMode)
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProBasMcuSelAdpRsp] unexpected byMediaMode:%d!\n", byMediaMode);
				return;
			}
			
			CSendSpy   tSpySnd;
			CRecvSpy   tSpyRcv;
			TSimCapSet tSrcCap;
			TSimCapSet tDstCap;
			TMtStatus  tMtStatus;
			u16        wSpyPort = SPY_CHANNL_NULL;
			u16        wSrcChnnl = 0;		
			TBasOutInfo	tOutInfo;

			//如果适配器的源时回传源，则从回传端口建交换到适配器
			u8 bySrcMtId = GetLocalMtFromOtherMcuMt(tSrc).GetMtId();
			tSrcCap = m_ptMtTable->GetSrcSCS(bySrcMtId);
			if( m_cSMcuSpyMana.GetRecvSpy( tSrc, tSpyRcv ) )
			{
				wSrcChnnl = tSpyRcv.m_tSpyAddr.GetPort();
				tSrcCap   = tSpyRcv.GetSimCapset();
			}	
			
			// [10/29/2010 liuxu][add] 放像时源端口为放像通道	
			if (tSrc == m_tPlayEqp)
			{
				wSrcChnnl = m_byPlayChnnl;
			}// over
	
			//[2011/07/07/zhangli] 放到这里，选看都录像都要支持prs
			StartBasPrsSupport(tEqp, byChnId);

			// [10/29/2010 liuxu][add] 自定义录像时建立从bas到录像机的交换
			if ( IsBasChnForRecAdapt( tEqp, byChnId ) )
			{
				switch (byMediaMode)
				{
// 				case MODE_AUDIO:
// 					{
// 						tSrc = GetAudBrdSrc();
// 						SetBasChnSrc( tEqp, byChnId, tSrc );
// 						TAudioTypeDesc tTempAudCap;
// 						m_cRecAdaptMgr.GetRecAudCapSet(tTempAudCap );
// 						
// 						if (!FindBasChnByAudCapForSel(tSrc, tTempAudCap, tOutInfo))
// 						{
// 							ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[ProBasMcuSelAdpRsp]FindBasChnByAudCapForSel failed, please check it\n");
// 							return;
// 						}
// 					}
// 					break;
				case MODE_VIDEO:
				case MODE_SECVIDEO:
					{
						if ( MODE_SECVIDEO == byMediaMode )
						{
							tSrc = m_tDoubleStreamSrc;
							SetBasChnSrc( tEqp, byChnId, tSrc );
						}
						else
						{
							tSrc = GetVidBrdSrc();
							SetBasChnSrc( tEqp, byChnId, tSrc );
						}

						//[nizhijun 2012/06/29] 录像机适配录像，如果源是VMP，不走BAS，直接收VMP的相关码流。
						//[nizhijun 2012/06/29] 这里加一段校验，目前如果广播源是VMP，录像机直接接受VMP的码流,如果这里源是VMP，那么就是出错了
						if ( MODE_VIDEO == byMediaMode && g_cMcuVcApp.IsBrdstVMP(m_tVmpEqp) && tSrc == m_tVmpEqp)
						{
							ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[ProBasMcuSelAdpRsp]recadapt error:because bas's tSrc is vmp!\n");
							return;
						}

						TVideoStreamCap tTempVidCap;
						m_cRecAdaptMgr.GetRecVideoCapSet( byMediaMode, tTempVidCap );		
						if (!FindBasChnByVidCapForSel(tSrc, tTempVidCap, byMediaMode, tOutInfo))
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[ProBasMcuSelAdpRsp]FindBasChnByVidCapForSel failed, please check it\n");
							
							return;
						}
					}
					break;
				default:
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[ProBasMcuSelAdpRsp]mode:%d is error\n", byMediaMode);
						return;
					}
				}

				// 建立从发言人到适配器的交换
				//[2011/08/12/zhangli]建到eqp的RTP交换都调用vc层的接口，这样能够设置eqp的src
				StartSwitchToPeriEqp(tSrc, wSrcChnnl, tEqp.GetEqpId(), byChnId, byMediaMode, SWITCH_MODE_BROADCAST, TRUE, TRUE, FALSE, FALSE);
				
				// 建立从适配器到录像机的交换
				StartSwitchToPeriEqp(tEqp, tOutInfo.m_byFrontOutNum +  tOutInfo.m_byOutIdx, 
					m_tRecEqp.GetEqpId(), m_byRecChnnl, byMediaMode, SWITCH_MODE_SELECT, FALSE, TRUE);
				
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_REC, 
					"Start AdatpRec Switch from Bas[Eqp.%d, Chnnl.%d(byTempFrontOutNum.%d + byOutIdx.%d)] To Rec\n", 
					tEqp.GetEqpId(), 
					byChnId,
					tOutInfo.m_byFrontOutNum,
					tOutInfo.m_byOutIdx);

				return;
			}
			else
			{
				StartSwitchToPeriEqp(tSrc, wSrcChnnl, tEqp.GetEqpId(), byChnId, byMediaMode, SWITCH_MODE_SELECT, FALSE, TRUE, FALSE, FALSE);
			}
			// [10/29/2010 liuxu] Add over

			u8 byOtherMode = MODE_NONE;
			if (MODE_VIDEO == byMediaMode)
			{
				byOtherMode = MODE_VIDEO2SECOND;
			}

			for (u8 byMtId = 1; byMtId < MAXNUM_CONF_MT; byMtId++)
			{
				if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
				{
					continue;
				}
				if (bySrcMtId == byMtId)
				{
					continue;
				}
				
				TBasOutInfo	tSpyOutInfo;
				tMtStatus.SetNull();
				//建交换到上级回传端口
				if (IsSupportMultiSpy() && m_ptMtTable->GetMt(byMtId) == m_tCascadeMMCU &&
					m_cLocalSpyMana.GetSpyChannlInfo( tSrc, tSpySnd ))
				{
					wSpyPort = tSpySnd.m_tSpyAddr.GetPort();
					tDstCap  = tSpySnd.GetSimCapset();
					if (!IsNeedSpyAdpt(tSrc, tDstCap, byMediaMode))
					{
						continue;
					}
					if(!FindBasChn2SpyForMt(tSrc, tDstCap, byMediaMode, tSpyOutInfo))
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[FindBasChn2SpyForMt] FindBasChn2SelFor SpyPort failed!\n");
						continue;
					}
					if (tSpyOutInfo.m_tBasEqp.GetEqpId() != tEqp.GetEqpId() || tSpyOutInfo.m_byChnId != byChnId)
					{
						continue;
					}
					tSpyOutInfo.m_tBasEqp.SetConfIdx(m_byConfIdx);
					g_cMpManager.StartSwitchToMmcu(tSpyOutInfo.m_tBasEqp, tSpyOutInfo.m_byFrontOutNum + tSpyOutInfo.m_byOutIdx, m_tCascadeMMCU, byMediaMode, 
													SWITCH_MODE_SELECT, FALSE, TRUE, FALSE, wSpyPort);	
				}
				else
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[FindBasChn2SelForMt] tSrc:%d-%d is not in m_cLocalSpyMana!\n", tSrc.GetMcuId(), tSrc.GetMcuId());
					if (m_ptMtTable->GetMtSelMtByMode(byMtId, byMediaMode) == tSrc)
					{
						if (!IsNeedSelAdpt(tSrc, m_ptMtTable->GetMt(byMtId), byMediaMode))
						{
							continue;
						}
						if(!FindBasChn2SelForMt(tSrc, m_ptMtTable->GetMt(byMtId), byMediaMode, tOutInfo))
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[FindBasChn2SelForMt] FindBasChn2SelForMt%d failed!\n", byMtId);
							continue;
						}
						if (tOutInfo.m_tBasEqp.GetEqpId() != tEqp.GetEqpId() || tOutInfo.m_byChnId != byChnId)
						{
							continue;
						}
						
						if (m_ptMtTable->GetMt(byMtId) == m_tCascadeMMCU)
						{
							g_cMpManager.StartSwitchToMmcu(tEqp, tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx, m_tCascadeMMCU, byMediaMode, 
								SWITCH_MODE_SELECT, FALSE, TRUE, FALSE);						
						}
						else
						{
							TSwitchGrp tSwitchGrp;
							tSwitchGrp.SetSrcChnl(tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx);
							tSwitchGrp.SetDstMtNum(1);
							TMt tMt = m_ptMtTable->GetMt(byMtId);
							tSwitchGrp.SetDstMt(&tMt);
							g_cMpManager.StartSwitchToAll(tEqp, 1, &tSwitchGrp, byMediaMode, SWITCH_MODE_SELECT);
						}							
					}	

					if (MODE_NONE != byOtherMode && m_ptMtTable->GetMtSelMtByMode(byMtId, byOtherMode) == tSrc)
					{						
						if (!IsNeedSelAdpt(tSrc, m_ptMtTable->GetMt(byMtId), byOtherMode))
						{
							continue;
						}
						if(!FindBasChn2SelForMt(tSrc, m_ptMtTable->GetMt(byMtId), byOtherMode, tOutInfo))
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[FindBasChn2SelForMt] FindBasChn2SelForMt%d failed!\n", byMtId);
							continue;
						}
						if (tOutInfo.m_tBasEqp.GetEqpId() != tEqp.GetEqpId() || tOutInfo.m_byChnId != byChnId)
						{
							continue;
						}
						
						if (m_ptMtTable->GetMt(byMtId) == m_tCascadeMMCU)
						{
							//级联暂时不处理
						}
						else
						{
							TSwitchGrp tSwitchGrp;
							tSwitchGrp.SetSrcChnl(tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx);
							tSwitchGrp.SetDstMtNum(1);
							TMt tMt = m_ptMtTable->GetMt(byMtId);
							tSwitchGrp.SetDstMt(&tMt);
							g_cMpManager.StartSwitchToAll(tEqp, 1, &tSwitchGrp, byOtherMode, SWITCH_MODE_SELECT);
						}							
					}
				}
			}
		}
		break;
	case BAS_MCU_STARTADAPT_NACK:
	case HDBAS_MCU_STARTADAPT_NACK:
	case BAS_MCU_CHANGEAUDPARAM_NACK:
		{
			// [10/29/2010 liuxu][add] 自定义录像时建立从bas到录像机的交换
			if ( IsBasChnForRecAdapt(tEqp,byChnId) )
			{
				u8 byMediaMode = GetBasChnMode(tEqp, byChnId);
				// 重置自定义录像相关参数,并终止适配, 停止交换和释放Bas资源
				ConfPrint(LOG_LVL_ERROR, MID_MCU_REC, "[Warning]Start Rec mode:%d ,Bas:%d-%d  Adapt Nacked, please Check\n",byMediaMode, tEqp.GetEqpId(), byChnId );
				ResetRecAdptParam(byMediaMode);
			}
			else
			{
				g_cMcuVcApp.UpdateBasChnStatus(tEqp, byChnId, BASCHN_STATE_READY);
				g_cMcuVcApp.ReleaseBasChn(tEqp, byChnId);
				ReMoveBasSelChn(tEqp, byChnId);
			}
		}
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProBasMcuSelAdpRsp] unexpected Message!\n");
		break;
	}
	return;
}
/*====================================================================
    函数名      ：ProcMcuBasConnectedNotif
    功能        ：码率适配登记处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/26    1.0         LI Yi         创建
====================================================================*/
/*
void CMcuVcInst::ProcMcuBasConnectedNotif(const CMessage * pcMsg)
{
//     CServMsg cServMsg(pcMsg->content, pcMsg->length);
//     TPeriEqpRegReq tEqp = *(TPeriEqpRegReq *)cServMsg.GetMsgBody();
// 
//     switch(CurState())
//     {
//     case STATE_ONGOING:
// 
//         if (EQP_TYPE_BAS == tEqp.GetEqpType() && m_tConf.GetConfAttrb().IsUseAdapter())
//         {
//             u16 wAdaptBitRate = 0;
//             TSimCapSet tSrcSimCapSet;
//             TSimCapSet tDstSimCapSet;
// 
//             if (!IsVidBrdSrcNull())
//             {
//                 //标清恢复先，高清稍后
//                 if ( IsHDConf( m_tConf ) )
//                 {
//                 }
//                 else
//                 {
//                     if (tEqp == m_tVidBasEqp && !m_tConf.m_tStatus.IsVidAdapting() &&
//                         IsNeedVidAdapt(tDstSimCapSet, tSrcSimCapSet, wAdaptBitRate))
//                     {
//                         StartAdapt(ADAPT_TYPE_VID, wAdaptBitRate, &tDstSimCapSet, &tSrcSimCapSet);
//                     }
//                     else if(tEqp == m_tVidBasEqp && !m_tConf.m_tStatus.IsVidAdapting()
//                         && IsNeedCifAdp() )
//                     {
//                         IsNeedVidAdapt(tDstSimCapSet, tSrcSimCapSet, wAdaptBitRate);
//                         StartAdapt(ADAPT_TYPE_VID, wAdaptBitRate, &tDstSimCapSet, &tSrcSimCapSet);
//                     }
// 
//                     if (tEqp == m_tBrBasEqp && !m_tConf.m_tStatus.IsBrAdapting() &&
//                         IsNeedBrAdapt(tDstSimCapSet, tSrcSimCapSet, wAdaptBitRate))
//                     {
//                         StartAdapt(ADAPT_TYPE_BR, wAdaptBitRate, &tDstSimCapSet, &tSrcSimCapSet);	
//                     }
//                 
//                     //zbq[04/08/2008] BAS重连上来，尝试恢复视频相关交换：彻底重刷一次. 下同.
//                     if ( (tEqp == m_tVidBasEqp &&
//                           (IsNeedCifAdp() ||
//                            IsNeedVidAdapt(tDstSimCapSet, tSrcSimCapSet, wAdaptBitRate)))
//                          ||
//                          (tEqp == m_tBrBasEqp &&
//                           IsNeedBrAdapt(tDstSimCapSet, tSrcSimCapSet, wAdaptBitRate)) )
//                     {
//                         TMt tVidSrc = GetLocalVidBrdSrc();
//                         ChangeVidBrdSrc(&tVidSrc);
//                     }
//                 }
//             }
// 
//             if (!IsAudBrdSrcNull())
//             {
//                 if (tEqp == m_tAudBasEqp && !m_tConf.m_tStatus.IsAudAdapting() &&
//                     IsNeedAudAdapt(tDstSimCapSet, tSrcSimCapSet))
//                 {
//                     StartAdapt(ADAPT_TYPE_AUD, 0, &tDstSimCapSet, &tSrcSimCapSet);
// 
//                     //zbq[04/08/2008] BAS重连上来，尝试恢复音频相关交换
//                     TMt tAudSrc = GetLocalAudBrdSrc();
//                     ChangeAudBrdSrc(&tAudSrc);
//                 }
//             }
//         }
//         break;
// 
//     default:
//         ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
//                 pcMsg->event, ::OspEventDesc(pcMsg->event), CurState());
//         break;
//     }
}*/

/*====================================================================
    函数名      ：ProcMcuBasDisconnectedNotif
    功能        ：码率适配断链处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/06/27    1.0         LI Yi         创建
====================================================================*/
void CMcuVcInst::ProcMcuBasDisconnectedNotif(const CMessage * pcMsg)
{
	CServMsg cServMsg(pcMsg->content, pcMsg->length);
	TEqp tDiscEqp = *(TEqp *)cServMsg.GetMsgBody();

	//判断该会议上的BAS通道是否有在这块掉线的BAS上,不存在了就不处理
	if ( !IsExistChnOnEqp(tDiscEqp) )
	{
		ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[ProcMcuBasDisconnectedNotif]eqp:%d chns is not exist\n",tDiscEqp.GetEqpId());
		return ;
	}
	
	TEqp atEqpArray[2];
	atEqpArray[0] = tDiscEqp;
	u8 byEqpNum = 1;

	//判断是ECARD板卡配置成两块basic模式，这样的话需要特殊处理，直接拿另外一块外设一起备份
	TEqp tSecEqp;
	u8 byBrdid =0;
	if ( BRD_TYPE_MPU2ECARD == g_cMcuAgent.GetMPU2TypeByEqpId(tDiscEqp.GetEqpId(),byBrdid) )
	{
		u8 byOtherEqpId = 0;
		if ( g_cMcuAgent.GetMpu2AnotherEqpId(tDiscEqp.GetEqpId(),byOtherEqpId) )
		{
			tSecEqp = tDiscEqp;
			tSecEqp.SetEqpId(byOtherEqpId);
			if ( IsExistChnOnEqp(tSecEqp) )
			{
				atEqpArray[1] = tSecEqp;
				byEqpNum++;
			}
		}
	}

	switch(CurState())
	{
	case STATE_ONGOING:
		{
			u8 abyRecMode[2]={0};
			for ( u8 byLoop = 0; byLoop<byEqpNum; byLoop++ )
			{
				//适配器掉链只停交换，不停适配器，不改变当前适配状态，待外设重新上线后判断其适配状态如果是正在适配则直接启动适配器
				if (m_tConf.GetConfAttrb().IsUseAdapter())
				{						
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "BAS %u disconnected message received in conference %s!\n", 
						atEqpArray[byLoop].GetEqpId(), m_tConf.GetConfName());

					u8 byChnNum = g_cMcuVcApp.GetBasInPutChnNum(atEqpArray[byLoop]);
					u8 byChnIdx = 0;
					//BOOL32 bIsStopedSwitch = FALSE;
					for (byChnIdx = 0; byChnIdx < byChnNum; byChnIdx++)
					{			
						ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,"[ProcMcuBasDisconnectedNotif] stop bas:%d 's switch,ChnId is: %d\n",atEqpArray[byLoop].GetEqpId(),byChnIdx);
						u8 byChnType = GetBasGrpType(atEqpArray[byLoop], byChnIdx);
						switch (byChnType)
						{
						case CHN_ADPMODE_BRD:
							{
								//1.停止掉链的适配通道交换
								atEqpArray[byLoop].SetConfIdx(m_byConfIdx);
								//广播源不为VMP，才需要停BAS相关交换
								if ( !GetVidBrdSrc().IsNull()  &&
									!(GetVidBrdSrc()== m_tVmpEqp)
									)
								{
									if (!StopBasSwitch(atEqpArray[byLoop], byChnIdx))
									{
										ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,"[ProcMcuBasDisconnectedNotif] StopBasSwitch Failed,BasID is:%d,ChnId is:%d\n",atEqpArray[byLoop].GetEqpId(),byChnIdx);	
									}	
								}
									

								//[2011/07/04/zhangli]添加会议支持prs的限制
								TConfAttrb tAttrb = m_tConf.GetConfAttrb();
								if (tAttrb.IsResendLosePack())
								{
									//[nizhijun 2010/12/17] BAS掉线时 停止prs 到 bas的rtcp 与rtp 交换
									u8	byOutNum = 0;
									u8  byPrsId =  0;
									u8  byPrsChnlId = 0;
									u8  byMode = GetBasChnMode(atEqpArray[byLoop], byChnIdx);

									u8 byFrontOutNum = 0;
									if ( !GetBasChnOutputNum(atEqpArray[byLoop],byChnIdx,byOutNum,byFrontOutNum) )
									{
										ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[ProcMcuBasDisconnectedNotif] GetBasChnOutputNum:%d-%d failed!\n",
												 atEqpArray[byLoop].GetEqpId(),byChnIdx
												 );
										return ;
									}
									
									for(u8 byOutChnl = 0; byOutChnl < byOutNum; byOutChnl++)
									{
										if (FindPrsChnForSrc(atEqpArray[byLoop], byFrontOutNum + byOutChnl, byMode,
											byPrsId, byPrsChnlId))
										{
											StopPrs(byPrsId, byPrsChnlId,byMode);
											RlsPrsChnl(byPrsId, byPrsChnlId);				
										}
									}
									//[nizhijun 2010/12/17]ends
								}

								g_cMcuVcApp.UpdateBasChnStatus(atEqpArray[byLoop], byChnIdx, BASCHN_STATE_READY);
								
								atEqpArray[byLoop].SetConfIdx(0);//临时处理
							}						
							break;
						case CHN_ADPMODE_SEL:
							{
								u8 byChnMode = GetBasChnMode(atEqpArray[byLoop], byChnIdx);
								//适配录像的通道
								if ( IsBasChnForRecAdapt( atEqpArray[byLoop], byChnIdx ) )
								{
									if ( MODE_VIDEO == byChnMode )
									{
										abyRecMode[0]=MODE_VIDEO;
									}
									else if ( MODE_SECVIDEO == byChnMode )
									{
										abyRecMode[1]=MODE_SECVIDEO;
									}
// 									else if ( MODE_AUDIO == byChnMode )
// 									{
// 										abyRecMode[2]=MODE_AUDIO;
// 									}
		
									StopBasAdaptOnlyForRecAdp(atEqpArray[byLoop],byChnIdx);
									ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[ProcMcuBasDisconnectedNotif]adp rec StopBas:%d-%d\n",atEqpArray[byLoop].GetEqpId(),byChnIdx);
								}
								//普通通道
								else
								{	
									TMt tSrc = GetBasChnSrc(atEqpArray[byLoop], byChnIdx);
									if (byChnMode == MODE_NONE || tSrc.IsNull())
									{
										break;
									}
									
									TBasOutInfo tOutInfo;
									TMtStatus tDstStatus;
									for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
									{
										if (!m_tConfAllMtInfo.MtJoinedConf(byMtId))
										{
											continue;
										}
										if (byMtId == tSrc.GetMtId())
										{
											continue;
										}
										tDstStatus.SetNull();
										m_ptMtTable->GetMtStatus(byMtId, &tDstStatus);
										TMt tMt = m_ptMtTable->GetMt(byMtId);
										if (tDstStatus.GetSelectMt(byChnMode) == tSrc && 
											IsNeedAdapt(tSrc, tMt, byChnMode) &&
											FindBasChn2SelForMt(tSrc, tMt, byChnMode, tOutInfo))
										{
											StopSelAdapt(tSrc, m_ptMtTable->GetMt(byMtId), byChnMode);
											NotifyMtReceive(m_ptMtTable->GetMt(byMtId), byMtId);
											MtStatusChange(&tMt, TRUE);
											if ( !tSrc.IsLocal() )
											{
												FreeRecvSpy(tSrc,byChnMode);
											}
											
											//恢复终端看广播视频源
											StartSwitchFromBrd(GetVidBrdSrc(),0,1,&tMt);
											ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[ProcMcuBasDisconnectedNotif]restore mt:%d-%d recv brd:%d-%d\n",
												tMt.GetMcuId(), tMt.GetMtId(), GetVidBrdSrc().GetMcuId(), GetVidBrdSrc().GetMtId()
												);
											
										}
									}
								}
							
								g_cMcuVcApp.UpdateBasChnStatus(atEqpArray[byLoop], byChnIdx, BASCHN_STATE_READY);
							}
							break;
						default:
							break;
						}	
					}
				}	
			}

			//2.寻找合适的适配通道	
			CBasChn *apcRplBasChn[MAXNUM_PERIEQP] ={NULL};
			TBasChnCapData atBasChnParam[MAXNUM_PERIEQP];
			if(FindBasChnForReplace(atEqpArray, byEqpNum, apcRplBasChn,atBasChnParam))
			{
				TMt tRealSrc;
				u8 byRecChnlIdx = 0;
				u8 byBasChnId = 0;
				if( IsRecNeedAdapt(MODE_AUDIO) &&
					IsRecordSrcBas(MODE_AUDIO, tRealSrc, byBasChnId, byRecChnlIdx)
				   )
				{
					TRecBasChn tRecBasChn;
					tRecBasChn.m_tBas = tRealSrc;
					tRecBasChn.m_byChnId = byBasChnId;
					m_cRecAdaptMgr.AddRecBasChn(MODE_AUDIO,tRecBasChn);
				}

				u8 byChnIdx = 0;
				for (byChnIdx = 0; byChnIdx < MAXNUM_PERIEQP; byChnIdx++)
				{
					if ( NULL == apcRplBasChn[byChnIdx] )
					{
						continue;
					}
					
					if (apcRplBasChn[byChnIdx]->GetBas().IsNull())
					{
						continue;
					}
					ChangeAdapt(apcRplBasChn[byChnIdx]->GetBas(), apcRplBasChn[byChnIdx]->GetChnId());
				}

				//[2011/07/04/zhangli]支持唇音同步备份
				if (!m_tConf.GetConfAttrb().IsSatDCastMode() && !m_tConf.m_tStatus.IsMixing() && g_cMcuVcApp.IsVASimultaneous())
				{
					TMt tUnLocalAudSrc = GetAudBrdSrc();
					if(tUnLocalAudSrc.IsNull())
					{
						return;
					}
					
					if (!(tUnLocalAudSrc == GetVidBrdSrc()))
					{
						return;
					}
					
					//交换到bas
					StartSwitchAud2Perieqp(tUnLocalAudSrc);
					
					//交换到个终端
					u8 bySrcChnnl = (tUnLocalAudSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;
					u16 wSpyStartPort = SPY_CHANNL_NULL;
					CRecvSpy tSpyResource; 
					if( m_cSMcuSpyMana.GetRecvSpy(tUnLocalAudSrc, tSpyResource))
					{
						wSpyStartPort = tSpyResource.m_tSpyAddr.GetPort();
					}
					StartSwitchToAllSubMtJoinedConf(tUnLocalAudSrc, bySrcChnnl, wSpyStartPort);
				}
			}	
			else
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcMcuBasDisconnectedNotif] FindBasChnForReplace byEqpNum:%d BasA<EqpId:%d> BasB<EqpId:%d> failed!\n", 
					byEqpNum,atEqpArray[0].GetEqpId(), atEqpArray[1].GetEqpId());
			}
			
			for ( u8 byIdx=0 ; byIdx <2; byIdx++ )
			{
				if ( abyRecMode[byIdx] != 0 && 
					FindBasChnForRecAptReplace( abyRecMode[byIdx]  )
					)
				{
					AdjustConfRecordSrcStream(abyRecMode[byIdx],TRUE);
					ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[ProcMcuBasDisconnectedNotif]AdjustConfRecordSrcStream for rec adapt mode:%d\n",abyRecMode[byIdx]);
				}
			}
		 }
		break;
    default:
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc(pcMsg->event), CurState());
        break;
    }
	return;
}

/*====================================================================
    函数名      : ProcBasStartupTimeout
    功能        ：启动码率适配应答超时消息处理函数
    输入        ：
    返回 ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/11/24    3.0         zmy           Create
====================================================================*/
//modify bas 2
// void CMcuVcInst::ProcBasStartupTimeout(const CMessage *pcMsg)
// {
// //     TPeriEqpStatus tStatus;
// //     u8 byAdaptType = *(u8 *)pcMsg->content;
// // 
// //     u8 byBasChnnl = EQP_CHANNO_INVALID;
// //     TEqp *ptBasEqp = NULL;
// // 
// //     switch(byAdaptType)
// //     {
// //     case ADAPT_TYPE_AUD:
// //         byBasChnnl = m_byAudBasChnnl;
// //         ptBasEqp = &m_tAudBasEqp;
// //     	break;
// // 
// //     case ADAPT_TYPE_VID:
// //         byBasChnnl = m_byVidBasChnnl;
// //         ptBasEqp = &m_tVidBasEqp;
// //     	break;
// // 
// //     case ADAPT_TYPE_BR:
// //         byBasChnnl = m_byBrBasChnnl;
// //         ptBasEqp = &m_tBrBasEqp;
// //         break;
// // 
// //     case ADAPT_TYPE_CASDAUD:
// //         byBasChnnl = m_byCasdAudBasChnnl;
// //         ptBasEqp = &m_tCasdAudBasEqp;
// //         break;
// // 
// //     case ADAPT_TYPE_CASDVID:
// //         byBasChnnl = m_byCasdVidBasChnnl;
// //         ptBasEqp = &m_tCasdVidBasEqp;
// //         break;
// // 
// //     default:
// //         ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasStartupTimeout] invalid byAdaptType.%d\n", byAdaptType);
// //         return;
// //         break;
// //     }  
// // 
// //     if (EQP_CHANNO_INVALID == byBasChnnl || ptBasEqp->IsNull())
// //     {
// //         ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasStartupTimeout] invalid byBasChnnl.%d\n", byBasChnnl);
// //         return;
// //     }
// // 
// //     //释放通道
// //     if (!g_cMcuVcApp.GetPeriEqpStatus(ptBasEqp->GetEqpId(), &tStatus))
// //     {
// //         //ptBasEqp->SetNull();
// //         return;
// //     }
// // 
// //     tStatus.m_tStatus.tBas.tChnnl[byBasChnnl].SetStatus(TBasChnStatus::READY);
// //     g_cMcuVcApp.SetPeriEqpStatus(ptBasEqp->GetEqpId(), &tStatus);
// // 
// //     //改变适配状态
// //     m_tConf.m_tStatus.SetAdaptMode(byAdaptType, FALSE);
// // 	// zgc, 2008-01-22, 上报模式
// // 	ConfModeChange();
// // 
// //     //发送停止消息，防止应答消息缓存在队列中
// //     CServMsg cServMsg;
// //     cServMsg.SetChnIndex(byBasChnnl);
// //     cServMsg.SetConfId(m_tConf.GetConfId());
// //     SendMsgToEqp(ptBasEqp->GetEqpId(), MCU_BAS_STOPADAPT_REQ, cServMsg);
//     //ptBasEqp->SetNull();
// 
//     return;
// }

/*=============================================================================
    函 数 名： ProcHduMcuNeedIFrameCmd
    功    能： 
    算法实现： 
    全局变量： 
    参    数： const CMessage * pcMsg
    返 回 值： void 
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2009/3/9    4.6		    江乐斌                  创建
	2013/03/11   4.7.2       陈兵					修改(HDU多画面请求关键支持)
=============================================================================*/
void CMcuVcInst::ProcHduMcuNeedIFrameCmd(const CMessage *pcMsg)
{
	CServMsg cServMsg(pcMsg->content, pcMsg->length);

    switch(CurState())
	{
    case STATE_ONGOING:	
	    switch( pcMsg->event ) 
		{			
	    case HDU_MCU_NEEDIFRAME_CMD:
		{
			u8 byChnlIdx = cServMsg.GetChnIndex();
			u8 byHduSubChnId = 0;

			if (byChnlIdx >= MAXNUM_HDU_CHANNEL)
			{
				return;
			}
			TPeriEqpStatus tHduInfo;
			g_cMcuVcApp.GetPeriEqpStatus(cServMsg.GetSrcSsnId(), &tHduInfo);

			// [2013/03/11 chenbing]  
			if (HDUCHN_MODE_FOUR == tHduInfo.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdx))
			{
				byHduSubChnId = *(u8 *)cServMsg.GetMsgBody();
			}

			// [2013/03/11 chenbing] 
			TMt tSrcMt = (TMt)tHduInfo.m_tStatus.tHdu.GetChnMt(byChnlIdx, byHduSubChnId);
	
			u8 abyMcuId[MAX_CASCADEDEPTH-1];
			memset( &abyMcuId[0],0,sizeof(abyMcuId));
			
			if( !tSrcMt.IsLocal() )
			{
				m_tConfAllMcuInfo.GetMcuIdByIdx(tSrcMt.GetMcuIdx(),&abyMcuId[0] );
			}
		
			TMt tLocalSrcMt = GetLocalMtFromOtherMcuMt( tSrcMt );
			TLogicalChannel tLogicChn;
			if (tSrcMt.IsNull() 
				|| ( MT_TYPE_MT == tSrcMt.GetMtType() 
					&& !m_ptMtTable->GetMtLogicChnnl(tLocalSrcMt.GetMtId(), LOGCHL_VIDEO, &tLogicChn, FALSE))				
				)
			{ 
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_CALL,  "[ProcHduMcuNeedIFrameCmd] tMt/tEqp.%d unexist or logicChn unexist!\n", 
					tSrcMt.IsLocal()?tSrcMt.GetMtId():tLocalSrcMt.GetMtId() );
			}
			else
			{
				if (TYPE_MT == tSrcMt.GetType())
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_HDU, "[ProcHduMcuNeedIFrameCmd]Req iframe to mt(%d,%d)\n",						
						   tSrcMt.GetMcuId(),tSrcMt.GetMtId() );

					// [pengjie 2010/4/2] 多回传请求关键帧支持
					if( tSrcMt.IsLocal())
					{
						tSrcMt = GetLocalMtFromOtherMcuMt(tSrcMt);

						// [pengjie 2010/9/30] hdu双流请求关键帧支持
						if( TW_MEMBERTYPE_DOUBLESTREAM == tHduInfo.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType )
						{
							NotifyFastUpdate(tSrcMt, MODE_SECVIDEO);
						}
						else
						{
							NotifyFastUpdate(tSrcMt, MODE_VIDEO);
						}
						// End
					}
					else
					{
						//级联单回传，先调度下级的终端，再调度该终端进电视墙，电视墙要等两分钟才能输出图像,单回传多回传时请球关键帧
						if( TW_MEMBERTYPE_DOUBLESTREAM == tHduInfo.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType )
						{
							NotifyFastUpdate(tSrcMt, MODE_SECVIDEO);
						}
						else
						{
							NotifyFastUpdate(tSrcMt, MODE_VIDEO);
						}
					}
				}
				else if (TYPE_MCUPERI == tSrcMt.GetType() && EQP_TYPE_VMP == tSrcMt.GetEqpType())
				{
					u8 bySrcChnnl = 0xFF;
					//u8 byMtMediaType = 0;
					//u8 byMtRes = 0;			

					//byMtMediaType = m_tConf.GetMainVideoMediaType();
					//byMtRes = m_tConf.GetMainVideoFormat();
					// 判断是否是MPU2合成器yhz-
					BOOL32 bIsMPU2VMP = FALSE;
					u8 byVmpSubType = GetVmpSubType(tSrcMt.GetEqpId());
					if (MPU2_VMP_ENHACED == byVmpSubType ||
						MPU2_VMP_BASIC == byVmpSubType)
					{
						bIsMPU2VMP = TRUE;
					}
					
					if (bIsMPU2VMP)//mpu2有后适配能力列表,不依赖会议主格式
					{
						// 默认4CIF
						u8 byOnlyAttrb = 0XFF;
						TVideoStreamCap tHduStrCap;
						tHduStrCap.SetMediaType(MEDIA_TYPE_H264);
						tHduStrCap.SetMaxBitRate(m_tConf.GetBitRate());

						u8 bySubType = HDU_SUBTYPE_HDU_M;
						if(!g_cMcuAgent.GetHduSubTypeByEqpId(cServMsg.GetSrcSsnId(),bySubType))
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHduMcuNeedIFrameCmd]GetHduSubTypeByEqpId failed!\n");
							
							return;
						}
						switch (bySubType)
						{// 获得hdu对应能力集
						case HDU_SUBTYPE_HDU2:
						case HDU_SUBTYPE_HDU2_S:
							{
								tHduStrCap.SetResolution(VIDEO_FORMAT_HD1080);
								tHduStrCap.SetUserDefFrameRate(60);
								tHduStrCap.SetH264ProfileAttrb(emHpAttrb);
							}
							break;
						case HDU_SUBTYPE_HDU_H:
							{
								byOnlyAttrb = emBpAttrb;	//只能解BP码流
								tHduStrCap.SetResolution(VIDEO_FORMAT_HD1080);
								tHduStrCap.SetUserDefFrameRate(60);
								tHduStrCap.SetH264ProfileAttrb(emBpAttrb);
							}
							break;
						case HDU_SUBTYPE_HDU_M:
							{
								byOnlyAttrb = emBpAttrb;	//只能解BP码流
								tHduStrCap.SetResolution(VIDEO_FORMAT_HD1080);
								tHduStrCap.SetUserDefFrameRate(30);
								tHduStrCap.SetH264ProfileAttrb(emBpAttrb);
							}
							break;
						case HDU_SUBTYPE_HDU_L:
						case HDU_SUBTYPE_HDU2_L:
							{
								byOnlyAttrb = emBpAttrb;	//只能解BP码流
								tHduStrCap.SetResolution(VIDEO_FORMAT_4CIF);
								tHduStrCap.SetUserDefFrameRate(30);
								tHduStrCap.SetH264ProfileAttrb(emBpAttrb);
							}
							break;
						default:
							{
								ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHduMcuNeedIFrameCmd]Hdu type is wrong!\n");
								return;
							}
							break;
						}
						TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tSrcMt);
						bySrcChnnl = tVMPOutParam.GetCorrectChnnlByStrCap(tHduStrCap, byOnlyAttrb);
					
					}
					else //非mpu2，出主格式那路
					{
						TVideoStreamCap tStrCap = m_tConf.GetMainSimCapSet().GetVideoCap();
						bySrcChnnl = GetVmpOutChnnlByRes(tSrcMt.GetEqpId(), 
							tStrCap.GetResolution(), 
							tStrCap.GetMediaType(),
							tStrCap.GetUserDefFrameRate(),
							tStrCap.GetH264ProfileAttrb());
                    
					}
					if (0XFF == bySrcChnnl)
					{
						ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ProcHduMcuNeedIFrameCmd] Can't find correct chnnl for hdu in MPU2 out param!\n",
							tSrcMt.GetMcuId(), tSrcMt.GetMtId());
						return;
					}
					
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_HDU, "[ProcHduMcuNeedIFrameCmd]Req iframe to eqp(eqpid:%d chnlidx:%d)\n", 
						
						   tSrcMt.GetEqpId(), bySrcChnnl);

					NotifyEqpFastUpdate(tSrcMt,bySrcChnnl);
				} 
				else
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_HDU, "[ProcHduMcuNeedIFrameCmd]src(mcuid:%d mtid:%d type:%d) in hdu channel%d has wrong type\n",
						   tSrcMt.GetMcuId(), tSrcMt.GetMtId(), tSrcMt.GetType(), byChnlIdx);
				}
			}
		}
		    break;
	    default:
		    ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHduMcuNeedIFrameCmd]:The Message type %u(%s) is not fit", pcMsg->event, ::OspEventDesc(pcMsg->event) );
		    break;
		}
	    break;

    default:
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHduMcuNeedIFrameCmd]Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc(pcMsg->event), CurState());
        break;
	}

	return;
}

/*=============================================================================
    函 数 名： ProcBasMcuCommand
    功    能： 
    算法实现： 
    全局变量： 
    参    数： const CMessage * pcMsg
    返 回 值： void 
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2008/9/18   4.0		    周广程                  创建
=============================================================================*/
void CMcuVcInst::ProcBasMcuCommand(const CMessage * pcMsg)
{
	CServMsg cServMsg(pcMsg->content, pcMsg->length);

    switch(CurState())
    {
    case STATE_ONGOING:

        switch( pcMsg->event ) 
        {			
        case BAS_MCU_NEEDIFRAME_CMD:
			{
// 				if (VCS_CONF == m_tConf.GetConfSource() && m_byCreateBy != CONF_CREATE_MT )
// 				{
// 					NotifyFastUpdate(m_tConf.GetChairman(), MODE_VIDEO/*, TRUE*/);
// 					NotifyFastUpdate(m_cVCSConfStatus.GetCurVCMT(), MODE_VIDEO/*, TRUE*/);			
// 					
// 					return;
// 				}
                u8 byEqpId   = cServMsg.GetSrcSsnId();
                u8 byChnIdx  = cServMsg.GetChnIndex();
				u8 byChnMode = GetBasChnMode(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
				TMt tSrc     = GetBasChnSrc(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
				if (MODE_NONE == byChnMode)
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasMcuCommand]GetChnMode--<EqpId:%d, ChnId:%d> failed!\n", byEqpId, byChnIdx);
					return;
				}
				if (tSrc.IsNull())
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasMcuCommand]GetChnSrc--<EqpId:%d, ChnId:%d> failed!\n", byEqpId, byChnIdx);
					return;
				}
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasMcuCommand] Bas[tEqp.%d, Chnnl.%d] Need Mode.%d IFrame from tSrc<McuId:%d,MtId:%d>!\n",
										byEqpId, byChnIdx, byChnMode, tSrc.GetMcuId(), tSrc.GetMtId());
				NotifyFastUpdate(tSrc, byChnMode);


				//稍后 考虑多回传
			}

//             if ( !IsHDConf(m_tConf) )
//             {
//                 if (m_tConf.HasSpeaker())
//                 {
// //                    tSrcMt = GetLocalSpeaker();
//                     
//                     if (cServMsg.GetChnIndex() != m_byVidBasChnnl &&
//                         cServMsg.GetChnIndex() != m_byBrBasChnnl &&
//                         cServMsg.GetChnIndex() != m_byCasdVidBasChnnl )
//                     {
//                         ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasMcuCommand]cServMsg.GetChnIndex()[%d] != m_byAnyBasChnnl\n",
//                             cServMsg.GetChnIndex());
//                         break;
//                     }
// 
// 					// [pengjie 2010/4/2] 多回传请求关键帧支持
// 					TMt tMtSpeaker = m_tConf.GetSpeaker();
// 					if( tMtSpeaker.IsLocal())
// 					{
// 						tSrcMt = GetLocalSpeaker();
// 						NotifyFastUpdate(tSrcMt, MODE_VIDEO);
// 					}
// 					else
// 					{
// 						if(m_cSMcuSpyMana.IsMtInSpyMember( tMtSpeaker, MODE_VIDEO ))
// 						{
// 							NotifyFastUpdate(tMtSpeaker, MODE_VIDEO);
// 						}
// 					}                    
//                 }
//                 else
//                 {
//                     ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ProcBasMcuCommand] Err: No speaker for VCU from eqp.%d\n", cServMsg.GetSrcSsnId());
//                 }
//             }
//             else
//             {
// 				if (VCS_CONF == m_tConf.GetConfSource())
// 				{
// 					NotifyFastUpdate(m_tConf.GetChairman(), MODE_VIDEO/*, TRUE*/);
// 					NotifyFastUpdate(m_cVCSConfStatus.GetCurVCMT(), MODE_VIDEO/*, TRUE*/);			
// 					if ( m_tConf.HasSpeaker() )
// 					{
// 						TMt tMtSpeaker = m_tConf.GetSpeaker();
// 						if (! (tMtSpeaker == m_tConf.GetChairman() ))
// 						{
// 							NotifyFastUpdate(tMtSpeaker, MODE_VIDEO);
// 						}
// 					}
// 					return;
// 				}
// 
//                 u8 byEqpId = cServMsg.GetSrcSsnId();
//                 u8 byChnIdx = cServMsg.GetChnIndex();
//                 ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ProcBasMcuCommand] Receive bas.%d<chn.%d> BAS_MCU_NEEDIFRAME_CMD!\n", byEqpId, byChnIdx );
// #ifndef _8KE_
//                 if ( !g_cMcuAgent.IsEqpBasHD(byEqpId) )
//                 {
//                     ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasMcuCommand] The bas.%d is common bas, the conf.%s is HD conf, It's impossible!\n",
//                                 byEqpId, m_tConf.GetConfName() );
//                     break;
//                 }
// #endif
//                 TEqp tEqp = g_cMcuVcApp.GetEqp(byEqpId);
//                 u8 byChnMode = m_pcBasMgr->GetChnMode(tEqp, byChnIdx);
// 
//                 if ( CHN_ADPMODE_MVBRD == byChnMode )
//                 {
//                     if ( m_tConf.HasSpeaker() )
//                     {
// //                         tSrcMt = GetLocalSpeaker();                      
// //                         NotifyFastUpdate(tSrcMt, MODE_VIDEO);
// 						// [pengjie 2010/4/2] 多回传请求关键帧支持
// 						TMt tMtSpeaker = m_tConf.GetSpeaker();
// 						if( tMtSpeaker.IsLocal())	// [5/12/2010 xliang] 此情况包含了向上级mcu请求关键帧
// 						{
// 							tSrcMt = GetLocalSpeaker();
// 							NotifyFastUpdate(tSrcMt, MODE_VIDEO);
// 						}
// 						else
// 						{
// 							if(m_cSMcuSpyMana.IsMtInSpyMember( tMtSpeaker, MODE_VIDEO ))
// 							{
// 								NotifyFastUpdate(tMtSpeaker, MODE_VIDEO);
// 							}
// 						}
//                     }
//                     else
//                     {
//                         ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ProcBasMcuCommand] Err: No speaker for VCU from eqp.%d\n", cServMsg.GetSrcSsnId());
//                     }
//                     break;
//                 }
//                 else if ( CHN_ADPMODE_DSBRD == byChnMode)
//                 {
//                     if ( !m_tDoubleStreamSrc.IsNull() )
//                     {
//                         tSrcMt = m_tDoubleStreamSrc;
//                         NotifyFastUpdate(tSrcMt, MODE_SECVIDEO);
//                     }
//                     else
//                     {
//                         ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ProcBasMcuCommand] Err: No ds src for VCU from eqp.%d\n", cServMsg.GetSrcSsnId());
//                     }
//                     break;
//                 }
// 				else
// 				{
// 					u8 bySrcId = 0;
// 					//zjl[20091229]bas向mcu请求关键帧时，区分选看和级联的情况，分别获取选看源和回传源进行请求关键帧
// 					if(m_cSelChnGrp.GetSelSrc(tEqp, byChnIdx, bySrcId))
// 					{
// 						NotifyFastUpdate(m_ptMtTable->GetMt(bySrcId), MODE_VIDEO);
// 						ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ProcBasMcuCommand] Send iFrame from Mt<McuId.%d, MtId.%d> to SelBasGrp<EqpId.%d, ChnId.%d>\n", 
// 							m_ptMtTable->GetMt(bySrcId).GetMcuId(),bySrcId,
// 							byEqpId, byChnIdx);
// 					}
// 					else
// 					{
// 						TConfMcInfo *ptConfMcInfo = NULL;
// 						if (tEqp == m_tCasdVidBasEqp && byChnIdx == m_byCasdVidBasChnnl &&
// 							!m_tCascadeMMCU.IsNull() && 
// 							(ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(m_tCascadeMMCU.GetMtId())) && 
// 							!ptConfMcInfo->m_tSpyMt.IsNull())
// 						{
// 							NotifyFastUpdate(ptConfMcInfo->m_tSpyMt, MODE_VIDEO);
// 							ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ProcBasMcuCommand] Send iFrame to Mt<McuId.%d, MtId.%d> from CasBas<EqpId.%d, ChnId.%d>\n", 
// 								ptConfMcInfo->m_tSpyMt.GetMcuId(), ptConfMcInfo->m_tSpyMt.GetMtId(),
// 								byEqpId, byChnIdx);
// 							
// 						}
// 						else
// 						{
// 							ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ProcBasMcuCommand] Err: No src for VCU from eqp(id:%d chnl:%d)\n",
// 								cServMsg.GetSrcSsnId(), cServMsg.GetChnIndex());
// 						}
// 					}
// 				}
//                 else if ( CHN_ADPMODE_DSSEL == byChnMode )
//                 {
// 					//从m_cBasMgr获取对应的选看源，作对应的关键帧请求
//                 }
// 				else if ( CHN_ADPMODE_MVSEL == byChnMode )
//                 {
// 					//从m_cBasMgr获取对应的选看源，作对应的关键帧请求
// 				}
					
                
//            }
            break;

        default:
            break;
        }
        break;

    default:
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasMcuCommand]Wrong message %u(%s) received in state %u!\n", 
                        pcMsg->event, ::OspEventDesc(pcMsg->event), CurState());
        break;
    }
}

/*===========================================================================
函 数 名： ProcHduMcuChnnlStatusNotif
功    能： 
算法实现： 
全局变量： 
参    数： const CMessage * pcMsg
返 回 值： void 
-----------------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2009/02/26  4.6.1		江乐斌                  创建

=============================================================================*/
void CMcuVcInst::ProcHduMcuChnnlStatusNotif( void )
{
	if (STATE_ONGOING != CurState())
    {
        return;
    }
}

/*------------------------------------------------------------------*/
/*                                 mau                              */
/*------------------------------------------------------------------*/


/*=============================================================================
    函 数 名： ProcHdBasChnnlStatusNotif
    功    能： 高清BAS通道状态通知会议处理函数
    算法实现： 
    全局变量： 
    参    数： const CMessage * pcMsg
    返 回 值： void 
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
   2010-6-60    4.6         周嘉麟		           创建
=============================================================================*/
void CMcuVcInst::ProcHdBasChnnlStatusNotif(const CMessage * pcMsg)
{
	CServMsg cServMsg(pcMsg->content, pcMsg->length);

	//通道类型(目前只有mpu或mau)
	u8  byChnType   = *(u8*)cServMsg.GetMsgBody();

    //THDBasChnStatus通道状态
	TBasBaseChnStatus tChnStatus = *(TBasBaseChnStatus*)(cServMsg.GetMsgBody() + sizeof(u8));
    if ( tChnStatus.GetStatus() != TBasBaseChnStatus::READY )
    {
        return;
    }

	if ( g_cMcuVcApp.GetBasChnStatus( tChnStatus.GetEqp(),  tChnStatus.GetChnIdx() ) != BASCHN_STATE_READY  )
	{
		return;
	}

    ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ProcHdBasChnnlStatusNotif] EqpId.%d, ChnIdx.%d, ChnType.%d, Status.%d\n",
             tChnStatus.GetEqpId(), 
             tChnStatus.GetChnIdx(), 
             byChnType,
             tChnStatus.GetStatus());

	THDBasVidChnStatus tVidChnStatus;
	memset(&tVidChnStatus, 0, sizeof(tVidChnStatus));
	if (!g_cMcuVcApp.GetHDBasChnStatus(tChnStatus.GetEqp(), tChnStatus.GetChnIdx(), tVidChnStatus))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHdBasChnnlStatusNotif] GetHDBasChnStatus--<EqpId:%d, ChnId:%d> failed!\n", 
						tChnStatus.GetEqpId(), tChnStatus.GetChnIdx());
		return;
	}
	
	//未被占用
	if (!tVidChnStatus.GetReservedType())
	{
// 		ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[ProcHdBasChnnlStatusNotif] Eqp<%d,%d> isn't reserved, ignore it\n", 
// 						tChnStatus.GetEqpId(), tChnStatus.GetChnIdx());
        return;
	}

// 	if (NULL == m_pcMcuBasMgr)
// 	{
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHdBasChnnlStatusNotif] m_pcMcuBasMgr<Insid:%d> is null!\n", GetInsID());
// 		return;
// 	}
// 	else
// 	{
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHdBasChnnlStatusNotif] m_pcMcuBasMgr<Insid:%d> is not null!\n", GetInsID());
// 	}

	//获取通道所在适配组
	u8 byGrpType = GetBasGrpType(tChnStatus.GetEqp(), tChnStatus.GetChnIdx());
	if (CHN_ADPMODE_NONE == byGrpType)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHdBasChnnlStatusNotif] GetGrpType failed bas:%d chn:%d!\n",tChnStatus.GetEqp().GetEqpId(), tChnStatus.GetChnIdx());
		return;
	}
	//获取适配模式
	u8 byChnMode = GetBasChnMode(tChnStatus.GetEqp(), tChnStatus.GetChnIdx());
	if(MODE_NONE == byChnMode)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHdBasChnnlStatusNotif] GetChnMode failed bas:%d chn:%d!\n",tChnStatus.GetEqp().GetEqpId(), tChnStatus.GetChnIdx());
		return;
	}

	switch (byGrpType)
	{
	case CHN_ADPMODE_BRD:
		switch (byChnMode)
		{
		case MODE_VIDEO:
			{
				if (m_tConf.m_tStatus.IsVidAdapting())
				{
					ChangeAdapt(tChnStatus.GetEqp(), tChnStatus.GetChnIdx());
					
					if (g_cMcuVcApp.IsVASimultaneous() && 
							(!m_tConf.GetSpeaker().IsNull() || 
							  m_tConf.m_tStatus.IsPlaying() ||
							  m_tConf.m_tStatus.IsPlayReady())
						 )
					{
						 for(u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
						 {
							 if(!m_tConfAllMtInfo.MtJoinedConf(byLoop))
							 {
								continue;
							 }

							 if(IsNeedAdapt(GetLocalVidBrdSrc(),  m_ptMtTable->GetMt(byLoop), MODE_VIDEO) &&							  
								 !IsNeedAdapt(GetLocalAudBrdSrc(), m_ptMtTable->GetMt(byLoop), MODE_AUDIO) )
							 {
								 StartSwitchAud2Perieqp(GetLocalVidBrdSrc());
								 StartSwitchAud2MtNeedAdp(GetAudBrdSrc(), m_ptMtTable->GetMt(byLoop));
							 }
						 }
					}
				}
				else
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHdBasChnnlStatusNotif] conf is not in BrdVidAdapting!\n");
					return;
				}
			}
			break;
		case MODE_SECVIDEO:
			{
 				if (m_tConf.m_tStatus.IsDSAdapting())
 				{
					ChangeAdapt(tChnStatus.GetEqp(), tChnStatus.GetChnIdx());
				}
 				else
 				{
 					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHdBasChnnlStatusNotif] conf is not in BrdDSAdapting!\n");
 					return;
 				}
			}
			break;
		case MODE_AUDIO:
			{
				if (m_tConf.m_tStatus.IsAudAdapting())
				{
					ChangeAdapt(tChnStatus.GetEqp(), tChnStatus.GetChnIdx());
				}
				else
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHdBasChnnlStatusNotif] conf is not in BrdAudAdapting!\n");
					return;
				}
			}
			break;
		default:
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHdBasChnnlStatusNotif] unexpected byChnMode:%d!\n", byChnMode);
			break;
		}
		break;
	case CHN_ADPMODE_SEL:
		{
			//录像适配BAS重启后恢复
			TRecBasChn tTempRecBasChn;
			tTempRecBasChn.m_tBas = tChnStatus.GetEqp();
			tTempRecBasChn.m_byChnId = tChnStatus.GetChnIdx();
			u8 byTempMediaMode = MODE_NONE;
			if ( m_cRecAdaptMgr.IsExistMediaModeForRecAdpat(tTempRecBasChn,byTempMediaMode) )
			{
				AdjustConfRecordSrcStream(byTempMediaMode,TRUE);
				ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[ProcHdBasChnnlStatusNotif]restore rec for rec adapt,bas:%d-%d,mode:%d\n",
						 tTempRecBasChn.m_tBas.GetEqpId(), tTempRecBasChn.m_byChnId, byTempMediaMode);
			}
		}
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHdBasChnnlStatusNotif] unexpected byGrpType:%d!\n", byGrpType);
		break;
	}
	return;
}

/*=============================================================================
    函 数 名： ProcAudBasChnnlStatusNotif
    功    能： 高清BAS通道状态通知会议处理函数
    算法实现： 
    全局变量： 
    参    数： const CMessage * pcMsg
    返 回 值： void 
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
   2013/03/15    4.7         倪志俊	           创建
=============================================================================*/
void CMcuVcInst::ProcAudBasChnnlStatusNotif( const CMessage * pcMsg )
{
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
    
    //状态判断
    TBasBaseChnStatus tChnStatus = *(TBasBaseChnStatus*)(cServMsg.GetMsgBody() + sizeof(u8));
    if ( tChnStatus.GetStatus() != TBasBaseChnStatus::READY )
    {
        return;
    }
	
    if ( g_cMcuVcApp.GetBasChnStatus( tChnStatus.GetEqp(),  tChnStatus.GetChnIdx() ) != BASCHN_STATE_READY  )
    {
        return;
    }
	
	//判断是否是已经预占的通道
    TAudBasChnStatus tAudChnStatus;
    memset( &tAudChnStatus, 0, sizeof(TAudBasChnStatus));
    if (!g_cMcuVcApp.GetAudBasChnStatus(tChnStatus.GetEqp(), tChnStatus.GetChnIdx(), tAudChnStatus))
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcAudBasChnnlStatusNotif] GetHDBasChnStatus failed bas:%d chn:%d!\n",tChnStatus.GetEqp().GetEqpId(), tChnStatus.GetChnIdx());
        return;
    }
	
    if ( !tAudChnStatus.IsReserved() )
    {
        return;
    }
	
    //开始恢复适配
    u8 byGrpType = GetBasGrpType(tChnStatus.GetEqp(), tChnStatus.GetChnIdx());
    if (CHN_ADPMODE_NONE == byGrpType)
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcAudBasChnnlStatusNotif] GetGrpType failed bas:%d chn:%d!\n",tChnStatus.GetEqp().GetEqpId(), tChnStatus.GetChnIdx());
        return;
    }
    //获取适配模式
    u8 byChnMode = GetBasChnMode(tChnStatus.GetEqp(), tChnStatus.GetChnIdx());
    if(MODE_NONE == byChnMode)
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcAudBasChnnlStatusNotif] GetChnMode failed bas:%d chn:%d!\n",tChnStatus.GetEqp().GetEqpId(), tChnStatus.GetChnIdx());
        return;
    }
	
    switch (byGrpType)
    {
    case CHN_ADPMODE_BRD:
		{
			switch (byChnMode)
			{
			case MODE_AUDIO:
				{
					if (m_tConf.m_tStatus.IsAudAdapting())
					{
						ChangeAdapt(tChnStatus.GetEqp(), tChnStatus.GetChnIdx());
					}
					else
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcAudBasChnnlStatusNotif] conf is not in BrdAudAdapting!\n");
						return;
					}
				}
				break;
			default:
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcAudBasChnnlStatusNotif] unexpected byChnMode:%d!\n", byChnMode);
				break;
			}
		}
        break;
	case CHN_ADPMODE_SEL:
		{
// 			//录像适配BAS重启后恢复
// 			TRecBasChn tTempRecBasChn;
// 			tTempRecBasChn.m_tBas = tChnStatus.GetEqp();
// 			tTempRecBasChn.m_byChnId = tChnStatus.GetChnIdx();
// 			u8 byTempMediaMode = MODE_NONE;
// 			if ( m_cRecAdaptMgr.IsExistMediaModeForRecAdpat(tTempRecBasChn,byTempMediaMode) &&
// 				byTempMediaMode == MODE_AUDIO
// 				)
// 			{
// 				AdjustConfRecordSrcStream(byTempMediaMode,TRUE);
// 				ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_BAS,"[ProcAudBasChnnlStatusNotif]restore rec for rec adapt,bas:%d-%d,mode:%d\n",
// 					tTempRecBasChn.m_tBas.GetEqpId(), tTempRecBasChn.m_byChnId, byTempMediaMode);
// 			}
		}
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcAudBasChnnlStatusNotif] unexpected byGrpType:%d!\n", byGrpType);
		break;
    }
    return;
}


/*=============================================================================
函 数 名： ProcBasStatusNotif
功    能： 标清BAS通道状态通知会议处理函数，如果通道被预占用，则开启适配
			加这个接口只为了重启8kebas，因为8kebas没有通道状态通知，只能在这里处理，其他类型的bas在通道状态通知里处理
算法实现： 
全局变量： 
参    数： const CMessage * pcMsg
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2010/07/19  4.6         zhangli					create
=============================================================================*/
void CMcuVcInst::ProcBasStatusNotif( const CMessage * pcMsg )
{
	CServMsg cServMsg(pcMsg->content, pcMsg->length);
	TPeriEqpStatus tStatus = *(TPeriEqpStatus *)cServMsg.GetMsgBody();
    
    if (!tStatus.IsLocal() ||
        tStatus.GetEqpId() == 0 || tStatus.GetEqpId() > MAXNUM_MCU_PERIEQP)
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasStatusNotif]TPeriEqpStatus content error! GetMcuId() = %d GetEqpId() = %d\n",
			tStatus.GetMcuId(), tStatus.GetEqpId());
        return;
    }
	
#ifdef _8KE_
    TEqp tEqp = (TEqp)tStatus;
	
	TPeriEqpStatus tOldStatus;
	memset(&tOldStatus, 0, sizeof(TPeriEqpStatus));
	u8 byEqpId = tEqp.GetEqpId();
	g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tOldStatus);
	
	for (u8 byChnIdx = 0; byChnIdx < MAXNUM_8KEBAS_VCHN; ++byChnIdx)
	{
		if (tOldStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus(byChnIdx)->IsReserved())
		{
			//获取通道所在适配组
			u8 byGrpType = GetBasGrpType(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
			if (CHN_ADPMODE_NONE == byGrpType)
			{
				continue;
			}
			//获取适配模式
			u8 byChnMode = GetBasChnMode(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
			if(MODE_NONE == byChnMode)
			{
				continue;
			}
			
			switch (byGrpType)
			{
			case CHN_ADPMODE_BRD:
				{
					switch (byChnMode)
					{
					case MODE_VIDEO:
						{
							if (m_tConf.m_tStatus.IsVidAdapting())
							{
								ChangeAdapt(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
							}
						}
						break;
					case MODE_SECVIDEO:
						{
							if (m_tConf.m_tStatus.IsDSAdapting())
							{
								ChangeAdapt(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
							}
						}
						break;
					case MODE_AUDIO:
						{
							if (m_tConf.m_tStatus.IsAudAdapting())
							{
								ChangeAdapt(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
							}
						}
						break;
					default:
						break;
					}
				}
				break;
			case CHN_ADPMODE_SEL:
				{
					ChangeAdapt(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
				}
				break;
			default:
				break;
			}
		}
	}
#endif
}

/*=============================================================================
    函 数 名： ProcBasChnnlStatusNotif
    功    能： 标清BAS通道状态通知会议处理函数
    算法实现： 
    全局变量： 
    参    数： const CMessage * pcMsg
    返 回 值： void 
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
	2010/07/19  4.6         周嘉麟					重写
=============================================================================*/
void CMcuVcInst::ProcBasChnnlStatusNotif( const CMessage * pcMsg )
{
	CServMsg cServMsg(pcMsg->content, pcMsg->length);
    u8 byChnIdx  = cServMsg.GetChnIndex();
	u8 byEqpId   = *(u8*)cServMsg.GetMsgBody();
	//CConfId cConfId = cServMsg.GetConfId();
	TBasChnStatus tChnStatus = *(TBasChnStatus*)(cServMsg.GetMsgBody() + sizeof(u8));
	if (tChnStatus.GetStatus() != TBasChnStatus::READY)
	{
		return;
	}

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ProcBasChnnlStatusNotif] EqpId.%d, ChnIdx.%d, ChnType.%d, Status.%d\n",
										byEqpId, byChnIdx, 
										tChnStatus.GetChannelType(),
									    tChnStatus.GetStatus());
	TPeriEqpStatus tBasStatus;
	if (!g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tBasStatus))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasChnnlStatusNotif] GetPeriEqpStatus failed!\n");
		return;
	}
	
	if (tBasStatus.m_tStatus.tBas.tChnnl[byChnIdx].IsReserved())
	{
		//获取通道所在适配组
		u8 byGrpType = GetBasGrpType(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
		if (CHN_ADPMODE_NONE == byGrpType)
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasChnnlStatusNotif] GetGrpType failed!\n");
			return;
		}
		//获取适配模式
		u8 byChnMode = GetBasChnMode(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
		if(MODE_NONE == byChnMode)
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasChnnlStatusNotif] GetChnMode failed!\n");
			return;
		}
		
		switch (byGrpType)
		{
		case CHN_ADPMODE_BRD:
			switch (byChnMode)
			{
			case MODE_VIDEO:
				{
					if (m_tConf.m_tStatus.IsVidAdapting())
					{
						ChangeAdapt(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
					}
					else
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasChnnlStatusNotif] conf is not in BrdVidAdapting!\n");
						return;
					}
				}
				break;
			case MODE_SECVIDEO:
				{
					if (m_tConf.m_tStatus.IsDSAdapting())
					{
						ChangeAdapt(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
					}
					else
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasChnnlStatusNotif] conf is not in BrdDSAdapting!\n");
						return;
					}
				}
				break;
			case MODE_AUDIO:
				{
					if (m_tConf.m_tStatus.IsAudAdapting())
					{
						ChangeAdapt(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
					}
					else
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasChnnlStatusNotif] conf is not in BrdAudAdapting!\n");
						return;
					}
				}
				break;
			default:
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasChnnlStatusNotif] unexpected byChnMode:%d!\n", byChnMode);
				break;
			}
			break;
			case CHN_ADPMODE_SEL:
				{
					ChangeAdapt(g_cMcuVcApp.GetEqp(byEqpId), byChnIdx);
				}
				break;
			default:
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcBasChnnlStatusNotif] unexpected byGrpType:%d!\n", byGrpType);
				break;
		}
	}
	return;

}

/*=============================================================================
    函 数 名： StopHDCascaseAdp
    功    能： 
    算法实现： 
    全局变量： 
    参    数： 
    返 回 值： BOOL32
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2009/04/13  4.5		    张宝卿                创建
=============================================================================*/
// BOOL32 CMcuVcInst::StopHDCascaseAdp()
// {
// 
//     CServMsg cServMsg;
//     cServMsg.SetChnIndex(0);
//     cServMsg.SetConfId(m_tConf.GetConfId());
//     
// 	if (!m_tCasdVidBasEqp.IsNull())
// 	{
// 		SendMsgToEqp(m_tCasdVidBasEqp.GetEqpId(), MCU_HDBAS_STOPADAPT_REQ, cServMsg);
// 
// 		StopSwitchToPeriEqp(m_tCasdVidBasEqp.GetEqpId(), m_byCasdVidBasChnnl, TRUE, MODE_VIDEO);
// 		g_cMpManager.RemoveSwitchBridge(m_tCasdVidBasEqp, m_byCasdVidBasChnnl*MAXNUM_VOUTPUT, MODE_VIDEO, TRUE);
// 		g_cMpManager.RemoveSwitchBridge(m_tCasdVidBasEqp, m_byCasdVidBasChnnl*MAXNUM_VOUTPUT+1, MODE_VIDEO, TRUE);
// 
// 		StopSwitchToSubMt(m_tCascadeMMCU.GetMtId(), MODE_VIDEO, SWITCH_MODE_SELECT);
// 
// 		m_tConf.m_tStatus.SetHDAdaptMode(CONF_HDBASMODE_CASDVID, FALSE);
// 		ConfModeChange();
// 
// 		g_cMcuVcApp.ReleaseHDBasChn(m_tCasdVidBasEqp.GetEqpId(), m_byCasdVidBasChnnl);
// 
// 	}
// 	else
// 	{
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,"[StopHDCascaseAdp] m_tCasdVidBasEqp is NULL.So can't release adp res.\n" );
// 	}
// 	
// 	//zjj20100225 多回传补充
// 	u8 byEqpId = 0;
// 
// 	u8 abyEqpId[ BASID_MAX - BASID_MIN + 1 ] = {0};
// 	u8 byNum = 0;
// 
// 	u8 abyBasChl[ MAXNUM_MPU_CHN ] = {0};
// 	u8 byChlNum = 0;
// 
// 	u8 byIndex = 0;
// 	u8 byChlIndex = 0;
// 	u8 byMediaMode = MODE_NONE;
// 	TMt tSrc;
// 	tSrc.SetNull();
// 	u16 wSpyPort = SPY_CHANNL_NULL;
// 	TEqp tBasEqp;
// 	tBasEqp.SetNull();
// 	u8 tBasChnl = 0;
// 	if( m_cLocalSpyMana.GetAllUsedBasEqpId( &abyEqpId[0],&byNum ) && byNum > 0 )
// 	{		
// 		byIndex = 0;
// 		while( byIndex < byNum )
// 		{
// 			if ( !g_cMcuAgent.IsEqpBasHD(abyEqpId[byIndex]) )
// 			{
// 				++byIndex;
// 				continue;
// 			}
// 			tBasEqp.SetMcuEqp(LOCAL_MCUID, abyEqpId[byIndex], EQP_TYPE_BAS);
// 			tBasEqp.SetConfIdx(m_byConfIdx);
// 
// 			SendMsgToEqp(tBasEqp.GetEqpId(), MCU_HDBAS_STOPADAPT_REQ, cServMsg);
// 
// 			if( m_cLocalSpyMana.GetAllUsedBasChlByEqp( tBasEqp,&abyBasChl[0],&byChlNum ) &&
// 						byChlNum > 0 
// 						)
// 			{
// 				byChlIndex = 0; 
// 				while( byChlIndex < byChlNum )
// 				{
// 					tBasChnl = abyBasChl[byChlIndex];
// 					StopSwitchToPeriEqp(tBasEqp.GetEqpId(), tBasChnl, TRUE, MODE_VIDEO);
// 					g_cMpManager.RemoveSwitchBridge(tBasEqp, tBasChnl*MAXNUM_VOUTPUT, MODE_VIDEO, TRUE);
// 					g_cMpManager.RemoveSwitchBridge(tBasEqp, tBasChnl*MAXNUM_VOUTPUT+1, MODE_VIDEO, TRUE);
// 
// 					if( m_cLocalSpyMana.GetSpyMtByBasResource( tBasEqp,tBasChnl,byMediaMode,tSrc,&wSpyPort ) )
// 					{
// 						StopSwitchToSubMt(m_tCascadeMMCU.GetMtId(), MODE_VIDEO, SWITCH_MODE_SELECT,TRUE,TRUE,FALSE,wSpyPort);
// 					}
// 					else
// 					{
// 						StopSwitchToSubMt(m_tCascadeMMCU.GetMtId(), MODE_VIDEO, SWITCH_MODE_SELECT);
// 					}
// 
// 										
// 
// 					g_cMcuVcApp.ReleaseHDBasChn(tBasEqp.GetEqpId(), tBasChnl);
// 					++byChlIndex;
// 				}
// 				
// 			}
// 			++byIndex;
// 		}
// 	}
// 	
// 
// 	m_tConf.m_tStatus.SetHDAdaptMode(CONF_HDBASMODE_CASDVID, FALSE);
// 	ConfModeChange();
//     m_tCasdVidBasEqp.SetNull();
// 
// 	//zjj20100224 多回传补充
// 	m_cLocalSpyMana.ClearAllSpyBasResource();
// 
//     return TRUE;
// }

/*=============================================================================
    函 数 名： StartHdVidSelAdp
    功    能： 
    算法实现： 
    全局变量： 
    参    数： BOOL32 bIsVGA
                TEqp &tEqp
                u8 &byChnIdx
    返 回 值： BOOL32 
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2009/5/23   4.5		    张宝卿                  创建
=============================================================================*/
// BOOL32 CMcuVcInst::StartHdVidSelAdp(TMt tSrc, TMt tDst, u8 bySelMode,TSimCapSet *tDstSimCap )
// {
//     //抢占BAS: FIXME. 目前不支持标清适配
//     
//     //FIXME: 暂时未支持mpu 和 通用管理，稍后
//    
// 	TMt tOrigSrc = tSrc;
// 	if (!tSrc.IsLocal())
// 	{
// 		tSrc = GetLocalMtFromOtherMcuMt(tSrc);
// 	}
// 	if (!tDst.IsLocal())
// 	{
// 		tDst = GetLocalMtFromOtherMcuMt(tDst);
// 	}
// 
// 	u8 byBasId  = 0xff;
// 	u8 byChnIdx = 0xff;
// 	u8 byOutIdx = 0;
// 	// 查询是否之前已有同源终端占用BAS,并且输出的码流可为新加入的终端所接受
// 	BOOL32 bNeedNewBas = IsNeedNewSelAdp(tSrc.GetMtId(), tDst.GetMtId(), MODE_VIDEO, &byBasId, &byChnIdx, &byOutIdx);
// 	if (bNeedNewBas)
// 	{
// 
// #ifdef _8KE_
// 		TSimCapSet tSrcCap = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
// 		TSimCapSet tDstCap = m_ptMtTable->GetDstSCS(tDst.GetMtId());
// 		u8 by8keBasType;
// 		if (MEDIA_TYPE_H264 == tSrcCap.GetVideoMediaType() &&
// 			IsResG(tSrcCap.GetVideoResolution(), VIDEO_FORMAT_4CIF))
// 		{
// 			by8keBasType = BAS_8KECHN_MV;
// 			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StartHdVidSelAdp] try to ocuppy 8ke Mv bas!\n");
// 		}
// 		else
// 		{
// 			by8keBasType = BAS_8KECHN_SEL;
// 			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StartHdVidSelAdp] try to ocuppy 8ke sel bas!\n");
// 		}
// 		//8kebas区分源的能力选择最合适的bas通道
// 		BOOL32 bRet = g_cMcuVcApp.GetIdle8keBasChn(by8keBasType, byBasId, byChnIdx);
// 		
// 		//如果没有占到sel型bas通道，则尝试占用主流通道
// 		if (!bRet)
// 		{
// 			if (BAS_8KECHN_SEL == by8keBasType)
// 			{
// 				bRet = g_cMcuVcApp.GetIdle8keBasChn(BAS_8KECHN_MV, byBasId, byChnIdx);
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StartHdVidSelAdp] try to ocuppy 8ke sel failed and try to ocuppy 8ke mv bas again!\n");
// 				if (!bRet)
// 				{
// 					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StartHdVidSelAdp] try to ocuppy 8ke sel failed and try to ocuppy 8ke mv bas again failed!\n");
// 				}
// 				else
// 				{
// 					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StartHdVidSelAdp] try to ocuppy 8ke sel failed and try to ocuppy 8ke mv bas again success!\n");
// 				}
// 			}	
// 			else
// 			{
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StartHdVidSelAdp] try to ocuppy 8ke Mv bas failed !\n");
// 			}
// 		}
// 		else
// 		{
// 			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StartHdVidSelAdp] ocuppy 8ke bas<Type:%d> success!\n", by8keBasType);
// 		}
// #else
// 		BOOL32 bRet = g_cMcuVcApp.GetIdleHDBasVidChl( byBasId, byChnIdx);
// #endif
// 		if ( bRet )
// 		{
// 			TPeriEqpStatus tHDBasStatus;
// 			g_cMcuVcApp.GetPeriEqpStatus( byBasId, &tHDBasStatus );
// 			THDBasVidChnStatus* ptChanStatus = NULL;
// 			if (TYPE_MPU == tHDBasStatus.m_tStatus.tHdBas.GetEqpType())
// 			{
// 				ptChanStatus = tHDBasStatus.m_tStatus.tHdBas.tStatus.tMpuBas.GetVidChnStatus( byChnIdx );
// 			}
// 			else if(TYPE_8KE_BAS == tHDBasStatus.m_tStatus.tHdBas.GetEqpType())
// 			{
// 				ptChanStatus = tHDBasStatus.m_tStatus.tHdBas.tStatus.t8keBas.GetVidChnStatus( byChnIdx );
// 			}
// 			else
// 			{
// 				ptChanStatus = tHDBasStatus.m_tStatus.tHdBas.tStatus.tMauBas.GetVidChnStatus( byChnIdx );
// 			}
// 
// 			if ( NULL != ptChanStatus )
// 			{
// 				TEqp tHDBas;
// 				tHDBas = ptChanStatus->GetEqp();
// 				tHDBas.SetConfIdx( m_byConfIdx );
// 				ptChanStatus->SetEqp( tHDBas );
// 				g_cMcuVcApp.SetPeriEqpStatus(byBasId, &tHDBasStatus);
// 				g_cMcuVcApp.SendPeriEqpStatusToMcs(byBasId);
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[StartHdVidSelAdp] Occupy HDBas.%d, chn.%d\n", byBasId, byChnIdx );
// 
// 				//根据源和目的准备参数，开启适配
// 				CServMsg cServMsg;
// 				TSimCapSet tSrcSCS = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
// 				TSimCapSet tDstSCS = m_ptMtTable->GetDstSCS(tDst.GetMtId());
// 
// 				//zjj20100201 
// 				//  [11/18/2009 pengjie] 级联多回传支持 这里是得到上级终端的能力级
// 				if( tDstSimCap != NULL)  
// 				{
// 					tDstSCS = *tDstSimCap;
// 				}
// 
// 				u8 abyMediaType[MAXNUM_8KEBAS_VOUTPUT] = {MEDIA_TYPE_NULL, MEDIA_TYPE_NULL, MEDIA_TYPE_NULL, MEDIA_TYPE_NULL};
// 				u8 abyRes[MAXNUM_8KEBAS_VOUTPUT]       = {VIDEO_FORMAT_CIF, VIDEO_FORMAT_CIF, VIDEO_FORMAT_CIF, VIDEO_FORMAT_CIF};
// 				
// 				//选看适配8000e策略：
// 				//源端能力上限为h264_4cif
// 				//源端能力大于h264_4cif,直接拒掉
// 				//适配参数格式为目的端格式，分辨率为源端和目的端取小
// 				//其余三路出挂空暂时参数设为目的端格式和cif分辨率
// 				if(TYPE_8KE_BAS == tHDBasStatus.m_tStatus.tHdBas.GetEqpType())
// 				{				
// 					for (u8 byIdx = 0; byIdx < MAXNUM_8KEBAS_VOUTPUT; byIdx++)
// 					{
// 						abyMediaType[byIdx] = tDstSCS.GetVideoMediaType();
// 						abyRes[byIdx]       = min(tSrcSCS.GetVideoResolution(), tDstSCS.GetVideoResolution());
// 					}
// 				}
// 				else
// 				{
// 					//u8 abyMediaType[MAXNUM_VOUTPUT] = {MEDIA_TYPE_NULL, MEDIA_TYPE_NULL};
// 					//u8 abyRes[MAXNUM_VOUTPUT]       = {VIDEO_FORMAT_CIF, VIDEO_FORMAT_CIF};
// 					if (MEDIA_TYPE_H264 == tDstSCS.GetVideoMediaType())
// 					{
// 						abyMediaType[0] = MEDIA_TYPE_H264;
// 						abyMediaType[1] = MEDIA_TYPE_H264;
// 						if (VIDEO_FORMAT_CIF == tDstSCS.GetVideoResolution())
// 						{
// 							abyRes[0] = VIDEO_FORMAT_4CIF;
// 							abyRes[1] = VIDEO_FORMAT_CIF;
// 						}
// 						else
// 						{
// 							abyRes[0] = tDstSCS.GetVideoResolution();
// 							abyRes[1] = VIDEO_FORMAT_CIF;
// 						}
// 						
// 					}
// 					else
// 					{
// 						if (MEDIA_TYPE_H264 == m_tConf.GetMainVideoMediaType() ||
// 							MEDIA_TYPE_H264 == m_tConf.GetSecVideoMediaType())
// 						{
// 							abyMediaType[0] = MEDIA_TYPE_H264;
// 							abyRes[0]       = VIDEO_FORMAT_4CIF;
// 						}
// 						abyMediaType[1] = tDstSCS.GetVideoMediaType();
// 						abyRes[1]       = tDstSCS.GetVideoResolution();
// 					}
// 				}
// 			
// 
// 				u16 wOutBitRate = m_tConf.GetBitRate();
// 				if (m_tConf.GetSecBitRate() != 0)
// 				{
// 					wOutBitRate = min(m_tConf.GetSecBitRate(), wOutBitRate);
// 				}
// 
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StartHdVidSelAdp] mtid:%d sel mtid:%d using hdbas(firstout:(%d, %d) secout:(%d, %d) bitrate:(%d)\n", 
// 						tDst.GetMtId(), tSrc.GetMtId(), abyMediaType[0], abyRes[0], abyMediaType[1], abyRes[1], wOutBitRate);
// 
// 
// 				//构造适配目的参数
// 				THDAdaptParam tHDAdpParam;
// 				u16 wWidth , wHeight = 0;
// 				u8 byFrameRate = 0;
// 
// 				//[03/01/2010] zjl modify 获取bas输出路数，同步支持mpu、mau、8kebas
// 				u8 byOutNum = 0;
// 				u8 byBasType = 0;
// 				if (!GetOutPutAcdBasEqp(tHDBas, byBasType, byOutNum)) 
// 				{
// 					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StartHdVidSelAdp] GetOutPutAcdBasEqp failed!\n");
// 				}
// 
// 				for (u8 byIdx = 0; byIdx < byOutNum; byIdx++)
// 				{
// 					tHDAdpParam.SetVidType(abyMediaType[byIdx]);
// 					tHDAdpParam.SetBitRate(wOutBitRate);
// 					tHDAdpParam.SetVidActiveType(GetActivePayload(m_tConf, abyMediaType[byIdx]));    
// 					
// 					if (g_cMcuVcApp.IsSupportChgLGCResAcdBR())
// 					{
// 						TLogicalChannel tVideoLogicChnnl;
// 						tVideoLogicChnnl.SetChannelType(tHDAdpParam.GetVidType());
// 						u8 byAdjChnRes = GetMtLegalResAccord2CallBR(tHDAdpParam.GetBitrate(),
// 																	abyRes[byIdx],
// 																	tVideoLogicChnnl,
// 																	FALSE);
// 						if (VIDEO_FORMAT_INVALID == byAdjChnRes)
// 						{
// 							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StartHdVidSelAdp:Error] byRes<%d> adjust to null!\n", abyRes[byIdx]);
// 						}
// 						else if(byAdjChnRes == abyRes[byIdx])
// 						{
// 							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StartHdVidSelAdp] no need to adjust org res<%d>!\n", abyRes[byIdx]);
// 						}
// 						else if (byAdjChnRes != abyRes[byIdx])
// 						{
// 							u16 wHeight = 0;
// 							u16 wWidth = 0;
// 							abyRes[byIdx] = byAdjChnRes;
// 							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StartHdVidSelAdp]  adjust Org res<%d> to Cur res<%d>!\n", abyRes[byIdx], byAdjChnRes);
// 						}
// 					}
// 					
// 					GetWHByRes(abyRes[byIdx], wWidth, wHeight);
// 					tHDAdpParam.SetResolution(wWidth, wHeight);
// 
// 					if (MEDIA_TYPE_H264 == abyMediaType[byIdx])
// 					{
// 						byFrameRate = ((abyMediaType[byIdx] == m_tConf.GetSecVideoMediaType()) ? m_tConf.GetSecVidUsrDefFPS() : m_tConf.GetMainVidUsrDefFPS());
// 					}
// 					else
// 					{
// 						byFrameRate = ((abyMediaType[byIdx] == m_tConf.GetSecVideoMediaType()) ? m_tConf.GetSecVidFrameRate() : m_tConf.GetMainVidFrameRate());
// 					}
// 					tHDAdpParam.SetFrameRate(byFrameRate);
// 
// 					tHDAdpParam.SetIsNeedByPrs(m_tConf.GetConfAttrb().IsResendLosePack());    
// 					cServMsg.CatMsgBody((u8*)&tHDAdpParam, sizeof(tHDAdpParam));
// 					if (TYPE_8KE_BAS == byBasType)
// 					{
// 						ptChanStatus->SetOutputVidParam(tHDAdpParam, byIdx, BAS_8KECHN_SEL);	
// 					}
// 					else
// 					{
// 						ptChanStatus->SetOutputVidParam(tHDAdpParam, byIdx);
// 					}
// 						
// 				}
// 
// 				TMediaEncrypt  tEncrypt = m_tConf.GetMediaKey();
// 				cServMsg.CatMsgBody( (u8*)&tEncrypt, sizeof(tEncrypt) );
// 
// 				TDoublePayload tDVPayload;
// 				if (MEDIA_TYPE_H264 == tSrcSCS.GetVideoMediaType() || 
// 					MEDIA_TYPE_H263PLUS == tSrcSCS.GetVideoMediaType() || 
// 					CONF_ENCRYPTMODE_NONE != tEncrypt.GetEncryptMode() )
// 				{
// 					tDVPayload.SetActivePayload(GetActivePayload(m_tConf, tSrcSCS.GetVideoMediaType()));
// 				}
// 				else
// 				{
// 					tDVPayload.SetActivePayload(tSrcSCS.GetVideoMediaType());
// 				}
// 				tDVPayload.SetRealPayLoad(tSrcSCS.GetVideoMediaType()); 
// 				cServMsg.CatMsgBody( (u8*)&tDVPayload, sizeof(tDVPayload) );
// 				cServMsg.SetChnIndex( byChnIdx );
// 				
// 				if (TYPE_8KE_BAS == byBasType)
// 				{
// 					SendMsgToEqp( byBasId, MCU_BAS_STARTADAPT_REQ, cServMsg );
// 				}
// 				else
// 				{
// 					SendMsgToEqp( byBasId, MCU_HDBAS_STARTADAPT_REQ, cServMsg );
// 				}
// 			
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StartHdVidSelAdp] CMcuVcInst: BAS.%d Chn.%d start adp!\n", byBasId, byChnIdx);
// 
// 
// 				//简单起见，事先建交换，4.6.1规范处理
// 				TEqp tHDAdpt = g_cMcuVcApp.GetEqp(byBasId);
// 				tHDAdpt.SetConfIdx(m_byConfIdx);
// 				if (TYPE_8KE_BAS == byBasType)
// 				{
// 					g_cMpManager.SetSwitchBridge(tSrc, 0, MODE_VIDEO);
// 					g_cMpManager.SetSwitchBridge(tHDAdpt, byChnIdx , MODE_VIDEO, TRUE);
// 			    	g_cMpManager.SetSwitchBridge(tHDAdpt, byChnIdx + 1, MODE_VIDEO, TRUE);
// 					g_cMpManager.SetSwitchBridge(tHDAdpt, byChnIdx + 2, MODE_VIDEO, TRUE);
// 					g_cMpManager.SetSwitchBridge(tHDAdpt, byChnIdx + 3, MODE_VIDEO, TRUE);
// 				}
// 				else
// 				{
// 					g_cMpManager.SetSwitchBridge(tSrc, 0, MODE_VIDEO);
// 					g_cMpManager.SetSwitchBridge(tHDAdpt, byChnIdx * 2, MODE_VIDEO, TRUE);
// 				    g_cMpManager.SetSwitchBridge(tHDAdpt, byChnIdx * 2 + 1, MODE_VIDEO, TRUE);
// 				}
// 				
// 				//选看适配不等启动回应,简单将通道变为正在适配中的状态
// 				ptChanStatus->SetStatus(TBasChnStatus::RUNING);
// 				g_cMcuVcApp.SetPeriEqpStatus(byBasId, &tHDBasStatus);
// 				g_cMcuVcApp.SendPeriEqpStatusToMcs(byBasId);
// 
// 				//zjj20100306 多回传补充 
// 				u16 wSrcChnnl = 0;
// 				CRecvSpy tSpyResource;
// 				if( m_cSMcuSpyMana.GetRecvSpy( tSrc, tSpyResource ) )
// 				{
// 					wSrcChnnl = tSpyResource.m_wSpyStartPort;
// 				}
// 
// 				g_cMpManager.StartSwitchToPeriEqp(tSrc, wSrcChnnl, tHDAdpt.GetEqpId(), byChnIdx, MODE_VIDEO, SWITCH_MODE_SELECT,
// 												  FALSE, TRUE, (VCS_CONF == m_tConf.GetConfSource()));
// 				// fwd rtcp
// 				TLogicalChannel tLogicalChannel;
// 				m_ptMtTable->GetMtLogicChnnl(tSrc.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE);
// 				u32 dwDstIp = tLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
// 				u16 wDstPort = tLogicalChannel.GetSndMediaCtrlChannel().GetPort();                  
// 		        SwitchVideoRtcpToDst(dwDstIp, wDstPort, tHDAdpt, byChnIdx * byOutNum/*MAXNUM_VOUTPUT*/, MODE_VIDEO, SWITCH_MODE_SELECT, TRUE);
// 			}
// 			else
// 			{
// 				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StartHdVidSelAdp] Get HDBas.%d Chan.%d status failed!\n", byBasId, byChnIdx );
// 				return FALSE;
// 			}
// 		}
// 		else
// 		{
// 			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StartHdVidSelAdp] no Idle HdBas to ocuppy!\n");
// 			return FALSE;
// 		}
// 	}
// 	else
// 	{
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StartHdVidSelAdp] no need to ocuppy new adapter!\n");
// 	}
//     
//     //抢到通道，写入SelGrp
//     TEqp tAdpBas = g_cMcuVcApp.GetEqp(byBasId);
// 	tAdpBas.SetConfIdx(m_byConfIdx);
//     m_cSelChnGrp.AddSel(tSrc.GetMtId(), tDst.GetMtId(), MODE_VIDEO, tAdpBas, byChnIdx);
// 
// 
// 	
// 	//zjj20100201
// 	//  [11/18/2009 pengjie] 级联多回传支持 这里是判断源终端是否是支持多回传
// 	CSendSpy tSpyResource;
// 	u16 wSpyPort = SPY_CHANNL_NULL;
// 	if( m_cLocalSpyMana.GetSpyChannlInfo( tSrc, tSpyResource ) )
// 	{
// 		wSpyPort = tSpyResource.m_wSpyStartPort;
// 	}
// 
// 	u8 byBasOutChnNum = 0;  //适配输出通道总数(根据外设类型区分)
// 	u8 byBasType = 0;
//     TSimCapSet tDstSCS = m_ptMtTable->GetDstSCS(tDst.GetMtId());
// 	
// 	//获取当前终端所能接收码流的 bas输出索引
// 	if (!FindAcceptCodeChnl(tDst.GetMtId(), MODE_VIDEO, byBasId, byChnIdx, byOutIdx))
// 	{
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StartHdVidSelAdp] FindAcceptCodeChnl failed!\n");
// 		return FALSE;
// 	}		
//  
// 	//根据bas类型得到它有几出
// 	if (!GetOutPutAcdBasEqp(tAdpBas, byBasType, byBasOutChnNum)) 
// 	{
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StartHdVidSelAdp] GetOutPutAcdBasEqp failed2!\n");
// 	}
// 	g_cMpManager.StartSwitchToSubMt(tAdpBas, byChnIdx * byBasOutChnNum + byOutIdx, tDst, MODE_VIDEO, SWITCH_MODE_BROADCAST, FALSE, TRUE, FALSE, wSpyPort);
//     if (m_tConf.GetConfAttrb().IsResendLosePack())
//     {
// 	 	u32 dwRcvIp, dwSrcIp;
// 	 	u16 wRcvPort;
// 		g_cMpManager.GetSwitchInfo( tAdpBas, dwRcvIp, wRcvPort, dwSrcIp );
// 		SwitchVideoRtcpToDst( g_cMcuVcApp.GetEqpIp(byBasId), wRcvPort + PORTSPAN * (byChnIdx * byBasOutChnNum + byOutIdx) + 1, tDst, 0, MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
//     }
// 
// // 	u32 dwRcvIp, dwSrcIp;
// // 	u16 wRcvPort;
// // 	TSimCapSet tDstSCS = m_ptMtTable->GetDstSCS(tDst.GetMtId());
// // 	if (MEDIA_TYPE_H264 != tDstSCS.GetVideoMediaType() ||
// // 		(MEDIA_TYPE_H264 == tDstSCS.GetVideoMediaType() && VIDEO_FORMAT_CIF == tDstSCS.GetVideoResolution()))
// // 	{
// // 		g_cMpManager.StartSwitchToSubMt(tAdpBas, byChnIdx * 2 + 1, tDst, MODE_VIDEO, SWITCH_MODE_BROADCAST, FALSE, TRUE, FALSE, wSpyPort);
// // 		g_cMpManager.GetSwitchInfo( tAdpBas, dwRcvIp, wRcvPort, dwSrcIp );
// // 
// // 		if (m_tConf.GetConfAttrb().IsResendLosePack())
// // 		{
// // 			SwitchVideoRtcpToDst( g_cMcuVcApp.GetEqpIp(tAdpBas.GetEqpId()), wRcvPort + PORTSPAN * (byChnIdx * 2 + 1) + 1, tDst, 0, MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
// // 		}			
// // 	}
// // 	else
// // 	{
// // 		g_cMpManager.StartSwitchToSubMt(tAdpBas, byChnIdx * 2, tDst, MODE_VIDEO, SWITCH_MODE_BROADCAST, FALSE, TRUE, FALSE, wSpyPort);
// // 		g_cMpManager.GetSwitchInfo( tAdpBas, dwRcvIp, wRcvPort, dwSrcIp );
// // 	
// // 		if(m_tConf.GetConfAttrb().IsResendLosePack())
// // 		{
// // 			SwitchVideoRtcpToDst( g_cMcuVcApp.GetEqpIp(tAdpBas.GetEqpId()), wRcvPort + PORTSPAN * (byChnIdx * 2) + 1, tDst, 0, MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
// // 		}		
// // 	}
//     
//     //选看标识置位
//     m_ptMtTable->SetMtSrc(tDst.GetMtId(), &tOrigSrc, MODE_VIDEO);
// 
//     //通知发送
//     NotifyMtSend(tSrc.GetMtId(), MODE_VIDEO);
//     NotifyMtReceive(tSrc, tDst.GetMtId());
// 
// 	// [pengjie 2010/4/2] 多回传请求关键帧支持
// 	if( tOrigSrc.IsLocal())
// 	{
// 		NotifyFastUpdate(tSrc, MODE_VIDEO, TRUE);
// 	}
// 	else
// 	{
// 		if(m_cSMcuSpyMana.IsMtInSpyMember( tOrigSrc, MODE_VIDEO ))
// 		{
// 			NotifyFastUpdate(tOrigSrc, MODE_VIDEO);
// 		}
// 	}
// 
// 
//     //非kdc厂商有广播源且节省带宽时，通知mt停止发送码流
// //     if(g_cMcuVcApp.IsSavingBandwidth() && 
// //         MT_MANU_KDC != m_ptMtTable->GetManuId( tDst.GetMtId()) &&
// //         MT_MANU_KDCMCU != m_ptMtTable->GetManuId( tDst.GetMtId()))
// //     {
// //         NotifyOtherMtSend(tDst.GetMtId(), FALSE);
// //     }
// 
//     //刷新界面
//     TMtStatus tMtStatus;
// 
//     //过滤目标终端为上级mcu的情况
//     m_ptMtTable->GetMtStatus( tDst.GetMtId(), &tMtStatus );
//     if( tSrc.GetType() == TYPE_MT && tSrc.GetMtId() != tDst.GetMtId() && 
//         (m_tCascadeMMCU.GetMtId() == 0 || tDst.GetMtId() != m_tCascadeMMCU.GetMtId()) )
//     {
//         TMtStatus tSrcMtStatus;
//         u8 byAddSelByMcsMode = MODE_NONE;
//         m_ptMtTable->GetMtStatus( tSrc.GetMtId(), &tSrcMtStatus );
// 
// 		TMt tLocalVidBrdSrc = GetLocalVidBrdSrc();
//         
//         //zbq[12/06/2007] VMP点名时序问题
//         if( ((!(tSrc == tLocalVidBrdSrc)) || (tSrc == tLocalVidBrdSrc && 
//             ROLLCALL_MODE_VMP == m_tConf.m_tStatus.GetRollCallMode() &&
//             m_tRollCaller == tLocalVidBrdSrc)) &&
//             tSrcMtStatus.IsSendVideo() && 
//             ( MODE_VIDEO == bySelMode || MODE_BOTH == bySelMode ) )
//         {
//             byAddSelByMcsMode = MODE_VIDEO;
//         }
//         if( !(tSrc == GetLocalAudBrdSrc()) && tSrcMtStatus.IsSendAudio() && 
//             ( MODE_AUDIO == bySelMode || MODE_BOTH == bySelMode ) )
//         {
//             if( MODE_VIDEO == byAddSelByMcsMode )
//             {
//                 byAddSelByMcsMode = MODE_BOTH;
//             }
//             else
//             {
//                 byAddSelByMcsMode = MODE_AUDIO;
//             }
//         }
//         
//         if( MODE_NONE != byAddSelByMcsMode )
//         {
//             tMtStatus.AddSelByMcsMode( bySelMode );
//         }
//         else
//         {
//             tMtStatus.RemoveSelByMcsMode( bySelMode );
//         }
//     }
//     else
//     {
//         tMtStatus.RemoveSelByMcsMode( bySelMode );
//     }
// 	tMtStatus.SetSelectMt(tOrigSrc, bySelMode);
//     m_ptMtTable->SetMtStatus( tDst.GetMtId(), &tMtStatus );    
//     MtStatusChange(tDst.GetMtId(), TRUE);
// 
//     //暂不支持PRS
//     if (m_tConf.GetConfAttrb().IsResendLosePack())
//     {
//     }
// 
//     return TRUE;
// }


/*=============================================================================
    函 数 名： StopHdVidSelAdp
    功    能： 
    算法实现： 
    全局变量： 
    参    数：  TMt &tSrc
                TMt &tDst
                u8 bySelMode
    返 回 值： BOOL32 
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2009/5/23   4.5		    张宝卿                  创建
=============================================================================*/
// BOOL32 CMcuVcInst::StopHdVidSelAdp(TMt tSrc, TMt tDst, u8 bySelMode,BOOL32 bIsAfterReleaseCanRestoreRecvBrd /*= TRUE*/)
// {
//     TSimCapSet tSrcSCS = m_ptMtTable->GetSrcSCS(tSrc.GetMtId());
//     TSimCapSet tDstSCS = m_ptMtTable->GetDstSCS(tDst.GetMtId());
// 
// 	if (!tSrc.IsLocal())
// 	{
// 		tSrc = GetLocalMtFromOtherMcuMt(tSrc);
// 	}
// 	if (!tDst.IsLocal())
// 	{
// 		tDst = GetLocalMtFromOtherMcuMt(tDst);
// 	}
// 
//     //非适配选看
//     TEqp tBas;
//     tBas.SetNull();
//     u8 byChnIdx = 0;
//     BOOL32 bRlsChn = FALSE;
//     BOOL32 bGetAdpChn = FALSE;
//     bGetAdpChn = m_cSelChnGrp.GetSelBasChn(tSrc.GetMtId(), tDst.GetMtId(), MODE_VIDEO, tBas, byChnIdx, bRlsChn);
//     if (!bGetAdpChn)
//     {
//         ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StopHdVidSelAdp] get adp chn failed for src.%d, dst.%d, mode.%d!\n",
//                         tSrc.GetMtId(), tDst.GetMtId(), bySelMode);
//         return FALSE;
//     }
//     else
//     {
//         ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopHdVidSelAdp] Chn<%d,%d> for sel<src.%d,dst.%d>, mode.%d, Rls.%d has been checked out!\n",
//                 tBas.GetEqpId(), byChnIdx, tSrc.GetMtId(), tDst.GetMtId(), bySelMode, bRlsChn);
//     }
// 
//     //拆交换
//     TEqp tHDAdpt = g_cMcuVcApp.GetEqp(tBas.GetEqpId());
//   
// 	TLogicalChannel tLogicalChannel;
// 	u32 dwRcvIp, dwSrcIp;
// 	u16 wRcvPort;
//     g_cMpManager.GetSwitchInfo( tHDAdpt, dwRcvIp, wRcvPort, dwSrcIp );
// 	if (bRlsChn)
// 	{
// 		g_cMpManager.RemoveSwitchBridge(tSrc, 0, MODE_VIDEO);
// 		g_cMpManager.RemoveSwitchBridge(tHDAdpt, 0, MODE_VIDEO);
// 		g_cMpManager.RemoveSwitchBridge(tHDAdpt, 1, MODE_VIDEO);    
// 		g_cMpManager.StopSwitchToPeriEqp(m_byConfIdx, tHDAdpt.GetEqpId(), byChnIdx, MODE_VIDEO);
// 
// 		// fw rtcp
// 		m_ptMtTable->GetMtLogicChnnl(tSrc.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE);
// 		u32 dwDstIp = tLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
// 		u16 wDstPort = tLogicalChannel.GetSndMediaCtrlChannel().GetPort(); 
// 		g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRcvIp, wRcvPort + PORTSPAN * byChnIdx, 
// 			                                dwDstIp, wDstPort);
//         g_cMcuVcApp.ReleaseHDBasChn(tBas.GetEqpId(), byChnIdx);
// 		//StopHDAdapt(tBas, byChnIdx);
// 	}
// 
//     g_cMpManager.StopSwitchToSubMt(tDst, MODE_VIDEO);
// 	// back prs
// 	m_ptMtTable->GetMtLogicChnnl(tDst.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, TRUE);
// 	u32 dwDstIp = tLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
// 	u16 wDstPort = tLogicalChannel.GetSndMediaCtrlChannel().GetPort(); 
// 	g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwDstIp, wDstPort, 
// 			                            dwRcvIp, wRcvPort + PORTSPAN * byChnIdx * 2 + 1);
//  	g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwDstIp, wDstPort, 
// 			                            dwRcvIp, wRcvPort + PORTSPAN * (byChnIdx * 2 + 1) + 1);  
//     //选看标识复位
//     TMt tMtNull;
//     tMtNull.SetNull();
// 
// 	TMtStatus tMtStatus;
//     m_ptMtTable->GetMtStatus(tDst.GetMtId(), &tMtStatus);
//     tMtStatus.RemoveSelByMcsMode(bySelMode);
// 	tMtStatus.SetSelectMt(tMtNull, bySelMode);
// 	m_ptMtTable->SetMtStatus(tDst.GetMtId(), &tMtStatus);
// 
//     m_ptMtTable->SetMtSrc(tDst.GetMtId(), &tMtNull, bySelMode);
// 
//     //交换恢复
// 	if( bIsAfterReleaseCanRestoreRecvBrd )
// 	{
// 		RestoreRcvMediaBrdSrc(tDst.GetMtId(), bySelMode, TRUE);
// 	}
//     
//     //暂不支持PRS
//     if (m_tConf.GetConfAttrb().IsResendLosePack())
//     {
//     }
// 
//     //清除关联项
//     if (!m_cSelChnGrp.RemoveSel(tSrc.GetMtId(), tDst.GetMtId(), MODE_VIDEO))
//     {
//         ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StopHdVidSelAdp] remove sel<src.%d, dst.%d> failed!\n", tSrc.GetMtId(), tDst.GetMtId());
//     }
//     
//     return TRUE;
// }
/*=============================================================================
    函 数 名： ReleaseResbySel
    功    能： 释放tSelDstMt与tSelDstMt选看的终端之间的通道
    算法实现： 
    全局变量： 
    参    数： TMt tSelDstMt
				bIsAfterReleaseCanRestoreRecvBrd 目标终端停止从适配接收码流后是否可以接收广播码流
    返 回 值： void 
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2009/5/23   4.5		    付秀华                  创建
	2010/5/7	4.5		    周晶晶                  bIsAfterReleaseCanRestoreRecvBrd
=============================================================================*/
void CMcuVcInst::ReleaseResbySel(TMt tSelDstMt, u8 bySelMode,BOOL32 bStopDstSwitch /*= TRUE*/)
{
	if (!tSelDstMt.IsLocal())
	{
		tSelDstMt = GetLocalMtFromOtherMcuMt(tSelDstMt);
	}
	TMtStatus tStatus;
	m_ptMtTable->GetMtStatus(tSelDstMt.GetMtId(), &tStatus);
	if (MODE_VIDEO == bySelMode || MODE_BOTH == bySelMode)
	{
 		TMt tVSelMt = tStatus.GetSelectMt(MODE_VIDEO);
		if (!tVSelMt.IsNull() &&
			IsNeedSelAdpt(tVSelMt, tSelDstMt, MODE_VIDEO))
		{
			StopSelAdapt(tVSelMt, tSelDstMt, MODE_VIDEO,bStopDstSwitch);
		}
	}

	if (MODE_AUDIO == bySelMode || MODE_BOTH == bySelMode)
	{
		TMt tASelMt = tStatus.GetSelectMt(MODE_AUDIO);

		if (!tASelMt.IsNull() &&
			IsNeedSelAdpt(tASelMt, tSelDstMt, MODE_AUDIO))
		{
			StopSelAdapt(tASelMt, tSelDstMt, MODE_AUDIO,bStopDstSwitch);
		}	
	}

	if (MODE_VIDEO2SECOND == bySelMode)
	{
		TMt tSecVidSelMt = m_ptMtTable->GetMtSelMtByMode(tSelDstMt.GetMtId(), MODE_VIDEO2SECOND);
		if (!tSecVidSelMt.IsNull() && IsNeedSelAdpt(tSecVidSelMt, tSelDstMt, MODE_VIDEO2SECOND))
		{
			StopSelAdapt(tSecVidSelMt, tSelDstMt, MODE_VIDEO2SECOND,bStopDstSwitch);
		}
	}
}
/*------------------------------------------------------------------*/
/*                                 Mixer                            */
/*------------------------------------------------------------------*/


/*====================================================================
    函数名      ：StartMixing
    功能        ：开始混音
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMixMode 混音模式
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/09    3.0         胡昌威         创建
	10/03/01	4.6			薛亮		   整合8000E
	13/03/18	4.7			国大卫		   支持多格式
====================================================================*/
BOOL32 CMcuVcInst::StartMixing( u8 byMixMode, u8 byEqpId )
{
	TPeriEqpStatus tPeriEqpStatus;
	//音频能力
	TAudioTypeDesc atAudioTypeDesc[MAXNUM_CONF_AUDIOTYPE];
	memset(atAudioTypeDesc, 0, sizeof(atAudioTypeDesc));
	//从会议属性中取出会议支持的音频类型
	u8 byAudioCapNum = m_tConfEx.GetAudioTypeDesc(atAudioTypeDesc);

	if ( byEqpId != 0 )
	{
		g_cMcuVcApp.GetPeriEqpStatus( byEqpId, &tPeriEqpStatus );
		if ( m_tMixEqp.GetEqpId() != 0 ||
			tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byGrpState != TMixerGrpStatus::READY)
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[StartMixing] Conf(%d) is using mixer(%d)!\n", m_byConfIdx, m_tMixEqp.GetEqpId());
			return FALSE;
		} 
	} 
	else
	{
		//20110526_tzy Bug00054628 VCS组呼中使用EAPU混音，有一定概率出现混音器状态为201
		//      当配置了多个混音器，并且某个会议向多个混音器发送了开启混音消息后，会导致混音器状态错误
		if ( VCS_CONF == m_tConf.GetConfSource() && !m_tMixEqp.IsNull() )
		{
			ConfPrint( LOG_LVL_ERROR, MID_MCU_MIXER, "[StartMixing] Can't Start Mixing Secondly, because VCS Conf Has Occupyed a Mixer(%d)!\n", 
				m_tMixEqp.GetEqpId() );
			return FALSE;
		}
		byEqpId = g_cMcuVcApp.GetIdleMixer(0, byAudioCapNum, atAudioTypeDesc);
		if( byEqpId == 0 ) //未找到空闲混音器
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[StartMixing] can't find idle mixer!\n");
			return FALSE;
		}
	}

	if ( !CheckMixerIsValide(byEqpId) )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[StartMixing] can't find idle mixer because CheckMixerIsValide()!\n");
		return FALSE;
	}

	if ( m_tConf.m_tStatus.IsVACing() || m_tConf.m_tStatus.IsMixing() )
	{
		TPeriEqpStatus tPeriStatus;
		g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriStatus);
		u8 byMixerState = tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState;

		if ( byMixerState == TMixerGrpStatus::MIXING)
		{
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[StartMixing] CURRENT MIXER(%d) CONFSTATUS(%d) MIXERSTATE(%d)!\n",
				m_tMixEqp.GetEqpId(), m_tConf.m_tStatus.GetMixerMode(), byMixerState );
			return FALSE;
		}
	}

	m_tMixEqp = g_cMcuVcApp.GetEqp( byEqpId );
	u8 byMixerSubtype = UNKONW_MIXER;
	g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetEqpId(),byMixerSubtype);
	if ((byMixerSubtype == EAPU_MIXER || byMixerSubtype == APU2_MIXER) && byMixMode == mcuVacMix)
	{
		return StartEmixerVac(m_tMixEqp.GetEqpId());
	}

	//tianzhiyong 20100420_tzy 记录当前混音器最大能力
	TMixParam tMixParam;
	tMixParam.SetMtMaxNum( GetMaxMixNum(m_tMixEqp.GetEqpId()) );
	m_tConf.m_tStatus.SetMixerParam(tMixParam);
	m_tMixEqp.SetConfIdx( m_byConfIdx );
	u8 byGrpId = 0;
	m_byMixGrpId = byGrpId;

	//占用混音器
	g_cMcuVcApp.GetPeriEqpStatus( m_tMixEqp.GetEqpId(), &tPeriEqpStatus ); 
	tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpId].m_byGrpMixDepth = GetMaxMixerDepth(byEqpId);
    u8 byMixerGrpState = TMixerGrpStatus::WAIT_BEGIN;

    switch (byMixMode)
    {
    case mcuPartMix:
        byMixerGrpState = TMixerGrpStatus::WAIT_START_SPECMIX;
        break;
    case mcuWholeMix:
        byMixerGrpState = TMixerGrpStatus::WAIT_START_AUTOMIX;
        break;
    case mcuVacMix:
        byMixerGrpState = TMixerGrpStatus::WAIT_START_VAC;
		break;
	case mcuVacWholeMix:
        byMixerGrpState = TMixerGrpStatus::WAIT_START_AUTOMIXANDVAC;
        break;
    default:
        break;
    }

    //先占用,超时后未成功再放弃
	tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[byGrpId].m_byGrpState = byMixerGrpState;
	g_cMcuVcApp.SetPeriEqpStatus( m_tMixEqp.GetEqpId(), &tPeriEqpStatus );
	ConfPrint( LOG_LVL_DETAIL, MID_MCU_MIXER, "[StartMixing] Eqp.%d ConfIdx.%d GrpState.%d!\n",
		   m_tMixEqp.GetEqpId(), m_byConfIdx, byMixerGrpState );

	u8 byAudioType = m_tConf.GetMainAudioMediaType();
    u8 byAudioType2 = m_tConf.GetSecAudioMediaType();
#if !defined(_8KE_) && !defined(_8KH_)
	TMixerStart tMixer;
	tMixer.SetAudioEncrypt(m_tConf.GetMediaKey());
	tMixer.SetAudioMode(byAudioType);
    tMixer.SetSecAudioMode(byAudioType2);
    tMixer.SetIsAllMix(TRUE);  // xsl [8/24/2006] 新的定制混音方案不用再通知当前参与混音的通道
	tMixer.SetMixGroupId(byGrpId);
    tMixer.SetMixDepth(GetMaxMixerDepth(byEqpId));   //zbq [11/22/2007] 给当前的非空混音深度
#else
	T8KEMixerStart tMixer;
	tMixer.SetAudioEncrypt(m_tConf.GetMediaKey());
	tMixer.SetAudioMode(byAudioType);
	tMixer.SetMixGroupId(byGrpId);
	tMixer.SetMixDepth(MAXNUM_MIXER_DEPTH);
#endif
	
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
    if ( tConfAttrb.IsResendLosePack() )
    {
        tMixer.SetIsNeedByPrs(TRUE);
    }
    else
    {
        tMixer.SetIsNeedByPrs(FALSE);
    }

	TDoublePayload tDPayload;
	tDPayload.SetRealPayLoad(byAudioType);
	tDPayload.SetActivePayload(GetActivePayload(m_tConf, byAudioType));

	CServMsg cServMsg;
	cServMsg.SetConfId( m_tConf.GetConfId() );
	cServMsg.SetMsgBody( (u8*)&tMixer, sizeof(tMixer) );
	cServMsg.CatMsgBody( (u8*)&tDPayload, sizeof(tDPayload) );

	//MCU前向纠错, zgc, 2007-09-27
	TCapSupportEx tCapSupportEx = m_tConf.GetCapSupportEx();
	cServMsg.CatMsgBody( (u8*)&tCapSupportEx, sizeof(tCapSupportEx) );
#ifdef _8KH_  //目前只针对8KH混音器外设增加AACLC和AACLD的双声道支持
	u8 byAudioTrackNum = m_tConfEx.GetMainAudioTypeDesc().GetAudioTrackNum();
	cServMsg.CatMsgBody( (u8 *)&byAudioTrackNum, sizeof(u8) );
#else
	cServMsg.CatMsgBody( (u8 *)&byAudioCapNum, sizeof(u8) );
	TAudioCapInfo tAudioCapInfo[MAXNUM_CONF_AUDIOTYPE];
	for (u8 byLoop = 0; byLoop < byAudioCapNum;byLoop++)
	{
		tAudioCapInfo[byLoop].SetAudioMediaType(atAudioTypeDesc[byLoop].GetAudioMediaType());
		tAudioCapInfo[byLoop].SetAudioTrackNum(atAudioTypeDesc[byLoop].GetAudioTrackNum());
		tAudioCapInfo[byLoop].SetActivePayLoad(GetActivePayload(m_tConf, atAudioTypeDesc[byLoop].GetAudioMediaType()));
	}
	cServMsg.CatMsgBody((u8*)&tAudioCapInfo[0], sizeof(TAudioCapInfo)* byAudioCapNum);
#endif
	//开启混音器前，对界面配置的转发板进行判断，若不在线，自动更换新的
	g_cMcuVcApp.ChkAndRefreshMpForEqp(byEqpId);

	//给混音器发开始消息
    SendMsgToEqp( m_tMixEqp.GetEqpId(), MCU_MIXER_STARTMIX_REQ, cServMsg );
	ConfPrint( LOG_LVL_DETAIL, MID_MCU_MIXER, "[StartMixing] AudioType.%d byMixMode[%d]!\n", byAudioType, byMixMode );

	//设置等待应答时钟
	SetTimer( MCUVC_MIX_WAITMIXERRSP_TIMER, g_cMcuVcApp.GetMixerWaitRspTimeout() * 1000);

	return TRUE;
}

/*====================================================================
    函数名      ：StopMixing
    功能        ：停止混音
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/09    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::StopMixing()
{
	TPeriEqpStatus tPeriStatus;
	g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriStatus);
	u8 byMixerState = tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState;
	if ( byMixerState != TMixerGrpStatus::MIXING)
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[StopMixing] CURRENT MIXER(%d) CONFSTATUS(%d) MIXERSTATE(%d)!\n",
			     m_tMixEqp.GetEqpId(),m_tConf.m_tStatus.GetMixerMode(),byMixerState);
		return;
	}

	CServMsg cServMsg;
	cServMsg.SetConfId(m_tConf.GetConfId());
	TMt tmt;

	//拆观众rtcp交换打包
	u8  byAudienceNum = 0;
	TMt atAudienceMt[MAXNUM_CONF_MT];

	//拆混音成员rtcp交换打包
	u8  byMixMemNum = 0;
	TMt atMixMemTMt[MAXNUM_MIXING_MEMBER];

	for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
	{
		if (m_tConfAllMtInfo.MtJoinedConf(byMtId))            
		{
			tmt = m_ptMtTable->GetMt( byMtId );

			TConfAttrb tConfattrb = m_tConf.GetConfAttrb();
			if (tConfattrb.IsResendLosePack())
			{
				if (!m_ptMtTable->IsMtInMixGrp(byMtId))
				{
					atAudienceMt[byAudienceNum] = tmt;
					byAudienceNum ++;
				}
				else
				{
					atMixMemTMt[byMixMemNum] = tmt;
					byMixMemNum ++;
				}
			}
		}
	}

	//打包拆观众rtcp交换
	if (byAudienceNum > 0)
	{
		u8 byPrsId = 0;
		u8 byPrsChnId = 0;
		if (FindPrsChnForBrd(MODE_AUDIO, byPrsId, byPrsChnId))
		{
			AddRemovePrsMember(byAudienceNum, atAudienceMt, byPrsId, byPrsChnId, MODE_AUDIO, FALSE);
		}
	}

	//打包拆混音成员rtcp交换
	if (byMixMemNum > 0)
	{
		AddRemoveMixRtcpMember(byMixMemNum, atMixMemTMt, FALSE);
	}
	u8 byMixerSubtype = UNKONW_MIXER;
	g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetEqpId(),byMixerSubtype);
    if ( m_tConf.m_tStatus.IsVACing() && (byMixerSubtype == EAPU_MIXER || byMixerSubtype == APU2_MIXER))
    {
        cServMsg.SetEventId(MCS_MCU_STOPVAC_REQ);
        MixerVACReq(cServMsg);
		if (m_tMixEqp.IsNull())
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[StopMixing] EMixer is none. So can't stop working\n");
			return;
		}
    }

    u8 byEqpId = m_tMixEqp.GetEqpId();    
    TPeriEqpStatus tPeriEqpStatus;
    g_cMcuVcApp.GetPeriEqpStatus( byEqpId, &tPeriEqpStatus );
    tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState = TMixerGrpStatus::WAIT_STOP;
    g_cMcuVcApp.SetPeriEqpStatus( byEqpId, &tPeriEqpStatus );

	cServMsg.SetMsgBody((u8 *)&m_byMixGrpId, 1);
	SendMsgToEqp(m_tMixEqp.GetEqpId(), MCU_MIXER_STOPMIX_REQ, cServMsg);
    SetTimer(MCUVC_MIX_WAITMIXERRSP_TIMER, g_cMcuVcApp.GetMixerWaitRspTimeout() * 1000);
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "Mixer stop working\n");
	return;
}

/*====================================================================
    函数名      ：SwitchMixMember
    功能        ：混音器交换码流给终端
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt *ptMt 成员终端
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/05/31    3.6         LIBO          创建
    06/08/04    4.0         xsl           增加N模式交换
	10/03/01	4.6			xl			  整合8000E
	13/03/19	4.7			国大卫		  支持多格式
====================================================================*/
void CMcuVcInst::SwitchMixMember(const TMt *ptMt, BOOL32 bNMode/*=false*/)
{
    //过滤音频环回
    TMtStatus tMtStatus;
    m_ptMtTable->GetMtStatus(ptMt->GetMtId(), &tMtStatus);
    if (tMtStatus.IsMediaLoop(MODE_AUDIO))
    {
        return;
    }
	
	//主席终端有音频选听就不能建到主席交换
	if ( *ptMt == m_tConf.GetChairman() &&
		!tMtStatus.GetSelectMt(MODE_AUDIO).IsNull() )
	{
		ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[SwitchMixMember] Can't allow build switch because Chairman's Polling!\n");
		return;
	}
	
    //N模式分散会议通知终端改变接收地址和端口为组播
    /*if ( bNMode && m_tConf.GetConfAttrb().IsSatDCastMode() )
    {
        ChangeSatDConfMtRcvAddr(ptMt->GetMtId(), LOGCHL_AUDIO);
        return;
    }*/

	//MT前向通道信息
	TTransportAddr tAddr;
	TLogicalChannel tLogicalChannel;
	TAudioTypeDesc tAudTypeInfo;
	if ( m_ptMtTable->GetMtLogicChnnl(ptMt->GetMtId(), LOGCHL_AUDIO, &tLogicalChannel, TRUE) )
	{
		tAddr = tLogicalChannel.GetRcvMediaChannel();
		tAudTypeInfo.SetAudioMediaType(tLogicalChannel.GetChannelType());
		tAudTypeInfo.SetAudioTrackNum(tLogicalChannel.GetAudioTrackNum());
	}
	else
	{
		return;
	}

    // xsl [8/19/2006] N模式分散会议通知终端改变接收地址和端口为组播
    if ( bNMode && 
         m_tConf.GetConfAttrb().IsSatDCastMode() && 
         IsMultiCastMt(ptMt->GetMtId()))
    {
        //拆之前N-1交换
        g_cMpManager.StopSwitch(m_byConfIdx, tAddr.GetIpAddr(), tAddr.GetPort());
        ChangeSatDConfMtRcvAddr(ptMt->GetMtId(), LOGCHL_AUDIO);
        m_ptMtTable->SetMtSrc( ptMt->GetMtId(), &m_tMixEqp, MODE_AUDIO );
        return;
    }
	
	u32 dwSwitchIpAddr;
	u16 wSwitchPort;	//src Eqp在转发板上的起始port
	u32 dwMtSwitchIp;
	u16 wMtSwitchPort;
	u32 dwMtSrcIp;
	u32 dwSrcIp;		//src eqpIp
	
	g_cMpManager.GetSwitchInfo(m_tMixEqp, dwSwitchIpAddr, wSwitchPort, dwSrcIp);
	g_cMpManager.GetSwitchInfo(*ptMt, dwMtSwitchIp, wMtSwitchPort, dwMtSrcIp);
	
	//区分不同混音器的N码流接收起始端口
    if (bNMode)
    {
		u8 byMixerSubtype = UNKONW_MIXER;
		g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetEqpId(),byMixerSubtype);
		if ( byMixerSubtype == EAPU_MIXER || byMixerSubtype == APU2_MIXER || byMixerSubtype == MIXER_8KI )
		{
			wSwitchPort += (GetMixerNModeChn() * PORTSPAN + 2);

			//APU2多格式不止一个N通道
			if (byMixerSubtype == APU2_MIXER || byMixerSubtype == MIXER_8KI)
			{
				//根据终端的格式选取N通道号
				u8 byPos = m_tConfEx.GetPosInConfByAudioCap(tAudTypeInfo);
				if (byPos == 0xFF)
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[SwitchMixMember] Mt.%d's MediaType.%d_TrackNum.%d Is Error!Not in AudioTypeInfo\n", 
						ptMt->GetMtId(), tAudTypeInfo.GetAudioMediaType(), tAudTypeInfo.GetAudioTrackNum());
					return;
				}
				wSwitchPort += (byPos * PORTSPAN);
			}

			ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[SwitchMixMember]: EQPID=[%d] NmodeChnIndx=[%d] wSwitchPort=[%d]\n",
				m_tMixEqp.GetEqpId(), GetMixerNModeChn(), wSwitchPort);
		}
		else
		{
			wSwitchPort = wSwitchPort + MAXPORTSPAN_MIXER_GROUP * m_byMixGrpId + 2;
		}	
    }
    else
    {
		TMt tmt = *ptMt;
        wSwitchPort = wSwitchPort + MAXPORTSPAN_MIXER_GROUP * m_byMixGrpId + PORTSPAN * GetMixChnPos(tmt) + 2;
    }
	
	// 语音激励交换：只有终端进混音的交换；没有混音器打出来建给终端的交换
	// 定制混音/会议讨论交换：既有混音成员进混音交换，也存在混音器分格式(N格式/N-1格式)的出交换
    // xsl [7/29/2006] N-1模式只将加入混音组的终端交换回来
	if ( m_tConf.m_tStatus.IsMixing() && 
		(m_ptMtTable->IsMtInMixGrp(ptMt->GetMtId()) && !bNMode || bNMode) 
		)
	{
		// zjj20090911对于VCS组呼会议进行远端静音，则不交换混音器码流给下级MCU
		if ( !((MT_TYPE_SMCU == m_ptMtTable->GetMtType(ptMt->GetMtId())) 
			&& (/*(VCS_CONF == m_tConf.GetConfSource() && m_cVCSConfStatus.IsRemSilence())
			//lukp [02/03/2010] 非VCS会议下如果是下级mcu且此mcu是静音,不做混音器到下级mcu的交换
			||*/ ((VCS_CONF != m_tConf.GetConfSource()) && tMtStatus.IsDecoderMute()))))
		{
			TMt tSrcMt;
			tSrcMt.SetNull();
			u8 bySwitchChannelMode = SWITCHCHANNEL_UNIFORMMODE_NONE;
			u8 byManuId = 0;
			u8 byUniformPayload = INVALID_PAYLOAD;
			byManuId = m_ptMtTable->GetManuId(ptMt->GetMtId());
			if ( byManuId != MT_MANU_KDC && byManuId != MT_MANU_KDCMCU )
			{
				bySwitchChannelMode = SWITCHCHANNEL_UNIFORMMODE_VALID;
				if (tLogicalChannel.GetChannelType() >= AP_MIN && tLogicalChannel.GetChannelType() <= AP_MAX)
				{
					byUniformPayload = tLogicalChannel.GetChannelType();
				}
			}
#if defined(_8KH_) || defined(_8KE_) || defined(_8KI_)//Bug00111781 8000H 过代理终端进混音后再退出混音后就听不到任何声音（混音中还有其他终端）
			dwMtSwitchIp = dwSwitchIpAddr;
			LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_MIXER,"[SwitchMixMember] dwMtSwitchIp =  %s\n",StrOfIP(dwMtSwitchIp));	
#endif
			g_cMpManager.StartSwitch( tSrcMt, m_byConfIdx, dwSrcIp, 0, 
				dwMtSwitchIp, wSwitchPort, tAddr.GetIpAddr(), tAddr.GetPort() ,0,0,bySwitchChannelMode,byUniformPayload,1,TRUE,ptMt->GetMtId());
		}
		
        // guzh [8/31/2006] 设置终端的音频源是混音器
        m_ptMtTable->SetMtSrc( ptMt->GetMtId(), &m_tMixEqp, MODE_AUDIO );
		
        // 清除选看状态
        m_ptMtTable->GetMtStatus(ptMt->GetMtId(), &tMtStatus);
        tMtStatus.RemoveSelByMcsMode(MODE_AUDIO);
        m_ptMtTable->SetMtStatus(ptMt->GetMtId(), &tMtStatus);
	}
	
	return;
}
 
/*====================================================================
    函数名      ：SwitchMixMember
    功能        ：混音器交换码流给终端
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt *ptMt 成员终端
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/05/31    3.6         LIBO          创建
    06/08/04    4.0         xsl           增加N模式交换
	10/03/01	4.6			xl			  整合8000E
	20110505    4.6         pengjie       批量建交换支持
	13/03/18	4.7			国大卫		  支持多格式
====================================================================*/
void CMcuVcInst::SwitchMixMember( BOOL32 bNMode )
{
	u8 byDstMixMtNum = 0;

	u8 abyDstNMtNum[MAXNUM_CONF_AUDIOTYPE];		/*多格式N终端组*/
	memset(&abyDstNMtNum[0], 0, sizeof(abyDstNMtNum));		
	TMt aatDstUnMixMt[MAXNUM_CONF_AUDIOTYPE][MAXNUM_CONF_MT];	/*多格式N终端数*/
	TMt atDstMixMt[MAXNUM_MIXING_MEMBER];

	TSwitchGrp atSwitchGrp[MAXNUM_MIXING_MEMBER];	/*N-1交换组*/
	TSwitchGrp atNSwitchGrp[MAXNUM_CONF_AUDIOTYPE];	/*N交换组*/

	TMtStatus tMtStatus;
	TLogicalChannel tLogicalChannel;	/*前向通道*/
	TMt tCurMt;

	for( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
    {
		if(m_tConfAllMtInfo.MtJoinedConf(byMtId))
		{
			if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
			{
				//过滤vrs新录播
				continue;
			}
			//过滤音频环回
			if (!m_ptMtTable->GetMtStatus(byMtId, &tMtStatus) || tMtStatus.IsMediaLoop(MODE_AUDIO))
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[SwitchMixMember]MT(%d) GetMtStatus() Failed Or IsMediaLoop(%d),So Continue!\n",
					byMtId,tMtStatus.IsMediaLoop(MODE_AUDIO));
				continue;
			}

			//主席终端有音频选听就不能建到主席交换
			if ( m_ptMtTable->GetMt( byMtId ) == m_tConf.GetChairman() &&
				!tMtStatus.GetSelectMt(MODE_AUDIO).IsNull() )
			{
				ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[SwitchMixMember] Can't allow build switch because Chairman's Polling!\n");
				continue;
			}

			// xsl [8/19/2006] N模式分散会议通知终端改变接收地址和端口为组播
			/*if (!m_ptMtTable->IsMtInMixGrp(byMtId) && m_tConf.GetConfAttrb().IsSatDCastMode())
			{
				ChangeSatDConfMtRcvAddr(byMtId, LOGCHL_AUDIO);
				continue;
			}*/

			//获取终端前向通道
			TAudioTypeDesc tAudTypeInfo;
			if (m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_AUDIO, &tLogicalChannel, TRUE))
			{
				tAudTypeInfo.SetAudioMediaType(tLogicalChannel.GetChannelType());
				tAudTypeInfo.SetAudioTrackNum(tLogicalChannel.GetAudioTrackNum());
			}
			else
			{
				continue;
			}

			//当前Mt
			tCurMt = m_ptMtTable->GetMt( byMtId );
			
			// 语音激励交换：只有终端进混音的交换；没有混音器打出来建给终端的交换
			// 定制混音/会议讨论交换：既有混音成员进混音交换，也存在混音器分格式(N格式/N-1格式)的出交换
			// xsl [7/29/2006] N-1模式只将加入混音组的终端交换回来
			if ( m_tConf.m_tStatus.IsMixing() )
			{
				// zjj20090911对于VCS组呼会议进行远端静音，则不交换混音器码流给下级MCU
				if ( !((MT_TYPE_SMCU == m_ptMtTable->GetMtType(byMtId)) 
					&& (/*(VCS_CONF == m_tConf.GetConfSource() && m_cVCSConfStatus.IsRemSilence())
					// lukp [02/03/2010] 非VCS会议下如果是下级mcu且此mcu是静音,不做混音器到下级mcu的交换
					||*/ ((VCS_CONF != m_tConf.GetConfSource()) && tMtStatus.IsDecoderMute())))
					)
				{
					if( !m_ptMtTable->IsMtInMixGrp(byMtId) )	/*非混音终端*/
					{
						u8 byPos = m_tConfEx.GetPosInConfByAudioCap(tAudTypeInfo);
						if (byPos == 0xFF)
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[SwitchMixMember] Mt.%d's MediaType.%d_TrackNum.%d Is Error!Not in AudioTypeInfo\n", 
								byMtId, tAudTypeInfo.GetAudioMediaType(), tAudTypeInfo.GetAudioTrackNum());
							continue;
						}
						aatDstUnMixMt[byPos][abyDstNMtNum[byPos]] = tCurMt;
				        abyDstNMtNum[byPos]++;
					}
					else	/*混音终端*/
					{
						atDstMixMt[byDstMixMtNum] = tCurMt;
						atSwitchGrp[byDstMixMtNum].SetDstMtNum(1);
						atSwitchGrp[byDstMixMtNum].SetDstMt(&atDstMixMt[byDstMixMtNum]);
						atSwitchGrp[byDstMixMtNum].SetSrcChnl(GetMixChnPos(tCurMt));
						byDstMixMtNum++;
					}
				}
				
				m_ptMtTable->SetMtSrc( byMtId, &m_tMixEqp, MODE_AUDIO );
				m_ptMtTable->GetMtStatus(byMtId, &tMtStatus);
				tMtStatus.RemoveSelByMcsMode(MODE_AUDIO);
				m_ptMtTable->SetMtStatus(byMtId, &tMtStatus);
			}
		}
	}

	//设置组信息
	for (u8 byLoop = 0; byLoop < MAXNUM_CONF_AUDIOTYPE; byLoop++)
	{
		if (abyDstNMtNum[byLoop] > 0)
		{
			atNSwitchGrp[byLoop].SetDstMtNum(abyDstNMtNum[byLoop]);
			atNSwitchGrp[byLoop].SetDstMt(aatDstUnMixMt[byLoop]);
			atNSwitchGrp[byLoop].SetSrcChnl(GetMixerNModeChn() + byLoop);
		}
	}

	//批量建交换
	if( bNMode )
	{
		g_cMpManager.StartSwitchToAll( m_tMixEqp, MAXNUM_CONF_AUDIOTYPE, atNSwitchGrp, MODE_AUDIO );
	}
	else
	{
		g_cMpManager.StartSwitchToAll( m_tMixEqp, byDstMixMtNum, atSwitchGrp, MODE_AUDIO );
	}

	return;
}

/*====================================================================
    函数名      ：AddMixMember
    功能        ：增加混音成员
    算法实现    ：通知mixer增加通道，非vac模式将mixer码流交换给mt，建上下行交换
    引用全局变量：
    输入参数说明：const TMt *ptMt 成员终端
                  u8 byVolume 成员音量
                  BOOL32 bForce 是否是强制 
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/09    3.0         胡昌威         创建
	10/03/01	4.6			xl			  整合8000E
====================================================================*/
BOOL32 CMcuVcInst::AddMixMember( const TMt *ptMt, u8 byVolume, BOOL32 bForce )
{
	return AddMixMember( 1,ptMt,byVolume,bForce );
//    是否在音频环回
//        TMtStatus tMtStatus;
//    	if (ptMt == NULL)
//    	{
//    		ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[AddMixMember]ptMt == NULL,So return FALSE!\n");
//    		return FALSE;
//    	}
//    	if ( !m_ptMtTable->GetMtStatus(ptMt->GetMtId(), &tMtStatus) || tMtStatus.IsMediaLoop(MODE_AUDIO))
//    	{
//    		ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[AddMixMember]MT(%d) GetMtStatus() Failed Or IsMediaLoop(%d),So return FALSE!\n",
//    			ptMt->GetMtId(),tMtStatus.IsMediaLoop(MODE_AUDIO));
//    		return FALSE;;
//    	}
//    	if( !m_tConf.m_tStatus.IsSpecMixing() &&
//    		m_ptMtTable->GetManuId(ptMt->GetMtId()) == MT_MANU_CHAORAN)
//    	{
//    		ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[AddMixMember]ChaoRan Mt(%d,%d) Can't Joined Mixer,So Return!\n",
//    			ptMt->GetMcuId(), ptMt->GetMtId());
//    		return FALSE;
//    	}
//        
//    	if(GetMixMtNumInGrp() < GetMaxMixNum(m_tMixEqp.GetEqpId()) ||
//    		(GetMixMtNumInGrp()== GetMaxMixNum(m_tMixEqp.GetEqpId()) && 
//    						m_ptMtTable->IsMtInMixGrp(ptMt->GetMtId())))
//    	{
//    	}
//    	else
//    	{
//    		ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[AddMixMember] current mixing mt num exceed %d, ingnore mt.%d!\n",
//    			GetMaxMixNum(m_tMixEqp.GetEqpId()), ptMt->GetMtId());
//    		return FALSE;
//    	}
//    	TMixMember tMixMember;
//    	memset(&tMixMember, 0, sizeof(tMixMember));
//    	tMixMember.m_byVolume = byVolume;
//    	tMixMember.m_tMember  = *ptMt;
//    	TLogicalChannel tLogicalChannel;
//    	m_ptMtTable->GetMtLogicChnnl(ptMt->GetMtId(), LOGCHL_AUDIO, &tLogicalChannel, FALSE);
//        tMixMember.m_byAudioType = tLogicalChannel.GetChannelType();
//    	u32 dwSwitchIpAddr;
//    	u16 wSwitchPort;
//    	u32 dwMtSwitchIp;
//    	u16 wMtSwitchPort;
//    	u32 dwMtSrcIp;
//    	u32 dwSrcIp;
//    	
//    	g_cMpManager.GetSwitchInfo(m_tMixEqp, dwSwitchIpAddr, wSwitchPort, dwSrcIp);
//    	g_cMpManager.GetSwitchInfo(*ptMt, dwMtSwitchIp, wMtSwitchPort, dwMtSrcIp);
//    	//这里应考虑同一混音器存在多个混音组的情况，源接收端口加以区分
//    	wSwitchPort = wSwitchPort + MAXPORTSPAN_MIXER_GROUP * m_byMixGrpId + PORTSPAN * GetMixChnPos(tMixMember.m_tMember) + 2;
//    	tMixMember.m_tAddr.SetPort(wSwitchPort);
//    	//Rtcp地址填混音器所挂转发板ip，回馈端口填混音器对应通道接收端口+1
//    #if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
//    	u32 dwMixSwitchIp    = 0;
//    	u16 wMixMcuStartPort = 0;
//    	u16 wMixStartPort    = 0;
//    	g_cMpManager.GetSwitchInfo(m_tMixEqp.GetEqpId(), dwMixSwitchIp, wMixMcuStartPort, wMixStartPort);
//    	tMixMember.m_tRtcpBackAddr.SetIpAddr(dwMixSwitchIp);
//    	tMixMember.m_tRtcpBackAddr.SetPort(wMixStartPort + PORTSPAN * GetMixChnPos(tMixMember.m_tMember)+ 2 + 1);
//    	tMixMember.m_tAddr.SetIpAddr(dwSwitchIpAddr);
//    #else
//    	TEqpMixerInfo tEqpMixerInfo;
//    	memset(&tEqpMixerInfo, 0, sizeof(TEqpMixerInfo));
//    	g_cMcuAgent.GetEqpMixerCfg(m_tMixEqp.GetEqpId(), &tEqpMixerInfo);
//    	tMixMember.m_tRtcpBackAddr.SetIpAddr(ntohl(g_cMcuAgent.GetBoardIpAddrFromIdx(tEqpMixerInfo.GetSwitchBrdId())));
//    	tMixMember.m_tRtcpBackAddr.SetPort(tEqpMixerInfo.GetEqpRecvPort() + PORTSPAN * GetMixChnPos(tMixMember.m_tMember) + 2 + 1);
//    	
//    	tMixMember.m_tAddr.SetIpAddr(dwMtSwitchIp);
//    #endif
//    CServMsg cServMsg;
//    	cServMsg.SetConfId(m_tConf.GetConfId());
//    	cServMsg.SetChnIndex(GetMixChnPos(tMixMember.m_tMember));
//    	cServMsg.SetMsgBody((u8*)&m_byMixGrpId, 1);
//    	cServMsg.CatMsgBody((u8*)&tMixMember, sizeof(TMixMember));
//    	cServMsg.CatMsgBody((u8*)&tLogicalChannel.m_byChannelType, sizeof(u8));
//    	//追加音频采样率，目前只针对AACLC以及AACLD音频类型有效
//    	u8 bySampleRate = AAC_SAMPLE_FRQ_32;
//    	cServMsg.CatMsgBody((u8*)&bySampleRate, sizeof(u8));
//    	//解码
//    	TAudioCapInfo tDecAudioCapInfo;
//    	TLogicalChannel tMtSendLogicalChannel;
//    	BOOL32 bGetSndChnl = m_ptMtTable->GetMtLogicChnnl(ptMt->GetMtId(), LOGCHL_AUDIO, &tMtSendLogicalChannel, FALSE);
//    	//编码
//    TAudioCapInfo tEncAudioCapInfo;
//    	TLogicalChannel tMtRcvLogicalChannel;
//    	BOOL32 bGetRcvChnl = m_ptMtTable->GetMtLogicChnnl(ptMt->GetMtId(), LOGCHL_AUDIO, &tMtRcvLogicalChannel, TRUE);
//    	
//    	if ( bGetRcvChnl == FALSE && bGetSndChnl == FALSE)
//    	{
//    		ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[AddMixMember]GetMtLogicChnnl(%d) RcvLogicalChannel and SendLogicalChn  FAILED!\n", ptMt->GetMtId());
//    		return FALSE;
//    	}
//    	tDecAudioCapInfo.SetAudioMediaType(tMtSendLogicalChannel.GetChannelType());
//    	tDecAudioCapInfo.SetAudioTrackNum(tMtSendLogicalChannel.GetAudioTrackNum());
//    	tDecAudioCapInfo.SetActivePayLoad(GetActivePayload(m_tConf,tMtSendLogicalChannel.GetChannelType()));
//    	cServMsg.CatMsgBody((u8*)&tDecAudioCapInfo, sizeof(TAudioCapInfo));
//    	
//    	tEncAudioCapInfo.SetAudioMediaType(tMtRcvLogicalChannel.GetChannelType());
//    	tEncAudioCapInfo.SetAudioTrackNum(tMtRcvLogicalChannel.GetAudioTrackNum());
//    	tEncAudioCapInfo.SetActivePayLoad(GetActivePayload(m_tConf,tMtRcvLogicalChannel.GetChannelType()));
//    	cServMsg.CatMsgBody((u8*)&tEncAudioCapInfo, sizeof(TAudioCapInfo));
//    	if (bForce)
//    	{
//    		ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[AddMixMember] FORCEACTIVE MtId:%d\n", tMixMember.m_tMember.GetMtId());
//    		SendMsgToEqp(m_tMixEqp.GetEqpId(), MCU_MIXER_FORCEACTIVE_REQ, cServMsg);
//            return TRUE;
//    	}
//    	u8 byMixerSubtype = UNKONW_MIXER;
//    	g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetEqpId(), byMixerSubtype);
//        // xsl [7/29/2006] 不在混音组内的mt才加入混音组
//        if ( !m_ptMtTable->IsMtInMixGrp(ptMt->GetMtId()) || byMixerSubtype == APU2_MIXER)
//        {
//            SendMsgToEqp(m_tMixEqp.GetEqpId(), MCU_MIXER_ADDMEMBER_REQ, cServMsg);
//            m_ptMtTable->SetMtInMixGrp(ptMt->GetMtId(), TRUE);
//    		
//    		//20100716_tzy 将该成员“进混音的信息”加入到“会议信息的混音信息”中
//            TMixParam tMixParam = m_tConf.m_tStatus.GetMixerParam();
//            tMixParam.AddMember(ptMt->GetMtId());
//           m_tConf.m_tStatus.SetMixerParam(tMixParam);
//            if (HasJoinedChairman())
//            {
//                CServMsg cServMsgToChairMan;
//                cServMsgToChairMan.SetMsgBody((u8 *)&m_tConf, sizeof(TConfInfo));
//                SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_CONF_NOTIF, cServMsgToChairMan);
//    			// [11/25/2010 xliang] 对T3，R3-full终端还需发下面的消息
//    			CServMsg cServMsgToT3Chairman;
//    		cServMsgToT3Chairman.SetMsgBody((u8 *)&tMixParam, sizeof(tMixParam));
//    		SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_DISCUSSPARAM_NOTIF, cServMsgToT3Chairman );
//            }
//        }
//    	//mqs [06/29/2011] 主席轮询模式下不允许建混音器到主席的音频交换
//    	//zjj20120920 现在改为主席终端有音频选听就不能建到主席交换
//    	if ( *ptMt == m_tConf.GetChairman() &&
//    		!tMtStatus.GetSelectMt(MODE_AUDIO).IsNull() )
//    	{		
//    		ConfPrint( LOG_LVL_WARNING, MID_MCU_MIXER, "[AddMixMember] Can't allow build switch because Chairman's Polling!\n");
//    		return FALSE;
//    	}
//    	// 语音激励交换：只有终端进混音的交换；没有混音器打出来建给终端的交换
//    	// 定制混音/会议讨论交换：既有混音成员进混音交换，也存在混音器分格式(N格式/N-1格式)的出交换
//    	// 此处建定制/讨论模式下，混音器N-1模式的混音器打给混音成员的交换
//    	if (m_tConf.m_tStatus.IsMixing())
//    	{
//    		// zjj20090911对于VCS组呼会议进行远端静音，则不交换混音器码流给下级MCU
//    		if (!((MT_TYPE_SMCU == m_ptMtTable->GetMtType(ptMt->GetMtId())) 
//    			&& (/*(VCS_CONF == m_tConf.GetConfSource() && m_cVCSConfStatus.IsRemSilence())
//    			//lukp [02/03/2010] 非VCS会议下如果是下级mcu且此mcu是静音,不做混音器到下级mcu的交换
//    			||*/ ((VCS_CONF != m_tConf.GetConfSource()) && tMtStatus.IsDecoderMute()))))
//    		{
//    			TMt tSrcMt;
//    			tSrcMt.SetNull();
//    			//zhouyiliang 20120911 增加归一重整的处理
//    			u8 bySwitchChannelMode = SWITCHCHANNEL_UNIFORMMODE_NONE;
//    			u8 byManuId = 0;
//    			u8 byUniformPayload = INVALID_PAYLOAD;
//    			
//    			byManuId = m_ptMtTable->GetManuId(ptMt->GetMtId());
//    			if ( byManuId != MT_MANU_KDC && byManuId != MT_MANU_KDCMCU )
//    			{
//    				bySwitchChannelMode = SWITCHCHANNEL_UNIFORMMODE_VALID;
//    				if (tLogicalChannel.GetChannelType() >= AP_MIN && tLogicalChannel.GetChannelType() <= AP_MAX)
//    				{
//    					byUniformPayload = tLogicalChannel.GetChannelType();
//    				}
//    			}
//    			//建混音器通道---->混音成员终端
//    			//20121128_tzy 终端前向音频接收通道未打开则不需要建从混音器N-1通道到终端交换
//    			if (m_ptMtTable->GetMtLogicChnnl(ptMt->GetMtId(), LOGCHL_AUDIO, &tLogicalChannel, TRUE))
//    			{
//    				g_cMpManager.StartSwitch(tSrcMt, m_byConfIdx, 
//    										dwSrcIp, 0, 
//    										tMixMember.m_tAddr.GetIpAddr(), tMixMember.m_tAddr.GetPort(), 
//    										tLogicalChannel.GetRcvMediaChannel().GetIpAddr(), tLogicalChannel.GetRcvMediaChannel().GetPort(),0,0,bySwitchChannelMode,byUniformPayload,1,TRUE,ptMt->GetMtId());
//    				// xsl [8/19/2006] 分散会议通知终端改变接收地址和端口为单播
//    			if ( m_tConf.GetConfAttrb().IsSatDCastMode() )
//    				{
//    					ChangeSatDConfMtRcvAddr(ptMt->GetMtId(), LOGCHL_AUDIO, FALSE);
//    				}
//    			}
//    			else
//    			{
//    				ConfPrint( LOG_LVL_WARNING, MID_MCU_MIXER, "[AddMixMember] Can't GetMtLogicChnnl(%d) MtRecv,So Return!\n",ptMt->GetMtId());
//    			}
//    		}
//            // guzh [8/31/2006] 设置终端的音频源是混音器
//            m_ptMtTable->SetMtSrc( ptMt->GetMtId(), &m_tMixEqp, MODE_AUDIO );
//            // 清除选看状态
//    	    m_ptMtTable->GetMtStatus(ptMt->GetMtId(), &tMtStatus);
//            tMtStatus.RemoveSelByMcsMode(MODE_AUDIO);
//            m_ptMtTable->SetMtStatus(ptMt->GetMtId(), &tMtStatus);
//    	}
//    	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
//    	if (tConfAttrb.IsResendLosePack())
//    	{	
//    		AddRemoveMixRtcpMember(tMixMember.m_tMember, TRUE);
//    	}
//    	return TRUE;
}

/*====================================================================
    函数名      ：AddMixMember
    功能        ：增加混音成员
    算法实现    ：通知mixer增加通道，非vac模式将mixer码流交换给mt，建上下行交换
    引用全局变量：
    输入参数说明：const u8 byMtNum 终端数量
	              const TMt *ptMt 成员终端
                  u8 byVolume 成员音量
                  BOOL32 bForce 是否是强制 
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/09    3.0         胡昌威         创建
	10/03/01	4.6			xl			  整合8000E
	20110505    4.6         pengjie       批量建交换支持
====================================================================*/
BOOL32 CMcuVcInst::AddMixMember( const u8 byMtNum, const TMt *ptMt, u8 byVolume, BOOL32 bForce )
{
	

	if (byMtNum > MAXNUM_MIXING_MEMBER)
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[AddMixMember]byMtNum(%d) > MAXNUM_MIXING_MEMBER(%d),So return False!\n",
				byMtNum , MAXNUM_MIXING_MEMBER);
		return FALSE;
	}
	TMt atDstMt[MAXNUM_MIXING_MEMBER];
	memcpy(atDstMt, ptMt, sizeof(TMt) * byMtNum);

	u8 bySwitchGrpNum = 0;
	TSwitchGrp atSwitchGrp[MAXNUM_MIXING_MEMBER];

	//建混音成员Rtcp交换终端
	u8  byAddMixMemRtcpNum = 0;
	TMt atAddMixMemMt[MAXNUM_MIXING_MEMBER];
	TMtStatus tMtStatus;
	TMixMember tMixMember;
	TLogicalChannel tLogicalChannel;
	u32 dwSwitchIpAddr;
	u16 wSwitchPort;
	u32 dwMtSwitchIp;
	u16 wMtSwitchPort;
	u32 dwMtSrcIp;
	u32 dwSrcIp;
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
	u32 dwMixSwitchIp    = 0;
	u16 wMixMcuStartPort = 0;
	u16 wMixStartPort    = 0;
#else
	TEqpMixerInfo tEqpMixerInfo;
#endif
	CServMsg cServMsg;
	TMixParam tMixParam;
	for( u8 byLoop = 0; byLoop < byMtNum; byLoop++ )
	{
		//是否在音频环回
		if (!m_ptMtTable->GetMtStatus(atDstMt[byLoop].GetMtId(), &tMtStatus) || tMtStatus.IsMediaLoop(MODE_AUDIO))
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[AddMixMember]MT(%d) GetMtStatus() Failed Or IsMediaLoop(%d),So Continue!\n",
				atDstMt[byLoop].GetMtId(),tMtStatus.IsMediaLoop(MODE_AUDIO));
			continue;
		}
		if( !m_tConf.m_tStatus.IsSpecMixing() &&
			m_ptMtTable->GetManuId(atDstMt[byLoop].GetMtId()) == MT_MANU_CHAORAN)
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[AddMixMember]ChaoRan Mt(%d,%d) Can't Joined Mixer,So Return!\n",
				atDstMt[byLoop].GetMcuId(), atDstMt[byLoop].GetMtId());
			continue;
		}
	    
		if(GetMixMtNumInGrp() < GetMaxMixNum(m_tMixEqp.GetEqpId()) ||
			(GetMixMtNumInGrp()== GetMaxMixNum(m_tMixEqp.GetEqpId()) && 
						m_ptMtTable->IsMtInMixGrp(atDstMt[byLoop].GetMtId())))
		{
		}
		else
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[AddMixMember] current mixing mt num exceed %d, ingnore mt.%d!\n",
				GetMaxMixNum(m_tMixEqp.GetEqpId()), atDstMt[byLoop].GetMtId());
			return FALSE;
		}
		
		
		// xsl [8/19/2006] 分散会议通知终端改变接收地址和端口为单播
		/*if ( m_tConf.GetConfAttrb().IsSatDCastMode() )
		{
			ChangeSatDConfMtRcvAddr(atDstMt[byLoop].GetMtId(), LOGCHL_AUDIO, FALSE);
		}*/

		memset(&tMixMember, 0, sizeof(tMixMember));
		tMixMember.m_byVolume = byVolume;
		tMixMember.m_tMember  = atDstMt[byLoop];
		
		m_ptMtTable->GetMtLogicChnnl(ptMt->GetMtId(), LOGCHL_AUDIO, &tLogicalChannel, FALSE);	
		
		tMixMember.m_byAudioType = tLogicalChannel.GetChannelType();
		g_cMpManager.GetSwitchInfo(m_tMixEqp, dwSwitchIpAddr, wSwitchPort, dwSrcIp);
		g_cMpManager.GetSwitchInfo(atDstMt[byLoop], dwMtSwitchIp, wMtSwitchPort, dwMtSrcIp);
		
		//这里应考虑同一混音器存在多个混音组的情况，源接收端口加以区分
		wSwitchPort = wSwitchPort + MAXPORTSPAN_MIXER_GROUP * m_byMixGrpId + PORTSPAN * GetMixChnPos(tMixMember.m_tMember) + 2;
		
		tMixMember.m_tAddr.SetPort(wSwitchPort);
		
	    //Rtcp地址填混音器所挂转发板ip，回馈端口填混音器对应通道接收端口+1
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
		g_cMpManager.GetSwitchInfo(m_tMixEqp.GetEqpId(), dwMixSwitchIp, wMixMcuStartPort, wMixStartPort);
		tMixMember.m_tRtcpBackAddr.SetIpAddr(dwMixSwitchIp);
		tMixMember.m_tRtcpBackAddr.SetPort(wMixStartPort + PORTSPAN * GetMixChnPos(tMixMember.m_tMember) + 2 + 1);

		tMixMember.m_tAddr.SetIpAddr(dwSwitchIpAddr);
#else
		memset(&tEqpMixerInfo, 0, sizeof(TEqpMixerInfo));
		g_cMcuAgent.GetEqpMixerCfg(m_tMixEqp.GetEqpId(), &tEqpMixerInfo);
		tMixMember.m_tRtcpBackAddr.SetIpAddr( ntohl(g_cMcuAgent.GetBoardIpAddrFromIdx(tEqpMixerInfo.GetSwitchBrdId())) );
		tMixMember.m_tRtcpBackAddr.SetPort(tEqpMixerInfo.GetEqpRecvPort() + PORTSPAN * GetMixChnPos(tMixMember.m_tMember) + 2 + 1);

		tMixMember.m_tAddr.SetIpAddr(dwMtSwitchIp);
#endif
		cServMsg.SetConfId(m_tConf.GetConfId());
		cServMsg.SetChnIndex(GetMixChnPos(tMixMember.m_tMember));
		cServMsg.SetMsgBody((u8*)&m_byMixGrpId, 1);
		cServMsg.CatMsgBody((u8*)&tMixMember, sizeof(TMixMember));
		cServMsg.CatMsgBody((u8*)&tLogicalChannel.m_byChannelType, sizeof(u8));
		//追加音频采样率，目前只针对AACLC以及AACLD音频类型有效
		u8 bySampleRate = AAC_SAMPLE_FRQ_32;
		cServMsg.CatMsgBody((u8*)&bySampleRate, sizeof(u8));

		TAudioCapInfo tDecAudioCapInfo;
		TLogicalChannel tMtSendLogicalChannel;
		BOOL32 bGetSndChnl = m_ptMtTable->GetMtLogicChnnl(ptMt->GetMtId(), LOGCHL_AUDIO, &tMtSendLogicalChannel, FALSE);
		TAudioCapInfo tEncAudioCapInfo;
		TLogicalChannel tMtRcvLogicalChannel;
		BOOL32 bGetRcvChnl = m_ptMtTable->GetMtLogicChnnl(ptMt->GetMtId(), LOGCHL_AUDIO, &tMtRcvLogicalChannel, TRUE);

		if ( bGetRcvChnl == FALSE && bGetSndChnl == FALSE)
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[AddMixMember]GetMtLogicChnnl(%d) RcvLogicalChannel and SendLogicalChn  FAILED!\n", ptMt->GetMtId());
			continue;
		}
		tDecAudioCapInfo.SetAudioMediaType(tMtSendLogicalChannel.GetChannelType());
		tDecAudioCapInfo.SetAudioTrackNum(tMtSendLogicalChannel.GetAudioTrackNum());
		tDecAudioCapInfo.SetActivePayLoad(GetActivePayload(m_tConf,tMtSendLogicalChannel.GetChannelType()));
		cServMsg.CatMsgBody((u8*)&tDecAudioCapInfo, sizeof(TAudioCapInfo));

		tEncAudioCapInfo.SetAudioMediaType(tMtRcvLogicalChannel.GetChannelType());
		tEncAudioCapInfo.SetAudioTrackNum(tMtRcvLogicalChannel.GetAudioTrackNum());
		tEncAudioCapInfo.SetActivePayLoad(GetActivePayload(m_tConf,tMtRcvLogicalChannel.GetChannelType()));
		cServMsg.CatMsgBody((u8*)&tEncAudioCapInfo, sizeof(TAudioCapInfo));

		if (bForce)
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "AddMixMember FORCEACTIVE MtId:%d\n", tMixMember.m_tMember.GetMtId());
			SendMsgToEqp(m_tMixEqp.GetEqpId(), MCU_MIXER_FORCEACTIVE_REQ, cServMsg);
			continue;
		}

		if (!m_ptMtTable->IsMtInMixGrp(atDstMt[byLoop].GetMtId()) || m_tConfEx.IsMultiAudioTypeConf())
		{
			SendMsgToEqp(m_tMixEqp.GetEqpId(), MCU_MIXER_ADDMEMBER_REQ, cServMsg);
			m_ptMtTable->SetMtInMixGrp(atDstMt[byLoop].GetMtId(), TRUE);
			
			// 20100716_tzy 将该成员“进混音的信息”加入到“会议信息的混音信息”中
			tMixParam = m_tConf.m_tStatus.GetMixerParam();
			tMixParam.AddMember(atDstMt[byLoop].GetMtId());
			m_tConf.m_tStatus.SetMixerParam(tMixParam);
		}

		// mqs [06/29/2011] 主席轮询模式下不允许建混音器到主席的音频交换
		//zjj20120920 现在改为主席终端有音频选听就不能建到主席交换
		if ( atDstMt[byLoop] == m_tConf.GetChairman() &&
			!tMtStatus.GetSelectMt(MODE_AUDIO).IsNull() )
		{					
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[AddMixMember] Can't allow build switch because Chairman's Polling!\n");
			continue;
		}
		
		// 语音激励交换：只有终端进混音的交换；没有混音器打出来建给终端的交换
		// 定制混音/会议讨论交换：既有混音成员进混音交换，也存在混音器分格式(N格式/N-1格式)的出交换
	    // 此处建定制/讨论模式下，混音器N-1模式的混音器打给混音成员的交换
		if (m_tConf.m_tStatus.IsMixing())
		{
			if ( !((MT_TYPE_SMCU == m_ptMtTable->GetMtType(atDstMt[byLoop].GetMtId())) 
				&& (/*(VCS_CONF == m_tConf.GetConfSource() && m_cVCSConfStatus.IsRemSilence())
				|| */((VCS_CONF != m_tConf.GetConfSource()) && tMtStatus.IsDecoderMute()))) )
			{
				//20121128_tzy 终端前向音频接收通道未打开则不需要建从混音器N-1通道到终端交换
				if (m_ptMtTable->GetMtLogicChnnl(atDstMt[byLoop].GetMtId(), LOGCHL_AUDIO, &tLogicalChannel, TRUE))
				{
					atSwitchGrp[bySwitchGrpNum].SetSrcChnl(GetMixChnPos(atDstMt[byLoop]));
					atSwitchGrp[bySwitchGrpNum].SetDstMtNum(1);
					atSwitchGrp[bySwitchGrpNum].SetDstMt(&atDstMt[byLoop]);
					bySwitchGrpNum++;
				}
				else
				{
					ConfPrint( LOG_LVL_WARNING, MID_MCU_MIXER, "[AddMixMember] Can't GetMtLogicChnnl(%d) MtRecv,So Return!\n",ptMt->GetMtId());
				}
			}
			
			m_ptMtTable->SetMtSrc( atDstMt[byLoop].GetMtId(), &m_tMixEqp, MODE_AUDIO );
			m_ptMtTable->GetMtStatus(atDstMt[byLoop].GetMtId(), &tMtStatus);
			tMtStatus.RemoveSelByMcsMode(MODE_AUDIO);
			m_ptMtTable->SetMtStatus(atDstMt[byLoop].GetMtId(), &tMtStatus);
		}
		
		//增加混音成员N-1 rtcp交换
		TConfAttrb tTempAttrb = m_tConf.GetConfAttrb();
		if (tTempAttrb.IsResendLosePack())
		{
			atAddMixMemMt[byAddMixMemRtcpNum] = tMixMember.m_tMember;
			byAddMixMemRtcpNum++;
		}
	}
	if (HasJoinedChairman())
	{
		CServMsg cServMsgToChairMan;
		cServMsgToChairMan.SetMsgBody((u8 *)&m_tConf, sizeof(TConfInfo));
		SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_CONF_NOTIF, cServMsgToChairMan);
		
		// [11/25/2010 xliang] 对T3，R3-full终端还需发下面的消息
		CServMsg cServMsgToT3Chairman;
		cServMsgToT3Chairman.SetMsgBody((u8 *)&tMixParam, sizeof(tMixParam));
		SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_DISCUSSPARAM_NOTIF, cServMsgToT3Chairman );
	}
	//批量建混音器到混音成员的N-1音频交换
	if( bySwitchGrpNum > 0 )
	{
		g_cMpManager.StartSwitchToAll( m_tMixEqp, bySwitchGrpNum, atSwitchGrp, MODE_AUDIO, SWITCH_MODE_SELECT );
	}

	//打包建N-1 rtcp交换
	if (byAddMixMemRtcpNum > 0)
	{
		AddRemoveMixRtcpMember(byAddMixMemRtcpNum, atAddMixMemMt, TRUE);
	}

	return TRUE;
}

/*====================================================================
    函数名      ：RemoveMixMember
    功能        ：移除混音成员
    算法实现    ：通知mixer移除通道
    引用全局变量：
    输入参数说明：const TMt *ptMt 成员终端
                  BOOL32 bForce 是否是强制 
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/09    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::RemoveMixMember( const TMt *ptMt, BOOL32 bForce )
{
	TMixMember tMixMember;
	tMixMember.m_byVolume = DEFAULT_MIXER_VOLUME;
	tMixMember.m_tMember  = *ptMt;
	
	TLogicalChannel tLogicalChannel;
	if( m_ptMtTable->GetMtLogicChnnl( ptMt->GetMtId(), LOGCHL_AUDIO, &tLogicalChannel, TRUE ) )
	{
		tMixMember.m_tAddr = tLogicalChannel.GetRcvMediaChannel();	
	}
	tMixMember.m_byAudioType = tLogicalChannel.GetChannelType();
	
	CServMsg cServMsg;
	cServMsg.SetConfId( m_tConf.GetConfId() );
	
	// [20111129 miaoqingsong] 移除混音成员时，倘若混音成员在逻辑通道中，则取实际的逻辑通道号，否则填无效值(Bug00070771)
	if ( IsMtInMixChn(*ptMt) )
	{
		cServMsg.SetChnIndex( GetMixChnPos(tMixMember.m_tMember) );
	} 
	else
	{
		cServMsg.SetChnIndex( VALUE_INVALID );
	}
	
	cServMsg.SetMsgBody( (u8*)&m_byMixGrpId, 1 );
	cServMsg.CatMsgBody( (u8*)&tMixMember, sizeof(TMixMember) );
	
	if( bForce )
	{
		SendMsgToEqp( m_tMixEqp.GetEqpId(), MCU_MIXER_CANCELFORCEACTIVE_REQ, cServMsg );
	}
	else
	{
        // xsl [7/29/2006] 只有在混音组内才移除通道
        if (m_ptMtTable->IsMtInMixGrp(ptMt->GetMtId()))
        {
            SendMsgToEqp( m_tMixEqp.GetEqpId(), MCU_MIXER_REMOVEMEMBER_REQ, cServMsg );
            m_ptMtTable->SetMtInMixGrp(ptMt->GetMtId(), FALSE);
			
			//20100716_tzy 将该成员从会议信息的混音信息中删除
            TMixParam tMixParam = m_tConf.m_tStatus.GetMixerParam();
            tMixParam.DelMember(ptMt->GetMtId());
            m_tConf.m_tStatus.SetMixerParam(tMixParam);
            if (HasJoinedChairman())
            {
                CServMsg cServMsgToChairMan;
                cServMsgToChairMan.SetMsgBody((u8 *)&m_tConf, sizeof(TConfInfo));
                SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_CONF_NOTIF, cServMsgToChairMan);
				
				// [11/25/2010 xliang] 对T3，R3-full终端还需发下面的消息
				CServMsg cServMsgToT3Chairman;
				cServMsgToT3Chairman.SetMsgBody((u8 *)&tMixParam, sizeof(tMixParam));
				SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_DISCUSSPARAM_NOTIF, cServMsgToT3Chairman );
            }
			
			//在停止混音时统一移除上下行Rtcp反馈交换
			//[liu lijiu][20101026]混音成员退出混音器，接收N混音，故应与PRS建立RTCP交换.
			TConfAttrb tTempAttrb = m_tConf.GetConfAttrb();
			if( tTempAttrb.IsResendLosePack() )
			{
				u8 byPrsId = 0;
				u8 byPrsChnId = 0;
				
				if(FindPrsChnForBrd(MODE_AUDIO, byPrsId, byPrsChnId))
				{
					AddRemovePrsMember(tMixMember.m_tMember.GetMtId(), byPrsId, byPrsChnId, MODE_AUDIO, TRUE);
				}				
			}
        }        
	}
	return;
}

/*====================================================================
    函数名      : AddRemoveMixRtcpMember
    功能        ：建立混音成员到其接收的混音通道间的RTCP交换，
	              混音器到终端的RTCP交换（支持打包）
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byDstMtNum   目的终端数
				  TMt *ptDstMt    目的终端
                  BOOL32 IsAdd    是否建交换
    返回值说明  ：void
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    11/05/06    4.0         周嘉麟         创建
====================================================================*/
void CMcuVcInst::AddRemoveMixRtcpMember(u8 byDstMtNum, TMt *ptDstMt, BOOL32 IsAdd )
{
	//若会议不支持丢包重传，直接返回
	TConfAttrb tConfattrb = m_tConf.GetConfAttrb();
	if (!tConfattrb.IsResendLosePack())
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[AddRemoveMixRtcpMember] ERROR: The Con can't support PRS!\n");
		return;
	}

	if (0 == byDstMtNum || NULL == ptDstMt)
	{
		return;
	}

	TTransportAddr  tEqpAddr;
	TTransportAddr  tSrcAddr;
	TTransportAddr  tMapAddr;
	TLogicalChannel tMtRcvLogicalChannel;

	u8 byRtcpMtNum = 0;
	//下行rtcp
	TSwitchChannelExt atMtToEqpRtcpChnExt[MAXNUM_MIXING_MEMBER];

 	//[2011/08/11/zhangli]拆旧的
 	u8 byRemoveMtToEqpNum = 0;
 	TSwitchChannelExt atRemoveMtToEqp[MAXNUM_MIXING_MEMBER];

 	u32 dwOldDstIp = 0;
 	u16 wOldDstPort = 0;

	u8 bySrcChnl = 0;
	TMt tMt;
	for (byRtcpMtNum = 0; byRtcpMtNum < byDstMtNum; byRtcpMtNum++)
	{
		tMt = ptDstMt[byRtcpMtNum];

		if (!m_ptMtTable->IsMtInMixGrp(tMt.GetMtId()))
		{
			continue;
		}
	
		if ( IsMultiCastMt(tMt.GetMtId()) )
		{
			continue;
		}
	
		if(!m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_AUDIO, &tMtRcvLogicalChannel, TRUE))
		{
			continue;
		}
		tSrcAddr = tMtRcvLogicalChannel.GetSndMediaCtrlChannel();
		tMapAddr = tMtRcvLogicalChannel.GetRcvMediaCtrlChannel();

		bySrcChnl = GetMixChnPos(tMt);


		if (!GetRemoteRtcpAddr(m_tMixEqp, bySrcChnl, MODE_AUDIO,tEqpAddr))
		{
			continue;
		}

		//下行rtcp
		atMtToEqpRtcpChnExt[byRtcpMtNum].SetDisIp(0);
		atMtToEqpRtcpChnExt[byRtcpMtNum].SetSrcIp(tSrcAddr.GetIpAddr());
		atMtToEqpRtcpChnExt[byRtcpMtNum].SetRcvIP(tSrcAddr.GetIpAddr());
		atMtToEqpRtcpChnExt[byRtcpMtNum].SetRcvPort(tSrcAddr.GetPort());
		atMtToEqpRtcpChnExt[byRtcpMtNum].SetRcvBindIP(tSrcAddr.GetIpAddr());
		atMtToEqpRtcpChnExt[byRtcpMtNum].SetSndBindIP(tSrcAddr.GetIpAddr());
		atMtToEqpRtcpChnExt[byRtcpMtNum].SetDstIP(tEqpAddr.GetIpAddr());
		atMtToEqpRtcpChnExt[byRtcpMtNum].SetDstPort(tEqpAddr.GetPort());
		atMtToEqpRtcpChnExt[byRtcpMtNum].SetMapIp(tMapAddr.GetIpAddr());
		atMtToEqpRtcpChnExt[byRtcpMtNum].SetMapPort(tMapAddr.GetPort());

		//拆除旧的交换
		dwOldDstIp = 0;
		wOldDstPort = 0;
		m_ptMtTable->GetMtRtcpDstAddr(tMt.GetMtId(), dwOldDstIp, wOldDstPort, MODE_AUDIO);
		if (IsAdd && dwOldDstIp != 0)
		{
			atRemoveMtToEqp[byRemoveMtToEqpNum] = atMtToEqpRtcpChnExt[byRtcpMtNum];
			atRemoveMtToEqp[byRemoveMtToEqpNum].SetDstIP(dwOldDstIp);
			atRemoveMtToEqp[byRemoveMtToEqpNum].SetDstPort(wOldDstPort);
			dwOldDstIp = 0;
			wOldDstPort = 0;
			m_ptMtTable->SetMtRtcpDstAddr(tMt.GetMtId(), 0, 0, MODE_AUDIO);
			byRemoveMtToEqpNum++;
		}
		
		//[2011/08/05/zhangli]记录交换目的端口和IP
		if (IsAdd)
		{
			m_ptMtTable->SetMtRtcpDstAddr(tMt.GetMtId(), tEqpAddr.GetIpAddr(), tEqpAddr.GetPort(), MODE_AUDIO);
		}
	}

	//拆旧的
	if (byRemoveMtToEqpNum > 0)
	{
		g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, byRemoveMtToEqpNum, atRemoveMtToEqp);
	}

	//打包拆除下行rtcp和上行rtcp
	if (byRtcpMtNum > 0)
	{
	   g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, byRtcpMtNum, atMtToEqpRtcpChnExt);
	}

	//打包建立下行rtcp和上行rtcp
	if (IsAdd && byRtcpMtNum > 0)
	{
		g_cMpManager.AddMultiToOneSwitch(m_byConfIdx, byRtcpMtNum, atMtToEqpRtcpChnExt);
	}
	return;
}
/*====================================================================
    函数名      : AddRemoveMixRtcpMember
    功能        ：建立混音成员到其接收的混音通道间的RTCP交换，
	              混音器到终端的RTCP交换
    算法实现    ：
    引用全局变量：
    输入参数说明：TMixMember tMixMember
                  BOOL32 IsAdd
    返回值说明  ：void
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/10/26    4.0         刘利九         create
====================================================================*/
void CMcuVcInst::AddRemoveMixRtcpMember(TMt tMt, BOOL32 IsAdd )
{
	AddRemoveMixRtcpMember( 1,&tMt,IsAdd );
	//若会议不支持丢包重传，直接返回
//	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
//	if (!tConfAttrb.IsResendLosePack())
//	{
//		ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[AddRemoveMixRtcpMember] ERROR: The Con can't support PRS!\n");
//		return;
//	}
//
//	if (!m_ptMtTable->IsMtInMixGrp(tMt.GetMtId()))
//	{
//		return;
//	}
//
//	TTransportAddr  tEqpAddr;
//	TTransportAddr  tSrcAddr;
//	TTransportAddr  tMapAddr;
//	TLogicalChannel tMtRcvLogicalChannel;
//	m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_AUDIO, &tMtRcvLogicalChannel, TRUE);	
//	
//	tSrcAddr = tMtRcvLogicalChannel.GetSndMediaCtrlChannel();
//	tMapAddr = tMtRcvLogicalChannel.GetRcvMediaCtrlChannel();	
//
//	u8 bySrcChnl = GetMixChnPos(tMt);
//
//	//拆除旧的交换
//	u32 dwOldDstIp = 0;
//	u16 wOldDstPort = 0;
//	m_ptMtTable->GetMtRtcpDstAddr(tMt.GetMtId(), dwOldDstIp, wOldDstPort, MODE_AUDIO);
//	if (dwOldDstIp != 0)
//	{
//		g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, tSrcAddr.GetIpAddr(), tSrcAddr.GetPort(), dwOldDstIp, wOldDstPort);
//		m_ptMtTable->SetMtRtcpDstAddr(tMt.GetMtId(), 0, 0, MODE_AUDIO);
//	}
//
//	if (!GetRemoteRtcpAddr(m_tMixEqp, bySrcChnl, MODE_AUDIO, tEqpAddr))
//	{
//		return;
//	}
//
//	//拆除下行RTCP交换
// 	g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, tSrcAddr.GetIpAddr(), tSrcAddr.GetPort(), 
// 		                                 tEqpAddr.GetIpAddr(), tEqpAddr.GetPort());
// 
//	if(IsAdd)
//	{
//		//[2011/08/05/zhangli]记录交换目的端口和IP
//		m_ptMtTable->SetMtRtcpDstAddr(tMt.GetMtId(), tEqpAddr.GetIpAddr(), tEqpAddr.GetPort(), MODE_AUDIO);
//
//		//添加上行Rtcp反馈交换
//		g_cMpManager.AddMultiToOneSwitch(m_byConfIdx, tSrcAddr.GetIpAddr(), 0, tSrcAddr.GetIpAddr(),tSrcAddr.GetPort(), 
//										 tEqpAddr.GetIpAddr(), tEqpAddr.GetPort(), 0, 0, tMapAddr.GetIpAddr(), tMapAddr.GetPort());
//	}

}

/*====================================================================
    函数名      ：GetMixChnPos
    功能        ：获取混音成员通道位置，用于区分交换端口号
    算法实现    ：
    引用全局变量：
    输入参数说明：u8     byMtId
                  BOOL32 bRemove
    返回值说明  ：u8: pos
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/03/19    4.0         张宝卿         创建
====================================================================*/
/*
u8 CMcuVcInst::GetMixChnPos( u8 byMtId, BOOL32 bRemove )
{
    u8 byDstPos = 0;
    if ( byMtId == 0 )
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetMixChnPos] param err: byMtId.%d \n", byMtId );
        return byDstPos;
    }
    
    if ( !bRemove )
    {
        BOOL32 bExist = FALSE;
        u8     byFirstIdle = 0xFF;

        u8 byPos = 0;
        
        for( byPos = 1; byPos < MAXNUM_MIXER_CHNNL+1; byPos++ )
        {
            // guzh [5/12/2007] Find the old one
            if ( byMtId == m_abyMixMtId[byPos])
            {
                bExist = TRUE;
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR,  "[GetMixChnPos] Mt.%d already exist at byPos.%d !\n", byMtId, byPos );
                byDstPos = byPos;
                break;
            }
            else if ( 0 == m_abyMixMtId[byPos] && 0xFF == byFirstIdle ) 
            {
                byFirstIdle = byPos;
            }
        }
        if ( !bExist )
        {
            if ( 0xFF != byFirstIdle )
            {
                m_abyMixMtId[byFirstIdle] = byMtId;
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR,  "[GetMixChnPos] Mt.%d set succeed, byPos.%d !\n", byMtId, byFirstIdle );
                byDstPos = byFirstIdle;
            }
            else
            {
                ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetMixChnPos] Mt.%d set to m_abyMixMtId failed !\n", byMtId );
            }
        }
    }
    else
    {
        BOOL32 bExist = FALSE;
        u8 byPos = 1;
        for( ; byPos < MAXNUM_MIXER_CHNNL+1; byPos++ )
        {
            if ( byMtId == m_abyMixMtId[byPos] )
            {
                m_abyMixMtId[byPos] = 0;
                bExist = TRUE;
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_MPMGR,  "[GetMixChnPos] Mt.%d remve m_abyMixMtId succeed, byPos.%d !\n", byMtId, byPos );
                break;
            }
        }
        if ( !bExist )
        {
            ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetMixChnPos] Mt.%d remve m_abyMixMtId failed !\n", byMtId );
        }
    }
    return byDstPos;
}
*/

/*====================================================================
    函数名      ：NotifyMixerSendToMt
    功能        ：通知混音器往终端发数据
    算法实现    ：
    引用全局变量：
    输入参数说明：BOOL32 bSend 是否发送
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/09    3.0         胡昌威         创建
====================================================================*/
BOOL32 CMcuVcInst::NotifyMixerSendToMt( BOOL32 bSend )
{
	u8 bySend = ( bSend == FALSE ) ? 0 : 1;

	CServMsg cServMsg;
	cServMsg.SetConfId( m_tConf.GetConfId() );
	cServMsg.SetMsgBody( (u8*)&m_byMixGrpId, 1 );
	cServMsg.CatMsgBody( (u8*)&bySend, 1 );

	//给混音器发开始消息
	SendMsgToEqp( m_tMixEqp.GetEqpId() , MCU_MIXER_SEND_NOTIFY, cServMsg );

	return TRUE;
}

/*====================================================================
    函数名      ：NotifyMixerSendToMt
    功能        ：通知混音器往终端发数据
    算法实现    ：
    引用全局变量：
    输入参数说明：BOOL32 bSend 是否发送
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/09    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::SetMixerSensitivity( u8 bySensVal )
{
	u32 dwSens = bySensVal;
	dwSens = htonl( dwSens );

	CServMsg cServMsg;
	cServMsg.SetConfId( m_tConf.GetConfId() );
	cServMsg.SetMsgBody( (u8*)&m_byMixGrpId, 1 );
	cServMsg.CatMsgBody( (u8*)&dwSens, sizeof(u32) );

	//给混音器发开始消息
	SendMsgToEqp( m_tMixEqp.GetEqpId() , MCU_MIXER_VACKEEPTIME_CMD, cServMsg );

	return;
}

/*=============================================================================
    函 数 名： SetMixDelayTime
    功    能： 设置混音延时时间间隔
    算法实现： 
    全局变量： 
    参    数： u16 wDelayTime
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2006/1/10    3.6	    万春雷                  创建
=============================================================================*/
void CMcuVcInst::SetMixDelayTime(u16 wDelayTime)
{
	CServMsg cServMsg;
	cServMsg.SetConfId( m_tConf.GetConfId() );
	cServMsg.SetMsgBody(&m_byMixGrpId, sizeof(u8));
	cServMsg.CatMsgBody((u8*)&wDelayTime, sizeof(u16));

	//给混音器发消息
	SendMsgToEqp( m_tMixEqp.GetEqpId() , MCU_MIXER_CHANGEMIXDELAY_CMD, cServMsg );

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[SetMixDelayTime] MixEqpId :%d, MixGrpId :%d, DelayTime :%u\n", 
		   m_tMixEqp.GetEqpId(), m_byMixGrpId, wDelayTime);

	return;
}

/*====================================================================
    函数名      ：SetMemberVolume
    功能        ：设置成员音量
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt *ptMt 混音成员
	              u8 byVolume 音量
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/09    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::SetMemberVolume( const TMt *ptMt, u8 byVolume )
{
	TMixMember  tMixMember;
	tMixMember.m_byVolume = byVolume;
	tMixMember.m_tMember  = *ptMt;

	TLogicalChannel tLogicalChannel;
	if ( m_ptMtTable->GetMtLogicChnnl( ptMt->GetMtId(), LOGCHL_AUDIO, &tLogicalChannel, TRUE ) )
	{
		tMixMember.m_tAddr = tLogicalChannel.GetRcvMediaChannel();	
	}
	tMixMember.m_byAudioType = tLogicalChannel.GetChannelType();

	CServMsg cServMsg;
	cServMsg.SetConfId( m_tConf.GetConfId() );
    cServMsg.SetChnIndex( GetMixChnPos(tMixMember.m_tMember) );
	cServMsg.SetMsgBody( (u8*)&m_byMixGrpId, 1 );
	cServMsg.CatMsgBody( (u8*)&tMixMember, sizeof(TMixMember) );
	SendMsgToEqp( m_tMixEqp.GetEqpId(), MCU_MIXER_SETCHNNLVOL_CMD, cServMsg );

	return;
}

/*====================================================================
    函数名      ：ProcMixerRspWaitTimer
    功能        ：MCU等待混音器应答超时处理
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/08    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::ProcMixerRspWaitTimer( const CMessage * pcMsg )
{
	// fxh
	KillTimer(MCUVC_MIX_WAITMIXERRSP_TIMER);
	if (m_tMixEqp.IsNull())
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[ProcMixerRspWaitTimer] m_tMixEqp Is Null!\n");
		return;
	}
	TPeriEqpStatus tPeriEqpStatus;
	u8 byMixGrpState;
	g_cMcuVcApp.GetPeriEqpStatus( m_tMixEqp.GetEqpId(), &tPeriEqpStatus );
    byMixGrpState = tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState;
	if (byMixGrpState != TMixerGrpStatus::WAIT_START_VAC &&
		byMixGrpState != TMixerGrpStatus::WAIT_START_SPECMIX &&
		byMixGrpState != TMixerGrpStatus::WAIT_START_AUTOMIX &&
		byMixGrpState != TMixerGrpStatus::WAIT_START_AUTOMIXANDVAC &&
		byMixGrpState != TMixerGrpStatus::WAIT_STOP
		)
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[ProcMixerRspWaitTimer] m_tMixEqp(%d) Status(%d),So Return!\n",
				m_tMixEqp.GetEqpId(),byMixGrpState);
		return;
	}
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[ProcMixerRspWaitTimer] Mixer Wait Timeout!\n");
	
	CServMsg cServMsg(pcMsg->content, pcMsg->length);
	
	switch (CurState())
	{
	case STATE_ONGOING:
		
		//放弃混音组
		tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState = TMixerGrpStatus::READY;
		g_cMcuVcApp.SetPeriEqpStatus( m_tMixEqp.GetEqpId(), &tPeriEqpStatus );

		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[ProcMixerRspWaitTimer] Wait Mixer'rsp Timeout(%d), the Conf Mixer(%d) byMixGrpState(%d)!\n",
			g_cMcuVcApp.GetMixerWaitRspTimeout(), m_tMixEqp.GetEqpId(), byMixGrpState);

		switch(byMixGrpState)
		{
		case TMixerGrpStatus::WAIT_START_SPECMIX:
		case TMixerGrpStatus::WAIT_START_AUTOMIX:
		case TMixerGrpStatus::WAIT_START_AUTOMIXANDVAC:
            {
				CServMsg cServEqpMsg;
				cServEqpMsg.SetConfId(m_tConf.GetConfId());
				cServEqpMsg.SetMsgBody((u8 *)&m_byMixGrpId, 1);

				//  [5/21/2013 guodawei] 混音器开启失败则清除界面
				for ( u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop ++ )
				{
					m_ptMtTable->SetMtInMixing( byLoop,FALSE ,FALSE);
				}
				MtStatusChange(NULL, FALSE);

				SendMsgToEqp(m_tMixEqp.GetEqpId(), MCU_MIXER_STOPMIX_REQ, cServEqpMsg);
			}
			break;

		case TMixerGrpStatus::WAIT_START_VAC:
			// guzh [11/9/2007]
			//NACK
			cServMsg.SetErrorCode( ERR_MCU_TIMEROUT );
			SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );

			//lukp[12/07/2009] 发送主席停止语音激励(之前回start的ACK或Notify了)
			if (HasJoinedChairman())
			{
				SendMsgToMt( m_tConf.GetChairman().GetMtId(), MCU_MT_STOPVAC_NOTIF, cServMsg );
			}
			break;
		case TMixerGrpStatus::WAIT_STOP:
			ProcMixStopSucRsp();			
		    break;
		default:
		    break;
		}
		
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[ProcMixerRspWaitTimer] Mixer Wait Timeout(%d),So Clear The Conf Mixer(%d)!\n",
		         g_cMcuVcApp.GetMixerWaitRspTimeout(),m_tMixEqp.GetEqpId());
		
		g_cMcuVcApp.GetPeriEqpStatus( m_tMixEqp.GetEqpId(), &tPeriEqpStatus );
		if (!m_tMixEqp.IsNull() && tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState == TMixerGrpStatus::READY)
		{
			m_tMixEqp.SetNull();
			m_byMixGrpId = 0;
		}

		break;

	default:

		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMixerRspWaitTimer] Wrong message %u(%s) received in state %u!\n",
			     pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState());
		break;
	}

	return;
}

/*====================================================================
    函数名      ：ProcMixerMcuRsp
    功能        ：混音器回应MCU消息处理函数
    算法实现    ：.
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/09    3.0         胡昌威        创建
	06/02/17	4.0			张宝卿		  混音状态恢复保护
    06/04/20	4.0			张宝卿		  停止混音后恢复选看状态
====================================================================*/
void CMcuVcInst::ProcMixerMcuRsp(const CMessage * pcMsg)
{
	CServMsg       cServMsg(pcMsg->content, pcMsg->length);	
	TPeriEqpStatus tPeriEqpStatus;
	TMt            tMt;
	u8             byMixGrpState;
	u8             byMtId;
	TMixMember     tMixMember;

	TMt tSpeakerMt = GetLocalSpeaker();
	BOOL32 bSpeakerFirst = FALSE;

	switch (CurState())
	{
	case STATE_ONGOING:

		switch (pcMsg->event)
		{
		case MIXER_MCU_STARTMIX_ACK:        //同意开始使用混音器应答
			{
				//设置参数
				g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
				byMixGrpState = tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState;
				BOOL32 bIsStartVac = (byMixGrpState == TMixerGrpStatus::WAIT_START_AUTOMIXANDVAC ? TRUE : FALSE) ;
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[MIXER_MCU_STARTMIX_ACK] Eqp.%d MixGrpState.%d\n", 
					m_tMixEqp.GetEqpId(), byMixGrpState);
				if (bIsStartVac) 
				{
					byMixGrpState = TMixerGrpStatus::WAIT_START_AUTOMIX;
				}
				//20101216_tzy 状态保护，只有以下状态时才能继续，否则返回
				if (byMixGrpState != TMixerGrpStatus::WAIT_START_VAC 
					&& byMixGrpState != TMixerGrpStatus::WAIT_START_SPECMIX
					&& byMixGrpState != TMixerGrpStatus::WAIT_START_AUTOMIX)
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[ProcMixerMcuRsp] MIXER_MCU_STARTMIX_ACK Eqp.%d Current MixGrpState.%d, so return\n", 
						m_tMixEqp.GetEqpId(), byMixGrpState);
					return;
				}
				//清除定时
				KillTimer(MCUVC_MIX_WAITMIXERRSP_TIMER);
				tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState = TMixerGrpStatus::MIXING;
				tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpId = m_byMixGrpId;
				tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byConfId = m_byConfIdx;
				g_cMcuVcApp.SetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
				
				//改变会议状态
				if (byMixGrpState == TMixerGrpStatus::WAIT_START_VAC)
				{
					m_tConf.m_tStatus.SetVACing();
					//通知主席及所有会控
					SendMsgToAllMcs(MCU_MCS_STARTVAC_NOTIF, cServMsg);
					
					//lukp[12/07/2009] 由于MCU_MT_STARTVAC_NOTIF 与 MCU_MT_STARTVAC_ACK回给mt的消息一样
					//之前在MixerVACReq中已经发过，此处注掉
					// 				if (HasJoinedChairman())
					// 				{
					// 					SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_STARTVAC_NOTIF, cServMsg);
					// 				}
					
					//通知混音器停止向终端发码流
					NotifyMixerSendToMt(FALSE);
					
				}
				else//混音及讨论
				{
					if (byMixGrpState == TMixerGrpStatus::WAIT_START_SPECMIX)
					{
						m_tConf.m_tStatus.SetSpecMixing();
					}
					else
					{
						m_tConf.m_tStatus.SetAutoMixing();
						//[chendaiwei 2010/09/28]N+1通知备端智能混音状态更新
						if( MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
						{
							ProcNPlusAutoMixUpdate(TRUE);
						}
					}
					
					TMcu tMcu;
					tMcu.SetMcuId(LOCAL_MCUID);
					cServMsg.SetMsgBody( (u8 *)&tMcu, sizeof(tMcu) ); 
					u8 byMixDepth = GetMaxMixerDepth(m_tMixEqp.GetEqpId());
					cServMsg.CatMsgBody( (u8*)&byMixDepth, 1 );
					if (!m_tCascadeMMCU.IsNull())
					{
						cServMsg.SetDstMtId( m_tCascadeMMCU.GetMtId() );
						SendMsgToMt(m_tCascadeMMCU.GetMtId(),  MCU_MCU_STARTMIXER_NOTIF, cServMsg);
					}
					
					NotifyChairmanMixMode();
					
					ChangeAudBrdSrc(&m_tMixEqp);  // 在定制混音或会议讨论模式下，广播源是混音器               
				}
				
				//混音状态通知,通知主席及所有会控
				MixerStatusChange();
				
				SetMixerSensitivity(m_tConf.GetTalkHoldTime());
				
				//lukp[02/05/2010]发言人必须先进混音通道
				//否则，先托发言人后语音激励，混音器收到第一路码流
				//会直接设成发言人，从而替换掉之前的发言人
				//这样就违背了语音激励的逻辑(先前发言人在说话，不能被替换原则)
				if (!tSpeakerMt.IsNull() 
					&& m_tConf.m_tStatus.IsVACing()
					&& m_tConf.m_tStatus.IsNoMixing())
				{
					AddMixMember(&tSpeakerMt, DEFAULT_MIXER_VOLUME, FALSE);
					bSpeakerFirst = TRUE;
				}
				
				u8 byInMixetMtNum = 0;
				TMt atInMixetMt[MAXNUM_MIXING_MEMBER];
				// xsl [8/4/2006] 添加混音成员, 交换码流给混音器		
				for (byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
				{
					if (m_tConfAllMtInfo.MtJoinedConf(byMtId))
					{
						if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
						{
							continue;
						}
						tMt = m_ptMtTable->GetMt(byMtId);    
						
						//  [12/2/2009 pengjie] Modify 级联多回传支持
						if ((!m_tConf.m_tStatus.IsSpecMixing() ||
							(m_tConf.m_tStatus.IsSpecMixing() && m_ptMtTable->IsMtInMixing(byMtId)))
							&& GetCurMixerNum() < GetMaxMixNum(m_tMixEqp.GetEqpId()))
						{
							//非发言人或者 非发言人优先
							if (!(tMt == tSpeakerMt) || ((tMt == tSpeakerMt) && !bSpeakerFirst))						
							{
								//通知mixer增加通道，非vac模式将mixer码流交换给mt，建上下行交换                
								//AddMixMember(&tMt, DEFAULT_MIXER_VOLUME, FALSE);
								atInMixetMt[byInMixetMtNum] = tMt;
								byInMixetMtNum++;
							}
							StartSwitchToPeriEqp(tMt, 0, m_tMixEqp.GetEqpId(), 
								(MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+GetMixChnPos(tMt)), 
								MODE_AUDIO, SWITCH_MODE_SELECT);
							//                        byMixMtNum++;
						}
						else
						{
							ConfPrint( LOG_LVL_WARNING, MID_MCU_MIXER, "[ProcMixerMcuRsp]IsSpecMixing(%d) CurMixerNum(%d) MixerMaxNum(%d)\n",
								m_tConf.m_tStatus.IsSpecMixing(),GetCurMixerNum(),GetMaxMixNum(m_tMixEqp.GetEqpId()));
						}
						
// 						//定制混音不在混音列表中听N模式声音
// 						if (m_tConf.m_tStatus.IsSpecMixing() && !m_ptMtTable->IsMtInMixing(byMtId))
// 						{
// 							SwitchMixMember(&tMt, TRUE);
// 						}
						if (m_tConf.m_tStatus.IsAutoMixing() && 
							m_ptMtTable->GetManuId(tMt.GetMtId()) == MT_MANU_CHAORAN)
						{
							SwitchMixMember(&tMt, TRUE);
						}
					}           
				}
				
				if( byInMixetMtNum > 0 )
				{
					AddMixMember( byInMixetMtNum, atInMixetMt, DEFAULT_MIXER_VOLUME, FALSE );
				}
				
				if (m_tConf.m_tStatus.IsSpecMixing() )
				{
					SwitchMixMember( TRUE );
				}
				
                u8 bySrcChnnl = GetMixerNModeChn();
				// xsl [8/19/2006] 如果是n模式分散会议需要交换到组播地址
                //[1/21/2013 zhushengze]语音激励不建N模式到组播地址交换
				if (m_tConf.GetConfAttrb().IsSatDCastMode() && byMixGrpState != TMixerGrpStatus::WAIT_START_VAC)
                {
                    g_cMpManager.StartDistrConfCast(m_tMixEqp, MODE_AUDIO, bySrcChnnl);
                }
                                
                
				
				// guzh [11/7/2007] 
				//在混音状态置位后再发起语音激励
				if ( m_byLastMixMode == mcuVacMix )
				{
					CServMsg cTempServMsg;				
					cTempServMsg.SetEventId(MCS_MCU_STARTVAC_REQ);				
					MixerVACReq(cTempServMsg);
					//上次混音器的工作情况恢复到此为止
					m_byLastMixMode = mcuNoMix;
				}
				
				if (m_tConf.m_tStatus.IsMixing())
				{
					//通知混音器开始向终端发码流
					NotifyMixerSendToMt(TRUE);
				}
				
				if (m_tConf.m_tStatus.IsSpecMixing() && !m_tCascadeMMCU.IsNull())
				{
					OnNtfMtStatusToMMcu( m_tCascadeMMCU.GetMtId());
				}
				MtStatusChange(NULL, TRUE);
				if (bIsStartVac) 
				{
					CServMsg cTempServMsg;				
					cTempServMsg.SetEventId(MCS_MCU_STARTVAC_REQ);				
					MixerVACReq(cTempServMsg);
				}
				g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
				cServMsg.SetMsgBody((u8 *)&tPeriEqpStatus, sizeof(tPeriEqpStatus));
				SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);

				NotifyAllSMcuMediaInfo( 0,MODE_AUDIO );
			}
			break;

		case MIXER_MCU_STOPMIX_ACK:         //同意停止混音应答	
			
			//20110107_tzy Bug00041692 先进行状态判断，状态正常之后再杀掉定时器，否则先干掉定时器，
			//如果之后判断状态不正常，那么状态机便不能正常翻转了。
			// 检测状态机
			/*if ((m_tConf.m_tStatus.IsVACing() || m_tConf.m_tStatus.IsMixing()) &&
				!m_tMixEqp.IsNull())
			{*/
			{
			
				TPeriEqpStatus tPeriStatus;
				g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriStatus);
				if (tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState != TMixerGrpStatus::WAIT_STOP)
				{
					ConfPrint( LOG_LVL_ERROR, MID_MCU_MIXER, "[CMcuVcInst%d] [ProcMixerMcuRsp] ERROR: stop mix(%d) ack recv at wrong state(%d)\n", 
						   GetInsID(), m_tMixEqp.GetMtId(), tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState );
					return;
				}
			}
            // fxh 清除定时器
			KillTimer(MCUVC_MIX_WAITMIXERRSP_TIMER);
            ProcMixStopSucRsp();
			break;
			

		case MIXER_MCU_ADDMEMBER_ACK:       //加入成员应答消息

			tMixMember =  *((TMixMember*)(cServMsg.GetMsgBody() + sizeof(u8)));
			if (tMixMember.m_tMember == GetLocalSpeaker() && !m_tConf.m_tStatus.IsNoMixing())//强制混音
			{
				AddMixMember(&tMixMember.m_tMember, DEFAULT_MIXER_VOLUME, TRUE);
			}
			break;

		case MIXER_MCU_REMOVEMEMBER_ACK:    //删除成员应答消息

			tMixMember =  *((TMixMember*)(cServMsg.GetMsgBody() + sizeof(u8)));
			if (tMixMember.m_tMember == GetLocalSpeaker())// xsl [8/4/2006]强制混音(此时终端可能已经不是发言人)
			{
				RemoveMixMember(&tMixMember.m_tMember, TRUE);
			}
			break;

		case MIXER_MCU_FORCEACTIVE_ACK:     //强制成员混音应答

			break;

		case MIXER_MCU_CANCELFORCEACTIVE_ACK:    //取消成员强制混音应答

			break;

		case MIXER_MCU_ADDMEMBER_NACK:      //加入成员应答消息
		case MIXER_MCU_REMOVEMEMBER_NACK:   //删除成员应答消息
		case MIXER_MCU_FORCEACTIVE_NACK:    //强制成员混音拒绝
		case MIXER_MCU_CANCELFORCEACTIVE_NACK:   //取消成员强制混音拒绝
		case MIXER_MCU_STARTMIX_NACK:       //拒绝开始混音应答
		case MIXER_MCU_STOPMIX_NACK:        //拒绝停止混音应答
		case MIXER_MCU_SETMIXDEPTH_NACK:    //设置混音深度拒绝消息
			break;

		default:
			ConfPrint( LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMixerMcuRsp] Wrong message %u(%s) received in state %u!\n", 
					pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
			break;
		}

		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMixerMcuRsp] Wrong message %u(%s) received in state %u!\n", 
				pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState());
		break;
	}

	return;
}

/*=============================================================================
  函 数 名： MixerStatusChange
  功    能： 混音状态通知, 通知所有会控和主席
  算法实现： 
  全局变量： 
  参    数： void
  返 回 值： void 
  ----------------------------------------------------------------------
  修改记录    ：
  日  期      版本        修改人        修改内容
  07/11/07	  4.0		  顾振华		调整为所有混音器状态的变更通知
=============================================================================*/
void CMcuVcInst::MixerStatusChange(void)
{    
    //TMcu tMcu;
    //tMcu.SetMcuId(LOCAL_MCUID);
    
    CServMsg cServMsg;
    //cServMsg.SetMsgBody( (u8 *)&tMcu, sizeof(tMcu) ); 
    u8 byMixerMode = m_tConf.m_tStatus.GetMixerMode();
    cServMsg.SetMsgBody( &byMixerMode, sizeof(u8));
    SendMsgToAllMcs(MCU_MCS_MIXPARAM_NOTIF, cServMsg);
    
    // guzh [11/7/2007] 是否可以省略？
    //SendConfInfoToChairMt();

    ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[MixerStatusChange] MixerMode: %d\n", byMixerMode );
    return;
}

/*====================================================================
    函数名      ：ProcMixerMcuRsp
    功能        ：混音器给MCU通知消息处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/09    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::ProcMixerMcuNotif(const CMessage * pcMsg)
{
    if (STATE_ONGOING != CurState())
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMixerMcuNotif] Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState());
        return;
    }
    
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
    u8 *pbyVACMember;
    u8 byMtId;
    TPeriEqpStatus tPeriEqpStatus;
    TMixerGrpStatus tMixerGrpStatus;
    TEqp tEqp;
    u8   byExciteChn;
    TPeriEqpRegReq tRegReq;

    switch (pcMsg->event)
    {
    case MIXER_MCU_ACTIVEMMBCHANGE_NOTIF:  //混音激励成员改变通知
		
        //得到讨论成员
        pbyVACMember = (u8 *)cServMsg.GetMsgBody();       
		
        byExciteChn = *(pbyVACMember + MAXNUM_MIXER_DEPTH);
        if (byExciteChn > 0 && byExciteChn <= MAXNUM_CONF_MT)
        {
            m_tVacLastSpeaker = m_ptMtTable->GetMt(byExciteChn);
        }
		
        //语音激励控制改变
        VACChange(m_tConf.m_tStatus.m_tMixParam, byExciteChn);
		
        break;
		
    case MIXER_MCU_CHNNLVOL_NOTIF:      //某通道音量通知消息   			
        break;
		
    case MIXER_MCU_GRPSTATUS_NOTIF:     //混音组状态通知
        tMixerGrpStatus = *(TMixerGrpStatus *)cServMsg.GetMsgBody();
		
        if (tMixerGrpStatus.m_byGrpId == m_byMixGrpId)
        {
			if (!m_tMixEqp.IsNull())
			{
				TMixerGrpStatus tOldMixerGrpStatus;
				g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
				tOldMixerGrpStatus = tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId];
				tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId] = tMixerGrpStatus;
				tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpId = tOldMixerGrpStatus.m_byGrpId;
				tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpMixDepth = tOldMixerGrpStatus.m_byGrpMixDepth;
				tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byConfId = m_byConfIdx;
				// guzh [11/9/2007] 业务负责切换
				tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState = tOldMixerGrpStatus.m_byGrpState;
				g_cMcuVcApp.SetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
				cServMsg.SetMsgBody((u8 *)&tPeriEqpStatus, sizeof(tPeriEqpStatus));
				SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);				
			}
        }
		
        break;
		
    case MIXER_MCU_MIXERSTATUS_NOTIF:
        {

            break;
        }
		
    case MCU_MIXERCONNECTED_NOTIF:   //混音器建链成功通知
		{
            tRegReq = *(TPeriEqpRegReq *)cServMsg.GetMsgBody();
			
            tEqp.SetMcuEqp((u8)tRegReq.GetMcuId(), tRegReq.GetEqpId(), tRegReq.GetEqpType());
			//VCS单方调度下未开启一键混音，则不用恢复
			if (VCS_CONF == m_tConf.GetConfSource() && m_cVCSConfStatus.GetCurVCMode() == VCS_SINGLE_MODE
				&& !m_cVCSConfStatus.GetMtInTvWallCanMixing())
			{
				return;
			}
			if ( !m_tMixEqp.IsNull() )
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[ProcMixerMcuNotif]m_tMixEqp(%d) So Return!!\n",m_tMixEqp.GetEqpId()); 
				return;
			}
			if (m_byLastMixMode == mcuNoMix)
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[ProcMixerMcuNotif]m_byLastMixMode == mcuNoMix So Return!!\n",m_tMixEqp.GetEqpId()); 
				return;
			}
			if (RestoreMixingByOtherMixer(m_byLastMixMode))
			{
				u8 byLoop = 0;
				//主席，当前调度终端，画面合成终端，如果开启了电视墙一键混音还要考虑电视墙中终端
				if (VCS_CONF == m_tConf.GetConfSource())
				{
					for( byLoop = 1;byLoop <= MAXNUM_CONF_MT; ++byLoop )
					{
						m_ptMtTable->SetMtInMixing(byLoop,FALSE,TRUE);
					}
					m_ptMtTable->SetMtInMixing(m_tConf.GetChairman().GetMtId(),TRUE,TRUE);
					m_ptMtTable->SetMtInMixing(GetLocalMtFromOtherMcuMt(m_cVCSConfStatus.GetCurVCMT()).GetMtId(),TRUE,TRUE);
					TMt tMt;
					//遍历VMP通道
					if( m_cVCSConfStatus.GetCurVCMode() == VCS_GROUPVMP_MODE ||
						m_cVCSConfStatus.GetCurVCMode() == VCS_MULVMP_MODE)
					{
						TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
						for (u8 byMemberIdx = 0; byMemberIdx < tVmpParam.GetMaxMemberNum() ; byMemberIdx++)
						{
							tMt.SetNull();
							tMt = GetLocalMtFromOtherMcuMt(*(TMt*)tVmpParam.GetVmpMember(byMemberIdx));
							if (!tMt.IsNull() && !m_ptMtTable->IsMtInMixing(tMt.GetMtId()))
							{
								m_ptMtTable->SetMtInMixing(tMt.GetMtId(),TRUE,TRUE);
							}
						}
					}
					//开启一键混音的话，遍历HDU通道
					if (m_cVCSConfStatus.GetMtInTvWallCanMixing())
					{
						const u8 byMaxTvwChnnlNum = MAXNUM_HDUBRD * MAXNUM_HDU_CHANNEL + MAXNUM_PERIEQP_CHNNL * MAXNUM_MAP;
						CConfTvwChnnl acTvwChnnlFind[byMaxTvwChnnlNum];	
						const u8 byTvwChnnlNum = GetAllCfgedTvwChnnl( acTvwChnnlFind, byMaxTvwChnnlNum );
						TTvwMember tTvwMember;
						for ( byLoop = 0; byLoop < byTvwChnnlNum; ++byLoop )
						{
							tTvwMember = acTvwChnnlFind[byLoop].GetMember();
							if( !IsVcsTvwMemberType( tTvwMember.byMemberType ) 
								|| ( tTvwMember.GetConfIdx() && tTvwMember.GetConfIdx() != m_byConfIdx) )
							{
								ConfPrint( LOG_LVL_WARNING, MID_MCU_EQP, "[RestoreMixingByOtherMixer]The chnnl Member of Conf Hdu Chnnl.%d is invalid\n", byLoop);
								continue;
							}
							if ( 0 == g_cMcuVcApp.GetChnnlMMode(acTvwChnnlFind[byLoop].GetEqpId(), acTvwChnnlFind[byLoop].GetChnnlIdx()) 
								|| !m_tConfAllMtInfo.MtJoinedConf(tMt))
							{
								ConfPrint( LOG_LVL_WARNING, MID_MCU_EQP, "[RestoreMixingByOtherMixer]The chnnl(%d,%d)'s MODE Is 0\n",
									acTvwChnnlFind[byLoop].GetEqpId(),acTvwChnnlFind[byLoop].GetChnnlIdx());
								continue;
							}
							tMt.SetNull();
							tMt = GetLocalMtFromOtherMcuMt((TMt)tTvwMember);
							if (!tMt.IsNull() && !m_ptMtTable->IsMtInMixing(tMt.GetMtId()))
							{
								m_ptMtTable->SetMtInMixing(tMt.GetMtId(),TRUE,TRUE);
							}
						}
					}
				}
			}
			break;
		}
		
    case MCU_MIXERDISCONNECTED_NOTIF:   //混音器断链通知
		{
			tEqp = *(TEqp *)cServMsg.GetMsgBody();
			TMt tmt;
			
			//否是本会议的混音器断链
			if (tEqp.GetEqpId() != m_tMixEqp.GetEqpId())
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[ProcMixerMcuNotif]tEqp.GetEqpId(%d) != m_tMixEqp.GetEqpId(%d),So Return!\n",
					tEqp.GetEqpId(),m_tMixEqp.GetEqpId());    
				return;
			}
			
			// guzh [11/7/2007] 保存混音器工作参数，混音终端列表则不清空，仅清TMtStatus
			m_byLastMixMode = m_tConf.m_tStatus.GetMixerMode();
			if (m_byLastMixMode == mcuNoMix)
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[ProcMixerMcuNotif]m_byLastMixMode == mcuNoMix,So Return!\n");    
				return;
			}
			
			//20110816 zjl 先保留byMixMode
			/*u8 byMixMode = mcuNoMix;
			if( m_tConf.m_tStatus.IsAutoMixing() )
			{
				byMixMode =  mcuWholeMix;
			}
			else if( m_tConf.m_tStatus.IsSpecMixing() )
			{
				byMixMode = mcuPartMix;
			}
			else if( m_tConf.m_tStatus.IsVACing())
			{
				byMixMode = mcuVacMix;
			}*/

			//改变会议状态
			if (m_tConf.m_tStatus.IsVACing())
			{
				//通知主席及所有会控
				SendMsgToAllMcs(MCU_MCS_STOPVAC_NOTIF, cServMsg);
				if (HasJoinedChairman())
				{
					SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_STOPVAC_NOTIF, cServMsg);
				}
				//停止向混音器交换数据，并恢复收听广播源
				for (byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
				{
					if(m_tConfAllMtInfo.MtJoinedConf(byMtId))            
					{
						if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
						{
							continue;
						}
						tmt = m_ptMtTable->GetMt( byMtId );
						StopSwitchToPeriEqp(m_tMixEqp.GetEqpId(), 
							(MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+GetMixChnPos(tmt)), FALSE, MODE_AUDIO);
						
						// xsl [7/29/2006]
						m_ptMtTable->SetMtInMixGrp(byMtId, FALSE);
					}
				}
			}
			
			if(m_tConf.m_tStatus.IsMixing())//混音(讨论)
			{
				//通知主席及所有会控 
				TMcu tMcu;
				tMcu.SetMcuId(LOCAL_MCUID);
				cServMsg.SetMsgBody((u8 *)&tMcu, sizeof(tMcu));
				if (!m_tCascadeMMCU.IsNull())
				{
					cServMsg.SetDstMtId(m_tCascadeMMCU.GetMtId());
					SendMsgToMt(m_tCascadeMMCU.GetMtId(), MCU_MCU_STOPMIXER_NOTIF, cServMsg);
				}
				if (HasJoinedChairman())
				{
					//20101213_tzy 添加混音模式字段
					u8 byMode = mcuNoMix;
					cServMsg.SetMsgBody(&byMode, sizeof(byMode));
					SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_STOPDISCUSS_NOTIF, cServMsg);
				}
				
				//停止向混音器交换数据，并恢复收听广播源
				TMixParam tMixParam = m_tConf.m_tStatus.GetMixerParam();
				
				/*/20110816 zjl 注掉部分没用，下面逻辑先ClearAllMembers，
							相当于清零，再遍历与会混音终端，增加到MixParam中以便恢复*/

				//zbq[04/10/2008] 定制混音保存混音终端列表
// 				if (mcuPartMix == tMixParam.GetMode() ||
// 					mcuVacPartMix == tMixParam.GetMode() )
// 				{
// 					for(u8 byMtIdx = 1; byMtIdx <= MAXNUM_CONF_MT; byMtIdx++)
// 					{
// 						if (m_tConfAllMtInfo.MtJoinedConf(byMtIdx) &&
// 							m_ptMtTable->IsMtInMixing(byMtIdx))
// 						{
// 							if (m_tConf.GetConfSource() ==  VCS_CONF)
// 							{
// 								if (m_ptMtTable->GetMtType( byMtIdx ) == MT_TYPE_MT && m_tConf.GetChairman().GetMtId() == byMtIdx)
// 								{
// 									//20101122_tzy 8000G下VCS会议只保留主席终端
// #ifdef 	_8KE_
// 									tMixParam.ClearAllMembers();	
// 									tMixParam.AddMember(byMtIdx);
// #endif
// 								}
// 							} 
// 							else
// 							{
// 								tMixParam.AddMember(byMtIdx);
// 							}
// 						}
// 					}
// 				}
				
				TMt atDstMt[MAXNUM_CONF_MT];
				memset(atDstMt, 0, sizeof(atDstMt));
				u8 byDstMtNum = 0;

				//[2011/08/16/zhangli]拆除混音成员到混音器（N-1）的RTCP交换
				TMt atMixMt[MAXNUM_CONF_MT];
				memset(atMixMt, 0, sizeof(atMixMt));
				u8 byMixMtNum = 0;
				TMtStatus tStatus;
				tMixParam.ClearAllMembers();
				for (byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
				{
					if (m_tConfAllMtInfo.MtJoinedConf(byMtId))            
					{
						if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
						{
							//跳过vrs新录播实体
							continue;
						}
						tmt = m_ptMtTable->GetMt( byMtId );
						StopSwitchToPeriEqp(m_tMixEqp.GetEqpId(), 
							(MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+GetMixChnPos(tmt)), FALSE, MODE_AUDIO );
						
						//zjl 20110510 StopSwitchToSubMt 接口重载替换
						//StopSwitchToSubMt(byMtId, MODE_AUDIO, SWITCH_MODE_BROADCAST, FALSE);	

						if( //m_tConf.GetChairman().GetMtId() == byMtId &&
							m_ptMtTable->GetMtStatus( byMtId,&tStatus ) &&
							!tStatus.GetSelectMt(MODE_AUDIO).IsNull() )
						{
							ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER,  "[ProcMixerMcuNotif] mt.%d has audio select.not stop audio switch\n" ,byMtId);
						}
						else
						{
							atDstMt[byDstMtNum] = tmt;
							byDstMtNum ++;
						}
						
						// xsl [9/21/2006] 恢复从组播地址接收
						/*if (m_tConf.GetConfAttrb().IsSatDCastMode() && m_ptMtTable->IsMtInMixGrp(byMtId))
						{
							ChangeSatDConfMtRcvAddr(byMtId, LOGCHL_AUDIO);
						}*/
						
						// xsl [7/29/2006]
						//m_ptMtTable->SetMtInMixGrp(byMtId, FALSE);
						
						if (m_ptMtTable->IsMtInMixGrp(byMtId))            
						{
							m_ptMtTable->SetMtInMixGrp(byMtId, FALSE);
							atMixMt[byMixMtNum] = tmt;
							byMixMtNum++;
							m_ptMtTable->SetMtInMixing(byMtId, FALSE, m_ptMtTable->IsMtAutoInSpec(byMtId));
		
							/*20110816 zjl 
							  1. vcs会议 或 mcs会议，所有混音成员都保留进混音
							  2. vcs会议 且 8000G， 只保留主席进混音*/
							if (m_tConf.GetConfSource() ==  VCS_CONF)
							{
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
								if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_MT && 
									m_tConf.GetChairman().GetMtId() == byMtId)
								{
									tMixParam.AddMember(byMtId);
								}
								else
								{
									//MCU_MT_MTADDMIX_NOTIF 只上报界面加入混音的终端
									continue;
								}
#else
								tMixParam.AddMember(byMtId);	
#endif
							}
							else
							{
								tMixParam.AddMember(byMtId);
							}
									
							u8 byMix = 0;
							cServMsg.SetMsgBody((u8*)&byMix, 1);
							SendMsgToMt(byMtId, MCU_MT_MTADDMIX_NOTIF, cServMsg);
						}
					}                
				}
				
				if (byDstMtNum > 0)
				{
					StopSwitchToSubMt(byDstMtNum, atDstMt, MODE_AUDIO, FALSE);
				}

				if (byMixMtNum > 0)
				{
					AddRemoveMixRtcpMember(byDstMtNum, atMixMt, FALSE);
				}
				
				m_tConf.m_tStatus.SetMixerParam( tMixParam );
				
				MtStatusChange();

				//20110816 zjl 混音器mcuNoMix状态必须要在恢复发言人音频码流前复位，否则当混音器掉链时，听不到发言人声音				
				m_tConf.m_tStatus.SetMixerMode( mcuNoMix );

				//改变视频源
				if (HasJoinedSpeaker())
				{
					TMt tSpeakerMt = GetLocalSpeaker();
					ChangeAudBrdSrc(&tSpeakerMt);
					
					//zjj20090925 补建唇音同步状态下bas到各个终端的音频交换
					StartSwitchAud3MtNeedAdp();
					
					if( m_tCascadeMMCU.IsNull() )
					{
						NotifyAllSMcuMediaInfo( 0,MODE_AUDIO );
					}
				}
				else
				{
					ChangeAudBrdSrc(NULL);
				}
				
				//向上级MCU发终端声音
				if (!m_tCascadeMMCU.IsNull())
				{
					TConfMcInfo *ptInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(m_tCascadeMMCU.GetMtId()));
					if (ptInfo != NULL&& 
						m_tConfAllMtInfo.MtJoinedConf(ptInfo->m_tSpyMt.GetMcuId(), ptInfo->m_tSpyMt.GetMtId()))
					{
						if ( IsNeedSelAdpt(ptInfo->m_tSpyMt,m_tCascadeMMCU,MODE_AUDIO) )
						{
							StartSelAdapt(ptInfo->m_tSpyMt, m_tCascadeMMCU, MODE_AUDIO);
						}
						else
						{			
							//zjl 20110510 StartSwitchToAll 替换 StartSwitchToSubMt
							//StartSwitchToSubMt(ptInfo->m_tSpyMt, 0, m_tCascadeMMCU.GetMtId(), MODE_AUDIO, SWITCH_MODE_SELECT);
							TSwitchGrp tSwitchGrp;
							tSwitchGrp.SetSrcChnl(0);
							tSwitchGrp.SetDstMtNum(1);
							tSwitchGrp.SetDstMt(&m_tCascadeMMCU);
							StartSwitchToAll(ptInfo->m_tSpyMt, 1, &tSwitchGrp, MODE_AUDIO, SWITCH_MODE_SELECT);
						}
					}
				}
			}
			
			// [4/25/2011 xliang] 点名过程中，VMP or mixer 断链，不迁移，不恢复
			BOOL32 bDisconnectInRoll = FALSE;		
			//zbq[12/05/2007] 停对应模式下的点名
			
			//20110514 zjl 停点名
			if ( ROLLCALL_MODE_NONE != m_tConf.m_tStatus.GetRollCallMode() )
			{
				CServMsg cMsg;
				RollCallStop(cMsg);
				bDisconnectInRoll = TRUE;
				m_tConfInStatus.SetVmpMixerDiscInRoll(TRUE);
			}
			else if( m_tConfInStatus.IsVmpMixerDiscInRoll() )
			{
				bDisconnectInRoll = TRUE;
				m_tConfInStatus.SetVmpMixerDiscInRoll(FALSE);
			}
			
			//放弃混音组
			g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
			tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState = TMixerGrpStatus::READY;
			g_cMcuVcApp.SetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
			
			g_cMcuVcApp.SetPeriEqpConnected( tEqp.GetEqpId(), FALSE, TRUE); 		
			m_tConf.m_tStatus.SetMixerMode( mcuNoMix );
			m_tMixEqp.SetNull();
			//20091014尝试其它空闲混音器恢复混音
			if( !bDisconnectInRoll
				&& RestoreMixingByOtherMixer( m_byLastMixMode ) )
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER,  "[ProcMixerMcuNotif] MCU_MIXERDISCONNECTED_NOTIF RestoreMixingByOtherMixer(%d) success\n" ,m_byLastMixMode);
			}
			else
			{
				// 清除混音器工作状态
				m_tConf.m_tStatus.SetVACing(FALSE);
				m_tConf.m_tStatus.SetNoMixing();
				MixerStatusChange(); 
				
				if (bDisconnectInRoll)
				{
					m_byLastMixMode = mcuNoMix;
				}
				memset(m_atMixMt,0,sizeof(m_atMixMt));
				if( m_tConf.GetConfSource() == VCS_CONF && m_cVCSConfStatus.GetMtInTvWallCanMixing() )
				{
					m_cVCSConfStatus.SetMtInTvWallCanMixing( FALSE );
					VCSConfStatusNotif();
				}
			}  
			
		}
		
        break; 
		
    default:
        break;
    }
    
    return;
}
		
/*====================================================================
    函数名      ：ProcMcsMcuAddMixMemberCmd
    功能        ：处理会控要求增加混音成员命令
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/10/14    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuAddMixMemberCmd( const CMessage * pcMsg )
{
	CServMsg cServMsg( pcMsg->content, pcMsg->length );
    
    STATECHECK;

// 	// [11/10/2010 xliang] translate mt msg
// 	if( MT_MCU_ADDMIXMEMBER_CMD == cServMsg.GetEventId() )
// 	{
// 		u8 byMtNum = cServMsg.GetMsgBodyLen()/sizeof(TMt);
// 		CServMsg cTransMsg = cServMsg;
// 		cTransMsg.SetMsgBody();
// 		for( u8 bylp = 0; bylp < byMtNum; bylp ++ )
// 		{
// 			TMt tMt = *(TMt *)(cServMsg.GetMsgBody() + sizeof(TMt) * bylp);
// 			tMt.SetMcuId(m_ptMtTable->GetMt(tMt.GetMtId()).GetMcuId());
// 			cTransMsg.CatMsgBody((u8*)&tMt, sizeof(TMt));
// 		}
// 		cServMsg = cTransMsg;
// 	}

    if ( m_tConf.m_tStatus.IsSpecMixing() )
    {
        //20100714_tzy 消息体内容：终端数目与相应终端数组
        if (cServMsg.GetMsgBodyLen() == 0)
        {
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMcsMcuAddMixMemberCmd] Message length = 0!\n");
            return;
        }
        u8 byMtNum = 0;
        TMt  * ptMt = NULL ;
        if (cServMsg.GetEventId() == MCS_MCU_ADDMIXMEMBER_CMD)
        {
            byMtNum = *(u8*)cServMsg.GetMsgBody();
            if ( byMtNum == 0 )
            {
				ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMcsMcuAddMixMemberCmd] byMtNum = [%d]!\n",byMtNum);
                return;
            }
            if (byMtNum == (cServMsg.GetMsgBodyLen() - sizeof(u8))/sizeof(TMt))
            {
                ptMt = (TMt *)(cServMsg.GetMsgBody() + sizeof(u8));
            } 
            else
            {
				ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMcsMcuAddMixMemberCmd] byMtNum(%d) is not equal to realnum(%d)!\n",
					     byMtNum, (cServMsg.GetMsgBodyLen() - sizeof(u8))/sizeof(TMt));
                return;
            }
        }
        else if (cServMsg.GetEventId() == MT_MCU_ADDMIXMEMBER_CMD)
        {
            byMtNum = cServMsg.GetMsgBodyLen()/sizeof(TMt);
            ptMt = (TMt *)(cServMsg.GetMsgBody());
        }
        else
        {
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMcsMcuAddMixMemberCmd] invalid event(%d)!\n", cServMsg.GetEventId());
            return;
        }
        if (ptMt == NULL || byMtNum == 0)
        {
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMcsMcuAddMixMemberCmd] ptMt == NULL || byMtNum <= 0!\n");
            return;
        }
        AddSpecMixMember( ptMt, byMtNum, FALSE);
    }
    else
    {
        ProcMixStart(cServMsg);
    }
	return;
}

/*====================================================================
    函数名      ：ProcMcsMcuRemoveMixMemberCmd
    功能        ：处理会控要求移除混音成员命令
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/10/14    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuRemoveMixMemberCmd( const CMessage * pcMsg )
{
	CServMsg cServMsg( pcMsg->content, pcMsg->length );
    
    STATECHECK;
    
	u8 byMtNum  = (cServMsg.GetMsgBodyLen())/sizeof(TMt);
	
// 	// [11/25/2010 xliang] translate mt msg
// 	if( MT_MCU_REMOVEMIXMEMBER_CMD == cServMsg.GetEventId() )
// 	{
// 		CServMsg cTransMsg = cServMsg;
// 		cTransMsg.SetMsgBody();
// 		for( u8 bylp = 0; bylp < byMtNum; bylp ++ )
// 		{
// 			TMt tMt = *(TMt *)(cServMsg.GetMsgBody() + sizeof(TMt) * bylp);
// 			tMt.SetMcuId(m_ptMtTable->GetMt(tMt.GetMtId()).GetMcuId());
// 			cTransMsg.CatMsgBody((u8*)&tMt, sizeof(TMt));
// 		}
// 		cServMsg = cTransMsg;
// 	}
	if (byMtNum == 0)
	{
		StopMixing();
	}
	else
	{
		TMt  *ptMt  = (TMt*)(cServMsg.GetMsgBody());
		if (ptMt != NULL)
		{
			RemoveSpecMixMember( ptMt, byMtNum);
			if (!ptMt->IsLocal())
			{
				//当下级无混音器，而在MCS界面上上传通道终端在混音中，那么点击该上传通道终端时，
				//应该判断该下级MCU是否需要被踢出混音
				TMt tLocalMt = GetLocalMtFromOtherMcuMt(*ptMt);
				if (GetCurConfMixMtNum(GetMcuIdxFromMcuId(tLocalMt.GetMtId())) == 0)
				{
					RemoveSpecMixMember(&tLocalMt,1);
				}
			}
		}
	}

    return;
}

/*====================================================================
    函数名      ：ProcMcsMcuReplaceMixMemberCmd
    功能        ：处理会控要求替换混音成员命令
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/11/17    4.0         张宝卿         创建
====================================================================*/
void CMcuVcInst::ProcMcsMcuReplaceMixMemberCmd( const CMessage * pcMsg )
{
    STATECHECK;
    
    CServMsg cServMsg(pcMsg->content, pcMsg->length);
    TMt tOldMt = *(TMt*)cServMsg.GetMsgBody();
    TMt tNewMt = *(TMt*)(cServMsg.GetMsgBody() + sizeof(TMt));

    if ( tNewMt.IsNull() )
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMcsMcuReplaceMixMemberCmd] tNewMt.IsNull, ignore it!\n");
        return;
    }
    if ( tOldMt.IsNull() )
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMcsMcuReplaceMixMemberCmd] tOldMt.IsNull, ignore it!\n");
        return;
    }
    if (!m_tConf.m_tStatus.IsSpecMixing())
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMcsMcuReplaceMixMemberCmd] conf mode.%d, unexpected opr, ignore it!\n",
			     m_tConf.m_tStatus.GetMixerMode());
        return;
    }
	if ( tNewMt == tOldMt )
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMcsMcuReplaceMixMemberCmd]tNewMt(%d,%d) == tOldMt, ignore it!\n",
			tNewMt.GetMcuId(),tNewMt.GetMtId());
        return;
    }
    if (tOldMt.IsLocal() &&
        !m_ptMtTable->IsMtInMixing(tOldMt.GetMtId()))
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMcsMcuReplaceMixMemberCmd] tOldMt.%d isn't in mixing, ignore it\n", 
			     tOldMt.GetMtId());
        return;
    }

	if (!tOldMt.IsLocal() && !tNewMt.IsLocal() )//被替换终端如果是本地则先将该终端踢出混音器，以保证新的如果是本地也能正常加入混音
	{
		AddSpecMixMember(&tNewMt, 1, FALSE);
		RemoveSpecMixMember(&tOldMt, 1, FALSE, FALSE);		
	}
	else
	{
		RemoveSpecMixMember(&tOldMt, 1, FALSE, FALSE);
		if( !tOldMt.IsLocal() && 1 == GetCurConfMixMtNum(tOldMt.GetMcuId()) )
		{
			tOldMt = GetLocalMtFromOtherMcuMt(tOldMt);
			RemoveSpecMixMember(&tOldMt, 1, FALSE, FALSE);
		}
		AddSpecMixMember(&tNewMt, 1, FALSE);		
	}
    
    return;
}

BOOL32 CMcuVcInst::AddSpecMixMember(const TMt *ptMt, u8 byMtNum, BOOL32 bAutoInSpec)
{
	return AddRemoveSpecMixMember(ptMt, byMtNum, TRUE, TRUE, bAutoInSpec, TRUE);
}

BOOL32 CMcuVcInst::RemoveSpecMixMember(const TMt *ptMt, u8 byMtNum, BOOL32 bCancelForceMix, BOOL32 bStopMixNonMem)
{
	return AddRemoveSpecMixMember(ptMt, byMtNum, FALSE, bStopMixNonMem, TRUE, bCancelForceMix);
}

/*====================================================================
    函数名      ：AddRemoveSpecMixMember
    功能        ：添加移除混音成员
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt *ptMt 成员终端
                  u8 byMtNum 成员个数
				  BOOL32 bAdd TRUE-添加 FALSE-移除
                  BOOL32 bStopMixNonMem: 移除终端 移空是否停混音
				  BOOL32 bAutoInSpec: 是否自动进定制混音 //仅Add时有用
				  BOOL32 bCancelForceMix: 是否取消强制混音 //仅Remove时有用

    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/09    3.0         胡昌威         创建
====================================================================*/
BOOL32 CMcuVcInst::AddRemoveSpecMixMember(const TMt *ptMt, u8 byMtNum, BOOL32 bAdd, BOOL32 bStopMixNonMem, BOOL32 bAutoInSpec, BOOL32 bCancelForceMix, BOOL32 bIsReplace)
{
    if (ptMt == NULL || byMtNum == 0)
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[AddRemoveSpecMixMember] ADD OR REMOVER MIXNUM ptMt == NULL OR byMtNum == 0,so return!\n");
		return FALSE;
    }
	
	// [miaoqingsong 20110819] 级联定制混音新策略:下级会议终端按"直属MCU分支"进行分组。	
	u8 bySmcuNum = 0;          //直属下级MCU分支数
	u8 abySmcuMtNum[MAXNUM_SUB_MCU];               
	TMt aatMtOut[MAXNUM_SUB_MCU * MAXNUM_MIXING_MEMBER]; 
	TMt *ptMixMt = &aatMtOut[0];
	memset( &abySmcuMtNum[0], 0, sizeof(abySmcuMtNum) );
	memset( (u8*)ptMixMt, 0, sizeof(aatMtOut) );
	
	//将const TMt类型转换为非const类型
	TMt *pNoConstMt = const_cast<TMt *>(ptMt);
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[AddRemoveSpecMixMember] ptMt is [%d,%d]\n", ptMt->GetMcuIdx(), ptMt->GetMtId());
	
	//将某会议下byMtNum个与会终端按照"直属MCU分支"进行分组
	GetMtListGroupBySmcu( pNoConstMt, byMtNum, bySmcuNum, &abySmcuMtNum[0], &aatMtOut[0] );
	ConfPrint( LOG_LVL_DETAIL, MID_MCU_MIXER, "[AddRemoveSpecMixMember] GetMtListGroupBySmcu return pNoConstMt[%d,%d], bySmcuNum.%d\n", 
		pNoConstMt->GetMcuIdx(), pNoConstMt->GetMtId(), bySmcuNum );
	
	TPeriEqpStatus tPeriEqpStatus;
	g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
	u8 byMixGrpState = tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState;
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "MixGrp[%d].State = %d\n", m_byMixGrpId, byMixGrpState);

	//处于WAIT_START_SPECMIX状态时，也可以增删混音成员
	if( byMixGrpState == TMixerGrpStatus::WAIT_START_SPECMIX )
	{
		BOOL32 bIsHasSmcuMem = FALSE;  //是否有下级终端参与混音
		for ( u8 byMixNum = 0; byMixNum < byMtNum; byMixNum++, ptMt++ )
		{
			if ( ptMt == NULL )
			{
				ConfPrint( LOG_LVL_ERROR, MID_MCU_MIXER, "[AddRemoveSpecMixMember] AddorRemove MixMt But ptMt == NULL, so return!\n");
				return FALSE;
			}
			if (bAdd && !m_tConfAllMtInfo.MtJoinedConf(*ptMt))
			{
				ConfPrint( LOG_LVL_ERROR, MID_MCU_MIXER, "[AddRemoveSpecMixMember]Mt(%d,%d) not joined conf, so return!\n",
					ptMt->GetMcuId(),ptMt->GetMtId());
				continue;
			}
			if ( ptMt->IsLocal() )
			{
				m_ptMtTable->SetMtInMixing( ptMt->GetMtId(), bAdd, bAutoInSpec );
			}
			else
			{
				bIsHasSmcuMem = TRUE;
			}
		}

		if ( bIsHasSmcuMem )
		{
			TMcu tMcu;
			CServMsg cServMsg;
			u8 byAddOrRemoveInfo = 0;
			for( u8 bySmcuIdx = 0; bySmcuIdx < bySmcuNum; bySmcuIdx ++ )
			{
				tMcu.SetMcu( ptMixMt->GetMcuId() );
				cServMsg.SetMsgBody( (u8*)&tMcu, sizeof(TMcu));
				cServMsg.CatMsgBody( (u8*)ptMixMt, (sizeof(TMt) * abySmcuMtNum[bySmcuIdx]));
				if (bAdd)
				{
					byAddOrRemoveInfo = bIsReplace ? 1 : 0;
				}
				else
				{
					byAddOrRemoveInfo =  bCancelForceMix ? 0 : 1;
				}

				cServMsg.CatMsgBody( (u8*)&byAddOrRemoveInfo, sizeof(u8) );
				ConfPrint( LOG_LVL_ERROR, MID_MCU_MIXER, "[AddRemoveSpecMixMember] PreAdd IsAdd:%d byAddOrRemoveInfo:%d!\n", bAdd, byAddOrRemoveInfo );

				if ( abySmcuMtNum[bySmcuIdx] > 0 )
				{
					OnAddRemoveMixToSMcu( &cServMsg, bAdd, bStopMixNonMem );
				}

				ptMixMt += abySmcuMtNum[bySmcuIdx];
			}
		}
		
		return TRUE;
	}

	//会议处于非定制混音模式时不能增删混音成员
	if ( !m_tConf.m_tStatus.IsSpecMixing() )
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[AddRemoveSpecMixMember] conf mode(%d), unexpected opr, ignore it, so return!\n", 
			m_tConf.m_tStatus.GetMixerMode());
		return FALSE;
    }
	
	//8000B 性能限制
	u16 wError = 0;
	if ( bAdd && !CMcuPfmLmt::IsMixOprSupported(m_tConf, GetMixMtNumInGrp(), byMtNum, wError) )
	{
		NotifyMcsAlarmInfo(0, wError);
		return FALSE;
	}
	

	BOOL32 bSuccess = TRUE;
	BOOL32 bIsHasSmcuMixMem = FALSE;   //是否有下级终端参与混音
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[AddRemoveSpecMixMember] byMtNum.%d\n", byMtNum);
	u8 byIsMix = 0;
	CServMsg cServMsg;
	TLogicalChannel tLogicChan;
	TMt tMt;
	for ( u8 byMixMemIdx = 0; byMixMemIdx < byMtNum; byMixMemIdx++ )
	{
		if (ptMt == NULL)
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[AddRemoveSpecMixMember] ptMt is null!\n");
			break;
		}

		ConfPrint( LOG_LVL_DETAIL, MID_MCU_MIXER, "[AddRemoveSpecMixMember]badd(%d) ptMt[%d,%d].IsLocal = %d!\n", bAdd,
			ptMt->GetMcuId(), ptMt->GetMtId(), ptMt->IsLocal() );
		
		if ( ptMt->IsLocal() )
		{
			if (bAdd && !m_tConfAllMtInfo.MtJoinedConf(*ptMt))
			{
				ConfPrint( LOG_LVL_ERROR, MID_MCU_MIXER, "[AddRemoveSpecMixMember]Mt(%d,%d) not joined conf, so return!\n",
					ptMt->GetMcuId(),ptMt->GetMtId());
				ptMt++;
				continue;
			}
			//若为add则判断当前是否超过最大混音通道数
			if (bAdd && (GetMixMtNumInGrp() >= GetMaxMixNum(m_tMixEqp.GetEqpId())) )
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[AddRemoveSpecMixMember] current mixing mt num exceed %d, ingnore mt.%d!\n",
					GetMaxMixNum(m_tMixEqp.GetEqpId()), ptMt->GetMtId());
				
				NotifyMcsAlarmInfo(0, ERR_MCU_OVERMAXMIXERCHNNL);
				ptMt++;
				bSuccess = FALSE;
				continue;;
			}
			if ( !bAdd )
			{
				bAutoInSpec = 1;
			}

			m_ptMtTable->SetMtInMixing(ptMt->GetMtId(), bAdd, bAutoInSpec);
			
			//20110127_tzy 是否可以将通知终端是否在插话放在收到添加成员成功之后做。
			byIsMix = bAdd ? 1 : 0 ;
            cServMsg.SetMsgBody((u8 *)&byIsMix, 1);
            SendMsgToMt(ptMt->GetMtId(), MCU_MT_MTADDMIX_NOTIF, cServMsg);
            
            //用于改变混音成员时处理
            if (bAdd)
            {
                if (!m_ptMtTable->IsMtInMixGrp(ptMt->GetMtId()))
                {
					AddMixMember(ptMt, DEFAULT_MIXER_VOLUME, FALSE);
                    if ( m_ptMtTable->GetMtLogicChnnl(ptMt->GetMtId(), LOGCHL_AUDIO, &tLogicChan, FALSE) )
                    {
						StartSwitchToPeriEqp(*ptMt, 0, m_tMixEqp.GetEqpId(), 
							(MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+GetMixChnPos(*ptMt)),
							MODE_AUDIO, SWITCH_MODE_SELECT);
                    }
					else
					{
						ConfPrint( LOG_LVL_DETAIL, MID_MCU_MIXER, "[AddRemoveSpecMixMember] ptMt[%d,%d]  GetMtLogicChnnl() Faile,So Continue!\n", 
								ptMt->GetMcuId(), ptMt->GetMtId());
						ptMt++;
						continue;
					}
                }
            }
            else 
            {
                if (m_ptMtTable->IsMtInMixGrp(ptMt->GetMtId()))
                {
                    RemoveMixMember(ptMt, bCancelForceMix);
// 					if ( IsMcu(tMt) && (MT_TYPE_SMCU == m_ptMtTable->GetMtType(ptMt->GetMtId())) && bStopMixNonMem )
// 					{
// 						TMt tSMcu;
// 						tSMcu.SetMcu( tMt.GetMtId() );
// 						CServMsg cMsg;
// 						cMsg.SetMsgBody((u8*)&tSMcu, sizeof(TMt));
// 						OnStopMixToSMcu( &cMsg );
// 					}
					tMt = m_ptMtTable->GetMt(ptMt->GetMtId());
                    u8 byMemChnPos = GetMixChnPos(*ptMt, TRUE);
					if (byMemChnPos != 0xFF) 
					{
						StopSwitchToPeriEqp(m_tMixEqp.GetEqpId(), 
							(MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+byMemChnPos),
							FALSE, MODE_AUDIO );
					}
					 
					//g_cMpManager.StopSwitchToSubMt(m_byConfIdx, 1, ptMt, MODE_AUDIO);
                    SwitchMixMember(ptMt, TRUE);
                }                  
			}
			
			MtStatusChange(ptMt, TRUE);
		}
		else
		{
			bIsHasSmcuMixMem = TRUE;
		}
		
		ptMt++;
	}
	
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[AddRemoveSpecMixMember] bIsHasSmcuMixMem.(%d), bySmcuNum.(%d)!\n", bIsHasSmcuMixMem, bySmcuNum);
	
	if ( bIsHasSmcuMixMem )
	{
		if ( 0 != bySmcuNum )
		{
			BOOL32 bIsSmcuInMmcu = TRUE ;
			TMcu tMcu;
			CServMsg cMsg;
			for ( u8 bySmcuMixIdx = 0; bySmcuMixIdx < bySmcuNum; bySmcuMixIdx++ )
			{
				if ( (ptMixMt == NULL) || (ptMixMt->IsNull()) )
				{
					continue;
				}
				
				tMt = GetLocalMtFromOtherMcuMt(*ptMixMt);
				bIsSmcuInMmcu = TRUE ;
				
				if ( !m_ptMtTable->IsMtInMixing(tMt.GetMtId()) && bAdd)
				{
					bIsSmcuInMmcu = FALSE;
					if ( !AddSpecMixMember(&tMt, 1, TRUE) ) 
					{				
						ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[AddRemoveSpecMixMember] ADD Smcu(%d) to LocalMix failed! so return!\n", 
							tMt.GetMtId());
						
						return FALSE;
					}
				}
				
				tMcu.SetMcu(ptMixMt->GetMcuId());
				cMsg.SetMsgBody( (u8*)&tMcu, sizeof(TMcu) );
				cMsg.CatMsgBody( (u8*)ptMixMt, (sizeof(TMt) * abySmcuMtNum[bySmcuMixIdx]) );
				
				if (bAdd)
				{
					u8 byReplace = 0;
					if ( !bIsSmcuInMmcu )
					{
						byReplace = 1;
					}
					cMsg.CatMsgBody( (u8*)&byReplace, sizeof(u8) );

					TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(ptMixMt->GetMcuId());
					if( ptMcInfo == NULL )
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[AddRemoveSpecMixMember] GetOtherMcInfo Failed, Mcu.%d!\n", ptMixMt->GetMcuId());
						return FALSE;
					}
					ptMcInfo->SetMtAutoInMix( *ptMixMt, bAutoInSpec );
					ConfPrint( LOG_LVL_DETAIL, MID_MCU_MIXER, "[AddRemoveSpecMixMember] OnAddRemoveMixToSMcu Replace:(%d) AutoInSpec:(%d)!\n", 
						byReplace, bAutoInSpec );
				}
				else
				{
					TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(ptMixMt->GetMcuId());
					if( ptMcInfo == NULL )
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[AddRemoveSpecMixMember] GetOtherMcInfo Failed, Mcu.%d!\n", ptMixMt->GetMcuId());
						return FALSE;
					}
					
					ptMcInfo->SetMtAutoInMix( *ptMixMt, TRUE );
					u8 byCancleForceMix = bCancelForceMix ? 1 : 0;
					cMsg.CatMsgBody((u8*)&byCancleForceMix, sizeof(u8));
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[AddRemoveSpecMixMember] OnAddRemoveMixToSMcu bCancelForceMix:(%d)!\n", bCancelForceMix);
				}
				
                if ( abySmcuMtNum[bySmcuMixIdx] > 0 )
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[AddRemoveSpecMixMember] call OnAddRemoveMixToSMcu send message to SMCU!\n");
					OnAddRemoveMixToSMcu( &cMsg, bAdd, bStopMixNonMem );
				}
                
				ptMixMt += abySmcuMtNum[bySmcuMixIdx];
			}
		} 
	}
	
    if (!m_tCascadeMMCU.IsNull())
    {
        OnNtfMtStatusToMMcu( m_tCascadeMMCU.GetMtId());
    }

	//20101102_tzy 踢出某个终端是否停混音逻辑
	if (!bAdd)
	{
		if ( (0 == GetCurConfMixMtNum()) && bStopMixNonMem )
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[AddRemoveSpecMixMember] StopMixing!\n");
			StopMixing();
		}
	}

    return bSuccess;
}

/*====================================================================
    函数名      ：ProcMtMcuApplyMixNotify
    功能        ：处理终端要求参加混音请求
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/10/14    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::ProcMtMcuApplyMixNotify( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TMt			tMt = m_ptMtTable->GetMt( cServMsg.GetSrcMtId() );
	TMt			tChairman;

	switch( CurState() )
	{
	case STATE_ONGOING:

		//未与会
		//[8/6/2008 xueliang] 增加过滤，即若未开启音频发送通道的与会终端申请插话，拒之
		if( !m_tConfAllMtInfo.MtJoinedConf( tMt.GetMtId() ) || 
			m_tConf.m_tStatus.IsNoMixing() ||
			!m_ptMtTable->IsLogicChnnlOpen(tMt.GetMtId(), LOGCHL_AUDIO, FALSE)
			 
			)
		{
			return;
		}

		//未处在定制混音模式下
		if( !m_tConf.m_tStatus.IsSpecMixing() )
		{
			return;
		}	
		
		// 查询是否已经处于混音组中
		if( !tMt.IsLocal() || 
			TRUE == m_ptMtTable->IsMtInMixing( tMt.GetMtId() ) )
		{
			return;
		}

		//有主席
		if( HasJoinedChairman() )
		{
			tChairman = m_tConf.GetChairman();
			
			if( tMt.GetMtId() == tChairman.GetMtId() )
			{
				//主席申请插话,同意
				AddSpecMixMember( &tChairman, 1, FALSE);
				return;
			}
			else
			{
				//通知主席
				cServMsg.SetMsgBody((u8*)&tMt, sizeof(tMt));
				cServMsg.SetDstMtId( tChairman.GetMtId() );			
				SendMsgToMt( tChairman.GetMtId(), MCU_MT_MTAPPLYMIX_NOTIF, cServMsg );			
			}
		}

		//通知会控
		cServMsg.SetMsgBody((u8*)&tMt, sizeof(tMt));
		SendMsgToAllMcs( MCU_MCS_MTAPPLYMIX_NOTIF, cServMsg );

		break;

	default:

		ConfPrint( LOG_LVL_ERROR, MID_MCU_MIXER, "Wrong message %u(%s) received in state %u!\n",
			   pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ：UnPackStartMixMsg
    功能        ：解析开启混音的消息
    算法实现    ：
    引用全局变量：
    输入参数说明：CServMsg &cServMsg 消息
				  TMixMsgInfo &tMixMsg 混音消息结构体
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/5/20     4.7.2       chendaiwei         创建
====================================================================*/
BOOL32 CMcuVcInst::UnPackStartMixMsg (CServMsg &cServMsg, TMixMsgInfo & tMixMsg)
{
	//级联
    if ( MCU_MCU_STARTMIXER_CMD == cServMsg.GetEventId() || 
		 MCU_MCU_ADDMIXMEMBER_CMD == cServMsg.GetEventId() )
    {
		tMixMsg.SetCascadeMixMsg();

        u8 byMixDepth = *(u8*)(cServMsg.GetMsgBody() + sizeof(TMcu));
        if (byMixDepth < 1)
        {
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[UnPackStartMixMsg] ERROR: Mixer's Depth < 1, So return!\n");
            return FALSE;
        }

		if (MCU_MCU_STARTMIXER_CMD == cServMsg.GetEventId())
		{
			tMixMsg.SetMixMemberPointer((TMt*)(cServMsg.GetMsgBody() + sizeof(TMcu) + sizeof(u8)));
			
			u8 byMtNum = (cServMsg.GetMsgBodyLen()-sizeof(TMcu)-sizeof(u8))/sizeof(TMt);
			tMixMsg.SetMixMtNum(byMtNum);
		}
		else
		{
			tMixMsg.SetMixMemberPointer((TMt*)(cServMsg.GetMsgBody() + sizeof(TMcu)));
			u8 byMtNum = (cServMsg.GetMsgBodyLen() - sizeof(TMcu)) / sizeof(TMt);
			tMixMsg.SetMixMtNum(byMtNum);


			BOOL32 bReplace = FALSE;
			BOOL32 bAutoInSpec = FALSE;
			if ( cServMsg.GetMsgBodyLen() > sizeof(TMcu) + sizeof(TMt)*byMtNum)
			{
				u8 byReplace = *(u8*)(cServMsg.GetMsgBody() + sizeof(TMcu) + sizeof(TMt)*byMtNum);
				tMixMsg.SetReplaceMemberFlag(byReplace);
			}
		}

		u8 byEqpId =  m_tMixEqp.GetEqpId();
		tMixMsg.SetEqpId(byEqpId);
    }
	//②消息体解析及校验：终端开启
	else if(MT_MCU_STARTDISCUSS_REQ == cServMsg.GetEventId())
	{
		u8 byMtNum = (cServMsg.GetMsgBodyLen() - sizeof(u8)) / sizeof(TMt);
		tMixMsg.SetMixMtNum(byMtNum);
		tMixMsg.SetMixMemberPointer((TMt *)(cServMsg.GetMsgBody() + sizeof(u8)));

		//20100708_tzy 支持终端开启语音激励后再开启会议讨论
		if (m_tConf.m_tStatus.IsVACing() && !m_tMixEqp.IsNull())
        {
            tMixMsg.SetEqpId(m_tMixEqp.GetEqpId());
        }
	}
	//③消息体解析及校验：MCS操作
	else if (cServMsg.GetEventId() == MCS_MCU_ADDMIXMEMBER_CMD)
	{
		//20100708_tzy 开始定制混音与会议讨论时支持手动选择混音器
        EmStartMixerMode emStartMixerMode = emStartMixerAutoMode;

		emStartMixerMode = (EmStartMixerMode)*(u8*)(cServMsg.GetMsgBody());
		if (emStartMixerMode == emStartMixerSelectMode)
		{
			u8 byEqpId = *(u8*)(cServMsg.GetMsgBody() + sizeof(u8));
			tMixMsg.SetEqpId(byEqpId);
		}
		
		u8 byMtNum = *(u8*)(cServMsg.GetMsgBody() + 2 * sizeof(u8));
		if ( byMtNum == (cServMsg.GetMsgBodyLen() - 3 * sizeof(u8)) / sizeof(TMt) )
		{
			if (byMtNum == 0)
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[3] ERROR: byMtNum == 0!\n");

				return FALSE;
			}
			else
			{
				tMixMsg.SetMixMtNum(byMtNum);
				tMixMsg.SetMixMemberPointer((TMt*)(cServMsg.GetMsgBody() + 3 * sizeof(u8)));
			}
		} 
		else
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[UnPackStartMixMsg] ERROR: byMtNum(%d) is not equal to message's length(%d)!\n",
				byMtNum,(cServMsg.GetMsgBodyLen() - 3 * sizeof(u8))/sizeof(TMt));
			
			return FALSE;
		}
    } 
	else if(cServMsg.GetEventId() == MCS_MCU_STARTDISCUSS_REQ)
	{
		//20100708_tzy 开始定制混音与会议讨论时支持手动选择混音器
        EmStartMixerMode emStartMixerMode = emStartMixerAutoMode;
		emStartMixerMode = (EmStartMixerMode)*(u8*)cServMsg.GetMsgBody();
		u8 bySelectMixId = *(u8*)(cServMsg.GetMsgBody() + sizeof(u8));
		
		// mqs [03/20/2011] 开启语音激励后，再手动开智能混音，先停止当前语音激励用的混音器，
		//         以保证智能混音和语音激励使用同一个混音器(一个会议占用一个混音器原则)
		
		u8 byEqpId = 0;
		if (m_tConf.m_tStatus.IsVACing())
		{
			
// 			if (emStartMixerMode == emStartMixerSelectMode)
// 			{
// 				CServMsg cStopVacMsg;
// 				cStopVacMsg.SetEventId(MCS_MCU_STOPVAC_REQ);
// 				MixerVACReq(cStopVacMsg);
// 				byEqpId = bySelectMixId;
// 			}
// 			else //在语音激励基础上开启智能混音，智能混音使用语音激励所用混音器(一个会议占用一个混音器原则)
			{
				byEqpId = m_tMixEqp.GetEqpId(); 
			}
		}
		else
		{
			if (emStartMixerMode == emStartMixerSelectMode)
			{
				byEqpId = bySelectMixId;
			}
		}
		
		tMixMsg.SetEqpId(byEqpId);
    }
	//④消息体解析及校验：会议点名
	//会议点名开始混音时mcu给自己发消息没有相应的eventid，走默认逻辑
    else
    {
		tMixMsg.SetMixMemberPointer((TMt*)cServMsg.GetMsgBody());
        u8 byMtNum = cServMsg.GetMsgBodyLen() / sizeof(TMt);
		tMixMsg.SetMixMtNum(byMtNum);
    }

	return TRUE;
}

/*====================================================================
    函数名      ：IsStartCascadeMixCheckPass
    功能        ：校验开启级联混音
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtNum参与混音终端数 eMcuMixMode eMixMode混音模式
				  TMt *ptMixMember 混音终端首地址 u8 &EqpId选用混音器
				  u16 &wErrorCode 错误码
    返回值说明  ：BOOL32 校验成功返回TRUE，失败返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/5/20     4.7.2       chendaiwei         创建
====================================================================*/
BOOL32 CMcuVcInst::IsStartCascadeMixCheckPass ( u8 byMtNum, emMcuMixMode eMixMode,TMt *ptMixMember,u8 &byEqpId, u16 &wErrorCode)
{
	//①已处于强制广播状态，会议强制收听发言人声音，不允许开启混音
    if ( m_tConf.m_tStatus.IsMustSeeSpeaker() ) 
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartCascadeMixCheckPass] ERROR: IsMustSeeSpeaker is true!\n");
        wErrorCode = ERR_MUSTSEESPEAKER_NOTMIXING;
        
		return FALSE;
    }

	// xsl [8/19/2006] 卫星分散会议不支持会议讨论
	if (eMixMode == mcuWholeMix && m_tConf.GetConfAttrb().IsSatDCastMode())
	{
		wErrorCode = ERR_MCU_DCAST_NOOP;
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartCascadeMixCheckPass] ERROR: distributed conf not supported discuss!\n");
		
		return FALSE;
    }

	//选用EqpId校验
	if (byEqpId != 0)
	{
		if (byEqpId != m_tMixEqp.GetEqpId() && m_tMixEqp.GetEqpId() != 0)
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[IsStartCascadeMixCheckPass] Conf(%d) is using mixer(%d)!\n",
				m_byConfIdx,m_tMixEqp.GetEqpId());
			
			return FALSE;
		}
		else
		{
			//手动选用混音器，且当前会议未开启混音
		}
	} 
	else
	{
		TAudioTypeDesc atAudioTypeDesc[MAXNUM_CONF_AUDIOTYPE];
		memset(atAudioTypeDesc, 0, sizeof(atAudioTypeDesc));
		u8 byAudioCapNum = m_tConfEx.GetAudioTypeDesc(atAudioTypeDesc);
		
		byEqpId = g_cMcuVcApp.GetIdleMixer(0, byAudioCapNum, atAudioTypeDesc);
		if( byEqpId == 0 )//未找到空闲混音器
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartCascadeMixCheckPass] can't find idle mixer!\n");
			wErrorCode = ERR_MCU_NOIDLEMIXER_INCONF;
				
			return FALSE;
		}
	}
	
	if(!CheckMixerIsValide(byEqpId))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartCascadeMixCheckPass] can't find idle mixer because CheckMixerIsValide()!\n");
		wErrorCode = ERR_MCU_NOIDLEMIXER_INCONF;
		
		return FALSE;
	}
	
	//处理指定成员混音时的混音成员
    u8  byJoinedMtNum = m_tConfAllMtInfo.GetLocalJoinedMtNum();
    u16 wError = 0;

#ifdef _MINIMCU_

    if (eMixMode == mcuWholeMix && !CMcuPfmLmt::IsMixOprSupported( m_tConf, GetMixMtNumInGrp(),byJoinedMtNum,wError ) )
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartCascadeMixCheckPass] ERROR: Can't support Mix operation!\n");
        
		wErrorCode = wError;

        return FALSE;
    }
#else
	if( GetMaxMixNum(byEqpId) == 0)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartCascadeMixCheckPass] ERROR: Can't support Mix operation!\n");
        
        return FALSE;		
	}
#endif

	//定制混音 参与数目校验
	if(eMixMode == mcuPartMix)
	{
		TMt *ptMt = (TMt*)ptMixMember;
		u8 bySmcuNum = 0;	/*下级参与混音的MCU数量*/
		u8 byMtMixLocal = 0;
		TMt tMt;
		
		//将某会议下的一批与会终端按照“直属MCU分支”进行分组
		GetMtListGroupBySmcu(ptMt, byMtNum, bySmcuNum);

		for( u8 byLoop = 0; byLoop < byMtNum; byLoop++ )
		{
			if (ptMt == NULL)
			{
				break;
			}
			tMt = *(ptMt+byLoop);
			if( tMt.IsLocal() && m_tConfAllMtInfo.MtJoinedConf(tMt.GetMtId()) &&
				m_ptMtTable->GetMtType(tMt.GetMtId()) != MT_TYPE_SMCU )
			{
				++byMtMixLocal;		
			}
		}

// 		if( tMixMsg.IsCascadeMixMsg() )
// 		{
			//上级MCU++
			++byMtMixLocal;
/*		}*/

		/*计算参与混音成员数量(本地在线终端数)*/
#ifdef _MINIMCU_
		if (!CMcuPfmLmt::IsMixOprSupported( m_tConf, GetMixMtNumInGrp(),byMtMixLocal + bySmcuNum,wError ) )
#else
		if (byMtMixLocal + bySmcuNum > GetMaxMixNum(byEqpId))
#endif
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[IsStartMixCheckPass] ERROR: spec MtNum(%d) can't exceed %d.So NACK!\n",
				byMtMixLocal + bySmcuNum, GetMaxMixNum(byEqpId));
			wErrorCode = ERR_MCU_OVERMAXMIXERCHNNL;
			
			return FALSE;
		}
	}
	else
	{
		u8 byMaxCount = 0;
		u16 wError = 0;
#ifdef _MINIMCU_
		byMaxCount = CMcuPfmLmt::GetMaxOprMixNum( m_tConf, wError );
#else
		byMaxCount = GetMaxMixNum(byEqpId);
#endif

		// miaoqingsong [05/17/2011] 当与会终端数超过混音器最大能力时，开启会议讨论自动转化为定制混音 
		if (byJoinedMtNum > byMaxCount)
		{
			if( /*tMixMsg.IsCascadeMixMsg() && */m_tConf.m_tStatus.IsSpecMixing())
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[IsStartCascadeMixCheckPass]swtich Mix Mode from spec to auto failed! due to joinedMt.%d > byMaxCount.%d\n",
				m_tConfAllMtInfo.GetLocalJoinedMtNum() , byMaxCount);
				
				return FALSE;
			}

			u8 byMinMixNum = 2; //最小混音通道数为2（上级MCU+全局发言人进混音）
			TConfMcInfo* ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(m_tCascadeMMCU.GetMtId())); 
			if (ptConfMcInfo != NULL)
			{
				TMt tTempMt = ptConfMcInfo->m_tConfAudioInfo.m_tMixerList[0].m_tSpeaker;
				u8 byMMcuSpeakMtId = tTempMt.IsMcuIdLocal() ? tTempMt.GetMtId() : tTempMt.GetMcuId();
				
				if( GetLocalSpeaker().GetMtId()!= 0 
					&& byMMcuSpeakMtId != GetLocalSpeaker().GetMtId()  
					&& m_tCascadeMMCU.GetMtId() != GetLocalSpeaker().GetMtId())
				{
					byMinMixNum ++; //有本地发言人 最小混音通道数为3
				}
			}

			if( byMaxCount < byMinMixNum )
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[IsStartCascadeMixCheckPass]swtich Mix Mode from spec to auto failed! due to byMaxCount.%d < byMinNum.%d\n",
			    byMaxCount,byMinMixNum);

				return FALSE;
			}
		}
	}

	return TRUE;
}

/*====================================================================
    函数名      ：IsStartMixCheckPass
    功能        ：检验开启混音条件
    算法实现    ：
    引用全局变量：
    输入参数说明：TMixMsgInfo &tMixMsg 混音消息结构体
    返回值说明  ：BOOL32 校验成功返回TRUE，失败返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/5/20     4.7.2       chendaiwei         创建
====================================================================*/
BOOL32 CMcuVcInst::IsStartLocalMixCheckPass ( u8 byMtNum, emMcuMixMode eMixMode,TMt *ptMixMember, u8 &byEqpId,u16 &wErrorCode)
{
	//①已处于强制广播状态，会议强制收听发言人声音，不允许开启混音
    if ( m_tConf.m_tStatus.IsMustSeeSpeaker() ) 
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartLocalMixCheckPass] ERROR: IsMustSeeSpeaker is true!\n");
        wErrorCode = ERR_MUSTSEESPEAKER_NOTMIXING;
        
		return FALSE;
    }

	// xsl [8/19/2006] 卫星分散会议不支持会议讨论
	if (eMixMode == mcuWholeMix && m_tConf.GetConfAttrb().IsSatDCastMode())
	{
		wErrorCode = ERR_MCU_DCAST_NOOP;
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartLocalMixCheckPass] ERROR: distributed conf not supported discuss!\n");
		
		return FALSE;
    }

	//1.已处于混音状态（定制或智能），开本地混音， NACK
    //2.已处于语音激励状态，开本地定制，Nack
	if( m_tConf.m_tStatus.IsMixing()||
		(eMixMode == mcuPartMix && m_tConf.m_tStatus.IsVACing() ) 
	  )
	{
		wErrorCode = 0;
		ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[IsStartLocalMixCheckPass]local mixing, cannot switch,return!\n");
		
		return FALSE;
	}

	//选用EqpId校验
	if (byEqpId != 0)
	{
		if (byEqpId != m_tMixEqp.GetEqpId() && m_tMixEqp.GetEqpId() != 0)
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[IsStartLocalMixCheckPass] Conf(%d) is using mixer(%d)!\n",
				m_byConfIdx,m_tMixEqp.GetEqpId());
			
			return FALSE;
		}
		else
		{
			//手动选用混音器，且当前会议未开启混音
			//已开启混音，byEqpId==m_tMixEqp.GetEqpId()
		}
	} 
	else
	{
		TAudioTypeDesc atAudioTypeDesc[MAXNUM_CONF_AUDIOTYPE];
		memset(atAudioTypeDesc, 0, sizeof(atAudioTypeDesc));
		u8 byAudioCapNum = m_tConfEx.GetAudioTypeDesc(atAudioTypeDesc);
		
		byEqpId = g_cMcuVcApp.GetIdleMixer(0, byAudioCapNum, atAudioTypeDesc);
		if( byEqpId == 0 )//未找到空闲混音器
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartMixCheckPass] can't find idle mixer!\n");
			wErrorCode = ERR_MCU_NOIDLEMIXER_INCONF;
				
			return FALSE;
		}
	}
	
	if(!CheckMixerIsValide(byEqpId))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartMixCheckPass] can't find idle mixer because CheckMixerIsValide()!\n");
		wErrorCode = ERR_MCU_NOIDLEMIXER_INCONF;
		
		return FALSE;
	}
	
	//处理指定成员混音时的混音成员
    u8  byJoinedMtNum = m_tConfAllMtInfo.GetLocalJoinedMtNum();
    u16 wError = 0;

#ifdef _MINIMCU_

    if (eMixMode == mcuWholeMix && !CMcuPfmLmt::IsMixOprSupported( m_tConf, GetMixMtNumInGrp(),byJoinedMtNum,wError ) )
    {
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartMixCheckPass] ERROR: Can't support Mix operation!\n");
        
		wErrorCode = wError;

        return FALSE;
    }
#else
	if( GetMaxMixNum(byEqpId) == 0)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[IsStartMixCheckPass] ERROR: Can't support Mix operation!\n");
        
        return FALSE;		
	}
#endif

	//定制混音 参与数目校验
	if(eMixMode == mcuPartMix)
	{
		TMt *ptMt = (TMt*)ptMixMember;
		u8 bySmcuNum = 0;	/*下级参与混音的MCU数量*/
		u8 byMtMixLocal = 0;
		TMt tMt;
		
		//将某会议下的一批与会终端按照“直属MCU分支”进行分组
		GetMtListGroupBySmcu(ptMt, byMtNum, bySmcuNum);

		for( u8 byLoop = 0; byLoop < byMtNum; byLoop++ )
		{
			if (ptMt == NULL)
			{
				break;
			}
			tMt = *(ptMt+byLoop);
			if( tMt.IsLocal() && m_tConfAllMtInfo.MtJoinedConf(tMt.GetMtId()) &&
				m_ptMtTable->GetMtType(tMt.GetMtId()) != MT_TYPE_SMCU )
			{
				++byMtMixLocal;		
			}
		}

		/*计算参与混音成员数量(本地在线终端数)*/
#ifdef _MINIMCU_
		if (!CMcuPfmLmt::IsMixOprSupported( m_tConf, GetMixMtNumInGrp(),byMtMixLocal + bySmcuNum,wError ) )
#else
		if (byMtMixLocal + bySmcuNum > GetMaxMixNum(byEqpId))
#endif
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[IsStartMixCheckPass] ERROR: spec MtNum(%d) can't exceed %d.So NACK!\n",
				byMtNum, GetMaxMixNum(byEqpId));
			wErrorCode = ERR_MCU_OVERMAXMIXERCHNNL;
			
			return FALSE;
		}
	}
	else
	{
		u8 byMaxCount = 0;
		u16 wError = 0;
#ifdef _MINIMCU_
		byMaxCount = CMcuPfmLmt::GetMaxOprMixNum( m_tConf, wError );
#else
		byMaxCount = GetMaxMixNum(byEqpId);
#endif

		// miaoqingsong [05/17/2011] 当与会终端数超过混音器最大能力时，开启会议讨论自动转化为定制混音 
		if (byJoinedMtNum > byMaxCount)
		{
			if( m_tConf.m_tStatus.IsVACing())
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_MIXER, "[IsStartMixCheckPass]CurJoinedMtNum > MaxMixNum() localmixMsg and conf is mixing,So return!!!\n");
				
				return FALSE;
			}
		}
	}

	return TRUE;
}

/*====================================================================
    函数名      ：StartCascadeMixDataCoordinate
    功能        ：开启级联混音数据整理
    算法实现    ：1.定制混音设置混音标志位
				  2.级联消息透传
    引用全局变量：
    输入参数说明：u8 byMtNum参与混音终端数 eMcuMixMode &eMixMode混音模式
				  TMt *ptMixMember 混音终端首地址
				  u8 byEqpId 混音器ID
    返回值说明  ：void 
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/5/20     4.7.2       chendaiwei         创建
====================================================================*/
void CMcuVcInst::StartCascadeMixDataCoordinate ( u8 byMtNum, emMcuMixMode &eMixMode, TMt *ptMixMember,u8 byEqpId)
{
    TMt *ptMt = (TMt*)ptMixMember;
	TMt tMt;
	
	//定制混音消息
	if( eMixMode == mcuPartMix)
	{

		TPeriEqpStatus tPeriStatus;
		g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tPeriStatus);
		
		//当前Mixer无混音状态.设置标志位
		if(  byEqpId!= 0 
			&& (tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState ==TMixerGrpStatus::READY
			    || tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState == TMixerGrpStatus::WAIT_STOP)
		   )
		{
			if( tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState == TMixerGrpStatus::WAIT_STOP )
			{
				ProcMixStopSucRsp(FALSE);
			}

			// zbq [11/29/2007] 先增加上级MCU进本地混音组
			if( !m_ptMtTable->IsMtInMixing(m_tCascadeMMCU.GetMtId()) )
			{
				m_ptMtTable->SetMtInMixing(m_tCascadeMMCU.GetMtId(), TRUE, TRUE);
			}

			// mqs [2011/08/19] 级联混音新策略：下级预混音终端按“直属MCU分支”进行分组
			u8 bySmcuNum = 0;	/*下级参与混音的MCU数量*/
			u8 abySmcuMtNum[MAXNUM_SUB_MCU];                    
			TMt aatMtOut[MAXNUM_SUB_MCU * MAXNUM_MIXING_MEMBER]; 
			TMt *ptOutMt = &aatMtOut[0];
			memset(&abySmcuMtNum[0], 0, sizeof(abySmcuMtNum));
			memset((u8*)ptOutMt, 0, MAXNUM_SUB_MCU * MAXNUM_MIXING_MEMBER * sizeof(TMt));
        
			//将某会议下的一批与会终端按照“直属MCU分支”进行分组
			GetMtListGroupBySmcu(ptMt, byMtNum, bySmcuNum, &abySmcuMtNum[0], &aatMtOut[0]);

			//是否有下级终端参与混音
			BOOL32 bIsHasSmcuMixMem = FALSE;

			/*	byMtNum表示所有拖入定制混音的终端数。
				级联混音下级MCU的所有终端进上级混音，对上级来说只能算作一个混音成员。	
				byMtMixLocal表示本级混音终端数，不算下级MCU和Mt。	*/

			for( u8 byLoop = 0; byLoop < byMtNum; byLoop++ )
			{
				if (ptMt == NULL)
				{
					break;
				}

				tMt = *ptMt;
				if ( tMt.IsLocal() )
				{
					if ( !m_tConfAllMtInfo.MtJoinedConf(tMt.GetMtId()))
					{
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[ProcMixStart] ptMt is not in Conf, So ++!\n");
						ptMt ++;
						continue;
					}

					if( tMt == m_tConf.GetSpeaker() ) //本地发言人终端自动进混音逻辑处理
					{
						if (m_ptMtTable->GetMtType(tMt.GetMtId()) == MT_TYPE_MMCU)
						{
							m_ptMtTable->SetMtInMixing( tMt.GetMtId(), TRUE, FALSE );
						}
						else
						{
							m_ptMtTable->SetMtInMixing( tMt.GetMtId(), TRUE, TRUE );
						}
					}
					else //本地非发言普通终端进混音逻辑处理
					{
						m_ptMtTable->SetMtInMixing( tMt.GetMtId(), TRUE, FALSE );
					}
				}
				else
				{
					tMt = GetLocalMtFromOtherMcuMt( *ptMt );
					if ( !m_tConfAllMtInfo.MtJoinedConf(tMt.GetMtId()))
					{
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[StartCascadeMixDataCoordinate] Smcu's ptMt is not in Conf, So ++!\n");
						ptMt ++;

						continue;
					}

					m_ptMtTable->SetMtInMixing(tMt.GetMtId(), TRUE, TRUE);
					TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(ptMt->GetMcuId());
					if( ptMcInfo == NULL )
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[StartCascadeMixDataCoordinate] ERROR: SMcu.%d is unexist, impossible!\n", ptMt->GetMcuId());
						ptMt ++;                  
						continue;
					}

					bIsHasSmcuMixMem = TRUE;
				}
				ptMt++;
			}

			if ( bIsHasSmcuMixMem )
			{
				for (u8 bySmcuIdx = 0; bySmcuIdx < bySmcuNum; bySmcuIdx++)
				{
					tMt = GetLocalMtFromOtherMcuMt( *ptOutMt );
					if ( !m_tConfAllMtInfo.MtJoinedConf(tMt.GetMtId()))
					{
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[StartCascadeMixDataCoordinate] SMCU's ptOutMt is not in Conf, So ++!\n");
						continue;
					}

					TMcu tMcu;
					tMcu.SetMcu(ptOutMt->GetMcuIdx());
					CServMsg cMsg;
					cMsg.SetEventId(MCU_MCU_ADDMIXMEMBER_CMD);
					cMsg.SetMsgBody((u8*)&tMcu, sizeof(TMcu));
					cMsg.CatMsgBody((u8*)ptOutMt, (sizeof(TMt) * abySmcuMtNum[bySmcuIdx]));

					//zbq[11/29/2007] 增加标识本次增加是否为替换增加。
					u8 byReplace = 1;
					cMsg.CatMsgBody((u8*)&byReplace, sizeof(u8));

					TConfMcInfo *ptMixMtMcInfo = NULL;
					for (u8 byMixNum = 0 ; byMixNum < abySmcuMtNum[bySmcuIdx]; byMixNum++)
					{
						if (ptOutMt == NULL)
						{
							break;
						}

						ptMixMtMcInfo = m_ptConfOtherMcTable->GetMcInfo(ptOutMt->GetMcuId());
						if( NULL == ptMixMtMcInfo )
						{
							ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[StartCascadeMixDataCoordinate] Fail to GetMcInfo.McuId(%d)\n", ptOutMt->GetMcuId());
							continue;
						}
						else
						{
							if (*ptOutMt == m_tConf.GetSpeaker() )
							{
								ptMixMtMcInfo->SetMtAutoInMix( *ptOutMt, TRUE );
							}
							else
							{
								ptMixMtMcInfo->SetMtAutoInMix( *ptOutMt, FALSE );
							}
						}
						ptOutMt++;
					}

					OnAddRemoveMixToSMcu(&cMsg, TRUE);
				}
				//当前发言人是下级MCU，则将上传通道中终端设置为自动进混音
				if (!m_tConf.GetSpeaker().IsNull() && !(m_tConf.GetSpeaker() == m_tCascadeMMCU)  && IsMcu(m_tConf.GetSpeaker()))
				{
					TMt tViewM;
					tViewM.SetNull();
					tViewM = GetSMcuViewMt(m_tConf.GetSpeaker(),TRUE);
					TConfMcInfo *ptMixMtMcInfo = NULL;
					ptMixMtMcInfo = m_ptConfOtherMcTable->GetMcInfo(tViewM.GetMcuIdx());
					if (NULL != ptMixMtMcInfo && !tViewM.IsNull())
					{
						ptMixMtMcInfo->SetMtAutoInMix( tViewM, TRUE );
					}
				}
			}
		}
	}
	else
	{
        // miaoqingsong [05/17/2011] 当与会终端数超过混音器最大能力时，开启会议讨论自动转化为定制混音
		u8  byJoinedMtNum = m_tConfAllMtInfo.GetLocalJoinedMtNum();
        if ( byJoinedMtNum > GetMaxMixNum(byEqpId) )
        {
			u8  byCount = 0;
            u8  byMaxCount = 0;
			u16 wError = 0;
#ifdef _MINIMCU_
			byMaxCount = CMcuPfmLmt::GetMaxOprMixNum( m_tConf, wError );
#else
			byMaxCount = GetMaxMixNum(byEqpId);
#endif
			TMcu tSMcu;	
			CServMsg cTmpMsg;

			m_ptMtTable->SetMtInMixing(m_tCascadeMMCU.GetMtId(), TRUE, FALSE);
			byCount ++ ;
			TConfMcInfo* ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(m_tCascadeMMCU.GetMtId())); 
			if (byCount < byMaxCount && ptConfMcInfo  != NULL)
			{
				TMt tTempMt = ptConfMcInfo->m_tConfAudioInfo.m_tMixerList[0].m_tSpeaker;
				u8 byMMcuSpeakMtId = tTempMt.IsMcuIdLocal() ? tTempMt.GetMtId() : tTempMt.GetMcuId();
				if (byMMcuSpeakMtId != 0 && !m_ptMtTable->IsMtInMixing(byMMcuSpeakMtId))
				{
					m_ptMtTable->SetMtInMixing(byMMcuSpeakMtId, TRUE, FALSE);
					byCount ++ ;
					if (m_ptMtTable->GetMtType(byMMcuSpeakMtId) == MT_TYPE_SMCU)
					{		
						tSMcu.SetMcuId( byMMcuSpeakMtId );
						cTmpMsg.SetMsgBody( (u8*)&tSMcu, sizeof(tSMcu) );
						u8 byDepth = MAXNUM_MIXER_DEPTH;
						cTmpMsg.CatMsgBody( &byDepth, sizeof(byDepth) );
						OnStartMixToSMcu(&cTmpMsg);
					}
				}
			}

  			//发言人优先自动进混音
			if ( m_tConf.HasSpeaker() && byCount < byMaxCount)
			{
				if (!m_ptMtTable->IsMtInMixing(GetLocalSpeaker().GetMtId()))
				{
					m_ptMtTable->SetMtInMixing(GetLocalSpeaker().GetMtId(), TRUE, TRUE);
					byCount++;
					if (m_ptMtTable->GetMtType(GetLocalSpeaker().GetMtId()) == MT_TYPE_SMCU)
					{		
						tSMcu.SetMcuId( GetLocalSpeaker().GetMtId() );
						cTmpMsg.SetMsgBody( (u8*)&tSMcu, sizeof(tSMcu) );
						u8 byDepth = MAXNUM_MIXER_DEPTH;
						cTmpMsg.CatMsgBody( &byDepth, sizeof(byDepth) );
						OnStartMixToSMcu(&cTmpMsg);
					}
				}
			}
			for ( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++ )
			{
				if ( byCount >= byMaxCount )
				{
					break;
				}
				
				if ( !m_tConfAllMtInfo.MtJoinedConf(byMtId) || m_ptMtTable->IsMtInMixing(byMtId)
					|| m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
				{
					continue;
				}
				m_ptMtTable->SetMtInMixing(byMtId, TRUE, FALSE);
				byCount ++ ;
				if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_SMCU)
				{		
					tSMcu.SetMcuId( byMtId );
					cTmpMsg.SetMsgBody( (u8*)&tSMcu, sizeof(tSMcu) );
					u8 byDepth = MAXNUM_MIXER_DEPTH;
					cTmpMsg.CatMsgBody( &byDepth, sizeof(byDepth) );
					OnStartMixToSMcu(&cTmpMsg);
				}
			}
			
			//期望开启智能混音，切换成定制混音
			eMixMode = mcuPartMix;
			ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MIXER,"[StartCascadeMixDataCoordinate] swtich discuss to spec mixing!\n");

			NotifyMcsAlarmInfo(0,ERR_MCU_DISCUSSAUTOCHANGE2SPECMIX);
        }
		else
		{
			// xsl [1/10/2006] 请求开启所有直联下级MCU全体混音                 
			TMcu tMcu;
			tMcu.SetMcuId(LOCAL_MCUID);	
			CServMsg cMsg;
			// guzh [11/7/2007] 忽略混音深度设置
			u8 byMixDepth = GetMaxMixerDepth(byEqpId);
			
			cMsg.SetMsgBody( (u8 *)&tMcu, sizeof(tMcu) ); 
			cMsg.CatMsgBody( (u8*)&byMixDepth, 1 );
			
			OnStartDiscussToAllSMcu( &cMsg );
		}
	}

    // zbq [06/27/2007] 开讨论或定制混音停当前所有与会终端的音频选看
	// mqs [03/18/2011] 会议讨论、定制混音时由于有新的广播源(混音器)，所以要停音频选看，让当前终端都听广播源(混音器)的声音
	// mqs [06/28/2011] 增加判断条件: 倘若当前会议模式为带音频的主席轮询选看时开启混音不停主席选听
	//zjj20120920 现在改为主席终端有音频选听就不能建到主席交换
	TMtStatus tMtStatus;
	TMt tSelMt;
	CSendSpy cSendSpy;
    for( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId ++ )
    {
        if ( m_tConfAllMtInfo.MtJoinedConf(byMtId) )
        {
			m_ptMtTable->GetMtStatus(byMtId, &tMtStatus);
            tSelMt = tMtStatus.GetSelectMt(MODE_AUDIO);
            if ( !tSelMt.IsNull() && 
				 !( byMtId == m_tConf.GetChairman().GetMtId() ) &&
				 ( !m_cLocalSpyMana.GetSpyChannlInfo(tSelMt,cSendSpy) ||				
					cSendSpy.GetSpyMode() == MODE_VIDEO ||
					!IsNeedSelAdpt(tSelMt,m_tCascadeMMCU,MODE_AUDIO) )					
                )
            {
                tMt = m_ptMtTable->GetMt(byMtId);
                StopSelectSrc(tMt, MODE_AUDIO);
            }
        }
    }

	return;
}

/*====================================================================
    函数名      ：StartMixDataCoordinate
    功能        ：开启混音数据整理
    算法实现    ：1.定制混音设置混音标志位
				  2.级联消息透传
    引用全局变量：
    输入参数说明：TMixMsgInfo &tMixMsg 混音消息结构体
    返回值说明  ：void 
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/5/20     4.7.2       chendaiwei         创建
====================================================================*/
void CMcuVcInst::StartLocalMixDataCoordinate ( u8 byMtNum, emMcuMixMode &eMixMode, TMt *ptMixMember,u8 byEqpId)
{
    TMt *ptMt = (TMt*)ptMixMember;
	TMt tMt;
	
	//定制混音消息
	if( eMixMode == mcuPartMix)
	{
		// mqs [2011/08/19] 级联混音新策略：下级预混音终端按“直属MCU分支”进行分组
		u8 bySmcuNum = 0;	/*下级参与混音的MCU数量*/
		u8 abySmcuMtNum[MAXNUM_SUB_MCU];                    
		TMt aatMtOut[MAXNUM_SUB_MCU * MAXNUM_MIXING_MEMBER]; 
		TMt *ptOutMt = &aatMtOut[0];
		memset(&abySmcuMtNum[0], 0, sizeof(abySmcuMtNum));
		memset((u8*)ptOutMt, 0, MAXNUM_SUB_MCU * MAXNUM_MIXING_MEMBER * sizeof(TMt));
        
		//添加实际上传终端进混音[6/21/2013 chendaiwei]
		//Bug00138730三级级联单回传，拖第二级MCU为全局发言人开启混音后，取消发言人，第二级混音器未关
		TMt tMixMember[MAXNUM_CONF_MT];
		memset(&tMixMember,0,sizeof(tMixMember));
		TMt tLocalSpeaker = GetLocalSpeaker();
		if(!tLocalSpeaker.IsNull() 
			&& m_ptMtTable->GetMtType(tLocalSpeaker.GetMtId()) == MT_TYPE_SMCU &&
			!IsLocalAndSMcuSupMultSpy(m_tConf.GetSpeaker().GetMcuId()) )
		{
 			TMt tViewMt = GetSMcuViewMt(tLocalSpeaker,TRUE);

			if( !tViewMt.IsNull())
			{
				BOOL32 bRepeat = FALSE;
				for(u8 byIdx = 0; byIdx < byMtNum; byIdx++ )
				{
					if( tViewMt.GetMcuId() == (ptMt+byIdx)->GetMcuId()
						&& tViewMt.GetMtId() == (ptMt+byIdx)->GetMtId())
					{
						bRepeat = TRUE;
						break;
					}
				}

				if ( !bRepeat)
				{
					memcpy(&tMixMember[0],ptMt,sizeof(TMt)*byMtNum);
					memcpy(&tMixMember[byMtNum],&tViewMt,sizeof(tViewMt));
					byMtNum++;
					ptMt = &tMixMember[0];

					ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MIXER,"[StartLocalMixCordinate] Add tViemMt(%d:%d) to Mix list!\n",tViewMt.GetMcuId(),tViewMt.GetMtId());
				}
			}
		}

		//将某会议下的一批与会终端按照“直属MCU分支”进行分组
		GetMtListGroupBySmcu(ptMt, byMtNum, bySmcuNum, &abySmcuMtNum[0], &aatMtOut[0]);

		//是否有下级终端参与混音
		BOOL32 bIsHasSmcuMixMem = FALSE;

		/*	byMtNum表示所有拖入定制混音的终端数。
			级联混音下级MCU的所有终端进上级混音，对上级来说只能算作一个混音成员。	
			byMtMixLocal表示本级混音终端数，不算下级MCU和Mt。	*/

		for( u8 byLoop = 0; byLoop < byMtNum; byLoop++ )
		{
			if (ptMt == NULL)
			{
				break;
			}

            tMt = *ptMt;
            if ( tMt.IsLocal() )
            {
                if ( !m_tConfAllMtInfo.MtJoinedConf(tMt.GetMtId()))
                {
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[ProcMixStart] ptMt is not in Conf, So ++!\n");
					ptMt ++;
                    continue;
                }

				if( tMt == m_tConf.GetSpeaker() ) //本地发言人终端自动进混音逻辑处理
				{
					if (m_ptMtTable->GetMtType(tMt.GetMtId()) == MT_TYPE_MMCU)
					{
						m_ptMtTable->SetMtInMixing( tMt.GetMtId(), TRUE, FALSE );
					}
					else
					{
						m_ptMtTable->SetMtInMixing( tMt.GetMtId(), TRUE, TRUE );
					}
				}
				else //本地非发言普通终端进混音逻辑处理
				{
					m_ptMtTable->SetMtInMixing( tMt.GetMtId(), TRUE, FALSE );
				}
            }
            else
            {
				tMt = GetLocalMtFromOtherMcuMt( *ptMt );
                if ( !m_tConfAllMtInfo.MtJoinedConf(tMt.GetMtId()))
                {
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[ProcMixStart] Smcu's ptMt is not in Conf, So ++!\n");
					ptMt ++;

                    continue;
                }

                m_ptMtTable->SetMtInMixing(tMt.GetMtId(), TRUE, TRUE);
                TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(ptMt->GetMcuId());
                if( ptMcInfo == NULL )
                {
					ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMixStart] ERROR: SMcu.%d is unexist, impossible!\n", ptMt->GetMcuId());
					ptMt ++;                  
                    continue;
                }

				bIsHasSmcuMixMem = TRUE;
            }
			ptMt++;
		}

		if ( bIsHasSmcuMixMem )
		{
			for (u8 bySmcuIdx = 0; bySmcuIdx < bySmcuNum; bySmcuIdx++)
			{
				tMt = GetLocalMtFromOtherMcuMt( *ptOutMt );
				if ( !m_tConfAllMtInfo.MtJoinedConf(tMt.GetMtId()))
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[ProcMixStart] SMCU's ptOutMt is not in Conf, So ++!\n");
					continue;
				}

				TMcu tMcu;
			    tMcu.SetMcu(ptOutMt->GetMcuIdx());
				CServMsg cMsg;
				cMsg.SetEventId(MCU_MCU_ADDMIXMEMBER_CMD);
				cMsg.SetMsgBody((u8*)&tMcu, sizeof(TMcu));
				cMsg.CatMsgBody((u8*)ptOutMt, (sizeof(TMt) * abySmcuMtNum[bySmcuIdx]));

				//zbq[11/29/2007] 增加标识本次增加是否为替换增加。
				u8 byReplace = 1;
				cMsg.CatMsgBody((u8*)&byReplace, sizeof(u8));

			    TConfMcInfo *ptMixMtMcInfo = NULL;
				for (u8 byMixNum = 0 ; byMixNum < abySmcuMtNum[bySmcuIdx]; byMixNum++)
				{
					if (ptOutMt == NULL)
					{
						break;
					}

					ptMixMtMcInfo = m_ptConfOtherMcTable->GetMcInfo(ptOutMt->GetMcuId());
					if( NULL == ptMixMtMcInfo )
					{
						ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[ProcMixStart] Fail to GetMcInfo.McuId(%d)\n", ptOutMt->GetMcuId());
						continue;
					}
					else
					{
						if (*ptOutMt == m_tConf.GetSpeaker() )
						{
							ptMixMtMcInfo->SetMtAutoInMix( *ptOutMt, TRUE );
						}
						else
						{
							ptMixMtMcInfo->SetMtAutoInMix( *ptOutMt, FALSE );
						}
					}
					ptOutMt++;
				}

				OnAddRemoveMixToSMcu(&cMsg, TRUE);
			}
			//当前发言人是下级MCU，则将上传通道中终端设置为自动进混音
			if (!m_tConf.GetSpeaker().IsNull() && !(m_tConf.GetSpeaker() == m_tCascadeMMCU)  && IsMcu(m_tConf.GetSpeaker()))
			{
				TMt tViewM;
				tViewM.SetNull();
				tViewM = GetSMcuViewMt(m_tConf.GetSpeaker(),TRUE);
				TConfMcInfo *ptMixMtMcInfo = NULL;
				ptMixMtMcInfo = m_ptConfOtherMcTable->GetMcInfo(tViewM.GetMcuIdx());
				if (NULL != ptMixMtMcInfo && !tViewM.IsNull())
				{
					ptMixMtMcInfo->SetMtAutoInMix( tViewM, TRUE );
				}
			}
		}
	}
	else
	{
        // miaoqingsong [05/17/2011] 当与会终端数超过混音器最大能力时，开启会议讨论自动转化为定制混音
		u8  byJoinedMtNum = m_tConfAllMtInfo.GetLocalJoinedMtNum();
		//u8 byEqpId = tMixMsg.GetEqpId();
        if ( byJoinedMtNum > GetMaxMixNum(byEqpId) )
        {
			u8  byCount = 0;
            u8  byMaxCount = 0;
			u16 wError = 0;
#ifdef _MINIMCU_
			byMaxCount = CMcuPfmLmt::GetMaxOprMixNum( m_tConf, wError );
#else
			byMaxCount = GetMaxMixNum(byEqpId);
#endif
			TMcu tSMcu;	
			CServMsg cTmpMsg;
			//把上级放到混音器中
  			//发言人优先自动进混音
			if ( m_tConf.HasSpeaker() && byCount < byMaxCount)
			{
				if (!m_ptMtTable->IsMtInMixing(GetLocalSpeaker().GetMtId()))
				{
					m_ptMtTable->SetMtInMixing(GetLocalSpeaker().GetMtId(), TRUE, TRUE);
					byCount++;
					if (m_ptMtTable->GetMtType(GetLocalSpeaker().GetMtId()) == MT_TYPE_SMCU)
					{		
						tSMcu.SetMcuId( GetLocalSpeaker().GetMtId() );
						cTmpMsg.SetMsgBody( (u8*)&tSMcu, sizeof(tSMcu) );
						u8 byDepth = MAXNUM_MIXER_DEPTH;
						cTmpMsg.CatMsgBody( &byDepth, sizeof(byDepth) );
						OnStartMixToSMcu(&cTmpMsg);
					}
				}
			}
			for ( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++ )
			{
				if ( byCount >= byMaxCount )
				{
					break;
				}
				
				if ( !m_tConfAllMtInfo.MtJoinedConf(byMtId) || m_ptMtTable->IsMtInMixing(byMtId)
					|| m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
				{
					continue;
				}
				m_ptMtTable->SetMtInMixing(byMtId, TRUE, FALSE);
				byCount ++ ;
				if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_SMCU)
				{		
					tSMcu.SetMcuId( byMtId );
					cTmpMsg.SetMsgBody( (u8*)&tSMcu, sizeof(tSMcu) );
					u8 byDepth = MAXNUM_MIXER_DEPTH;
					cTmpMsg.CatMsgBody( &byDepth, sizeof(byDepth) );
					OnStartMixToSMcu(&cTmpMsg);
				}
			}
			
			//期望开启智能混音，切换成定制混音
			eMixMode = mcuPartMix;

			NotifyMcsAlarmInfo( 0, ERR_MCU_DISCUSSAUTOCHANGE2SPECMIX);
        }
		else
		{
			// xsl [1/10/2006] 请求开启所有直联下级MCU全体混音                 
			TMcu tMcu;
			tMcu.SetMcuId(LOCAL_MCUID);	
			CServMsg cMsg;
			u8 byMixDepth = GetMaxMixerDepth(byEqpId);
			
			cMsg.SetMsgBody( (u8 *)&tMcu, sizeof(tMcu) ); 
			cMsg.CatMsgBody( (u8*)&byMixDepth, 1 );
			
			OnStartDiscussToAllSMcu( &cMsg );
		}
	}

    // zbq [06/27/2007] 开讨论或定制混音停当前所有与会终端的音频选看
	// mqs [03/18/2011] 会议讨论、定制混音时由于有新的广播源(混音器)，所以要停音频选看，让当前终端都听广播源(混音器)的声音
	// mqs [06/28/2011] 增加判断条件: 倘若当前会议模式为带音频的主席轮询选看时开启混音不停主席选听
	//zjj20120920 现在改为主席终端有音频选听就不能建到主席交换
    for( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId ++ )
    {
        if ( m_tConfAllMtInfo.MtJoinedConf(byMtId) )
        {
            TMtStatus tMtStatus;
            if ( m_ptMtTable->GetMtStatus(byMtId, &tMtStatus) &&
                 !tMtStatus.GetSelectMt(MODE_AUDIO).IsNull() && 
				 !( byMtId == m_tConf.GetChairman().GetMtId() )
                )
            {
                tMt = m_ptMtTable->GetMt(byMtId);
                StopSelectSrc(tMt, MODE_AUDIO);
            }
        }
    }

	return;
}


/*====================================================================
    函数名      ：ProcMixStart
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/11/09    4.0         张宝卿          创建
====================================================================*/
void CMcuVcInst::ProcMixStart( CServMsg &cServMsg )
{

#define REJECT_MIXER_START( wError )	\
	{ \
		if( cServMsg.GetEventId() == MT_MCU_STARTDISCUSS_REQ )	\
		{ \
			cServMsg.SetErrorCode( wError ); \
			cServMsg.SetMsgBody( &byMixMode, sizeof(byMixMode)); \
			SendReplyBack(cServMsg, cServMsg.GetEventId() + 2);	\
		} \
		else if ( cServMsg.GetEventId() != MCU_MCU_STARTMIXER_CMD && \
			 cServMsg.GetEventId() != MCU_MCU_ADDMIXMEMBER_CMD && \
			cServMsg.GetEventId() != MCS_MCU_ADDMIXMEMBER_CMD) \
		{ \
			cServMsg.SetErrorCode( wError );	\
			SendReplyBack(cServMsg, cServMsg.GetEventId() + 2); \
		} \
		else \
		{ \
			NotifyMcsAlarmInfo( 0, wError ); \
		} \
	}

	TMixMsgInfo tMixMsg;

	BOOL32 bRet = UnPackStartMixMsg(cServMsg,tMixMsg);
	u8 byMixMode = (u8)tMixMsg.GetMixMode();
	if(!bRet)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[ProcMixStart] unpack msg failed!\n");
        
        REJECT_MIXER_START(0)
        return;
	}

	u16 wErrCode = 0;
	if(tMixMsg.IsCascadeMixMsg())
	{
		if(!StartCascadeMix(tMixMsg.GetMixMtNum(),tMixMsg.GetMixMode(),tMixMsg.GetMixMemberPointer(),tMixMsg.GetEqpId(),tMixMsg.GetReplaceMemberFlag(),wErrCode))
		{
			REJECT_MIXER_START(wErrCode);
			
			return;
		}
	}
	else
	{
		if(!StartLocalMix(tMixMsg.GetMixMtNum(),tMixMsg.GetMixMode(),tMixMsg.GetMixMemberPointer(),tMixMsg.GetEqpId(),wErrCode))
		{
			REJECT_MIXER_START(wErrCode);

			return;
		}
	}

	//ACK
	if (cServMsg.GetEventId() == MT_MCU_STARTDISCUSS_REQ)
	{
		// lukp[12/01/2009] MTC开启会议讨论或语音激励时需要返回mixmode；
		//           由于后面才处理得到混音模式，此处就返回前面的byMixMode即可。
		u8 byMixMode = tMixMsg.GetMixMode();
		cServMsg.SetMsgBody(&byMixMode, sizeof(byMixMode));
        SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
	}
    else if ( cServMsg.GetEventId() != MCU_MCU_STARTMIXER_CMD &&
		cServMsg.GetEventId() != MCS_MCU_ADDMIXMEMBER_CMD &&
		cServMsg.GetEventId() != MCU_MCU_ADDMIXMEMBER_CMD )
    {
        SendReplyBack( cServMsg, cServMsg.GetEventId() + 1 );
    }

    return;
#undef REJECT_MIXER_START
}


/*====================================================================
    函数名      ：StartCascadeMix
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtNum混音终端数目 emMcuMixMode eMixMode混音模式
				  TMT *ptMixMember指定混音成员首地址
				  u8 byEqpId 混音器ID
				  u8 byReplaceMember是否冲下级混音成员
				  u16 &wErrorCode 错误码
    返回值说明  ：开启成功返回TRUE,否则返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/05/23    4.7.2        陈代伟          创建
====================================================================*/
BOOL32 CMcuVcInst::StartCascadeMix( u8 byMtNum, emMcuMixMode eMixMode,TMt *ptMixMember,u8 byEqpId, u8 byReplaceMember,u16 &wErrorCode)
{
	if(!IsStartCascadeMixCheckPass(byMtNum,eMixMode,ptMixMember,byEqpId,wErrorCode))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[StartCascadeMix]IsStartCascadeMixCheckPass failed!\n");
        
        return FALSE;
	}

	StartCascadeMixDataCoordinate(byMtNum,eMixMode,ptMixMember,byEqpId);

	if(eMixMode == mcuPartMix)
	{
		TPeriEqpStatus tPeriStatus;
		g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriStatus);

		//不需要再开启混音器
		if(    tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState ==TMixerGrpStatus::MIXING
			|| tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState == TMixerGrpStatus::WAIT_START_SPECMIX
			|| tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState == TMixerGrpStatus::WAIT_START_AUTOMIX
			|| tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState == TMixerGrpStatus::WAIT_START_VAC
			|| tPeriStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState == TMixerGrpStatus::WAIT_START_AUTOMIXANDVAC)
		{
			if (m_tConf.m_tStatus.IsVACing())
			{
				NotifyMcsAlarmInfo(0, ERR_MCU_MMCUSPECMIX_VAC);
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[AddMixerMemberCmd] Local VAC mode has been canceled due to cas specmixing\n" );
				u8 byMixerSubtype = UNKONW_MIXER;
				g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetEqpId(),byMixerSubtype);
				if (byMixerSubtype == EAPU_MIXER || byMixerSubtype == APU2_MIXER)
				{
					if (m_tConf.m_tStatus.IsNoMixing())
					{
						NotifyMixerSendToMt(TRUE);
					}
					
					CServMsg cServMsg;
					SendMsgToEqp( m_tMixEqp.GetEqpId(), MCU_MIXER_STOPVAC_CMD, cServMsg );
				}
				m_tConf.m_tStatus.SetVACing(FALSE);
			}


			m_tConf.m_tStatus.SetSpecMixing(TRUE);
			
			if ( byReplaceMember || 
				m_tConf.m_tStatus.IsAutoMixing() || 
				m_tConf.m_tStatus.IsVACing() ||
			    !m_ptMtTable->IsMtInMixing(m_tCascadeMMCU.GetMtId()))
			{
				for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
				{
					TMt tTempMt;
					
					if (m_tConfAllMtInfo.MtJoinedConf(byMtId) 
						&& (m_ptMtTable->IsMtInMixGrp(byMtId)
						    ||m_ptMtTable->IsMtInMixing(byMtId)) )            
					{
						tTempMt = m_ptMtTable->GetMt(byMtId);
						RemoveSpecMixMember(&tTempMt, 1, FALSE, FALSE);
					}
				}
			}
						
			//将上级加入混音器
			if (!m_ptMtTable->IsMtInMixing(m_tCascadeMMCU.GetMtId()))
			{
				AddSpecMixMember( &m_tCascadeMMCU, 1, FALSE );
			}
			
			AddSpecMixMember( ptMixMember, byMtNum, FALSE );
			SwitchMixMember( TRUE );
			
			ConfModeChange();
			
			ConfStatusChange();
		}
		else
		{
			if (!StartMixing(mcuPartMix,byEqpId))
			{
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[ProcMixStart] StartMixing operation is failed!\n");
				wErrorCode = ERR_MCU_NOIDLEMIXER_INCONF;
				
				return FALSE;
			}
		}
	}
	else if (eMixMode == mcuWholeMix )
	{
		if(m_tConf.m_tStatus.IsNoMixing() )
		{
			if(m_tConf.m_tStatus.IsVACing())
			{
				SwitchMixModeVacToVacWhole();
			}
			else
			{
				if (!StartMixing(mcuWholeMix,byEqpId))
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[ProcMixStart] StartMixing operation is failed!\n");
					wErrorCode = ERR_MCU_NOIDLEMIXER_INCONF;
					
					return FALSE;
				}

				// [chendaiwei 2010/09/28] N+1通知备端智能混音状态更新
				if( MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
				{
					ProcNPlusAutoMixUpdate(TRUE);
				}
			}
		}
		else if ( m_tConf.m_tStatus.IsSpecMixing())
		{
			SwitchMixModeSpecToAutoMix();
		}
		else if(m_tConf.m_tStatus.IsAutoMixing())
		{
			//智能混音透传自然支持
		}
	}

	return TRUE;
}

/*====================================================================
    函数名      StartLocalMix
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtNum 参与混音终端数 emMcuMixMode eMixMode混音模式
				  TMt *ptMixMember混音成员
				  u8 byEqpId 混音器ID
				  u16 &wErrorCode错误码
    返回值说明  ：开启成功返回TRUE，开启失败返回FALSE
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/05/23    4.7.2       chendaiwei    创建
====================================================================*/
//TODO:模式优先
BOOL32 CMcuVcInst::StartLocalMix( u8 byMtNum, emMcuMixMode eMixMode,TMt *ptMixMember,u8 byEqpId,u16 &wErrorCode)
{
	if(!IsStartLocalMixCheckPass(byMtNum, eMixMode,ptMixMember,byEqpId,wErrorCode))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[StartLocalMix]IsStartMixCheckPass failed!\n");
        
        return FALSE;
	}

	StartLocalMixDataCoordinate(byMtNum,eMixMode,ptMixMember,byEqpId);

	if(eMixMode == mcuPartMix)
	{
		if (!StartMixing(mcuPartMix,byEqpId))
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[StartLocalMix] StartMixing operation is failed!\n");
			wErrorCode = ERR_MCU_NOIDLEMIXER_INCONF;
			
			return FALSE;
		}
	}
	else if (eMixMode == mcuWholeMix)
	{
		if(m_tConf.m_tStatus.IsVACing())
		{
			SwitchMixModeVacToVacWhole();
		}
		else
		{
			if (!StartMixing(mcuWholeMix,byEqpId))
			{
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[StartLocalMix] StartMixing operation is failed!\n");
				wErrorCode = ERR_MCU_NOIDLEMIXER_INCONF;
				
				return FALSE;
			}
		
			// [chendaiwei 2010/09/28] N+1通知备端智能混音状态更新
			if( MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
			{
				ProcNPlusAutoMixUpdate(TRUE);
			}
		}
	}

	return TRUE;
}

/*====================================================================
    函数名      ：SwitchMixModeSpecToAutoMix
    功能        ：切换混音模式（定制到智能混音）
    算法实现    ：仅限级联
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/05/20    4.7.2       chendaiwei    创建
====================================================================*/
void CMcuVcInst::SwitchMixModeSpecToAutoMix( void )
{
	TMt tMt;
	u8 byMtIdx = 0;
    //移除当前所有的定制混音成员
    for( byMtIdx = 1; byMtIdx <= MAXNUM_CONF_MT; byMtIdx++ )
    {
        if ( m_tConfAllMtInfo.MtInConf(byMtIdx) && m_ptMtTable->IsMtInMixing(byMtIdx) )
        {
            tMt = m_ptMtTable->GetMt(byMtIdx);
            RemoveSpecMixMember(&tMt, 1, FALSE, FALSE);
        }
    }
    
	//设置当前为智能混音状态
    m_tConf.m_tStatus.SetAutoMixing(TRUE);
	
	// [chendaiwei 2010/09/28] N+1通知备端智能混音状态更新
	if( MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
	{
		ProcNPlusAutoMixUpdate(TRUE);
	}
	NotifyChairmanMixMode();
	
    // 重新建交换，开启智能混音
    u8 byMixMtNum = 0;
    for (byMtIdx = 1; byMtIdx <= MAXNUM_CONF_MT; byMtIdx++)
    {
        if (m_tConfAllMtInfo.MtJoinedConf(byMtIdx))
        {
			if (m_ptMtTable->GetMtType(byMtIdx) == MT_TYPE_VRSREC)
			{
				continue;
			}
            tMt = m_ptMtTable->GetMt(byMtIdx);
            if (byMixMtNum < GetMaxMixNum(m_tMixEqp.GetEqpId()))
            {               
                AddMixMember(&tMt, DEFAULT_MIXER_VOLUME, FALSE);
				StartSwitchToPeriEqp(tMt, 0, m_tMixEqp.GetEqpId(), 
					(MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+GetMixChnPos(tMt)), 
					MODE_AUDIO, SWITCH_MODE_SELECT);
                byMixMtNum++;
            }  
        }
    }
	
    //卫星会议音频广播交换取混音器的Ｎ码流
    
    if (m_tConf.GetConfAttrb().IsSatDCastMode())
    {
		u8 bySrcChnnl = GetMixerNModeChn();
        g_cMpManager.StartDistrConfCast(m_tMixEqp, MODE_AUDIO, bySrcChnnl);
    }
	
    //整理N模式交换
    for (byMtIdx = 1; byMtIdx <= MAXNUM_CONF_MT; byMtIdx++)
    {
        if ( m_tConfAllMtInfo.MtJoinedConf(byMtIdx) && !m_ptMtTable->IsMtInMixGrp(byMtIdx) )
        {
			if (m_ptMtTable->GetMtType(byMtIdx) == MT_TYPE_VRSREC)
			{
				continue;
			}
            tMt = m_ptMtTable->GetMt(byMtIdx);
            SwitchMixMember(&tMt, TRUE);
        }           
    }

	MixerStatusChange();

	return;
}

/*====================================================================
    函数名      ：SwitchMixModeVacToVacWhole
    功能        ：切换混音模式（语音激励到语音激励+智能模式）
    算法实现    ：仅限级联
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/05/20    4.7.2       chendaiwei    创建
====================================================================*/
void CMcuVcInst::SwitchMixModeVacToVacWhole( void )
{
	m_tConf.m_tStatus.SetAutoMixing();
	u8 byMixDepth = GetMaxMixerDepth(m_tMixEqp.GetEqpId());
	m_tMixEqp.SetConfIdx(m_byConfIdx);
	
	// [chendaiwei 2010/09/28] N+1通知备端智能混音状态更新
	if( MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
	{
		ProcNPlusAutoMixUpdate(TRUE);
	}
	
	TMcu tMcu;
	tMcu.SetMcu(LOCAL_MCUID);	
	CServMsg	cServMsg;		
	cServMsg.SetMsgBody((u8 *)&tMcu, sizeof(tMcu)); 
	cServMsg.CatMsgBody((u8*)&byMixDepth, 1);
	if(!m_tCascadeMMCU.IsNull())
	{
		cServMsg.SetDstMtId(m_tCascadeMMCU.GetMtId());
		SendMsgToMt(m_tCascadeMMCU.GetMtId(), MCU_MCU_STARTMIXER_NOTIF, cServMsg);						
	}
	NotifyChairmanMixMode();
	
	TMt tMt;
	TMt atDstMt[MAXNUM_CONF_MT];
	memset( atDstMt, 0, sizeof(atDstMt) );
	u8 byDstMtNum = 0;
	
	TMtStatus tStatus;
	u8 byMixMemberNum = 0;
	TMt atMixMemberGrp[MAXNUM_MIXING_MEMBER];
	u8 byLoop = 0;
	//添加混音成员, 混音器交换码流给mt
	for( byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++)
	{
		if (m_tConfAllMtInfo.MtJoinedConf(byLoop))
		{
			if (m_ptMtTable->GetMtType(byLoop) == MT_TYPE_VRSREC)
			{
				continue;
			}
			tMt = m_ptMtTable->GetMt(byLoop);
			if (m_ptMtTable->GetManuId(byLoop) == MT_MANU_CHAORAN)
			{
				SwitchMixMember(&tMt, TRUE);
			}
			else
			{	
				if ( m_ptMtTable->IsMtInMixGrp(byLoop) && byMixMemberNum < MAXNUM_MIXING_MEMBER )
				{
					atMixMemberGrp[byMixMemberNum] = tMt;
					byMixMemberNum++;
				}
				
				if( m_tConf.GetChairman() == tMt &&
					m_ptMtTable->GetMtStatus( byLoop,&tStatus ) &&
					!tStatus.GetSelectMt(MODE_AUDIO).IsNull() )
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER,  "[ProcMixStart] Chairman has audio select.not stop audio switch\n" );
				}
				else
				{
					atDstMt[byDstMtNum] = tMt;
					byDstMtNum ++;
				}					
			}
		}
	}
	
	if (byDstMtNum > 0)
	{
		StopSwitchToSubMt(byDstMtNum, atDstMt, MODE_AUDIO, FALSE);
	}
	
	//zjl 20110510 建交换到混音成员
	SwitchMixMember(FALSE);
	
	//补一下终端到混音器的N-1模式RTCP交换
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	if ( tConfAttrb.IsResendLosePack() && byMixMemberNum > 0 )
	{
		AddRemoveMixRtcpMember(byDstMtNum, atMixMemberGrp, TRUE);
	}
	
	//TODO:changeAudBrdSrc
	//通知混音器开始向终端发码流
	NotifyMixerSendToMt(TRUE);
	SetAudBrdSrc(m_tMixEqp);
	MixerStatusChange();
	
	//多格式混音建桥
	TAudioTypeDesc atAudTypeInfo[MAXNUM_CONF_AUDIOTYPE];
	u8 byAudCapNum = m_tConfEx.GetAudioTypeDesc(atAudTypeInfo);
	for ( byLoop = 0; byLoop < byAudCapNum; byLoop++)
	{
		g_cMpManager.SetSwitchBridge(m_tMixEqp, GetMixerNModeChn() + byLoop, MODE_AUDIO);	
	}
	MtStatusChange(	NULL,TRUE );

	return;
}

/*====================================================================
    函数名      ：ProcMixStop
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/11/09    4.0         张宝卿          创建
====================================================================*/
void CMcuVcInst::ProcMixStop( CServMsg &cServMsg, BOOL32 bRCStop )
{
    //尚未处于混音状态, NACK 
    if ( m_tConf.m_tStatus.IsNoMixing() )
    {
        cServMsg.SetErrorCode( ERR_MCU_CONFNOTINDISCUSSCMODE );
        if ( cServMsg.GetEventId() != MCU_MCU_STOPMIXER_CMD )
        {
            SendReplyBack( cServMsg, cServMsg.GetEventId() + 2 );
        }
        return;
    }
    
    //ACK
    if ( MCU_MCU_STOPMIXER_CMD != cServMsg.GetEventId() )
    {
        SendReplyBack(cServMsg, cServMsg.GetEventId() + 1);
    }

	TMt tMt;
    if ( m_tConf.m_tStatus.IsAutoMixing() )
    {
        OnStopDiscussToAllSMcu(&cServMsg); 
		//[chendaiwei 2010/09/28]N+1通知备端智能混音状态更新
		if( MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
		{
			ProcNPlusAutoMixUpdate(FALSE);
		}
    }
    else if ( m_tConf.m_tStatus.IsSpecMixing() )
    {
        for( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
        {
            tMt = m_ptMtTable->GetMt(byMtId);
            if ( MT_TYPE_SMCU == tMt.GetMtType() &&
                 ( m_ptMtTable->IsMtInMixing(byMtId) || bRCStop ))
            {
                TMt tSMcu;
                tSMcu.SetMcu(byMtId);
                CServMsg cMsg;
                cMsg.SetMsgBody((u8*)&tSMcu, sizeof(TMt));
                OnStopMixToSMcu( &cMsg );
            }
        }
    }
    
	/*
	//  [12/3/2009 pengjie] 级联多回传支持 这里释放相应的回传和混音资源
	for( u8 byMixChn = 0; byMixChn < MAXNUM_MIXER_CHNNL + 1; byMixChn++ )
	{
		// 1、取出混音通道成员 如果是回传成员，尝试释放该回传通道
		// 2、释放混音通道
		if( !m_atMixMt[byMixChn].IsLocal() && !m_atMixMt[byMixChn].IsNull() )
		{
			FreeSpyMixerMember( m_atMixMt[byMixChn] );
		}
	}
    // End
	*/

    if (m_tConf.m_tStatus.IsVACing())
    {
		BOOL32 byOldIsDiscuss = m_tConf.m_tStatus.IsAutoMixing();
        // guzh [11/7/2007] 只设置状态
        m_tConf.m_tStatus.SetNoMixing();
        
        //通知混音器停止向终端发码流
        NotifyMixerSendToMt(FALSE);
        
		TMt atDstMt[MAXNUM_CONF_MT];
		memset(atDstMt, 0, sizeof(atDstMt));
		u8  byDstMtNum = 0;
		TMtStatus tStatus;
        //停止混音器向终端的交换
        for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
        {
            if (m_tConfAllMtInfo.MtJoinedConf(byMtId))
            {         
				//zjl 20110510 StopSwitchToSubMt 接口重载替换
                //StopSwitchToSubMt(byMtId, MODE_AUDIO, SWITCH_MODE_BROADCAST, FALSE);
				if( //m_tConf.GetChairman().GetMtId() == byMtId &&
					m_ptMtTable->GetMtStatus( byMtId,&tStatus ) &&
					!tStatus.GetSelectMt(MODE_AUDIO).IsNull() )
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER,  "[ProcMixStop] mt.%d has audio select.not stop audio switch\n",byMtId );
				}
				else
				{
					atDstMt[byDstMtNum] = m_ptMtTable->GetMt(byMtId);
					byDstMtNum ++;
				}
            }
        }

		if (byDstMtNum > 0)
		{
			StopSwitchToSubMt(byDstMtNum, atDstMt, MODE_AUDIO, FALSE);
		}
        
        //通知主席及所有会控
        MixerStatusChange();
        
        TMt tMcu;
        tMcu.SetMcu(LOCAL_MCUID);
        cServMsg.SetMsgBody((u8 *)&tMcu, sizeof(tMcu));
        if(!m_tCascadeMMCU.IsNull())
        {
            cServMsg.SetDstMtId( m_tCascadeMMCU.GetMtId() );
            SendMsgToMt(m_tCascadeMMCU.GetMtId(), MCU_MCU_STOPMIXER_NOTIF, cServMsg);
        }
        if( HasJoinedChairman() )
        {
			//20101213_tzy 添加混音模式字段
            u8 byMixMode = m_tConf.m_tStatus.GetMixerMode();
            cServMsg.SetMsgBody(&byMixMode, sizeof(byMixMode));
            SendMsgToMt( m_tConf.GetChairman().GetMtId(), MCU_MT_STOPDISCUSS_NOTIF, cServMsg );
        }
        
        //改变视频源
        if( HasJoinedSpeaker() )
        {
            TMt tSpeakerMt = GetLocalSpeaker();
            ChangeAudBrdSrc( &tSpeakerMt );

			//zjj20090925 补建唇音同步状态下bas到各个终端的音频交换
			StartSwitchAud3MtNeedAdp();

			if( m_tCascadeMMCU.IsNull() )
			{
				NotifyAllSMcuMediaInfo( 0,MODE_AUDIO );
			}
        }
        else
        {
            ChangeAudBrdSrc( NULL );
        }
		
		//停止讨论，若存在主席，自动开启主席定制混音
		if (g_cMcuVcApp.IsChairAutoSpecMix() && byOldIsDiscuss )
		{
			ChairmanAutoSpecMix();
		}
    }
    else
    {
        StopMixing();//停止混音，等ACK回来设置状态
    }

    return;
}


/*------------------------------------------------------------------*/
/*                                 VMP                              */
/*------------------------------------------------------------------*/

/*====================================================================
    函数名      ：IsDynamicVmp
    功能        ：画面合成是否是动态分屏
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/04/01    3.0         胡昌威         创建
====================================================================*/
BOOL32 CMcuVcInst::IsDynamicVmp( u8 byVmpId )
{
	if (!IsValidVmpId(byVmpId))
	{
		return FALSE;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );

	if( g_cMcuVcApp.GetVMPMode(tVmpEqp) != CONF_VMPMODE_AUTO )
	{
		return FALSE;
	}

	return TRUE;
}

/*====================================================================
    函数名      ：SetVmpChnnl
    功能        ：设置画面合成器通道 
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/04    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::SetVmpChnnl(u8 byVmpId, TMt tMt, u8 byChnnl, u8 byMemberType, BOOL32 bMsgMcs)
{
	if (!IsValidVmpId(byVmpId))
	{
        ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[SetVmpChnnl] VmpId:%d not Valid.", byVmpId);
        return;
	}
	// 加保护,若byChnnl为错误通道号,直接返回
	if (byChnnl >= MAXNUM_VMP_MEMBER)
	{
        ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[SetVmpChnnl] byChnnl:%d not available for vmp.", byChnnl);
        return;
	}

	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
    CServMsg cServMsg;

    TMt tLocalMt = GetLocalMtFromOtherMcuMt(tMt);

	// 获得要调整的通道
	BOOL32 bIsDStream = FALSE;
	u8 byChannel = LOGCHL_VIDEO;
	u8 byMode = MODE_VIDEO;
	if (VMP_MEMBERTYPE_DSTREAM == byMemberType)
	{
		bIsDStream = TRUE;
		byChannel = LOGCHL_SECVIDEO;
		byMode = MODE_SECVIDEO;
	}

    // guzh [5/23/2007] 这里检测终端条件是否在线作为最后保护
    if ( tMt.IsNull() ||
         !m_tConfAllMtInfo.MtJoinedConf(tMt.GetMcuId(), tMt.GetMtId()) )
    {
        ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[SetVmpChnnl] Mt.%d not available for vmp chnl.%d.", tLocalMt.GetMtId(), byChnnl );
        return;
    }
	
	TVMPParam_25Mem tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
	TVMPMember *ptVmpMember = tLastVmpParam.GetVmpMember(byChnnl);
	BOOL32 bLogicChnlOpen = m_ptMtTable->IsLogicChnnlOpen(tLocalMt.GetMtId(), byChannel, FALSE);
	// 支持电话终端进VMP
	BOOL32 bIsPhoneMt = IsPhoneMt(tMt);
	if (!bLogicChnlOpen || bIsPhoneMt)
	{
		// 停旧交换
		u8 byLastMode = MODE_VIDEO;
		if (ptVmpMember && VMP_MEMBERTYPE_DSTREAM == ptVmpMember->GetMemberType())
		{
			byLastMode = MODE_SECVIDEO;
		}
		StopSwitchToPeriEqp(tVmpEqp.GetEqpId(), byChnnl, FALSE, byLastMode);
		/* VCS会议支持电话终端进VMP
		if (m_tConf.GetConfSource() != VCS_CONF)
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[SetVmpChnnl] Mt.%d not available for vmp chnl.%d.", tLocalMt.GetMtId(), byChnnl );
			return;
		}*/
	}

	TPeriEqpStatus tPeriEqpStatus; 
	memset( &tPeriEqpStatus,0,sizeof(TPeriEqpStatus) );
	// 现在vcs有加保护,防止频繁操作,Setvmpchnl时不需要参照PeriEqpStatus信息,此时PeriEqpStatus信息用来给MCS刷图标
	/*if( !tMt.IsLocal() && m_tConf.GetConfSource() == VCS_CONF &&
		m_tConf.m_tStatus.GetVmpParam().IsVMPAuto() &&
		g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tPeriEqpStatus )
		)
	{
		
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,"[SetVmpChnnl] (%d.%d) is in vmpMember.(%d) \n",
			tMt.GetMcuId(),
			tMt.GetMtId(),
			tPeriEqpStatus.m_tStatus.tVmp.m_tVMPParam.IsMtInMember( tMt )
			);
			
		
		if( !tPeriEqpStatus.m_tStatus.tVmp.m_tVMPParam.IsMtInMember( tMt ) )
		{
			//zjj20100226 由于时序问题，这里务必要把会议的vmp成员信息更新成vmp设备的成员信息
			TVMPParam tVmpParam = m_tConf.m_tStatus.GetVmpParam();
			if( tVmpParam.IsMtInMember( tMt ) )
			{
				m_tConf.m_tStatus.SetVmpParam( tPeriEqpStatus.m_tStatus.tVmp.m_tVMPParam );
			}
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[SetVmpChnnl] tMt(%d.%d) is not in vmpMember. so not switch to vmp!\n",
					tMt.GetMcuId(),tMt.GetMtId()
					);
			return;
		}
	}*/

    //开始交换码流
    // guzh [4/24/2007] 照理目前不支持放像进入vmp
    //u8 bySrcChnnl = (m_tVidBrdSrc == m_tPlayEqp) ? m_byPlayChnnl : 0;
    u8 bySrcChnnl = (tLocalMt == m_tPlayEqp) ? m_byPlayChnnl : 0;
		 
    // xliang [4/14/2009] 根据具体情况建交换. 
	// 该判断对于模板启画面合成的情况不适用，所以交换还是得建，只是修改bStopBeforeStart值
	BOOL32 bStopBeforeStart = TRUE;
	if( ptVmpMember != NULL 
		&& ptVmpMember->GetMcuId() == tMt.GetMcuId()
		&& ptVmpMember->GetMtId() == tMt.GetMtId()
		&& ptVmpMember->GetMemberType() == byMemberType
		)
// 	if (m_tLastVmpParam.IsMtInMember(tMt) 
// 		&& m_tLastVmpParam.GetChlOfMtInMember(tMt) == byChnnl)
	{
		bStopBeforeStart = FALSE;
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "Mt.%u in the channel.%u has no change, so no bStopBeforeStart!\n",
			tMt.GetMtId(), byChnnl);
	}

	
    //改变状态
	TVMPParam_25Mem tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
    TVMPMember tVMPMember;
	tVMPMember = *tConfVmpParam.GetVmpMember( byChnnl );
	if( tVMPMember.IsNull() ||
		!tVMPMember.IsLocal() ||
		MT_TYPE_SMCU != m_ptMtTable->GetMtType(tVMPMember.GetMtId()) ||
		!IsMtInMcu(tVMPMember,tMt) 
		)
	{
		tVMPMember.SetMemberTMt(tMt);
		tVMPMember.SetMemberType(byMemberType);
		tConfVmpParam.SetVmpMember(byChnnl, tVMPMember);
		if ( bStopBeforeStart &&  !tMt.IsLocal() )
		{
			/*zhouyiliang 20110826,通知mcs刷界面，现在mcs都是通过eqpstatus,同步外设复合状态
			g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tPeriEqpStatus );
			tPeriEqpStatus.m_tStatus.tVmp.m_tVMPParam = m_tConf.m_tStatus.m_tVMPParam;
			g_cMcuVcApp.SetPeriEqpStatus(m_tVmpEqp.GetEqpId(), &tPeriEqpStatus );
			CServMsg cMsg;
			cMsg.SetMsgBody( ( u8 * )&tPeriEqpStatus, sizeof( tPeriEqpStatus ) );
			SendMsgToAllMcs( MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cMsg );*/

			// 新的业务逻辑不需要在Setvmpchnl的时候再通知刷新界面
			//bMsgMcs = TRUE;
		}
	}
	g_cMcuVcApp.SetConfVmpParam(tVmpEqp, tConfVmpParam);

	//zhouyiliang 20100811 MCU_MCU_SPYCHNNL_NOTIF 在建到外设交换前发
	//上次已经建过了，不需再建，
	//zhouyiliang 20100913如果是上传通道里面的终端，且该通道中是mcu,不用SendMMcuSpyNotify
 	BOOL32 bIsOutViewMemberMt = FALSE;
 	TVMPMember tMemeber = *tConfVmpParam.GetVmpMember( byChnnl );
 	if ( MT_TYPE_SMCU == tMemeber.GetMtType() && !tMt.IsLocal() ) 
 	{
 		TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo( GetMcuIdxFromMcuId( tMemeber.GetMtId() ) );
 		if (NULL != ptConfMcInfo && !ptConfMcInfo->m_tMMcuViewMt.IsNull()
 			&& tMt == ptConfMcInfo->m_tMMcuViewMt )
 		{
 			bIsOutViewMemberMt = TRUE;
 		}
 	
 	}
	// 对于下级电话终端不发SendMMcuSpyNotify
 	if (!bIsPhoneMt && !bIsDStream && IsLocalAndSMcuSupMultSpy(tMt.GetMcuId()) && !tMt.IsLocal() && !bIsOutViewMemberMt )
 	{
 		u8 byRes = VIDEO_FORMAT_INVALID;
 		CVmpChgFormatResult cVmpChgFormatResult;
		// bConsiderVmpBrd 默认是TRUE,会导致tMT出前适配通道，此处改为FALSE带下去
 		if (! GetMtFormat(tVmpEqp.GetEqpId(), tMt, &tConfVmpParam, byRes, FALSE) ) 
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_SPY, "[SetVmpChnnl] Get Mt(mcuid.%d, mtid.%d) MtFormat Failed !\n",
				tMt.GetMcuId(), tMt.GetMtId() );
			FreeRecvSpy(tMt,MODE_VIDEO);
			return;
 		} 

		TSimCapSet tSimCapSet = GetMtSimCapSetByMode( GetFstMcuIdFromMcuIdx(tMt.GetMcuId()) );	
		if(tSimCapSet.IsNull())
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_SPY, "[SetVmpChnnl] Get Mt(mcuid.%d, mtid.%d) SimCapSet Failed !\n",
				tMt.GetMcuId(), tMt.GetMtId() );
			FreeRecvSpy(tMt,MODE_VIDEO);
			return;
		}
		// 调整到画面合成要求的分辨率
		tSimCapSet.SetVideoResolution( byRes );

		// 帧率调整,8KH 8KI 1080与720都要降帧
		u8 byVmpSubType = GetVmpSubType(tVmpEqp.GetEqpId());
		if( (VIDEO_FORMAT_HD1080 == byRes || VMP_8KH == byVmpSubType || VMP_8KI == byVmpSubType)
			&& tSimCapSet.GetUserDefFrameRate() >= 50
			)
		{
			//帧率减半 20110418zhouyiliang
			tSimCapSet.SetUserDefFrameRate( tSimCapSet.GetUserDefFrameRate()/2 );
			//tSimCapSet.SetUserDefFrameRate(30);
		}
		
		//如果当前终端已回传则能力集要与已回传目的能力集取小
		if(!GetMinSpyDstCapSet(tMt, tSimCapSet))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_SPY, "[SetVmpChnnl] GetMinSpyDstCapSet failed!\n");
			return;
		}

		// 20120410 yhz 成员与m_tLastVmpParam通道内不一致时,发送SpyNotify
		if (ptVmpMember && !(tMt == (TMt)*ptVmpMember))
		{
 			SendMMcuSpyNotify( tMt,MCS_MCU_STARTVMP_REQ,tSimCapSet );
		}
 	}
	
	if (bLogicChnlOpen && !bIsPhoneMt)
	{
		//[2011/08/18/zhangli]如果vmp通道成员是下级mcu，且tMt不是本级的，则tMt要local
		// 双流跟随通道,需要用local后的建交换
		if (bIsOutViewMemberMt || bIsDStream)
		{
			StartSwitchToPeriEqp(tLocalMt, bySrcChnnl, tVmpEqp.GetEqpId(),
				byChnnl, byMode, SWITCH_MODE_SELECT, FALSE, 
				bStopBeforeStart);
		}
		else
		{
			StartSwitchToPeriEqp(tMt, bySrcChnnl, tVmpEqp.GetEqpId(),
				byChnnl, byMode, SWITCH_MODE_SELECT, FALSE, 
				bStopBeforeStart);
		}
	}

	// [12/25/2009 xliang] 该setIn会影响级联切换发言人的问题，
	// 其实在目前“单回传风险性”逻辑中，此处setin 可省去
//     if (!tMt.IsLocal())
//     {
//         OnMMcuSetIn(tMt, 0, SWITCH_MODE_SELECT);
//     }

	//zhouyiliang 20110823 m_tLastVmpParam的成员只有在SetVmpChnnl成功才更新
	TVMPMember* ptLastMem = tLastVmpParam.GetVmpMember(byChnnl);
	if ( NULL != ptLastMem ) 
	{
		ptLastMem->SetMemberTMt(tMt);
		ptLastMem->SetMemberType(byMemberType);
	}
	g_cMcuVcApp.SetLastVmpParam(tVmpEqp, tLastVmpParam);
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_SPY, "-------------------------------------------\n");
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_SPY, "[SetVmpChnnl] set tMt(%d,%d) to Vmp[%d]Chnnl:%d\n",
		tMt.GetMcuId(), tMt.GetMtId(), byVmpId, byChnnl);
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_SPY, "-------------------------------------------\n");

    //通知会控及主席
    if (bMsgMcs)
    {
		cServMsg.SetEqpId(byVmpId);
        cServMsg.SetMsgBody((u8*)&tConfVmpParam, sizeof(tConfVmpParam));
        SendMsgToAllMcs(MCU_MCS_VMPPARAM_NOTIF, cServMsg);
		SendVmpParamToChairMan();
    }

	//[2011/08/18/zhangli]建立vmp到mt的RTCP交换，在StartSwitchToPeriEqp里建
//     if (m_tConf.GetConfAttrb().IsResendLosePack())
//     {
// 		if (bIsOutViewMemberMt) 
// 		{
// 			BuildRtcpSwitchForSrcToDst(m_tVmpEqp, tLocalMt, MODE_VIDEO, byChnnl);
// 		}
// 		else
// 		{
// 			BuildRtcpSwitchForSrcToDst(m_tVmpEqp, tMt, MODE_VIDEO, byChnnl);
// 		}
//     }
}

/*====================================================================
    函数名      ：GetVmpChnnl
    功能        ：得到画面合成器通道
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/04    3.0         胡昌威         创建
====================================================================*/
u8 CMcuVcInst::GetVmpChnnl( void )
{
	//此接口未被使用，废除
	u8 byChnnl = 0;
	TVMPMember tVMPMember;
	u8 byMemberNum = m_tConf.m_tStatus.GetVmpParam().GetMaxMemberNum();

    //有空闲通道,返回空闲通道
	while( byChnnl < byMemberNum )
	{
		TVMPParam tvmpParam = m_tConf.m_tStatus.GetVmpParam();
        tVMPMember = *tvmpParam.GetVmpMember( byChnnl );
		if( tVMPMember.IsNull() )
		{
			return byChnnl;
		}

        byChnnl ++;
	}

	//没有空闲通道,返回一个未在语音激励结果中的通道
	u8 byChl = 0;
	byChnnl = 0;
	while( byChnnl < byMemberNum )
	{
		TVMPParam tVmpParam = m_tConf.m_tStatus.GetVmpParam();
        tVMPMember = *tVmpParam.GetVmpMember( byChl );
		//if( !m_tConf.m_tStatus.m_tDiscussParam.IsMtInMember( (TMt)tVMPMember ) )
        if ( m_ptMtTable->IsMtInMixing(tVMPMember.GetMtId()))
		{
			return byChl;
		}

		byChnnl++;
        byChl ++;
		if( byChl == byMemberNum )
		{
            byChl = 0;
		}
	}
	

	return byChl;
}


/*====================================================================
    函数名      ：ChangeVmpChannelParam
    功能        ：改变会议画面合成方式
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/05/28    3.6         libo          创建    
	7/8/2009    4.6         xliang		  修正+优化（含FIXME）
	7/25/2011   4.6         彭国锋        Bug00058964修改
====================================================================*/
void CMcuVcInst::ChangeVmpChannelParam(TMt * ptNewSrc, u8 byMemberType, TMt * ptOldSrc)
{
	TVMPParam_25Mem  tVmpParam;
	u8 byVmpId = 0;
	TEqp tVmpEqp;
	// zbq [06/01/2007] 是否真正调整了通道参数
	BOOL32 bVmpParamChged = FALSE;
	for (u8 byIdx = 0; byIdx < MAXNUM_CONF_VMP; byIdx++)
	{
		if (!IsValidVmpId(m_abyVmpEqpId[byIdx]))
		{
			continue;
		}
		
		byVmpId = m_abyVmpEqpId[byIdx];
		tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
		tVmpParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp); 
		// 跟随通道合成成员调整判断
		bVmpParamChged = IsVmpChannelParamChged(tVmpEqp, tVmpParam, ptNewSrc, byMemberType, ptOldSrc);
   
		// zbq [06/01/2007] 通道参数均未调整，则不告知VMP修改参数。否则，引发的此次
		// 无谓的修改将导致交换重新调整，对8000C来说，由于性能限制，合成画面将不能平滑过渡
		if ( bVmpParamChged )
		{
			
			// 卫星会议有调整，需要考虑会不会超出 [pengguofeng 2/18/2013]
			if ( m_tConf.GetConfAttrb().IsSatDCastMode() && ptNewSrc != NULL
				&& //IsOverSatCastChnnlNum(tVmpParam))TMt * ptNewSrc, u8 byMemberType
				!IsSatMtCanContinue(GetLocalMtFromOtherMcuMt(*ptNewSrc).GetMtId(),emVmpChnChange,
								&tVmpEqp,tVmpParam.GetChlOfMemberType(byMemberType), 0xFF, &tVmpParam))
			{
				tVmpParam.ClearVmpMember(tVmpParam.GetChlOfMemberType(byMemberType));
				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeVmpChannelParam]Sat conf:change Vmp Param Failed, return\n");
				//return;
			}

			//lukunpeng 2010/07/09 此处为什么需要在AdjustVmpParam之前就覆盖当前参数呢？
			//AdjustVmpParam内部会做赋值操作啊。之前就设定好，在调整分辨率的时候，
			//发现已经在画面合成中，会Return FALSE

			AdjustVmpParam(byVmpId, &tVmpParam);

		}

	}
    return;
}

/*==============================================================================
函数名    :  IsVmpChannelParamChged
功能      :  跟随通道合成成员调整判断
算法实现  :  
参数说明  :  const TEqp &tVmpEqp in
			 TVMPParam_25Mem &tVmpParam in/out
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130531					yanghuaizhi							
==============================================================================*/
BOOL32 CMcuVcInst::IsVmpChannelParamChged(const TEqp &tVmpEqp, TVMPParam_25Mem &tVmpParam, TMt * ptNewSrc, u8 byMemberType, TMt * ptOldSrc)
{
	BOOL32 bVmpParamChged = FALSE;
	u8 byMaxMemberNum = tVmpParam.GetMaxMemberNum();
	// 合成模式不正确，不做调整,可能正在开启中
	if (tVmpParam.GetVMPMode() == CONF_VMPMODE_NONE)
	{
		return FALSE;
	}

	if (!tVmpParam.IsVMPAuto())
	{
		// xliang [3/20/2009] 为保证高清会议下，MPU没有同一个MT进多个通道，对发言人跟随做策略调整
		u8 byVmpSubType = GetVmpSubType(tVmpEqp.GetEqpId());
		if(	byMemberType == VMP_MEMBERTYPE_SPEAKER 
			&& !IsAllowVmpMemRepeated(tVmpEqp.GetEqpId())// [2/17/2012 pengguofeng]新需求：8000A和8000H都通过配置文件来决定
			)
		{
			AdjustVmpParambyMemberType(tVmpEqp.GetEqpId(), ptNewSrc, tVmpParam, byMemberType, ptOldSrc);
			bVmpParamChged = TRUE;
		}
		else
		{
			u16 wError = 0;
			//检查并修正画面合成参数
			//级联单回传会议下级终端与发言人跟随同时在vmp中,刷新发言人跟随通道同时也要刷新其它下级终端所在通道.yhz
			if ( !CheckVmpParam(tVmpEqp.GetEqpId(), tVmpParam, wError ) )
			{
				tVmpParam.Print(LOG_LVL_KEYSTATUS);
				ConfPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[ChangeVmpChannelParam] CheckVmpParam failed, wError[%d].\n", wError);
				return FALSE;
			}
			
			TMt tMt;
			TVMPMember tVmpMember;
			TPollInfo tPollInfo;
			BOOL32 bNoneKeda = FALSE;
			BOOL32 bClearMember = FALSE;//是否清除通道,用于非科达终端进跟随通道,仅保留1路跟随,其余关闭
			u8 byLoop = 0;
			if (ptNewSrc && !ptNewSrc->IsNull())
			{
				bNoneKeda = !IsKedaMt(*ptNewSrc, TRUE) || !IsKedaMt(*ptNewSrc, FALSE);
			}
			if (NULL != m_tConf.m_tStatus.GetPollInfo())
			{
				tPollInfo = *(m_tConf.m_tStatus.GetPollInfo());
			}
			for (byLoop = 0; byLoop < byMaxMemberNum; byLoop++)
			{
				bClearMember = FALSE;
				if ( tVmpParam.GetVmpMember(byLoop)->GetMemberType() == byMemberType )
				{
					// 顾振华 [5/23/2006] 只允许终端进入通道，不允许放像设备
					if (ptNewSrc == NULL || ptNewSrc->GetType() == TYPE_MCUPERI)
					{ 
						tMt.SetNull();
					}
					// 非科达终端不能进多通道,仅保留1路vmp跟随通道
					else if (bNoneKeda && byLoop != tVmpParam.GetChlOfMemberType(byMemberType))
					{
						tMt.SetNull();
						bClearMember = TRUE;
					}
					else
					{
						tMt = *ptNewSrc;
					}

					tVmpParam.ClearVmpMember(byLoop);

					if (!bClearMember)
					{
						tVmpMember.SetMemberTMt(tMt);
						tVmpMember.SetMemberType(byMemberType);
						tVmpParam.SetVmpMember(byLoop, tVmpMember);
					}

					bVmpParamChged = TRUE;
				}

				// 2011-7-25 add by peng guofeng: Bug00058964重新修改：在此处提前设置画面合成参数，并在后面设置到外设中去
				if (tVmpParam.GetVmpMember(byLoop)->GetMemberType() == VMP_MEMBERTYPE_SPEAKER
					&& byMemberType == VMP_MEMBERTYPE_POLL) //只有轮询会影响发言人,主席不影响
					//&& byMemberType != VMP_MEMBERTYPE_SPEAKER) // 顺便操作的业务不应该是和输入参数类型一样的，那样会重复做2回
				{
					if ( ptNewSrc && !ptNewSrc->IsNull() &&
						 (tPollInfo.GetMediaMode() == MODE_BOTH || tPollInfo.GetMediaMode() == MODE_BOTH_BOTH)
						) //只针对会改变发言人的场景调整发言人,不影响发言人跟随通道的,无需重调
					{
						//非科达终端不能进vmp多通道,仅保留1路vmp跟随通道
						if (bNoneKeda && byLoop != tVmpParam.GetChlOfMemberType(VMP_MEMBERTYPE_SPEAKER))
						{
							tMt.SetNull();
							bClearMember = TRUE;
						}
						else
						{
							tMt = *ptNewSrc;
						}

						tVmpParam.ClearVmpMember(byLoop);
						
						if (!bClearMember)
						{
							tVmpMember.SetMemberTMt(tMt);
							tVmpMember.SetMemberType(VMP_MEMBERTYPE_SPEAKER);
							tVmpParam.SetVmpMember(byLoop, tVmpMember);
						}
					
						bVmpParamChged = TRUE;
					}
				}
				// 2011-7-25 add end
			} 

			//zgc, 2007-12-24, 没有跟随模式时拖合成终端为发言人或主席
			if ( byMemberType == VMP_MEMBERTYPE_SPEAKER || byMemberType == VMP_MEMBERTYPE_CHAIRMAN )
			{
				if ( ( ptNewSrc != NULL && !ptNewSrc->IsNull() && ptNewSrc->GetType() != TYPE_MCUPERI && tVmpParam.IsMtInMember( *ptNewSrc ) )
					|| ( ptOldSrc != NULL && !ptOldSrc->IsNull() && ptOldSrc->GetType() != TYPE_MCUPERI && tVmpParam.IsMtInMember( *ptOldSrc ) )
					)
				{
					bVmpParamChged = TRUE;
				}

				// 级联单回传时，需要将同mcu下的下级终端都更新为新发言人
				TVMPMember *ptVmpMember = NULL;
				if (ptNewSrc != NULL && !ptNewSrc->IsNull() && !ptNewSrc->IsLocal() 
					&& byMemberType == VMP_MEMBERTYPE_SPEAKER && !IsLocalAndSMcuSupMultSpy(ptNewSrc->GetMcuId()))
				{
					TMt tLocalMt = GetLocalMtFromOtherMcuMt(*ptNewSrc);
					for (byLoop = 0; byLoop < byMaxMemberNum; byLoop++)
					{
						ptVmpMember = tVmpParam.GetVmpMember(byLoop);
						// 跳过空成员，跳过本级成员
						if (NULL == ptVmpMember || ptVmpMember->IsNull() || ptVmpMember->IsLocal())
						{
							continue;
						}
						// 同一mcu下终端，更新为新发言人
						if (tLocalMt == GetLocalMtFromOtherMcuMt(*ptVmpMember))
						{
							ptVmpMember->SetMemberTMt(*ptNewSrc);
							bVmpParamChged = TRUE;
						}
					}
				}
			}
		}
	}        
	else
	{     
		u8  byNewMemberChnl = MAXNUM_VMP_MEMBER;
		if (byMemberType == VMP_MEMBERTYPE_SPEAKER)
		{
			byNewMemberChnl = 0;
		}
		else if (byMemberType == VMP_MEMBERTYPE_CHAIRMAN)
		{
			if(HasJoinedSpeaker() && GetLocalSpeaker().GetType() != TYPE_MCUPERI)
			{
				byNewMemberChnl = 1;
			}
			else
			{
				byNewMemberChnl = 0;
			}
			
		}
		else if (byMemberType == VMP_MEMBERTYPE_POLL)
		{
			byNewMemberChnl = 2;
		}

		if (ptNewSrc != NULL)
		{
			if (!ptNewSrc->IsNull())
			{
				if (tVmpParam.IsMtInMember(*ptNewSrc) &&
					byNewMemberChnl < MAXNUM_VMP_MEMBER)
				{
					if (byMemberType == VMP_MEMBERTYPE_CHAIRMAN 
						&&
						//拖发言人做主席，需要调整成员。原主席边框颜色和成员类型需改变[9/19/2012 chendaiwei]
						( /*(!ptNewSrc->IsNull() && ptNewSrc->GetMtId() == GetLocalSpeaker().GetMtId())
						|| */byMaxMemberNum < 2 )
						)
					{
						if(byMaxMemberNum >= 2)
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangeVmpChannelParam] Mt.%u is both speaker and chairman, ignore change!\n", ptNewSrc->GetMtId());
						}
						return FALSE;
					}
					
					TVMPMember tVmpMember    = *(tVmpParam.GetVmpMember(byNewMemberChnl)); 
					u8 byMemberChnl  = tVmpParam.GetChlOfMtInMember(*ptNewSrc);
					TVMPMember tTmpVmpMember;
					tTmpVmpMember.SetNull();
					if (byMemberChnl < MAXNUM_VMP_MEMBER)
					{
						tTmpVmpMember = *(tVmpParam.GetVmpMember(byMemberChnl));
					}
					
					if(tVmpMember.GetMtId() == tTmpVmpMember.GetMtId()
						&& tVmpMember.GetMcuId() == tTmpVmpMember.GetMcuId() )
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangeVmpChannelParam] vmp member has no change at all, so no need to change vmp param!\
							but Mt format still need to change!\n");
						
						// 只有在vmp非广播的时候拖第1个终端做发言人时,vmp风格和成员不变,发言人可能进前适配,需要调分辨率
						if (byMemberType == VMP_MEMBERTYPE_SPEAKER && !tVmpParam.IsVMPBrdst())
						{
							//only change video format due to Speaker VIP
							ChangeMtVideoFormat( tVmpMember, FALSE );
						}
						
						// 改变主席时,若有发言人,且默认是发言人选看主席,此时主席可能进前适配
						// 由于发言人选看是在后面做,此处调分辨率主席仍进不了前适配,全调时会调整前适配
						if (byMemberType == VMP_MEMBERTYPE_CHAIRMAN)
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangeVmpChannelParam] byMemberType is MEMBERTYPE_CHAIRMAN, speaker maybe see chairman, need adjust vmp.\n");
						}
						else
						{
							TVMPParam_25Mem tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
							tLastVmpParam.GetVmpMember(byNewMemberChnl)->SetMemberType(byMemberType);
							g_cMcuVcApp.SetLastVmpParam(tVmpEqp, tLastVmpParam);
							return FALSE;	//成员实质无变化，直接return
						}
					}
				}
				else
				{
				// 2011-7-26 uncomment by peng guofeng Bug00059137: 下级MCU终端替换本地终端发言，原发言人交换未拆除
				// 2011-9-15 由于VCS也有这个问题，所以拆的地方改在ChangeVmpSwitch里一并进行，此处就不再拆了
				}
				// 2011-7-26 uncomment end
				//这里设成员意义不大.

				bVmpParamChged = TRUE;
			}
			else if(ptOldSrc != NULL && !ptOldSrc->IsNull())	//cancel chairman or speaker. 
			{
				//FIXME：目前无条件调参数, 最终在MPU中过滤
				bVmpParamChged = TRUE;
			}
			else
			{
				//Do nothing
			}
			
		}
	}

	return bVmpParamChged;
}

/*====================================================================
    函数名      ：ChangeVmpStyle
    功能        ：改变会议动态画面合成方式
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt tMt 增加或移除的终端
				  BOOL32 bAddMt TRUE-增加 FALSE-移除
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/03/31    3.0         胡昌威          创建
====================================================================*/
void CMcuVcInst::ChangeVmpStyle(TMt tMt, BOOL32 bAddMt/*, BOOL32 bChangeVmpParam*/)
{
	u8 byVmpId = 0;
	//临时 VCS动态画面合成根据当前所有在线终端进行合成
	//若移除终端,但该终端状态仍为在线,则临时更改该状态,待更改画面合成风格后还原
	u8 byTempChgMtStat = FALSE;
	TPeriEqpStatus tPeriEqpStatus;
	TVMPParam_25Mem tVMPParam;
	
	// 临时 VCS动态画面合成根据当前所有在线终端进行合成
	if (FALSE == bAddMt && m_tConfAllMtInfo.MtJoinedConf(tMt))
	{
		m_tConfAllMtInfo.RemoveJoinedMt( tMt );
		byTempChgMtStat = TRUE;
	}

	for (u8 byIdx = 0; byIdx < MAXNUM_CONF_VMP; byIdx++)
	{
		if (!IsValidVmpId(m_abyVmpEqpId[byIdx]))
		{
			continue;
		}

		byVmpId = m_abyVmpEqpId[byIdx];
		//检查状态是否是动态分屏				
		if( !IsDynamicVmp(byVmpId) )
		{
			continue;
		}

		g_cMcuVcApp.GetPeriEqpStatus(byVmpId , &tPeriEqpStatus);  
		tVMPParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();

		// 跳过非START状态的合成器
		if (tPeriEqpStatus.m_tStatus.tVmp.m_byUseState != TVmpStatus::START)
		{
			continue;
		}

		AdjustVmpParam(byVmpId, &tVMPParam);
	}

	if (byTempChgMtStat)
	{
		m_tConfAllMtInfo.AddJoinedMt(tMt);
	}
}

/*====================================================================
    函数名      ：ChangeVmpSwitch
    功能        ：改变画面合成器交换参数
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt * ptNewSrc：源,NULL为所有通道
                  u8 byState          ：VMP目的状态
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/04    3.0         胡昌威         创建
	10/01/19    4.6         薛亮           重整
	11/07/29	4.6			彭国锋		  移除参数bySrcType
====================================================================*/
void CMcuVcInst::ChangeVmpSwitch(u8 byVmpId, u8 byState)
{
	if (!IsValidVmpId(byVmpId))
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ChangeVmpSwitch]vmpid(%d) is not valid.\n", byVmpId);
		return;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	TVMPParam_25Mem  tVMPParam;   
	TVmpChnnlInfo tVmpChnnlInfo;
	u8 byVmpSubType = GetVmpSubType( byVmpId );// 取vmp子类型
	u8 byMode = MODE_VIDEO;	//默认Mode为Video,双流时需更新为MODE_SECVIDEO
	//u8 byChnnlType = LOGCHL_VIDEO;
	TLogicalChannel tLogicChannel;
	TMt tLocalVmpMt; //local化终端,用于判逻辑通道是否打开
	
	TMt tMtMember;
	//所有通道停止向VMP交换
	if (byState == VMP_STATE_STOP)
	{
		// 停止VMP相关所有交换
		StopVmpSwitch(tVmpEqp);
		return;
	}

	// 将VmpParam信息从PeriVmpParam中更新到ConfVmpParam
	UpdateConfVmpParam(tVmpEqp.GetEqpId());
	tVMPParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
	const u8   byMemberNum = tVMPParam.GetMaxMemberNum();
	TVMPParam_25Mem tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);

	// 调整旧通道成员分辨率
	if (VMP_STATE_CHANGE == byState && CONF_VMPMODE_NONE != tLastVmpParam.GetVMPMode())
	{
		AdjustMtResInLastVmpParam(tVmpEqp.GetEqpId());
	}
	
	// 先处理画面合成广播，把需要被冲掉的选看冲掉
	if (VMP_STATE_START == byState && tVMPParam.IsVMPBrdst())
	{
		// 有vmp在广播，需更新旧vmp广播模式
		if (!m_tVmpEqp.IsNull() && tVmpEqp.GetEqpId() != m_tVmpEqp.GetEqpId())
		{
			SetVMPBrdst(m_tVmpEqp, FALSE);
			//刷界面
			TVMPParam_25Mem tOldBrdstVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
			CServMsg cServMsg;
			cServMsg.SetEqpId(m_tVmpEqp.GetEqpId());
			cServMsg.SetMsgBody( (u8*)&tOldBrdstVmpParam, sizeof(tOldBrdstVmpParam) );
			SendMsgToAllMcs( MCU_MCS_VMPPARAM_NOTIF, cServMsg );
		}
		
		m_tVmpEqp = tVmpEqp;//记录广播vmp
		ChangeVidBrdSrc(&tVmpEqp);
	}

	//会控控制模式 
	if (CONF_VMPMODE_CTRL == tVMPParam.GetVMPMode())
	{
		ChangeCtrlModeVmpSwitch(tVmpEqp, byState, tVMPParam);
	}
	//自动设置成员模式
	// xliang [7/3/2009] 简化重整
	else if( tVMPParam.GetVMPMode() == CONF_VMPMODE_AUTO )
	{
		ChangeAutoModeVmpSwitch(tVmpEqp, byState, tVMPParam);
	}

	g_cMcuVcApp.SetConfVmpParam(tVmpEqp, tVMPParam);
	//zjl[20091208]新增会议模板hdu配置电视墙成员，如果设置了选看画面合成，则在启动vmp时建交换到hdu
	// 支持多画面合成后，hdu通道选看vmp需指定vmpid，模版不再支持选看vmp
	//FindConfHduChnnlAndReplace( &tVmpEqp, NULL, TW_MEMBERTYPE_SWITCHVMP);

    //节省带宽时，改变画面合成成员时，需要控制非keda厂商mt码流是否发送...
	CServMsg cServMsg;
	cServMsg.SetEqpId(byVmpId);
	cServMsg.SetMsgBody( (u8*)&tVMPParam, sizeof(tVMPParam) );
	SendMsgToAllMcs( MCU_MCS_VMPPARAM_NOTIF, cServMsg ); //告诉会控刷界面
    
	tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
	//20110823 zhouyiliang将风格等成员除外的东西赋给m_tLastVmpParam,成员赋值SetVmpChnnl里和前面处理，不在这赋
	memcpy(&tLastVmpParam, &tVMPParam, 8 );//成员信息以外信息
	
	// 清理m_tLastVmpParam中多余通道信息,vmp风格由大变小时,m_tLastVmpParam中原来的多余通道内容未被清理
	for (u8 byChlIdx = 0; byChlIdx < MAXNUM_VMP_MEMBER; byChlIdx++ )
	{
		if (byChlIdx < byMemberNum)
		{
			/* 针对vcs会议,清掉已freespy过的旧成员,防止多个notify回来时造成的多次释放同一终端问题.
			if (VCS_CONF == m_tConf.GetConfSource())
			{
				TVMPMember tOldMember = *tLastVmpParam.GetVmpMember(byChlIdx);
				TVMPMember tNewMember = *tVMPParam.GetVmpMember(byChlIdx);
				if (!(tOldMember == tNewMember))
				{
					tLastVmpParam.ClearVmpMember(byChlIdx);
				}
			}*/
		}
		else
		{
			tLastVmpParam.ClearVmpMember(byChlIdx);
		}
	}
	g_cMcuVcApp.SetLastVmpParam(tVmpEqp, tLastVmpParam);

    ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChangeVmpSwitch] The result vmp(%d) param:", tVmpEqp.GetEqpId());
    tVMPParam.Print();

	// 通知主席终端更新vmpparam
	SendVmpParamToChairMan();
	
	// xliang [4/20/2009] 在一次处理改变VMP param过程中，用户快速又请求另一种change vmp param
	// (实际场景主要是切换风格后，立马勾选/取消"广播码流"按钮), 可能会导致实际效果与操作不符。
	// 为解决该问题，严格来讲应把VMP从改变参数到建完交换(广播/非广播)封装成原子操作，期间相关的请求不做响应。[FIXME]
	// 这里退一步, 把VMP从改变参数到发出交换信令完成 作为原子
	m_byVmpOperating = 0;

}

/*==============================================================================
函数名    :  StopVmpSwitch
功能      :  停止VMP相关所有交换,包括进vmp的和vmp出的
算法实现  :  
参数说明  :  const TEqp &tVmpEqp
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130530					yanghuaizhi							
==============================================================================*/
void CMcuVcInst::StopVmpSwitch(const TEqp &tVmpEqp)
{
	TVMPParam_25Mem  tVMPParam;   
	TVmpChnnlInfo tVmpChnnlInfo;
	tVMPParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
	tVmpChnnlInfo = g_cMcuVcApp.GetVmpChnnlInfo(tVmpEqp);
	TVMPMember tVMPMember;
	TPeriEqpStatus tVmpEqpStatus; 
	TVMPParam_25Mem tNullVmpParam;
	u8 byMode = MODE_VIDEO;	//默认Mode为Video,双流时需更新为MODE_SECVIDEO
	TMt tMtMember;
	
	//需要先停广播，切广播源，停广播vmp时，可能会导致被选看终端在别的vmp中占前适配，有发言人时冲选看，又不需要进vmp
	//若是VMP广播，则把VMP到当前广播终端的交换也停掉。有发言人存在的话，发言人开始广播
	TMt tMt = m_tConf.GetSpeaker();//GetLocalSpeaker();
	if (tVMPParam.IsVMPBrdst() && m_tVmpEqp.GetEqpId() == tVmpEqp.GetEqpId())	
	{
		if (HasJoinedSpeaker())
		{
			//zjj20100413 增加多回传后要传入非local过的终端
			if ( m_tConf.GetConfAttrb().IsSatDCastMode()
				&& IsMultiCastMt(GetLocalSpeaker().GetMtId())
				&& GetCurSatMtNum() == 0 && !IsSatMtSend(GetLocalSpeaker())) //避免和发言时判断当前VMP广播不会累加计数，用emVmp区分
			{
				//卫星会议，恢复发言人要考虑要不超过当前回传路数
				LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[VmpCommonReq]stopvmp satMtNum(0),so can't recover vidbrdsrc(%d)\n",
						GetCurSatMtNum(),tMt.GetMtId());
				ChangeVidBrdSrc(NULL);
				//ChangeSpeaker( NULL );
			}
			else
			{
				ChangeVidBrdSrc(&tMt);
				// 2011-8-25 add by pgf: 补建唇音同步交换
				// [miaoqingsong 20111118] 添加判断条件：只有当音频广播源与视频广播源相同时才补建唇音同步交换，
				//            以防止VCS会议下切换组呼模式，错误的拆桥，导致非混音器转发板的终端听不到主席声音。
				if ( g_cMcuVcApp.IsVASimultaneous() && (GetLocalVidBrdSrc() == GetLocalAudBrdSrc()) )
				{
					ChangeAudBrdSrc( &tMt );
				}
			}				
		}
		else
		{
			ChangeVidBrdSrc(NULL);
		}
	}
	
	// 清ConfVmpParam合成成员，调终端分辨率
	g_cMcuVcApp.SetConfVmpParam(tVmpEqp, tNullVmpParam);
    for (u8 byLoop = 0; byLoop < tVMPParam.GetMaxMemberNum(); byLoop++)
	{
		//取画面合成成员,加保护
		if (NULL == tVMPParam.GetVmpMember(byLoop)) {
			tVMPMember.SetNull();
		} else {
			tVMPMember = *(tVMPParam.GetVmpMember(byLoop));
		}

		//[0].NULL成员直接找下一个
		if (tVMPMember.IsNull())
		{
			continue;
		}

		//双流跟随通道,停双流到vmp的交换
		byMode = MODE_VIDEO;
		if (VMP_MEMBERTYPE_DSTREAM == tVMPMember.GetMemberType())
		{
			byMode = MODE_SECVIDEO;
		}

		//[1].停止向VMP的交换
		{
			StopSwitchToPeriEqp(tVmpEqp.GetEqpId(), byLoop, FALSE, byMode);
		}
		
		//[2]. 多回传资源释放判断
		if( !tVMPMember.IsLocal() && MODE_VIDEO == byMode)
		{
			FreeRecvSpy(tVMPMember, MODE_VIDEO);
		}

        //[3].恢复终端分辨率,只恢复主流分辨率,双流无需恢复
		if (MODE_VIDEO == byMode)
		{
			//ChangeMtVideoFormat( (TMt)tVMPMember);
			ChangeMtResFpsInVmp(tVmpEqp.GetEqpId(), tVMPMember, &tNullVmpParam, FALSE);
		}
		//20100903_tzy VCS会议下自动画面合成模式时，出画面合成器终端也移除出混音器
		//zjj20101110 增加判断条件：如果终端在电视墙中而且起了电视墙一键混音也不能退出混音
		//miaoqingsong [20111205] 增加判断条件：如果是组呼会议主席不能退出混音；VMP成员不在混音器中跳过删除混音成员操作
		if (m_tConf.GetConfSource() == VCS_CONF && tVMPParam.IsVMPAuto() &&
			( !ISGROUPMODE(m_cVCSConfStatus.GetCurVCMode()) || !((TMt)tVMPMember == m_tConf.GetChairman()) ) &&
			( !m_cVCSConfStatus.GetMtInTvWallCanMixing() || 
			(IsMtNotInOtherTvWallChnnl((TMt)tVMPMember,0,0) && IsMtNotInOtherHduChnnl((TMt)tVMPMember,0,0) &&
			!((TMt)tVMPMember == m_tConf.GetChairman())) ) && 
			( (tVMPMember.IsLocal() && m_ptMtTable->IsMtInMixing(tVMPMember.GetMtId())) || 
			  !tVMPMember.IsLocal() )
			)
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeVmpSwitch]RemoveMtFromMixer tVMPMember(%d)(%d)\n", tVMPMember.GetMcuId(),
				tVMPMember.GetMtId());
			tMtMember = (TMt)tVMPMember;
			RemoveSpecMixMember(&tMtMember,1,FALSE,FALSE);
			// 需加判所属mcu下是否有其它终端在电视墙中，没有的时候才需要清除smcu的混音通道
			if (!tMtMember.IsLocal() && !IsHasMtInHduOrTwByMcuIdx(tMtMember.GetMcuIdx()))
			{
				tMtMember = GetLocalMtFromOtherMcuMt(tMtMember);
				RemoveSpecMixMember(&tMtMember,1,FALSE,FALSE);
			}
		}

		if( VCS_CONF == m_tConf.GetConfSource() )
		{
			NotifyMtSpeakStatus( (TMt)tVMPMember, emCanceled );
		}			
		
	}
	
	g_cMcuVcApp.GetPeriEqpStatus( tVmpEqp.GetEqpId(), &tVmpEqpStatus );
	// VMP掉线时,为做备份处理,先不清理前适配信息
	if (ISTRUE(tVmpEqpStatus.m_byOnline))
	{
		// 清空VMP抢占通道信息
		tVmpChnnlInfo.clear();
		g_cMcuVcApp.SetVmpChnnlInfo(tVmpEqp, tVmpChnnlInfo);
	}

	// 停媒体源为vmp的所有会控通道,停所有选看vmp交换
	RestoreAllSubMtJoinedConfWatchingSrcMt(tVmpEqp);
	AdjustSwitchToAllMcWatchingSrcMt(tVmpEqp);
	
	//zhouyiliang 20101028 stop vmp 的话lastvmpparam要清空
	//memset( &m_tLastVmpParam, 0, sizeof(m_tLastVmpParam) );
	tVMPParam.Clear();
	g_cMcuVcApp.SetLastVmpParam(tVmpEqp, tVMPParam);
	return;
}

/*==============================================================================
函数名    :  GetVmpMemberSort
功能      :  对合成成员通道排序，按发言人>不可降分辨率Mt>其余终端
算法实现  :  
参数说明  :  TVMPParam_25Mem &tVMPParam [IN] 合成信息
			 u8 &byLen [IN/OUT] 传入的数组长度，返回排序后长度
			 u8 *pbyMemSort [OUT] 返回排序后的通道数组
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130708					yanghuaizhi							
==============================================================================*/
void CMcuVcInst::GetVmpMemberSort(TVMPParam_25Mem &tVMPParam, u8 &byLen, u8 *pbyMemSort)
{
	if (byLen < MAXNUM_VMP_MEMBER || pbyMemSort == NULL)
	{
		return;
	}

	// 排序方法，遍历成员，分别取出发言人列表、不能降分辨率Mt列表、其它终端列表
	// 然后将3个列表合并到一个列表中，按发言人+不能降分辨率Mt+其它成员
	u8 bySpeakerNum = 0;
	u8 byUnableAjustResMtNum = 0;
	u8 byOtherMtNum = 0;
	u8 abySpeakerSort[MAXNUM_VMP_MEMBER];
	memset(abySpeakerSort, 0, sizeof(abySpeakerSort));
	u8 abyUnableAjustResMtSort[MAXNUM_VMP_MEMBER];
	memset(abyUnableAjustResMtSort, 0, sizeof(abyUnableAjustResMtSort));
	u8 abyOtherMtSort[MAXNUM_VMP_MEMBER];
	memset(abyOtherMtSort, 0, sizeof(abyOtherMtSort));
	TExInfoForResFps tExInfoForRes;
	TVMPMember tVmpMember;
	TChnnlMemberInfo tVmpChlInfo;
	for (u8 byIdx=0; byIdx < tVMPParam.GetMaxMemberNum(); byIdx++)
	{
		tVmpMember = *tVMPParam.GetVmpMember(byIdx);
		if (tVmpMember.IsNull())
		{
			// 归入Other列表，可能是无成员的跟随通道
			abyOtherMtSort[byOtherMtNum++] = byIdx;
			continue;
		}
		tExInfoForRes.m_byMemberType = tVmpMember.GetMemberType();
		// 复用vip信息接口，根据vip属性区分发言人与不可降分辨率终端，vmp广播时发言人不占前适配
		tVmpChlInfo = IsVipMemForVmp(tVmpMember, tExInfoForRes);
		// 普通终端
		if (tVmpChlInfo.IsAttrNull())
		{
			abyOtherMtSort[byOtherMtNum++] = byIdx;
		}
		else if (tVmpChlInfo.IsAttrSpeaker())
		{
			// 发言人
			abySpeakerSort[bySpeakerNum++] = byIdx;
		}
		else if (!tVmpChlInfo.IsCanAdjResMt())
		{
			// 不可降分辨率终端
			abyUnableAjustResMtSort[byUnableAjustResMtNum++] = byIdx;
		}
		else
		{
			// 选看终端
			abyOtherMtSort[byOtherMtNum++] = byIdx;
		}
	}

	// 组合排序
	memcpy(pbyMemSort, abySpeakerSort, bySpeakerNum);
	memcpy(pbyMemSort+bySpeakerNum, abyUnableAjustResMtSort, byUnableAjustResMtNum);
	memcpy(pbyMemSort+bySpeakerNum+byUnableAjustResMtNum, abyOtherMtSort, byOtherMtNum);

	// 更新排序的总成员数
	byLen = bySpeakerNum + byUnableAjustResMtNum + byOtherMtNum;
	return;
}

/*==============================================================================
函数名    :  IsRcvH264DependInMark
功能      :  判终端是否要按特殊方式解码
算法实现  :  
参数说明  :  u8 byMtId
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
131105					yanghuaizhi							
==============================================================================*/
BOOL32 CMcuVcInst::IsRcvH264DependInMark(u8 byMtId)
{
	if (byMtId == 0 || byMtId > MAXNUM_CONF_MT)
	{
		return FALSE;
	}

	BOOL32 bRet = FALSE;
	TLogicalChannel tChnnl;
	if (m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_VIDEO, &tChnnl, FALSE))
    {
		if (MEDIA_TYPE_H264 == tChnnl.GetChannelType())
		{
			u8 byManuId = m_ptMtTable->GetManuId(byMtId);
			bRet = g_cMcuVcApp.IsRcvH264DependInMark(byManuId,m_ptMtTable->GetProductId(byMtId));
		}
	}

	return bRet;
}

/*==============================================================================
函数名    :  ChangeCtrlModeVmpSwitch
功能      :  会控指定模式建交换处理,包含调分辨率建交换
算法实现  :  
参数说明  :  const TEqp &tVmpEqp
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130530					yanghuaizhi							
==============================================================================*/
void CMcuVcInst::ChangeCtrlModeVmpSwitch(const TEqp &tVmpEqp, u8 byState,TVMPParam_25Mem &tVMPParam)
{
	u8 byLoop = 0;
	TVMPMember tVMPMember;
	TVMPMember *ptOldMember = NULL;
	BOOL32 bNoneKeda = FALSE;
	TMt tNullMt;
	tNullMt.SetNull();
	u8 byMode = MODE_VIDEO;
	u8 byOldMode = MODE_VIDEO;
	const u8   byMemberNum = tVMPParam.GetMaxMemberNum();
	TVMPParam_25Mem tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
	
	// 模版vmp开启时，若已有终端上线，则需通知外设刷新信息
	if (byState == VMP_STATE_START && tVmpEqp.GetEqpId() == m_tModuleVmpEqp.GetEqpId())
	{
		RefreshVmpChlMemalias(tVmpEqp.GetEqpId());
	}

	u8 bySortLen = MAXNUM_VMP_MEMBER;
	u8 abyMemSort[MAXNUM_VMP_MEMBER];
	memset(abyMemSort, 0, sizeof(abyMemSort));
	GetVmpMemberSort(tVMPParam, bySortLen, abyMemSort);

	for (u8 byIdx=0; byIdx<bySortLen; byIdx++)
	//for (byLoop = 0; byLoop < byMemberNum; byLoop++)
	{
		byLoop = abyMemSort[byIdx];
		if (byLoop >= MAXNUM_VMP_MEMBER)
		{
			break;// byLoop必须为正常值
		}
		tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
		// 加保护,防止返回指针为空
		if (NULL == tVMPParam.GetVmpMember(byLoop)) {
			tVMPMember.SetNull();
		} else {
			tVMPMember = *tVMPParam.GetVmpMember(byLoop);
		}
		
		// 记录新成员交换模式
		byMode = MODE_VIDEO;
		//byChnnlType = LOGCHL_VIDEO;
		if (VMP_MEMBERTYPE_DSTREAM == tVMPMember.GetMemberType())
		{
			byMode = MODE_SECVIDEO;
			//byChnnlType = LOGCHL_SECVIDEO;
		}
		// 获得old成员,与old交换模式(主流/双流)
		ptOldMember = tLastVmpParam.GetVmpMember(byLoop);
		byOldMode = MODE_VIDEO;
		if (ptOldMember && VMP_MEMBERTYPE_DSTREAM == ptOldMember->GetMemberType())
		{
			byOldMode = MODE_SECVIDEO;
		}

		if ( tVMPMember.IsNull() )
		{
			if( byState != VMP_STATE_START && !tLastVmpParam.GetVmpMember( byLoop )->IsNull() )
			{
				StopSwitchToPeriEqp(tVmpEqp.GetEqpId(), byLoop, FALSE, byOldMode);
			}
			// 更新LastVmpParam中此通道成员,可能是发言人跟随轮询跟随等,更新m_tLastVmpParam
			tLastVmpParam.SetVmpMember(byLoop, tVMPMember);
			g_cMcuVcApp.SetLastVmpParam(tVmpEqp, tLastVmpParam);
			continue;
		}

		// 2011-10-18 add by pgf:前后参数中成员如果完全一样，则过滤，不用给他调分辨率
		if ( ptOldMember && !ptOldMember->IsNull() && !tVMPMember.IsNull()
			&& tLastVmpParam.GetVMPStyle() == tVMPParam.GetVMPStyle()
			&& *ptOldMember == tVMPMember
			&& tVMPMember.GetMemberType() == ptOldMember->GetMemberType()/*VMP_MEMBERTYPE_MCSSPEC*/ )
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP, "same as in Last Param so no need to change. Channl:%d mt<%d %d>\n",
				byLoop, tVMPMember.GetMcuIdx(), tVMPMember.GetMtId());
			continue;
		}

		// [5/19/2011 xliang] condense the following logic
		if (m_tConfAllMtInfo.MtJoinedConf(tVMPMember))
		{
			BOOL32 bRet = FALSE;
			BOOL32 bIsStart = (byState == VMP_STATE_START) ? TRUE:FALSE;
			bRet = ChangeMtResFpsInVmp(tVmpEqp.GetEqpId(), tVMPMember, &tVMPParam, TRUE, tVMPMember.GetMemberType(), byLoop);
			if(bRet)
			{
				LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChangeVmpSwitch]line:%d, 'SetVmpChnnl' tVMPMember.GetMtId()=%u \n"
					,__LINE__,tVMPMember.GetMtId());
				// 模版vmp开启时，若已有终端上线，则需通知外设刷新信息
				if (bIsStart && tVmpEqp.GetEqpId() == m_tModuleVmpEqp.GetEqpId())
				{
					UpdataVmpEncryptParam(tVMPMember, byLoop);
				}
			}
			else
			{
				// 调分辨率失败，不建新交换，停旧交换
				StopSwitchToPeriEqp(tVmpEqp.GetEqpId(), byLoop, FALSE, byOldMode);
				// 交换已拆，清除LastVmpParam中该通道旧成员
				tLastVmpParam.ClearVmpMember(byLoop);
				g_cMcuVcApp.SetLastVmpParam(tVmpEqp, tLastVmpParam);
				LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChangeVmpSwitch]ChangeMtVideoFormat failed for mtId=%u \n", tVMPMember.GetMtId());
			}
		}
		else
		{
			LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChangeVmpSwitch]line:%d, 'StopSwitchToPeriEqp and clear' tVMPMember.GetMtId()=%u \n"
							,__LINE__,tVMPMember.GetMtId());
			StopSwitchToPeriEqp(tVmpEqp.GetEqpId(), byLoop, FALSE, byOldMode);
			tVMPMember.SetMemberTMt(tNullMt);
			tVMPMember.SetMemberType(tVMPMember.GetMemberType());
			tVMPParam.SetVmpMember(byLoop, tVMPMember);
		}
	}
	
	// 若发现当前有空余前适配通道，且发言人不在前适配中，则让发言人进入前适配
	AdjustVmpHdChnlInfo(tVmpEqp);

	return;
}

/*==============================================================================
函数名    :  ChangeAutoModeVmpSwitch
功能      :  自动模式建交换处理,包含调分辨率建交换
算法实现  :  
参数说明  :  const TEqp &tVmpEqp
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130530					yanghuaizhi							
==============================================================================*/
void CMcuVcInst::ChangeAutoModeVmpSwitch(const TEqp &tVmpEqp, u8 byState,TVMPParam_25Mem &tVMPParam)
{
	TVmpChnnlInfo tVmpChnnlInfo = g_cMcuVcApp.GetVmpChnnlInfo(tVmpEqp);
	const u8   byMemberNum = tVMPParam.GetMaxMemberNum();
	TVMPParam_25Mem tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
	TLogicalChannel tLogicChannel;
	if( VMP_STATE_START  == byState ||
        VMP_STATE_CHANGE == byState )
	{
		// Auto时要清前适配内容,不清最大前适配个数
		tVmpChnnlInfo = g_cMcuVcApp.GetVmpChnnlInfo(tVmpEqp);
		tVmpChnnlInfo.clearHdChnnl();
		g_cMcuVcApp.SetVmpChnnlInfo(tVmpEqp, tVmpChnnlInfo);

		//清空成员
		for(u8 byLoopIdx = 0; byLoopIdx < byMemberNum; byLoopIdx++ )
		{
			if (m_tConf.GetConfAttrb().IsSatDCastMode())
			{
				StopSwitchToPeriEqp(tVmpEqp.GetEqpId(), byLoopIdx, FALSE, MODE_VIDEO);
			}			
		} 

		TVMPMember tVMPMember;
		TVMPMember tLstVMPMember;
		for (u8 byLoop = 0; byLoop < byMemberNum; byLoop++)
		{
			tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
			// 加保护,防止指针返回空
			if (NULL == tVMPParam.GetVmpMember(byLoop)) {
				tVMPMember.SetNull();
			} else {
				tVMPMember = *tVMPParam.GetVmpMember(byLoop);
			}
			if (NULL == tLastVmpParam.GetVmpMember(byLoop)) {
				tLstVMPMember.SetNull();
			} else {
				tLstVMPMember = *tLastVmpParam.GetVmpMember(byLoop);
			}

			if (tVMPMember.IsNull())
			{
				StopSwitchToPeriEqp(tVmpEqp.GetEqpId(), byLoop, FALSE, MODE_VIDEO);
				TConfAttrb tTempConfattrb = m_tConf.GetConfAttrb();
				if (tTempConfattrb.IsResendLosePack())
				{
					if (!tLstVMPMember.IsNull())
					{
						StopRtcpSwitchAlltoOne(/**ptVmpMember*/tLstVMPMember, 0, MODE_VIDEO);
					}					
				}
				tLastVmpParam.SetVmpMember(byLoop, tVMPMember);
				g_cMcuVcApp.SetLastVmpParam(tVmpEqp, tLastVmpParam);
			}
			else
			{
				if (m_tConfAllMtInfo.MtJoinedConf(tVMPMember) )
				{

					//zhouyiliang 20110322 由于changevmpswitch一开始已经将m_tVmpChnnlInfo清空，前适配通道要重新占
					BOOL32 bRet = FALSE;
					BOOL32 bIsVmpStart = (byState == VMP_STATE_START)? TRUE:FALSE;
					bRet = ChangeMtResFpsInVmp(tVmpEqp.GetEqpId(), tVMPMember, &tVMPParam, TRUE, tVMPMember.GetMemberType(), byLoop);
                    LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChangeVmpSwitch]line:%d, 'ChangeMtVideoFormat' = %u\n"
                            ,__LINE__,bRet);

					if( tLastVmpParam.GetVMPStyle() != tVMPParam.GetVMPStyle() 
						//|| !m_tLastVmpParam.IsMtInMember(tVMPMember) 
						|| !(tLstVMPMember == tVMPMember)
						)
					{
						
						if(bRet)
						{
							if( VCS_CONF == m_tConf.GetConfSource() &&									
 								byState == VMP_STATE_START &&
								m_cVCSConfStatus.GetCurVCMode() == VCS_MULVMP_MODE &&
								tVMPMember.IsLocal() &&
								( m_ptMtTable->IsMtInHdu( tVMPMember.GetMtId() ) ||
									m_ptMtTable->IsMtInTvWall( tVMPMember.GetMtId() ) )
								)
							{
								NotifyMtSpeakStatus( (TMt)tVMPMember, emAgreed );
							}
                            LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChangeVmpSwitch]line:%d, 'SetVmpChnnl' tVMPMember.GetMtId()=%u tVMPMember.GetMemberType()=%u\n"
                            ,__LINE__,tVMPMember.GetMtId(),tVMPMember.GetMemberType());
						
						}
						else
						{
							ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP, "StopSwitchTo VMP:%d of Channel:%d Mode:%d\n",
									tVmpEqp.GetEqpId(), byLoop, MODE_VIDEO);
							StopSwitchToPeriEqp(tVmpEqp.GetEqpId(), byLoop, FALSE, MODE_VIDEO);
							// 交换已拆，清除LastVmpParam中该通道旧成员
							tLastVmpParam.ClearVmpMember(byLoop);
							g_cMcuVcApp.SetLastVmpParam(tVmpEqp, tLastVmpParam);

							//zhouyiliang 20110322vcs多方多画面如果调分辨率不成功，不设置进画面合成成员
							if (VCS_CONF == m_tConf.GetConfSource() &&
								m_cVCSConfStatus.GetCurVCMode() == VCS_MULVMP_MODE &&
								m_cVCSConfStatus.GetCurVCMT() == (TMt)tVMPMember 
								)
							{
								if( IsMtNotInOtherTvWallChnnl((TMt)tVMPMember,0,0) && IsMtNotInOtherHduChnnl((TMt)tVMPMember,0,0) )
								{
									VCSDropMT(m_cVCSConfStatus.GetCurVCMT());																			
								}
								NotifyMcsAlarmInfo(0,ERR_VMP_NO_VIP_VMPCHNNL);									
								tVMPParam.ClearVmpMember(byLoop);
								if ( byLoop >= 1 )
								{	
									TVMPMember* ptLastVcMt = tVMPParam.GetVmpMember(byLoop - 1);
									//setcurvcmt
									if (NULL != ptLastVcMt )
									{
										TMt tLastVcMt = (TMt)(*ptLastVcMt);
										m_cVCSConfStatus.SetCurVCMT(tLastVcMt);
										VCSConfStatusNotif();
									}
									
								}
							
							}
							
						}
					}
					else
					{
						//zhouyiliang 20110322vcs多方多画面如果调分辨率不成功，不设置进画面合成成员
						if( !bRet && VCS_CONF == m_tConf.GetConfSource() &&
								m_cVCSConfStatus.GetCurVCMode() == VCS_MULVMP_MODE  )
						{

						}
						else
						{
							u8 bySrcChnnl = (tVMPMember == m_tPlayEqp) ? m_byPlayChnnl : 0;
							//zhouyiliang 20100916 如果上次通道该通道中的画面合成成员和这次一样，bstopbeforestart =FALSE
                            LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChangeVmpSwitch]line:%d, 'StartSwitchToPeriEqp' tVMPMember.GetMtId()=%u \n"
                            ,__LINE__,tVMPMember.GetMtId());
							// 电话终端未开视频逻辑通道,不建交换
							if (m_ptMtTable->GetMtLogicChnnl(tVMPMember.GetMtId(), LOGCHL_VIDEO, &tLogicChannel, FALSE))
							{
								StartSwitchToPeriEqp(tVMPMember, bySrcChnnl, tVmpEqp.GetEqpId(),
									byLoop, MODE_VIDEO, SWITCH_MODE_SELECT, FALSE, 
									FALSE
								);
							}
							tVMPParam.SetVmpMember(byLoop, tVMPMember);
							tLastVmpParam.SetVmpMember(byLoop, tVMPMember);
							g_cMcuVcApp.SetLastVmpParam(tVmpEqp, tLastVmpParam);
						}							
					}						
					
				}
			}
		}

		if (VCS_CONF == m_tConf.GetConfSource())
		{
			// 挂断被踢出画面合成器的成员
			if ( CONF_VMPMODE_NONE != tLastVmpParam.GetVMPMode() )
			{
				TMt tVMPMemberOld;
				for( s32 nIndex = 0; nIndex < tLastVmpParam.GetMaxMemberNum(); nIndex ++ )
				{
					// 加保护,防止返回指针为空
					if (NULL == tLastVmpParam.GetVmpMember(nIndex)) {
						tVMPMemberOld.SetNull();
					} else {
						tVMPMemberOld = (TMt)(*tLastVmpParam.GetVmpMember(nIndex));
					}
    
					if ( !tVMPParam.IsMtInMember(tVMPMemberOld) &&
						m_tConfAllMtInfo.MtJoinedConf(tVMPMemberOld.GetMcuId(), tVMPMemberOld.GetMtId())) 
					{
						if (!ISGROUPMODE(m_cVCSConfStatus.GetCurVCMode()) &&
							!m_ptMtTable->IsMtInTvWall( GetLocalMtFromOtherMcuMt(tVMPMemberOld).GetMtId() ) &&
							!m_ptMtTable->IsMtInHdu( GetLocalMtFromOtherMcuMt(tVMPMemberOld).GetMtId() )
							)
							
						{
							VCSDropMT(tVMPMemberOld);
						}
					}
				}             
			}
		}
	}
	
	return;
}

/*=============================================================================
    函 数 名： CancelOneVmpFollowSwitch
    功    能： 清空会控模式下的指定跟随类型的相应复合交换及状态
    算法实现： 
    全局变量： 
    参    数： u8 byMemberType
    返 回 值： void 
-----------------------------------------------------------------------------
    修改记录：
    日  期		版本		修改人		走读人    修改内容
    2005/03/21  3.6			万春雷                  创建
=============================================================================*/
void CMcuVcInst::CancelOneVmpFollowSwitch( u8 byMemberType, BOOL32 bNotify )
{
	//会控控制模式 
	if( CONF_VMPMODE_CTRL != g_cMcuVcApp.GetVMPMode(m_tVmpEqp) || 
		VMP_MEMBERTYPE_MCSSPEC == byMemberType )
	{
		return;
	}

//	u8 byLoop; 此函数未被使用
	TVMPMember tVMPMember;
	TVMPParam tVMPParam = m_tConf.m_tStatus.GetVmpParam();
	u8 byMemberNum = tVMPParam.GetMaxMemberNum();

	for(u8 byLoop = 0; byLoop < byMemberNum; byLoop++ )
	{
		TVMPParam tTempParam = m_tConf.m_tStatus.GetVmpParam();
		tVMPMember = *tTempParam.GetVmpMember( byLoop );
		if( !tVMPMember.IsNull() && 
			byMemberType == tVMPMember.GetMemberType() )
		{
			StopSwitchToPeriEqp( m_tVmpEqp.GetEqpId(), byLoop, TRUE, MODE_VIDEO );
			
			TMt tMt;
			tMt.SetNull();
			tVMPMember.SetMemberTMt( tMt );
			tVMPMember.SetMemberType( byMemberType );
			m_tConf.m_tStatus.m_tVMPParam.SetVmpMember( byLoop, tVMPMember);

			//同步外设复合状态,此函数未被使用
			TPeriEqpStatus tPeriEqpStatus;
			g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tPeriEqpStatus );
			tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(m_tConf.m_tStatus.m_tVMPParam);
			g_cMcuVcApp.SetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tPeriEqpStatus );
		}
	}

	if( bNotify )
	{
		CServMsg cServMsg;
		cServMsg.SetMsgBody( (u8*)&m_tConf.m_tStatus.m_tVMPParam, sizeof(TVMPParam) );

		SendMsgToAllMcs( MCU_MCS_VMPPARAM_NOTIF, cServMsg );
		
		/*TPeriEqpStatus tVmpEqpStatus;
		g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tVmpEqpStatus );
		cServMsg.SetMsgBody( ( u8 * )&tVmpEqpStatus, sizeof( tVmpEqpStatus ) );
		SendMsgToAllMcs( MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg );*/
	}

	return;
}

/*====================================================================
    函数名      ：ChangeVmpBitRate
    功能        ：改变画面合成的码率 
    算法实现    ：
    引用全局变量：
    输入参数说明：u16 wBitRate, 画面合成的码率
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/05/21    3.0         胡昌威         创建
====================================================================*/
//modify bas 2
void CMcuVcInst::ChangeVmpBitRate(u16 wBitRate, u8 byVmpChanNo/* = 1*/)
{
    TPeriEqpStatus tVmpStatus;
	g_cMcuVcApp.GetPeriEqpStatus(m_tVmpEqp.GetEqpId(), &tVmpStatus);
    u8 byVmpSubType = tVmpStatus.m_tStatus.tVmp.m_bySubType;
	// 非vpu直接调整
	if( VMP != byVmpSubType)
	{
		AdjustVmpBrdBitRate();
		return;
	}
    u16 wVmpBitRate = htons(wBitRate);

    CServMsg cServMsg;
    cServMsg.SetConfId(m_tConf.GetConfId());
    cServMsg.SetChnIndex(byVmpChanNo);
    cServMsg.SetMsgBody((u8*)&wVmpBitRate, sizeof(u16));	
    SendMsgToEqp(m_tVmpEqp.GetEqpId(), MCU_VMP_SETCHANNELBITRATE_REQ, cServMsg);

    u16 wOriBitrate = 0;

    if (1 == byVmpChanNo)
    {
        wOriBitrate = m_wVidBasBitrate;
        m_wVidBasBitrate = wBitRate;
    }
    else if (2 == byVmpChanNo)
    {
        wOriBitrate = m_wBasBitrate;
        m_wBasBitrate = wBitRate;
    }

    ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeVmpBitrate] ChanNo.%d be changed from BR.%d to BR.%d\n", byVmpChanNo, wOriBitrate, wBitRate);

    return;
}

/*====================================================================
    函数名      ：RefreshVmpChlMemalias
    功能        ：刷新vmp外设通道台标,用于不调外设通道更新场景
    算法实现    ：根据m_tConf的vmpparam内容与m_tLastVmpParam内容比较
				  找到不一致的通道,刷新
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    12/11/12    4.7         yanghuaizhi     创建
====================================================================*/
void CMcuVcInst::RefreshVmpChlMemalias(u8 byVmpId)
{
	if (!IsValidVmpId(byVmpId))
	{
		return;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	u8 byVmpSubType = GetVmpSubType(byVmpId);
	// vpu与mpu暂不支持台标,mpu要支持通道根据别名显示图片
	if (byVmpSubType == VMP)
	{
		return;
	}
	TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
	TVMPParam_25Mem tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
	TVMPMember* ptVmpMember;
	TVMPMember* ptVmpOldMember;
	// 扩容 [7/4/2013 liaokang]
    //s8 achAlias[VALIDLEN_ALIAS+1] = {0};
    s8 achAlias[MAXLEN_ALIAS] = {0};
	CServMsg cMsg;
	cMsg.SetConfId(m_tConf.GetConfId());
	cMsg.SetConfIdx(m_byConfIdx);
	u8 abyMcuId[MAX_CASCADEDEPTH-1];
	memset( &abyMcuId[0],0,sizeof(abyMcuId) );
	u16 wMcuIdx = 0;
	u8 byMtNum = 0;
	u8 byMcuIdxNum = 0;
	u16 awMcuIdx[MAXNUM_VMP_MEMBER];
	memset( awMcuIdx,INVALID_MCUIDX,sizeof(awMcuIdx) );
	u8 abyMcuIdxMtNum[MAXNUM_VMP_MEMBER];
	memset( abyMcuIdxMtNum,0,sizeof(abyMcuIdxMtNum) );

	// 第一步：发本级成员别名给外设，清除本级成员与相等成员,剩余为下级需要获得别名的终端
	u8 byIdx,byTmpIdx;
	for (byIdx=0; byIdx<tVmpParam.GetMaxMemberNum(); byIdx++)
	{
		ptVmpMember = tVmpParam.GetVmpMember(byIdx);
		ptVmpOldMember = tLastVmpParam.GetVmpMember(byIdx);
		if (ptVmpMember->IsNull())
		{
			continue;
		}
		if (*ptVmpMember == *ptVmpOldMember)
		{
			// 新旧成员相等，直接剔除，为下级终端别名做准备
			ptVmpMember->SetNull();
			continue;
		}
		memset(achAlias, 0, sizeof(achAlias));
		if (GetMtAliasToVmp(*ptVmpMember, achAlias) )
		{
			// 本级终端直接取别名即可，下级终端需到mtadp取别名
			if (ptVmpMember->IsLocal())
			{
				cMsg.SetChnIndex(byIdx);
				cMsg.SetMsgBody( (u8*)achAlias, sizeof(achAlias) );
				cMsg.CatMsgBody(&byIdx, sizeof(u8));
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[RefreshVmpChlMemalias]vmp member.%d info: mt(%d,%d), alias is %s!\n", 
					byIdx, ptVmpMember->GetMcuId(), ptVmpMember->GetMtId(), achAlias);
				SendMsgToEqp(tVmpEqp.GetEqpId(), MCU_VMP_CHANGEMEMALIAS_CMD, cMsg);
				
				// 清除该通道成员，为下级终端别名做准备
				ptVmpMember->SetNull();
				continue;
			}
			else if (0 == strcmp("",achAlias))//别名为空，不做处理，只有别名不为空，才去取扩展后别名
			{
				ptVmpMember->SetNull();
				continue;
			}
		}
		else
		{
			// 获得别名失败，也不做处理
			ptVmpMember->SetNull();
			continue;
		}
		
		wMcuIdx = ptVmpMember->GetMcuIdx();
		for (byTmpIdx = 0; byTmpIdx < MAXNUM_VMP_MEMBER; byTmpIdx++)
		{
			if (awMcuIdx[byTmpIdx] == INVALID_MCUIDX || awMcuIdx[byTmpIdx] == wMcuIdx)
			{
				break;
			}
		}
		if (awMcuIdx[byTmpIdx] == INVALID_MCUIDX)
		{
			byMcuIdxNum++;
			awMcuIdx[byTmpIdx] = wMcuIdx;
		}
		abyMcuIdxMtNum[byTmpIdx]++;//记录该下级mcu下有多少个终端
	}
	
	// 针对下级终端，向mtadp请求别名
	u8 byMtId = 0;
	u8 byChlNum = 0;
	for (byTmpIdx=0; byTmpIdx<byMcuIdxNum; byTmpIdx++)
	{
		byMtId = 0;
		byMtNum = abyMcuIdxMtNum[byTmpIdx];
		cMsg.SetMsgBody(&byVmpId, sizeof(u8));
		if ( !m_tConfAllMcuInfo.GetMcuIdByIdx( awMcuIdx[byTmpIdx],&abyMcuId[0] ) )
		{
			continue;
		}
		cMsg.CatMsgBody(&abyMcuId[1], sizeof(u8));
		cMsg.CatMsgBody(&byMtNum, sizeof(u8));
		LogPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetSmcuMtAliasInVmp]VmpId:%d, abyMcuId(%d,%d), byMtNum.%d\n", byVmpId, abyMcuId[0], abyMcuId[1], byMtNum);
		for (byIdx=0; byIdx<tVmpParam.GetMaxMemberNum(); byIdx++)
		{
			ptVmpMember = tVmpParam.GetVmpMember(byIdx);
			if (!ptVmpMember || ptVmpMember->IsNull())
			{
				continue;
			}
			wMcuIdx = ptVmpMember->GetMcuIdx();
			// mcuIdx一致
			if (wMcuIdx == awMcuIdx[byTmpIdx])
			{
				byMtId = ptVmpMember->GetMtId();
				byChlNum = 1;
				cMsg.CatMsgBody(&byMtId, sizeof(u8));
				cMsg.CatMsgBody(&byChlNum, sizeof(u8));
				cMsg.CatMsgBody(&byIdx, sizeof(u8));
				LogPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetSmcuMtAliasInVmp]MtId:%d, ChlNum.%d, ChlId.%d\n", byMtId, byChlNum, byIdx);
			}
		}
		SendMsgToMt(abyMcuId[0], MCU_MTADP_GETSMCUMTALIAS_CMD, cMsg);
	}
}

/*====================================================================
    函数名      ：GetSmcuMtAliasInVmp
    功能        ：获得画面合成中下级终端别名(别名扩容支持)
    算法实现    ：根据tConf的vmpparam内容与EqpStatus的VmpParam内容比较
				  找到不一致的通道,若是下级终端，获取其别名供外设刷新
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    12/11/12    4.7         yanghuaizhi     创建
====================================================================*/
void CMcuVcInst::GetSmcuMtAliasInVmp(u8 byVmpId)
{
	if (!IsValidVmpId(byVmpId))
	{
		return;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	u8 byVmpSubType = GetVmpSubType(byVmpId);
	// vpu与mpu暂不支持台标,mpu要支持通道根据别名显示图片
	if (byVmpSubType == VMP)
	{
		return;
	}
	TPeriEqpStatus tPeriEqpStatus;
	g_cMcuVcApp.GetPeriEqpStatus(byVmpId , &tPeriEqpStatus);
	TVMPParam_25Mem tPeriVmpParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();
	TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
	TVMPMember* ptVmpMember;
	TVMPMember* ptVmpOldMember;
    s8 achAlias[MAXLEN_ALIAS] = {0};
	// 消息内容：byEqpid + byMcuId + byMtNum + byMtNum*[ byMtId + byChlNum + byChlNum*[byChlIdx]]
	CServMsg cMsg;
	cMsg.SetConfId(m_tConf.GetConfId());
	cMsg.SetConfIdx(m_byConfIdx);
	u8 abyMcuId[MAX_CASCADEDEPTH-1];
	memset( &abyMcuId[0],0,sizeof(abyMcuId) );
	u16 wMcuIdx = 0;
	u8 byMtNum = 0;
	u8 byMcuIdxNum = 0;
	u16 awMcuIdx[MAXNUM_VMP_MEMBER];
	memset( awMcuIdx,INVALID_MCUIDX,sizeof(awMcuIdx) );
	u8 abyMcuIdxMtNum[MAXNUM_VMP_MEMBER];
	memset( abyMcuIdxMtNum,0,sizeof(abyMcuIdxMtNum) );

	// 第一步：清除本级成员与相等成员,剩余为下级需要获得别名的终端
	u8 byIdx,byTmpIdx;
	for (byIdx=0; byIdx<tPeriVmpParam.GetMaxMemberNum(); byIdx++)
	{
		ptVmpOldMember = tVmpParam.GetVmpMember(byIdx);
		ptVmpMember = tPeriVmpParam.GetVmpMember(byIdx);
		if (!ptVmpOldMember || !ptVmpMember || ptVmpMember->IsNull())
		{
			continue;
		}
		// 成员相等或是本级终端不做处理,切风格时，仍需要
		if (ptVmpMember->IsLocal() || *ptVmpMember == *ptVmpOldMember)
		{
			ptVmpMember->SetNull();
			continue;
		}
		memset(achAlias, 0, sizeof(achAlias));
		if (GetMtAliasToVmp(*ptVmpMember, achAlias) )
		{
			if (0 == strcmp("",achAlias))//别名为空，不做处理，只有别名不为空，才去取扩展后别名
			{
				ptVmpMember->SetNull();
				continue;
			}
		}
		else
		{
			// 获得别名失败，也不做处理
			ptVmpMember->SetNull();
			continue;
		}
		
		wMcuIdx = ptVmpMember->GetMcuIdx();
		for (byTmpIdx = 0; byTmpIdx < MAXNUM_VMP_MEMBER; byTmpIdx++)
		{
			if (awMcuIdx[byTmpIdx] == INVALID_MCUIDX || awMcuIdx[byTmpIdx] == wMcuIdx)
			{
				break;
			}
		}
		if (awMcuIdx[byTmpIdx] == INVALID_MCUIDX)
		{
			byMcuIdxNum++;
			awMcuIdx[byTmpIdx] = wMcuIdx;
		}
		abyMcuIdxMtNum[byTmpIdx]++;//记录该下级mcu下有多少个终端
	}

	u8 byMtId = 0;
	u8 byChlNum = 0;
	for (byTmpIdx=0; byTmpIdx<byMcuIdxNum; byTmpIdx++)
	{
		byMtId = 0;
		byMtNum = abyMcuIdxMtNum[byTmpIdx];
		cMsg.SetMsgBody(&byVmpId, sizeof(u8));
		if ( !m_tConfAllMcuInfo.GetMcuIdByIdx( awMcuIdx[byTmpIdx],&abyMcuId[0] ) )
		{
			continue;
		}
		cMsg.CatMsgBody(&abyMcuId[1], sizeof(u8));
		cMsg.CatMsgBody(&byMtNum, sizeof(u8));
		LogPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetSmcuMtAliasInVmp]VmpId:%d, abyMcuId(%d,%d), byMtNum.%d\n", byVmpId, abyMcuId[0], abyMcuId[1], byMtNum);
		for (byIdx=0; byIdx<tPeriVmpParam.GetMaxMemberNum(); byIdx++)
		{
			ptVmpMember = tPeriVmpParam.GetVmpMember(byIdx);
			if (!ptVmpMember || ptVmpMember->IsNull())
			{
				continue;
			}
			wMcuIdx = ptVmpMember->GetMcuIdx();
			// mcuIdx一致
			if (wMcuIdx == awMcuIdx[byTmpIdx])
			{
				byMtId = ptVmpMember->GetMtId();
				byChlNum = 1;
				cMsg.CatMsgBody(&byMtId, sizeof(u8));
				cMsg.CatMsgBody(&byChlNum, sizeof(u8));
				cMsg.CatMsgBody(&byIdx, sizeof(u8));
				LogPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetSmcuMtAliasInVmp]MtId:%d, ChlNum.%d, ChlId.%d\n", byMtId, byChlNum, byIdx);
			}
		}
		SendMsgToMt(abyMcuId[0], MCU_MTADP_GETSMCUMTALIAS_CMD, cMsg);
	}
}

/*====================================================================
    函数名      ：AdjustVmpSelBitRate
    功能        ：调整指定画面合成的当前选看输出码率
    算法实现    ：兼容新老VMP，调整某通道的最低接收能力
    引用全局变量：
    输入参数说明：  TEqp [in]	指定vmp
					TMt* [in]	老VMP用作调通道号的参考，对于MPU无意义
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/02/28    4.7        yanghuaizhi          创建
====================================================================*/
void CMcuVcInst::AdjustVmpSelBitRate(TEqp tVmpEqp)
{
	if (!IsValidVmpId(tVmpEqp.GetEqpId()))
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[AdjustVmpSelBitRate] tVmpEqp[id:%d] is not VMP!\n ");
		return;
	}

	u8 byVmpSubType = GetVmpSubType(tVmpEqp.GetEqpId());
	if (VMP == byVmpSubType)
	{
		// vpu不支持被选看
		return;
	}
	
	u8 byVmpOutChnnl = 0;
	u8 byMaxOutChnl = 0;
	byMaxOutChnl = MAXNUM_MPU_OUTCHNNL;
	TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
	TVideoStreamCap tVidStrCap;
	u16 wMinMtReqBitRate;
	u16 wOriBitrate;
	u16 wVmpBitRate;
	//MPU2需计算后适配数
	if (MPU2_VMP_BASIC == byVmpSubType ||
		MPU2_VMP_ENHACED == byVmpSubType)
	{
		byMaxOutChnl = tVMPOutParam.GetVmpOutCount();
	}
	
	CServMsg cServMsg;
	for (; byVmpOutChnnl < byMaxOutChnl; byVmpOutChnnl ++)// yhz-
	{
		//20110527,songkun,vmp广播呼叫低速没有降
        wMinMtReqBitRate = GetMinMtRcvBitByVmpChn(tVmpEqp.GetEqpId(),TRUE,byVmpOutChnnl);
		tVidStrCap = tVMPOutParam.GetVmpOutCapIdx(byVmpOutChnnl);
		
		wOriBitrate = 0;
		if ( wMinMtReqBitRate != tVidStrCap.GetMaxBitRate() )
		{
			wOriBitrate = tVidStrCap.GetMaxBitRate();
			SetVMPOutChlBitrate(tVmpEqp, byVmpOutChnnl, wMinMtReqBitRate);
			wVmpBitRate = htons(wMinMtReqBitRate);
			
			cServMsg.Init();
			cServMsg.SetConfId(m_tConf.GetConfId());
			cServMsg.SetChnIndex(byVmpOutChnnl);
			cServMsg.SetMsgBody((u8*)&wVmpBitRate, sizeof(u16));	
			SendMsgToEqp(tVmpEqp.GetEqpId(), MCU_VMP_SETCHANNELBITRATE_REQ, cServMsg);
			
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[AdjustVmpBrdBitrate] VMP.%d ChanNo.%d be changed from BR.%d to BR.%d\n", 
				tVmpEqp.GetEqpId(), byVmpOutChnnl, wOriBitrate, wMinMtReqBitRate);
		}
	}
	g_cMcuVcApp.SetVMPOutParam(tVmpEqp, tVMPOutParam);

	return;
}

/*====================================================================
    函数名      ：AdjustVmpBrdBitRate
    功能        ：调整画面合成的当前输出码率
    算法实现    ：兼容新老VMP，调整某通道的最低接收能力
    引用全局变量：
    输入参数说明：TMt *		[in]	老VMP用作调通道号的参考，对于MPU无意义
    返回值说明  ：u8		对于老VMP返回调整的实际通道号，对于MPU无意义
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    09/08/04    4.6         薛亮          创建
====================================================================*/
void CMcuVcInst::AdjustVmpBrdBitRate(TMt *ptMt /*= NULL*/)
{
	TMt tVidBrdSrc = GetVidBrdSrc();
	if (tVidBrdSrc.GetEqpType() != EQP_TYPE_VMP || tVidBrdSrc.GetEqpId() != m_tVmpEqp.GetEqpId())
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[AdjustVmpBrdBitRate] VidBrdSrc(%d,%d) is not VMP(%d)!\n ",
			tVidBrdSrc.GetMcuId(), tVidBrdSrc.GetMtId(), m_tVmpEqp.GetEqpId());
		return;
	}
    u8 byVmpSubType = GetVmpSubType(m_tVmpEqp.GetEqpId());
	if( VMP == byVmpSubType)
	{
		// 调整vpu广播码率
		AdjustVpuBrdBitRate(ptMt);
	}
	else
	{
		// 调整mpu广播码率
		AdjustMpuBrdBitRate();
	}

    return;
}

/*==============================================================================
函数名    :  AdjustVpuBrdBitRate
功能      :  调整vpu广播码率
算法实现  :  
参数说明  :  TMt *ptMt
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130530					yanghuaizhi							
==============================================================================*/
void CMcuVcInst::AdjustVpuBrdBitRate(TMt *ptMt)
{
	if( NULL == ptMt || ptMt->IsNull() )
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[AdjustVmpBrdBitRate] ptMt is NULL as using old VMP!\n ");
		return;
	}
	u8  byMediaType = 0;
	u8 byVmpChanNo = 0;
	TSimCapSet tDstSimCapSet = m_ptMtTable->GetDstSCS(ptMt->GetMtId());
	byMediaType = m_tConf.GetMainVideoMediaType();
	//双速会议要考虑入会时的呼叫码率
	if ( 0 != m_tConf.GetSecBitRate() && 
		MEDIA_TYPE_NULL == m_tConf.GetSecVideoMediaType())
	{
		if (m_ptMtTable->GetDialBitrate(ptMt->GetMtId()) == m_tConf.GetBitRate())
		{
			byVmpChanNo = 1;
		}
		else
		{
			byVmpChanNo = 2;
		}
	}
	//单速或双格式会议
	else
	{
		if (tDstSimCapSet.GetVideoMediaType() == byMediaType)
		{
			byVmpChanNo = 1;
		}
		else
		{
			byVmpChanNo = 2;
		}
	}
	
	u8 byEncType = m_tConf.GetCapSupport().GetMainSimCapSet().GetVideoMediaType();
	u16 wMinMtReqBitRate = GetLeastMtReqBitrate( TRUE, byEncType );
	
	u16 wOriBitrate = 0;
	u16 wVMPBrdBitrate = GetVMPOutChlBitrate(m_tVmpEqp, byVmpChanNo-1);
	if ( wMinMtReqBitRate != wVMPBrdBitrate)
	{
		wOriBitrate = wVMPBrdBitrate;
		SetVMPOutChlBitrate(m_tVmpEqp, byVmpChanNo-1, wMinMtReqBitRate);
		u16 wVmpBitRate = htons(wMinMtReqBitRate);
		
		CServMsg cServMsg;
		cServMsg.SetConfId(m_tConf.GetConfId());
		cServMsg.SetChnIndex(byVmpChanNo);
		cServMsg.SetMsgBody((u8*)&wVmpBitRate, sizeof(u16));	
		SendMsgToEqp(m_tVmpEqp.GetEqpId(), MCU_VMP_SETCHANNELBITRATE_REQ, cServMsg);
		
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[AdjustVmpBrdBitrate] ChanNo.%d be changed from BR.%d to BR.%d\n", byVmpChanNo, wOriBitrate, wMinMtReqBitRate);
	}
	
	return ;
}

/*==============================================================================
函数名    :  AdjustMpuBrdBitRate
功能      :  调整mpu广播码率
算法实现  :  
参数说明  :  
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130530					yanghuaizhi							
==============================================================================*/
void CMcuVcInst::AdjustMpuBrdBitRate()
{
	TPeriEqpStatus tVmpStatus;
	g_cMcuVcApp.GetPeriEqpStatus(m_tVmpEqp.GetEqpId(), &tVmpStatus);
    u8 byVmpSubType = tVmpStatus.m_tStatus.tVmp.m_bySubType;
	u8 byBoardVer	= tVmpStatus.m_tStatus.tVmp.m_byBoardVer;
	u8 byVmpOutChnnl = 0;
	u8 byMaxOutChnl = 0;
	byMaxOutChnl = MAXNUM_MPU_OUTCHNNL;
	//MPU2需计算后适配数
	if (MPU2_VMP_BASIC == byVmpSubType ||
		MPU2_VMP_ENHACED == byVmpSubType)
	{
		TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(m_tVmpEqp);
		byMaxOutChnl = tVMPOutParam.GetVmpOutCount();
	}
	
	for (; byVmpOutChnnl < byMaxOutChnl; byVmpOutChnnl ++)// yhz-
	{
		
		if (byVmpSubType == MPU_SVMP && byBoardVer == MPU_BOARD_A128 && byVmpOutChnnl == 3) //A板只有3路
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "MPU A version, only 3 out channel!\n" );
			break;
		}
		//20110527,songkun,vmp广播呼叫低速没有降
        u16 wMinMtReqBitRate = GetMinMtRcvBitByVmpChn(m_tVmpEqp.GetEqpId(),TRUE,byVmpOutChnnl);
		
		u16 wOriBitrate = 0;
		u16 wVMPBrdBitrate = GetVMPOutChlBitrate(m_tVmpEqp, byVmpOutChnnl);
		if ( wMinMtReqBitRate != wVMPBrdBitrate )
		{
			wOriBitrate = wVMPBrdBitrate;
			SetVMPOutChlBitrate(m_tVmpEqp, byVmpOutChnnl, wMinMtReqBitRate);
			u16 wVmpBitRate = htons(wMinMtReqBitRate);
			
			CServMsg cServMsg;
			cServMsg.SetConfId(m_tConf.GetConfId());
			cServMsg.SetChnIndex(byVmpOutChnnl);
			cServMsg.SetMsgBody((u8*)&wVmpBitRate, sizeof(u16));	
			SendMsgToEqp(m_tVmpEqp.GetEqpId(), MCU_VMP_SETCHANNELBITRATE_REQ, cServMsg);
			
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[AdjustVmpBrdBitrate] ChanNo.%d be changed from BR.%d to BR.%d\n", 
				byVmpOutChnnl, wOriBitrate, wMinMtReqBitRate);
		}
	}

    return;
}

/*====================================================================
    函数名      ：UpdataVmpEncryptParam
    功能        ：改变画面合成的编解码参数,用于模版开启的vmp
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt tMt
                  u8  byChnlNo
				  u8 byEqpId 默认值为0 表示模板开启VmP
				             值不为0 表示Nplus模板开启多vmp
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/04/18    3.6         libo          创建
====================================================================*/
void CMcuVcInst::UpdataVmpEncryptParam(TMt tMt, u8 byChnlNo,u8 byEqpId)
{
    //TVMPParam tConfVMPParam;
	u8 byVmpEqpId = (byEqpId == 0)? m_tModuleVmpEqp.GetEqpId():byEqpId;

    TMediaEncrypt  tVideoEncrypt;
    TDoublePayload tDoublePayload;
	u8 byRcvH264DependInMark = 0;  //用于8ke/h/i vmp按特殊方式解码设置（针对华为终端）

    //tConfVMPParam = m_tConfEqpModule.m_tVmpModule.m_tVMPParam;

	if (m_tConfEqpModule.m_tVmpModuleInfo.m_abyVmpMember[byChnlNo]!= tMt.GetMtId() && byEqpId == 0)
    {
        return;
    }

    BOOL32 bRet = FALSE;
    TLogicalChannel tChnnl;

    bRet = m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tChnnl, FALSE);
    if (bRet == TRUE)
    {
        tVideoEncrypt = tChnnl.GetMediaEncrypt();
        tDoublePayload.SetRealPayLoad(tChnnl.GetChannelType());
		tDoublePayload.SetActivePayload(tChnnl.GetActivePayload());
		byRcvH264DependInMark = IsRcvH264DependInMark(tMt.GetMtId());
    }
	
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[UpdataVmpEncryptParam] ChanNo.%d RcvH264DependInMark.%d\n", 
		byChnlNo, byRcvH264DependInMark);

    CServMsg cServMsg;
    cServMsg.SetConfId( m_tConf.GetConfId() );
    cServMsg.SetMsgBody( (u8*)&byChnlNo, sizeof(u8) );
    cServMsg.CatMsgBody( (u8*)&tVideoEncrypt, sizeof(TMediaEncrypt) );
    cServMsg.CatMsgBody( (u8*)&tDoublePayload, sizeof(TDoublePayload) );
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
    cServMsg.CatMsgBody( (u8*)&byRcvH264DependInMark, sizeof(u8) );
#endif

    SendMsgToEqp( byVmpEqpId, MCU_VMP_UPDATAVMPENCRYPTPARAM_REQ, cServMsg );

}

/*====================================================================
    函数名      ：ChangeVmpParameter
    功能        ：给VMP下编码等参数总入口
    算法实现    ：
    引用全局变量：
    输入参数说明：TVMPParam *ptVMPParam		[i]
				  BOOL32 bStart				[i]是否是开始画面合成
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    11/02/18    4.6         薛亮          创建
====================================================================*/
void CMcuVcInst::ChangeVmpParam(u8 byVmpId, TVMPParam_25Mem *ptVMPParam, BOOL32 bStart)
{
	if (!IsValidVmpId(byVmpId))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[ChangeVmpParam] byVmpId(%d) is not valid, return!\n", byVmpId);
		return;
	}
	if( NULL == ptVMPParam )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[ChangeVmpParam] ptVMPParam is NULL, return!\n");
		return;
	}
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP, "Tick:%d, [ChangeVmpParam]VmpId(%d) VMPParam is", OspTickGet(), byVmpId);
	ptVMPParam->Print(LOG_LVL_KEYSTATUS);

	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	// 获得给外设发送消息的共通数据
	TVmpCommonAttrb tVmpCommonAttrb = GetVmpCommonAttrb(byVmpId, ptVMPParam, bStart);

	//将合成成员更新到TPeriEqpStatus中
	TPeriEqpStatus tPeriEqpStatus; 
	g_cMcuVcApp.GetPeriEqpStatus( byVmpId, &tPeriEqpStatus );
	tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(*ptVMPParam);
	g_cMcuVcApp.SetPeriEqpStatus( byVmpId, &tPeriEqpStatus );

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChangeVmpParam]PeriEqpStatus vmpParam is follow:\n===========\n");
	ptVMPParam->Print();
	
	u8 byVmpSubType = GetVmpSubType(byVmpId);
	if(byVmpSubType == VMP)
	{
		CParamToOldVmp cParamToVmp(tVmpCommonAttrb, m_byConfIdx, byVmpId);
		ConstructMsgAndSendtoVmp(byVmpId, cParamToVmp, bStart);
	}
	else if( byVmpSubType == MPU_SVMP)
	{
		CParamToMpuVmp cParamToVmp(tVmpCommonAttrb, m_byConfIdx, byVmpId);
		ConstructMsgAndSendtoVmp(byVmpId, cParamToVmp, bStart);
	}
	else if(byVmpSubType == VMP_8KE || byVmpSubType == VMP_8KH)
	{
		CParamTo8kg8khVmp cParamToVmp(tVmpCommonAttrb, m_byConfIdx, byVmpId);
		ConstructMsgAndSendtoVmp(byVmpId, cParamToVmp, bStart);
		
	}//MPU2类型 yhz-
	else if( byVmpSubType == MPU2_VMP_ENHACED || byVmpSubType == MPU2_VMP_BASIC)
	{
		TKDVVMPOutParam tVmpOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
		CParamToKDVVmp cParamToVmp(tVmpCommonAttrb, m_byConfIdx, byVmpId, tVmpOutParam);
		ConstructMsgAndSendtoVmp(byVmpId, cParamToVmp, bStart);
		
	}//8KIVMP类型
	else if( byVmpSubType == VMP_8KI)
	{
		TKDVVMPOutParam tVmpOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
		CParamTo8kiVmp cParamToVmp(tVmpCommonAttrb, m_byConfIdx, byVmpId, tVmpOutParam);
		ConstructMsgAndSendtoVmp(byVmpId, cParamToVmp, bStart);
		
	}
	else
	{
		//exception
	}

	if (!bStart)
	{
		ProcUnfinishedChangeVmpCmd(byVmpId);
	}
}

/*====================================================================
    函数名      ：ConstructMsgAndSendtoVmp
    功能        ：构建开启VMP的消息体并发送给VMP
    算法实现    ：
    引用全局变量：
    输入参数说明：CParamToVmp &cParamToVmp	[i]
				  BOOL32 bStart				[i]是否是开始画面合成
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    11/02/18    4.6         薛亮          创建
====================================================================*/
void CMcuVcInst::ConstructMsgAndSendtoVmp(u8 byVmpId, CParamToVmp &cParamToVmp, BOOL32 bStart)
{
	CServMsg cServMsg;
	cParamToVmp.ConstructMsgToVmp(cServMsg);

	TPeriEqpStatus tPeriEqpStatus;
	//发消息
	if (bStart)
	{
		//状态由RESERVE更新为WAIT_START
		g_cMcuVcApp.GetPeriEqpStatus(byVmpId, &tPeriEqpStatus);
		tPeriEqpStatus.m_tStatus.tVmp.m_byUseState = TVmpStatus::WAIT_START;
		g_cMcuVcApp.SetPeriEqpStatus(byVmpId, &tPeriEqpStatus);
		SendMsgToEqp(byVmpId, MCU_VMP_STARTVIDMIX_REQ, cServMsg);
		u8 byVmpIdx = byVmpId - VMPID_MIN;
		// MPU2 Basic*2板卡开启慢,两个会议同时恢复时需要时间长,按12秒
		if (MPU2_VMP_BASIC == GetVmpSubType(byVmpId) &&
			BRD_TYPE_MPU2ECARD == g_cMcuAgent.GetMPU2TypeByVmpEqpId(byVmpId))
		{
			SetTimer(MCUVC_VMP_WAITVMPRSP_TIMER+byVmpIdx, 2*TIMESPACE_WAIT_VMPRSP);
		}
		else //其余板卡按6秒
		{
			SetTimer(MCUVC_VMP_WAITVMPRSP_TIMER+byVmpIdx, TIMESPACE_WAIT_VMPRSP);
		}
		//m_tConfInStatus.SetVmpNotify(FALSE);
	}
	else
	{
		// 设置Timer,vmp响应后KillTimer,超时后将VmpNotify置TRUE
		/*TPeriEqpStatus tPeriEqpStatus;
		g_cMcuVcApp.GetPeriEqpStatus(m_tVmpEqp.GetEqpId(), &tPeriEqpStatus);
		if ( TVmpStatus::START == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState )
		{
			SetTimer(MCUVC_VMP_WAITVMPRSP_TIMER, TIMESPACE_WAIT_VMPRSP);
		}*/
		SendMsgToEqp(byVmpId, MCU_VMP_CHANGEVIDMIXPARAM_CMD, cServMsg);
	}
	

}
/*====================================================================
    函数名      ：ChangeVmpParam
    功能        ：画面合成参数改变
    算法实现    ：
    引用全局变量：
    输入参数说明：TVMPParam *ptVMPParam, 画面合成参数
				  BOOL32 bStart 是否是开始画面合成
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/04    3.0         胡昌威         创建
====================================================================*/
// void CMcuVcInst::ChangeVmpParam(TVMPParam *ptVMPParam, BOOL32 bStart)
// {
// 	if (ptVMPParam == NULL)
// 	{
// 		return;
// 	}
// 
//     // guzh [7/25/2007] 当前会议的合成参数，本函数不会保存风格等参数，而是等VMP回应再保存
//     // 在此之前会 SetPeriEqpStatus 中临时保存
//     // 在VMP回应之前的GetVmpParam会返回以前的Param    
// 	TVMPParam tConfVMPParam = m_tConf.m_tStatus.GetVmpParam();
//     
//     u16 wMinMtReqBitrate = 0;
// 
//     //设置参数
//     CKDVVMPParam cKDVVMPParam;
//     memset(&cKDVVMPParam, 0, sizeof(cKDVVMPParam));
//     cKDVVMPParam.m_byVMPStyle = ptVMPParam->GetVMPStyle();
//     cKDVVMPParam.m_byEncType = m_tConf.GetMainVideoMediaType();
//     
//     //先判断双速单格式会议的情况：第一通道为会议码率，第二通道为非会议码率的最低码率（>=会议辅助码率）
//     if (0 != m_tConf.GetSecBitRate() && 
//         MEDIA_TYPE_NULL == m_tConf.GetSecVideoMediaType())
//     {
//         wMinMtReqBitrate = m_tConf.GetBitRate();
//     }
//     else
//     {
//         wMinMtReqBitrate = GetLeastMtReqBitrate(TRUE, cKDVVMPParam.m_byEncType);
//         //m_awVMPBrdBitrate[0] = wMinMtReqBitrate;
//     }
//     m_awVMPBrdBitrate[0] = wMinMtReqBitrate;
// //     if (wMinMtReqBitrate < m_wVidBasBitrate || 0 == m_wVidBasBitrate)
// //     {
// //         m_wVidBasBitrate = wMinMtReqBitrate;
// //     }
//     cKDVVMPParam.m_wBitRate = htons(wMinMtReqBitrate);
// 
//     
//     u16 wWidth = 0;
//     u16 wHeight = 0;
//     m_tConf.GetVideoScale(cKDVVMPParam.m_byEncType,
//                           wWidth,
//                           wHeight);
//     cKDVVMPParam.m_wVideoWidth = wWidth;
//     cKDVVMPParam.m_wVideoHeight = wHeight;
// 
// 
//     //现在约定16CIF即是2CIF,规则按照AUTO处理, xsl [8/11/2006] mpeg2 4cif按2cif处理
// 	u8 byRes = m_tConf.GetVideoFormat(cKDVVMPParam.m_byEncType);
//     if( VIDEO_FORMAT_16CIF == byRes ||
//         (MEDIA_TYPE_H262 == cKDVVMPParam.m_byEncType && VIDEO_FORMAT_4CIF == byRes))
//     {
//         cKDVVMPParam.m_wVideoWidth  = 352;
//         cKDVVMPParam.m_wVideoHeight = 576;
//     }
//     
// 	cKDVVMPParam.m_wVideoWidth  = htons(cKDVVMPParam.m_wVideoWidth);
// 	cKDVVMPParam.m_wVideoHeight = htons(cKDVVMPParam.m_wVideoHeight);
// 	
// 
// 	//lukunpeng 2010/07/16 画面合成成员转换到cKDVVMPParam
// //	TMt tSpeakerMt = m_tConf.GetSpeaker();
// 
//     // 顾振华 [5/23/2006] 只允许终端进入通道，不允许放像设备
// //    if (tSpeakerMt.GetType() == TYPE_MCUPERI)
// //    {
// //        memset(&tSpeakerMt, 0, sizeof(TMt));
// //    }
// //    TMt tChairMt = m_tConf.GetChairman();
//     
//  //   u8 byMemberNum = ptVMPParam->GetMaxMemberNum();
// 
// 	//lukunpeng 2010/07/19 将VMPParam中的member转换到CKDVVMPParam，
// 	//主要CKDVVMPParam的长度最大是MAXNUM_SDVMP_MEMBER
// 	u8 byMember	= BatchTransVmpMemberToTVMPMemberEx(
// 		ptVMPParam->GetVmpMember(0),
// 		ptVMPParam->GetMaxMemberNum(),
// 		cKDVVMPParam.m_atMtMember,
// 		MAXNUM_SDVMP_MEMBER);
// 
// 	u8 byLoop = ptVMPParam->GetMaxMemberNum();
// 	cKDVVMPParam.m_byMemberNum  = ptVMPParam->GetMaxMemberNum();
// 	
// 	//清掉其余通道的交换
// //	u8 byMaxVMPMember = MAXNUM_SDVMP_MEMBER;
// 	if (ptVMPParam->IsVMPAuto() || VCS_CONF == m_tConf.GetConfSource())
// 	{
// 		byLoop = byMember;
// 		cKDVVMPParam.m_byMemberNum  = byMember;
// 	}
// 	
// 	for (; byLoop < MAXNUM_SDVMP_MEMBER; byLoop++)
// 	{
// 		StopSwitchToPeriEqp(m_tVmpEqp.GetEqpId(), byLoop, TRUE, MODE_VIDEO);
// 		ptVMPParam->ClearVmpMember(byLoop);
// 		//tConfVMPParam.ClearVmpMember(byLoop);// meaning?
// 	}
// 
// 	ptVMPParam->Print();
// 
// 	//将合成成员更新到TPeriEqpStatus中
// 	TPeriEqpStatus tPeriEqpStatus; 
// 	g_cMcuVcApp.GetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tPeriEqpStatus );
// 	tPeriEqpStatus.m_tStatus.tVmp.m_tVMPParam = *ptVMPParam;
// 	g_cMcuVcApp.SetPeriEqpStatus( m_tVmpEqp.GetEqpId(), &tPeriEqpStatus );
// 
//     //填载荷类型等参数
//     TLogicalChannel tChnnl;
//     BOOL32 bRet = FALSE;
//     for (byLoop = 0; byLoop < ptVMPParam->GetMaxMemberNum()/*MAXNUM_SDVMP_MEMBER*/; byLoop++)
//     {
// 	     //zbq[03/03/2009] 跨级终端的载荷取对应的mcu
//         TMt tTmpMt = (TMt)cKDVVMPParam.m_atMtMember[byLoop];
// 		if (tTmpMt.IsNull())
// 		{
// 			continue;
// 		}
// 
//         if (!tTmpMt.IsLocal())
//         {
//             tTmpMt = GetLocalMtFromOtherMcuMt(tTmpMt);
//         }	
// 
//         bRet = m_ptMtTable->GetMtLogicChnnl(tTmpMt.GetMtId(), LOGCHL_VIDEO, &tChnnl, FALSE);
//         if (bRet)
//         {
//             cKDVVMPParam.m_tVideoEncrypt[byLoop] = tChnnl.GetMediaEncrypt();
//             cKDVVMPParam.m_tDoublePayload[byLoop].SetRealPayLoad(tChnnl.GetChannelType());
//             cKDVVMPParam.m_tDoublePayload[byLoop].SetActivePayload(tChnnl.GetActivePayload());
//         }
//     }
// 	
// 	u8 byNeedPrs = m_tConf.GetConfAttrb().IsResendLosePack();
//     
//     if(g_bPrintEqpMsg)
//     {
//         ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangeVmpParam] vmp param is followed:\n");
//         cKDVVMPParam.Print();
//     }    
// 
// 	CServMsg cServMsg;
// 	cServMsg.SetConfId(m_tConf.GetConfId());
// 	cServMsg.SetMsgBody((u8*)&cKDVVMPParam, sizeof(cKDVVMPParam));
// 	
//     //双速单格式会议时第二通道填主媒体格式
//     if (0 != m_tConf.GetSecBitRate() && 
//         MEDIA_TYPE_NULL == m_tConf.GetSecVideoMediaType())
//     {
//         cKDVVMPParam.m_byEncType = m_tConf.GetMainVideoMediaType();
//     }
//     else
//     {
//         cKDVVMPParam.m_byEncType = m_tConf.GetSecVideoMediaType();
//         
//         //xsl [8/11/2006] mpeg2 4cif按2cif处理
//         m_tConf.GetVideoScale(cKDVVMPParam.m_byEncType, wWidth, wHeight);
//         cKDVVMPParam.m_wVideoWidth = wWidth;
//         cKDVVMPParam.m_wVideoHeight = wHeight;
//         byRes = m_tConf.GetVideoFormat(cKDVVMPParam.m_byEncType);
//         if( VIDEO_FORMAT_16CIF == byRes ||
//             (MEDIA_TYPE_H262 == cKDVVMPParam.m_byEncType && VIDEO_FORMAT_4CIF == byRes))
//         {
//             cKDVVMPParam.m_wVideoWidth  = 352;
//             cKDVVMPParam.m_wVideoHeight = 576;
//         }        
//         cKDVVMPParam.m_wVideoWidth  = htons(cKDVVMPParam.m_wVideoWidth);
//         cKDVVMPParam.m_wVideoHeight = htons(cKDVVMPParam.m_wVideoHeight);
//     }
//     
//     //modify bas 2
//     // 单速单格式会议，码率清0, zgc, 2008-03-19
//     if ( MEDIA_TYPE_NULL == cKDVVMPParam.m_byEncType )
//     {
//         wMinMtReqBitrate = 0;
//     }
//     else
//     {
//         wMinMtReqBitrate = GetLeastMtReqBitrate(TRUE, cKDVVMPParam.m_byEncType);
//         if (wMinMtReqBitrate < m_wBasBitrate || 0 == m_wBasBitrate)
//         {
//             m_wBasBitrate = wMinMtReqBitrate;
//         }
//     }
//     cKDVVMPParam.m_wBitRate = htons(wMinMtReqBitrate);
// 
// 	cServMsg.CatMsgBody((u8 *)&cKDVVMPParam, sizeof(cKDVVMPParam));
// 	cServMsg.CatMsgBody((u8 *)&byNeedPrs, sizeof(byNeedPrs)); 
// 
//     //画面合成风格
//     u8 bySchemeId = ptVMPParam->GetVMPSchemeId();
//     TVmpStyleCfgInfo tMcuVmpStyle;    
//     if(0 == bySchemeId)
//     {
//         ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeVmpParam] SchemeId :%d, use default\n", bySchemeId);
//         tMcuVmpStyle.ResetDefaultColor();		
//     }  
//     else
//     {		
//         u8  byVmpStyleNum = 0;
//         TVmpAttachCfg atVmpStyle[MAX_VMPSTYLE_NUM];
//         if (SUCCESS_AGENT == g_cMcuAgent.ReadVmpAttachTable(&byVmpStyleNum, atVmpStyle) && 
//             bySchemeId <= MAX_VMPSTYLE_NUM) // 顾振华 [4/30/2006] 这里应该检查是否越界即可
//         {
//             //zbq[04/02/2008] 取对应方案号的方案，而不是直接取索引
//             u8 byStyleNo = 0;
//             for( ; byStyleNo < byVmpStyleNum && byStyleNo < MAX_VMPSTYLE_NUM; byStyleNo ++ )
//             {
//                 if ( bySchemeId == atVmpStyle[byStyleNo].GetIndex() )
//                 {
//                     break;
//                 }
//             }
//             if ( byVmpStyleNum == byStyleNo ||
//                  MAX_VMPSTYLE_NUM == byStyleNo )
//             {
//                 tMcuVmpStyle.ResetDefaultColor();
//                 ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangeVmpParam] Get vmp cfg failed! use default(NoIdx)\n");                
//             }
//             else
//             {
//                 tMcuVmpStyle.SetBackgroundColor(atVmpStyle[byStyleNo].GetBGDColor());
//                 tMcuVmpStyle.SetFrameColor(atVmpStyle[byStyleNo].GetFrameColor());
//                 tMcuVmpStyle.SetChairFrameColor(atVmpStyle[byStyleNo].GetChairFrameColor());
//                 tMcuVmpStyle.SetSpeakerFrameColor(atVmpStyle[byStyleNo].GetSpeakerFrameColor());
//                 tMcuVmpStyle.SetSchemeId(atVmpStyle[byStyleNo].GetIndex());
//                 tMcuVmpStyle.SetFontType( atVmpStyle[byStyleNo].GetFontType() );
//                 tMcuVmpStyle.SetFontSize( atVmpStyle[byStyleNo].GetFontSize() );
//                 tMcuVmpStyle.SetTextColor( atVmpStyle[byStyleNo].GetTextColor() );
//                 tMcuVmpStyle.SetTopicBkColor( atVmpStyle[byStyleNo].GetTopicBGDColor() );
//                 tMcuVmpStyle.SetDiaphaneity( atVmpStyle[byStyleNo].GetDiaphaneity() );
//                 
//                 ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeVmpParam] get vmpstyle info success, SchemeId :%d\n", bySchemeId);
//                 ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeVmpParam] GRDColor.0x%x, AudFrmColor.0x%x, ChairFrmColor.0x%x, SpeakerFrmColor.0x%x\n",
//                         tMcuVmpStyle.GetBackgroundColor(),
//                         tMcuVmpStyle.GetFrameColor(),
//                         tMcuVmpStyle.GetChairFrameColor(),
//                         tMcuVmpStyle.GetSpeakerFrameColor() );
//             }
//         }
//         else
//         {
//             tMcuVmpStyle.ResetDefaultColor();
//             ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangeVmpParam] Get vmp cfg failed! use default\n");
//         }
//     }
//     tMcuVmpStyle.SetIsRimEnabled( ptVMPParam->GetIsRimEnabled() );
// 
//     tConfVMPParam.SetVMPSchemeId(bySchemeId);
// 	// 保存是否有边框的标志, zgc, 2007-05-16
// 	tConfVMPParam.SetIsRimEnabled( ptVMPParam->GetIsRimEnabled() );
// 
//     m_tConf.m_tStatus.SetVmpParam(tConfVMPParam);
// 
//     cServMsg.CatMsgBody((u8*)&tMcuVmpStyle, sizeof(tMcuVmpStyle));
// 
// 	//发消息
// 	if (bStart)
// 	{
// 		// MCU前向纠错修改, zgc, 2007-09-27
// 		TCapSupportEx tCapSupportEx = m_tConf.GetCapSupportEx();
// 		cServMsg.CatMsgBody((u8*)&tCapSupportEx, sizeof(tCapSupportEx));
// 
// 		SetTimer(MCUVC_VMP_WAITVMPRSP_TIMER, 6*1000);
// 		SendMsgToEqp(m_tVmpEqp.GetEqpId(), MCU_VMP_STARTVIDMIX_REQ, cServMsg);
// 	}
// 	else
// 	{
// 		SendMsgToEqp(m_tVmpEqp.GetEqpId(), MCU_VMP_CHANGEVIDMIXPARAM_REQ, cServMsg);
// 	}
// 
//     m_tConfInStatus.SetVmpNotify(FALSE);
// }
// 
/*====================================================================
    函数名      ：ProcVmpMcuMsg
    功能        ：画面合成器消息处理
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/04    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::ProcVmpMcuRsp( const CMessage * pcMsg )
{
	//CServMsg	cServMsg( pcMsg->content, pcMsg->length );

	switch( CurState() )
	{
	case STATE_ONGOING:

        switch( pcMsg->event ) 
		{		
        case VMP_MCU_STARTVIDMIX_ACK:       //VMP给MCU开始工作确认
        case VMP_MCU_STARTVIDMIX_NACK:      //VMP给MCU开始工作拒绝
		case VMP_MCU_STOPVIDMIX_ACK:        //VMP给MCU停止工作确认
		case VMP_MCU_STOPVIDMIX_NACK:       //VMP给MCU停止工作拒绝
		case VMP_MCU_CHANGEVIDMIXPARAM_ACK: //VMP给MCU改变复合参数确认			
		case VMP_MCU_GETVIDMIXPARAM_ACK:    //VMP给MCU回送复合参数确认			
		case VMP_MCU_GETVIDMIXPARAM_NACK:   //VMP给MCU回送复合参数拒绝
			break;
		case VMP_MCU_CHANGEVIDMIXPARAM_NACK://VMP给MCU改变复合参数拒绝
			{
				/*zhouyiliang 20110513 vmp给mcu合成change请求nack消息，也要设置SetVmpNotify，防止下次change无法做
				//此时肯定不会再来notify了，如果不置为true，那么用到IsVmpNotify的地方都无法通过，下次就无法change
				m_tConfInStatus.SetVmpNotify(TRUE);
				if ( m_tConf.m_tStatus.GetRollCallMode() == ROLLCALL_MODE_VMP )
				{
					LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_EQP,"[ProcVmpMcuRsp]Recover Rollcall finish Mark!\n");
					SetLastMultiSpyRollCallFinish(TRUE);
				}
				
				//清除定时
				KillTimer( MCUVC_VMP_WAITVMPRSP_TIMER );*/
			}
			break;
        default:
			break;
        }

		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "Wrong message %u(%s) received in state %u!\n", 
			   pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}	
}

/*====================================================================
    函数名      ：ProcVmpRspWaitTimer
    功能        ：MCU等待VMP应答超时处理
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    03/12/08    3.0         胡昌威         创建
====================================================================*/
void CMcuVcInst::ProcVmpRspWaitTimer( const CMessage * pcMsg )
{
	KillTimer(pcMsg->event);
	u8 byVmpIdx = pcMsg->event - MCUVC_VMP_WAITVMPRSP_TIMER;
	u8 byVmpId = VMPID_MIN + byVmpIdx;

	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TPeriEqpStatus tPeriEqpStatus;

	if (!IsValidVmpId(byVmpId))
	{
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_EQP,"[ProcVmpRspWaitTimer]VmpId(%d) is not valid!\n", byVmpId);
		return;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	
	switch( CurState() )
	{
	case STATE_ONGOING:

		if (!tVmpEqp.IsNull() &&
			g_cMcuVcApp.GetPeriEqpStatus(tVmpEqp.GetEqpId() , &tPeriEqpStatus) &&
			tPeriEqpStatus.GetConfIdx() == m_byConfIdx)
		{
			TVMPParam_25Mem tEqpStatusVmpParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();
			TVMPParam_25Mem tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
			//free掉tPeriEqpStatus里面有而confvmpparam里面没有的下级多回传成员
			if (TVmpStatus::WAIT_START == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState ||
				TVmpStatus::RESERVE == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState || 
				TVmpStatus::START == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState)
			{
				u8 byVmpMemNum = tEqpStatusVmpParam.GetVMPMemberNum();
				TVMPMember* ptVmpMember = NULL;
				TVMPMember* ptLastVmpMember = NULL;
				for (u8 byLoop = 0 ; byLoop < byVmpMemNum; byLoop++)
				{    
					ptVmpMember = tEqpStatusVmpParam.GetVmpMember(byLoop);
					ptLastVmpMember = tConfVmpParam.GetVmpMember(byLoop);
					if ( NULL != ptVmpMember && ptLastVmpMember && !ptVmpMember->IsNull() && !ptVmpMember->IsLocal() && 
							IsLocalAndSMcuSupMultSpy(ptVmpMember->GetMcuId()) && 
							!((TMt)*ptVmpMember == (TMt)*ptLastVmpMember) 
						 )
					{
						FreeRecvSpy((TMt)*ptVmpMember,MODE_VIDEO);
						if ( VCS_CONF == m_tConf.GetConfSource() && (TMt)*ptVmpMember == m_cVCSConfStatus.GetCurVCMT() )
						{
							TMt tNullMt;
							tNullMt.SetNull();
							m_cVCSConfStatus.SetCurVCMT(tNullMt);
						}
					}
				}
				if (TVmpStatus::START == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState)
				{
					// START状态下不会出现超时
					//m_tConf.m_tStatus.SetVmpParam(m_tLastVmpParam);//更新会议VmpParam
				}
			}
			

			// VCS会议开启vmp抢占用的状态是RESERVE,超时应同WAIT_START一样处理
			if (TVmpStatus::WAIT_START == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState ||
				TVmpStatus::RESERVE == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState)
			{
				tPeriEqpStatus.m_tStatus.tVmp.m_byUseState = TVmpStatus::IDLE;
				tPeriEqpStatus.SetConfIdx(0);
				g_cMcuVcApp.SetPeriEqpStatus( tVmpEqp.GetEqpId() , &tPeriEqpStatus );
				// xliang [5/4/2009] 上报会控
				cServMsg.SetMsgBody();
				cServMsg.SetMsgBody( ( u8 * )&tPeriEqpStatus, sizeof( tPeriEqpStatus ) );
				SendMsgToAllMcs( MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg );

				cServMsg.SetMsgBody();
				SendMsgToEqp( tVmpEqp.GetEqpId(), MCU_VMP_STOPVIDMIX_REQ, cServMsg );
				if ( m_tConf.m_tStatus.GetRollCallMode() == ROLLCALL_MODE_VMP )
				{
					LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_EQP,"[ProcVmpRspWaitTimer]Recover Rollcall finish Mark!\n");
					SetLastMultiSpyRollCallFinish(TRUE);
				}
				tVmpEqp.SetNull();
				RemoveVmpIdFromVmpList(byVmpId);
			}
			else if (TVmpStatus::WAIT_STOP== tPeriEqpStatus.m_tStatus.tVmp.m_byUseState)
			{
				ProcVMPStopSucRsp(byVmpId);
			}
			else if (TVmpStatus::START == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState)
			{
				// Change时超时未响应,将VmpNotify置TRUE,防止备切主后,VmpNotify一直为FALSE
				//m_tConfInStatus.SetVmpNotify(TRUE);
				if ( m_tConf.m_tStatus.GetRollCallMode() == ROLLCALL_MODE_VMP )
				{
					LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_EQP,"[ProcVmpRspWaitTimer]Recover Rollcall finish Mark!\n");
					SetLastMultiSpyRollCallFinish(TRUE);
				}
			}
			else
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ProcVmpRspWaitTimer] no steps needed in state(%d) for vmp(%d) in conf(%d)\n",
					   tPeriEqpStatus.m_tStatus.tVmp.m_byUseState, tVmpEqp.GetEqpId(), m_byConfIdx);

			}
		}
		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[VmpRspWaitTimer]Wrong message %u(%s) received in state %u!\n", 
			   pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ：ProcVmpMcuNotif
    功能        ：处理Vmp给Mcu的通知
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/10/31    4.0         libo          创建
====================================================================*/
void CMcuVcInst::ProcVmpMcuNotif(const CMessage * pcMsg)
{
	CServMsg cServMsg(pcMsg->content, pcMsg->length);
	
	u8 byVmpId = cServMsg.GetSrcSsnId();
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );

	switch( CurState() )
	{
	case STATE_ONGOING:

        switch( pcMsg->event ) 
		{
		case VMP_MCU_STARTVIDMIX_NOTIF:     //VMP给MCU开始工作通知
			{
				ProcVmpMcuStartVmpNotify(cServMsg);
			}
            break;

		case VMP_MCU_STOPVIDMIX_NOTIF:      //VMP给MCU停止工作通知
			{
				u8 byVmpIdx = byVmpId - VMPID_MIN;
				TPeriEqpStatus tPeriEqpStatus;
				KillTimer(MCUVC_VMP_WAITVMPRSP_TIMER+byVmpIdx);
				if (!tVmpEqp.IsNull() &&
					g_cMcuVcApp.GetPeriEqpStatus(byVmpId , &tPeriEqpStatus) &&
					tPeriEqpStatus.GetConfIdx() == m_byConfIdx &&
					TVmpStatus::WAIT_STOP == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState)
				{
					ProcVMPStopSucRsp(tVmpEqp.GetEqpId());
				}
			}
			break;
			
		case VMP_MCU_CHANGESTATUS_NOTIF:    //VMP给MCU改变复合参数通知 
			{
				break;
			}
			

        case MCU_VMPCONNECTED_NOTIF:
			{
				ProcVmpConnectedNotify(cServMsg);
			}
            break;

		case MCU_VMPDISCONNECTED_NOTIF:
			{
				ProcVmpDisconnectedNotify(cServMsg);
			}
			break;
			
		case VMP_MCU_NEEDIFRAME_CMD:

			{
				u8 byChlIdx = cServMsg.GetChnIndex();
				if (byChlIdx >= MAXNUM_VMP_MEMBER)
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP,  "VMP_MCU_NEEDIFRAME_CMD, byChlIdx(%d) is not correct channel for vmp.\n", byChlIdx);
					break;
				}
				TVMPParam_25Mem tVMPParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);//m_tConf.m_tStatus.m_tVMPParam;
				TVMPParam_25Mem tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
				// 若ConfVmpParam与LastVmpParam通道信息不一致，表示未成功建交换，不请求关键帧
				TVMPMember tCurVmpMember = *tVMPParam.GetVmpMember(byChlIdx);
				TVMPMember tLastVmpMember = *tLastVmpParam.GetVmpMember(byChlIdx);
				if (!(tCurVmpMember == tLastVmpMember))
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP,  "VMP_MCU_NEEDIFRAME_CMD, ChlIdx(%d) ConfVmpMember is not equal LastVmpMember.\n", 
						byChlIdx);
					break;
				}
				
				TVMPMember tSrcMt = *tVMPParam.GetVmpMember( byChlIdx );
				
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP,  "Receive VMP_MCU_NEEDIFRAME_CMD to tSrcMt(%d,%d)\n",tSrcMt.GetMcuId(),tSrcMt.GetMtId() );
				
				// 双流源支持
				u8 byMode = MODE_VIDEO;
				if (VMP_MEMBERTYPE_DSTREAM == tSrcMt.GetMemberType())
				{
					byMode = MODE_SECVIDEO;
					tSrcMt.SetMemberTMt(m_tDoubleStreamSrc);//对双流源请求关键帧
				}
				else
				{
					// 针对电话终端，逻辑通道未开，不请求关键帧
					TLogicalChannel tLogicChannel;
					TMt tLocalMt = GetLocalMtFromOtherMcuMt(tSrcMt);
					if (!m_ptMtTable->GetMtLogicChnnl( tLocalMt.GetMtId(), LOGCHL_VIDEO, &tLogicChannel, FALSE ))
					{
						break;
					}
				}
				
				// 加保护,源不为空时才请求关键帧
				if (!tSrcMt.IsNull())
				{
					NotifyFastUpdate( tSrcMt, byMode );
				}
				// End
			}
            break;
				
        default:
			break;
        }

		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[VmpMcuNotif]Wrong message %u(%s) received in state %u!\n", 
			   pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}	
}


/*==============================================================================
函数名    :  ProcVmpMcuStartVmpNotify
功能      :  VMP给MCU开始工作通知
算法实现  :  
参数说明  :  CServMsg &cServMsg
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130530					yanghuaizhi							
==============================================================================*/
void CMcuVcInst::ProcVmpMcuStartVmpNotify(CServMsg &cServMsg)
{
	// 获得vmpid
	u8 byVmpId = cServMsg.GetSrcSsnId();
	if (!IsValidVmpId(byVmpId))
	{
		return;
	}

    TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	TPeriEqpStatus tPeriEqpStatus;
	g_cMcuVcApp.GetPeriEqpStatus(byVmpId , &tPeriEqpStatus);
	TVMPParam_25Mem tPeriVmpParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();
	TVMPParam_25Mem tConfVMPParam; //开启时会议合成信息为空

	// vmp处理中对下级单回传新成员执行OnMMcuSetIn
	OnMMcuSetInForVmp(tConfVMPParam, tPeriVmpParam);

	//清除定时
	// 用于停指定定时器
	u8 byVmpIdx = byVmpId - VMPID_MIN;
	KillTimer( MCUVC_VMP_WAITVMPRSP_TIMER + byVmpIdx);
	if (!tVmpEqp.IsNull() &&
		tPeriEqpStatus.GetConfIdx() == m_byConfIdx &&
		(TVmpStatus::RESERVE == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState
		 || TVmpStatus::WAIT_START == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState))//主备考虑，RESERVE时也执行
	{
		TVMPParam_25Mem tVMPParam;
		tVMPParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();
		//同步外设复合状态
		tVMPParam.SetVMPMode( tVMPParam.IsVMPAuto() ? CONF_VMPMODE_AUTO : CONF_VMPMODE_CTRL );
		tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(tVMPParam);
		tPeriEqpStatus.m_tStatus.tVmp.m_byUseState = TVmpStatus::START;
		g_cMcuVcApp.SetPeriEqpStatus( tVmpEqp.GetEqpId(), &tPeriEqpStatus );

		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[ProcVmpMcuNotif]Tick:%d,ev VMP_MCU_STARTVIDMIX_NOTIF,vmp(%d)tVMPParam is",
			OspTickGet(), tVmpEqp.GetEqpId());
		tVMPParam.Print(LOG_LVL_KEYSTATUS);
		//开始交换数据 
		ChangeVmpSwitch(tVmpEqp.GetEqpId());

		// xliang [12/22/2008] 批量轮询定时
		if (m_tConf.m_tStatus.m_tVMPParam.IsVMPBatchPoll() 
			//! 
			)
		{
			u32 dwTimerT = m_tVmpBatchPollInfo.GetFirstPollT();
			
			if(dwTimerT < VMP_BATCHPOLL_TMIN)
			{
				dwTimerT = VMP_BATCHPOLL_TMIN;
			}
			else if(dwTimerT > VMP_BATCHPOLL_TMAX)
			{
				dwTimerT = VMP_BATCHPOLL_TMAX;
			}
			
			SetTimer(MCUVC_VMPBATCHPOLL_TIMER,dwTimerT);
			
		}
		
		//通知主席及所有会控
		tVMPParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
		cServMsg.SetMsgBody( (u8*)&tVMPParam, sizeof(TVMPParam) );
		SendMsgToAllMcs( MCU_MCS_STARTVMP_NOTIF, cServMsg );

		//vmp掉线备份或掉线再上线时,开启vmp后,需恢复vmp单通道轮询
		if (m_tVmpPollParam.GetPollState() != POLL_STATE_NONE)
		{
			// 从轮询暂停处重新开始
			m_tVmpPollParam.SpecPollPos( m_tVmpPollParam.GetCurrentIdx() );
			// 设置Timer,继续轮询
			SetTimer(MCUVC_VMPPOLLING_CHANGE_TIMER, 10);
		}

		if( HasJoinedChairman() )
		{
			SendMsgToMt( m_tConf.GetChairman().GetMtId(), MCU_MT_STARTVMP_NOTIF, cServMsg );
		}

		m_tConfInStatus.SetVmpNotify(TRUE);     
		if ( m_tConf.m_tStatus.GetRollCallMode() == ROLLCALL_MODE_VMP )
		{
			LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_EQP,"[ProcVmpMcuNotif]Recover Rollcall finish Mark!\n");
			SetLastMultiSpyRollCallFinish(TRUE);
		}

		//FastUpdate to Vmp
		NotifyFastUpdate(tVmpEqp, 0);
		u8 byVmpSubType = tPeriEqpStatus.m_tStatus.tVmp.m_bySubType;
		u8 byMpuBoardVer = tPeriEqpStatus.m_tStatus.tVmp.m_byBoardVer;
		if ((MPU_SVMP == byVmpSubType && MPU_BOARD_B256 == byMpuBoardVer)
			|| VMP_8KE == byVmpSubType || VMP_8KH == byVmpSubType)
		{
			for (u8 byTmpIdx=1; byTmpIdx<MAXNUM_MPU_OUTCHNNL; byTmpIdx++)
			{
				NotifyFastUpdate(tVmpEqp, byTmpIdx);
			}
		}// MPU2时,按照后适配个数请求关键帧
		else if (MPU2_VMP_BASIC == byVmpSubType || MPU2_VMP_ENHACED == byVmpSubType || VMP_8KI == byVmpSubType)
		{
			TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
			for (u8 byTmpIdx=1; byTmpIdx<tVMPOutParam.GetVmpOutCount(); byTmpIdx++)
			{
				NotifyFastUpdate(tVmpEqp, byTmpIdx);
			}
		}

		//n+1备份更新vmp信息
		if (MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
		{
			ProcNPlusVmpUpdate();
		}

		// 20120613 yhz 针对模版开启的自动vmp,会先开启vmp(无成员),等终端上线后再调整vmp.
		// 开启vmp时,vmp外设可能响应较慢,若所有终端都上线之后mcu才收到vmp发来的VSTARTVIDMIX_NOTIF,
		// 由于再无终端上线,不会再调整vmp,导致已上线的终端未加入vmp,此处追加一次判断,
		// 若是模版开启的自动vmp,收到VSTARTVIDMIX_NOTIF时,在线终端不为0,但vmpparam成员为0,需重调一次vmp
		TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
		if (IsDynamicVmp(byVmpId) &&
			(( m_tConf.GetConfSource() != VCS_CONF &&
			   tConfAttrb.IsHasVmpModule() && 
			   !m_tConfInStatus.IsVmpModuleUsed() &&
			   byVmpId == m_tModuleVmpEqp.GetEqpId())
			||
			(
				g_cMcuVcApp.NPlusIsVmpOccupyByConf (byVmpId,m_byConfIdx)
			   && m_byCreateBy == CONF_CREATE_NPLUS
			))
		   )
		{
			//与会终端不为0,但vmp成员为0时,再调整1次vmp
			if (0 < m_tConfAllMtInfo.GetLocalJoinedMtNum() &&
				0 == tVMPParam.GetVMPMemberNum())
			{
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ProcVmpMcuNotif]LocalJoinedMtNum is %d, VmpParamMtNum is %d, AdjustVmpParam.\n",
					m_tConfAllMtInfo.GetLocalJoinedMtNum(), tVMPParam.GetVMPMemberNum());
				AdjustVmpParam(byVmpId, &tVMPParam);
			}
		}
	}
	else
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcVmpMcuNotif]vmp(%d) Recv VMP_MCU_STARTVIDMIX_NOTIF in wrong state\n", byVmpId);
	}

	return;
}

/*==============================================================================
函数名    :  ProcVmpConnectedNotify
功能      :  VMP上线通知
算法实现  :  
参数说明  :  CServMsg &cServMsg
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130530					yanghuaizhi							
==============================================================================*/
void CMcuVcInst::ProcVmpConnectedNotify(CServMsg &cServMsg)
{
	TEqp tEqp;
    TPeriEqpRegReq tRegReq;
	tRegReq = *(TPeriEqpRegReq *)cServMsg.GetMsgBody();
	tEqp.SetMcuEqp((u8)tRegReq.GetMcuId(), tRegReq.GetEqpId(), tRegReq.GetEqpType());
	
	TPeriEqpStatus tPeriEqpStatus;
	TVMPParam_25Mem tPeriVmpParam;
	TVMPParam_25Mem tVMPParam;
	//只有广播vmp支持上线恢复，m_tVmpEqp即是广播vmp
	g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId() , &tPeriEqpStatus);
	if (m_tVmpEqp.GetMtId() != tEqp.GetMtId() ||
		m_tVmpEqp.GetMcuId() != tEqp.GetMcuId() ||
		m_tVmpEqp.GetType() != tEqp.GetType())
	{
		if (tPeriEqpStatus.GetConfIdx() == m_byConfIdx)
		{
			//清空此次上线的tEqp的PeriEqpStatus信息，ConfIdx和VMPParam
			tPeriEqpStatus.SetConfIdx(0);
			memset(&tPeriVmpParam, 0, sizeof(tPeriVmpParam));
			tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(tPeriVmpParam);
			g_cMcuVcApp.SetPeriEqpStatus(tEqp.GetEqpId(), &tPeriEqpStatus);
		}
		return;
	}
	
	//lukunpeng 2010/07/29 由于此时是vmp恢复，需要先清空之前conf中保存的vmpparam。
	g_cMcuVcApp.SetConfVmpParam(m_tVmpEqp, tVMPParam);
	g_cMcuVcApp.SetLastVmpParam(m_tVmpEqp, tVMPParam);
	
	//设置状态
	tVMPParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();
	//vmp掉线再上线后,不再恢复主席选看vmp,因为可能主席已变,或已选看别的终端
	tVMPParam.SetVMPSeeByChairman(FALSE);
	
	//[2011/09/27/zhangli]Bug00061885把外设状态清除，主动清除mcs侧保存的数据，并且重启vmp用到的不一定是上线的vmp
	//[2011/11/03/zhangli]只清空成员参数
	TVMPParam tNullVMPParam;
	memset(&tNullVMPParam, 0, sizeof(TVMPParam));
	tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(tNullVMPParam);
	
	g_cMcuVcApp.SetPeriEqpStatus(m_tVmpEqp.GetEqpId(), &tPeriEqpStatus);
	cServMsg.SetMsgBody((u8*)&tPeriEqpStatus, sizeof(TPeriEqpStatus));
	SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
	
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[Vmp Connected] tVMPParam is follows:\n");
	tVMPParam.Print();
	
	// 获得当前vmp单通道轮询信息,开启vmp时会清空轮询状态
	u8 byVmpPollState = m_tVmpPollParam.GetPollState();
	TMtPollParam tVmpPollParam = m_tVmpPollParam.GetMtPollParam();
	
	cServMsg.SetEventId(MCS_MCU_STARTVMP_REQ);
	cServMsg.SetEqpId(tEqp.GetEqpId());//开启时指定vmpid
	cServMsg.SetMsgBody((u8 *)&tVMPParam, sizeof(tVMPParam));
	VmpCommonReq(cServMsg);
	
	// 开启合成时会清除vmp单通道轮询状态,此处重设参数
	if (POLL_STATE_NONE != byVmpPollState)
	{
		// 此处只重设轮询参数,因m_tconf中vmpparam信息还未更新,不做轮询恢复
		// 统一在收到vmpstartnotify后做恢复轮询处理
		m_tVmpPollParam.SetPollState(byVmpPollState);
		m_tVmpPollParam.SetMtPollParam(tVmpPollParam);
	}

	return;
}

/*==============================================================================
函数名    :  ProcVmpDisconnectedNotify
功能      :  VMP掉线通知
算法实现  :  
参数说明  :  CServMsg &cServMsg
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130530					yanghuaizhi							
==============================================================================*/
void CMcuVcInst::ProcVmpDisconnectedNotify(CServMsg &cServMsg)
{
	TEqp tEqp;
	tEqp = *(TEqp *)cServMsg.GetMsgBody();
	TVMPParam_25Mem tVMPParam;

	// 该外设不属于该会议，不做处理
	if (!IsVmpIdInVmpList(tEqp.GetEqpId()))
	{
		return;
	}

	BOOL32 bIsBrdVmp = TRUE;
	if (m_tVmpEqp.GetMtId() != tEqp.GetMtId() ||
		m_tVmpEqp.GetMcuId() != tEqp.GetMcuId() ||
		m_tVmpEqp.GetType() != tEqp.GetType())
	{
		bIsBrdVmp = FALSE;
	}

	// [4/25/2011 xliang] 点名过程中，VMP or mixer 断链，不迁移，不恢复
	BOOL32 bDisconnectInRoll = FALSE;		
	//zbq[12/05/2007] 停对应模式下的点名
	if ( ROLLCALL_MODE_VMP == m_tConf.m_tStatus.GetRollCallMode() )
	{
		CServMsg cMsg;
		RollCallStop(cMsg);
		bDisconnectInRoll = TRUE;
		m_tConfInStatus.SetVmpMixerDiscInRoll(TRUE);
	}
	else if (m_tConfInStatus.IsVmpMixerDiscInRoll())
	{
		bDisconnectInRoll = TRUE;
		m_tConfInStatus.SetVmpMixerDiscInRoll(FALSE);
	}

	// 只备份广播vmp，非广播vmp不备份，不存在主席终端选看vmp场景
	TMt tLastVmpEqp = tEqp;

	g_cMcuVcApp.SetVMPMode(tEqp, CONF_VMPMODE_NONE );	// 移至ChangeVmpSwitch之前
	
	//停止交换数据
	ChangeVmpSwitch(tEqp.GetEqpId(), VMP_STATE_STOP );
	
	// [12/18/2009 xliang] 把该外设置成invalid
	g_cMcuVcApp.SetPeriEqpConnected( tEqp.GetEqpId(), FALSE, FALSE );
	
	TPeriEqpStatus tPeriEqpStatus;
	g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId() , &tPeriEqpStatus);
	tVMPParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();	//先前的合成参数
	TVMPParam_25Mem tPeriVmpParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();	
	
	u8 byIdx = 0;
	u8 byNewVmpId = 0;
	u16 wError = 0;
	TMt tMcu;

	//找剩余空闲可用的VMP资源
	// VCS会议不支持VMP迁移
	if ( VCS_CONF == m_tConf.GetConfSource() 
		|| bDisconnectInRoll
		|| !bIsBrdVmp	//仅做广播vmp备份，非广播vmp不备份
		|| !IsMCUSupportVmpStyle(tVMPParam.GetVMPStyle(), byNewVmpId, EQP_TYPE_VMP, wError) //找合适的vmp
		|| !IsVMPSupportVmpStyle(tVMPParam.GetVMPStyle(), byNewVmpId, wError) //可能不支持需要的风格
		|| !IsVmpSupportBackup(tVMPParam, tEqp.GetEqpId(), byNewVmpId))//找到vmp时,如果新vmp不能备份旧vmp,同样不做迁移
	{
		//没找到的处理

		//zjj20091216 这里只把状态置为空,不要把成员清除，因为如果这个vmp再上线时可以再恢复(除非是vcs会议就不再恢复,下面条件里把m_tVmpEqp置空了)
		tPeriEqpStatus.m_tStatus.tVmp.m_byUseState = TVmpStatus::IDLE;
		tPeriEqpStatus.SetConfIdx(0);
		tPeriVmpParam.SetVMPMode( CONF_VMPMODE_NONE );

		/*20110808 zjl 点名vmp模式下，如果vmp断链再上线，不恢复vmp(依靠m_tVmpEqp.SetNull()过滤)，
						这里将成员清空，防止vmp上线后，mcu将外设状态上报界面时成员状态仍然显示合成状态*/
		if(bDisconnectInRoll)
		{
			u8 byVmpMaxMemNum = tPeriVmpParam.GetMaxMemberNum();
			for (u8 byMemIdx = 0; byMemIdx < byVmpMaxMemNum; byMemIdx++)
			{
				tPeriVmpParam.ClearVmpMember(byMemIdx);
			}
		}
		
		tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(tPeriVmpParam);
		g_cMcuVcApp.SetPeriEqpStatus( tEqp.GetEqpId() , &tPeriEqpStatus );
		
		//20101130_tzy Bug00041616两级级联模式，在点名双画面或自动多画面模式下，调度任意终端，重启mmp恢复后，被调度的终端未剔除混音器
		TVMPParam_25Mem tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(tEqp);
		for (u8 byVMPMemIdx = 0; byVMPMemIdx < tConfVmpParam.GetMaxMemberNum(); byVMPMemIdx++)
		{
			TMt tMt = (TMt)(*tConfVmpParam.GetVmpMember(byVMPMemIdx));
			if (!tMt.IsNull() && !tMt.IsLocal() && 
				(!m_cVCSConfStatus.GetMtInTvWallCanMixing() ||
				(IsMtNotInOtherTvWallChnnl(tMt,0,0) && IsMtNotInOtherHduChnnl(tMt,0,0) &&
					!(tMt == m_tConf.GetChairman()) )
					))			
			{
				CServMsg cMsg;
				tMcu.SetNull();
				tMcu.SetMcu(0);
				tMcu.SetMcuIdx( tMt.GetMcuIdx() );
				cMsg.SetMsgBody((u8*)&tMcu, sizeof(TMcu));
				cMsg.CatMsgBody((u8*)&tMt, sizeof(TMt));
				u8 bNotForceRemove = 0;
				cMsg.CatMsgBody((u8*)&bNotForceRemove, sizeof(bNotForceRemove));
				OnAddRemoveMixToSMcu(&cMsg, FALSE,TRUE);			
			}
		}

		//对于VCS会议，若在画面合成状态则恢复到单方调度
		// 若在组呼画面合成状态则恢复到发言人模式
		if (VCS_CONF == m_tConf.GetConfSource() &&
			(VCS_MULVMP_MODE == m_cVCSConfStatus.GetCurVCMode() ||
			VCS_GROUPVMP_MODE == m_cVCSConfStatus.GetCurVCMode() ||
			VCS_GROUPROLLCALL_MODE == m_cVCSConfStatus.GetCurVCMode())
			)
		{
			// fxh 释放画面合成器,该合成器重启后不自动启动画面合成
			g_cMcuVcApp.ClearVmpInfo(m_tVmpEqp);
			m_tVmpEqp.SetNull();

			if (VCS_MULVMP_MODE == m_cVCSConfStatus.GetCurVCMode())
			{
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP, "Vmp disced, restore conf to single\n");
				RestoreVCConf(VCS_SINGLE_MODE);
			}
			else if (VCS_GROUPVMP_MODE == m_cVCSConfStatus.GetCurVCMode() ||
				VCS_GROUPROLLCALL_MODE == m_cVCSConfStatus.GetCurVCMode()
				)
			{
				//20110303_tzy bug48252上面虽然做过将退出画面合成器的终端，但当时并未将当前调度终端清空
				//导致未踢出下级混音器，此时将当前调度终端清空，并重新将老调度终端踢出下级混音器。
				TMt tNull;
				tNull.SetNull();
				TMt tCurVCMT = m_cVCSConfStatus.GetCurVCMT();
				m_cVCSConfStatus.SetCurVCMT( tNull );
				if (!tCurVCMT.IsNull() && !tCurVCMT.IsLocal() && 
					(
						!m_cVCSConfStatus.GetMtInTvWallCanMixing() 
						||
						(IsMtNotInOtherTvWallChnnl(tCurVCMT,0,0) && IsMtNotInOtherHduChnnl(tCurVCMT,0,0) )
					)
					)			
				{
					CServMsg cMsg;
					tMcu.SetNull();
					tMcu.SetMcu(0);
					tMcu.SetMcuIdx( tCurVCMT.GetMcuIdx() );
					cMsg.SetMsgBody((u8*)&tMcu, sizeof(TMcu));
					cMsg.CatMsgBody((u8*)&tCurVCMT, sizeof(TMt));
					u8 bNotForceRemove = 0;
					cMsg.CatMsgBody((u8*)&bNotForceRemove, sizeof(bNotForceRemove));
					OnAddRemoveMixToSMcu(&cMsg, FALSE,FALSE);
				}
				//zjj20091102 不再切换回发言人模式而是切换到主席模式
				RestoreVCConf(VCS_GROUPCHAIRMAN_MODE);
			}
		}

		// [7/21/2011 liuxu] hdu功能封装
		FindConfHduHduChnnlAndStop(&tLastVmpEqp, TW_MEMBERTYPE_SWITCHVMP, TRUE);

		// vmp单通道轮询处理,掉线未找到合适vmp备份时,需等待vmp上线继续合成,
		// 此时先将界面状态刷为未轮询,等上线后,再将界面恢复
		KillTimer(MCUVC_VMPPOLLING_CHANGE_TIMER);
		if (POLL_STATE_NONE != m_tVmpPollParam.GetPollState())
		{
			CServMsg cMsg;
			TVmpPollParam tTmpVmpPollParam = m_tVmpPollParam;
			// 停轮询清轮询状态
			tTmpVmpPollParam.SetPollState(POLL_STATE_NONE);
			tTmpVmpPollParam.SetMediaMode(MODE_NONE);
			cMsg.SetMsgBody((u8 *)&tTmpVmpPollParam, sizeof(tTmpVmpPollParam));
			SendMsgToAllMcs(MCU_MCS_VMPPOLLSTATE_NOTIF, cMsg);
		}
		
		//通知主席及所有会控 
		cServMsg.SetMsgBody();
		cServMsg.SetEqpId(tEqp.GetEqpId());
		SendMsgToAllMcs( MCU_MCS_STOPVMP_NOTIF, cServMsg );//停止时不发MCU_MCS_VMPPARAM_NOTIF，停止时消息体内容为空
		if( HasJoinedChairman() )
		{
			SendMsgToMt( m_tConf.GetChairman().GetMtId(), MCU_MT_STOPVMP_NOTIF, cServMsg );
		}

		if (bDisconnectInRoll)
		{
			g_cMcuVcApp.ClearVmpInfo(m_tVmpEqp);
			m_tVmpEqp.SetNull();
		}

		// 将此外设从会议占用vmp索引中清除
		RemoveVmpIdFromVmpList(tEqp.GetEqpId());
		// 清除该vmp会议中的相关信息
		g_cMcuVcApp.ClearVmpInfo(tEqp);
		
		//外设状态上报会控
		cServMsg.SetMsgBody( ( u8 * )&tPeriEqpStatus, sizeof( tPeriEqpStatus ) );
		SendMsgToAllMcs( MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg );

	}
	else
	{
		//清空现在正在使用的vmp的状态
		tPeriEqpStatus.m_tStatus.tVmp.m_byUseState = TVmpStatus::IDLE;
		tPeriVmpParam.SetVMPMode(CONF_VMPMODE_NONE);
		
		for( byIdx =0;byIdx < MAXNUM_VMP_MEMBER;byIdx++ )
		{
			tPeriVmpParam.ClearVmpMember( byIdx );
		}					
		tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(tPeriVmpParam);
		tPeriEqpStatus.SetConfIdx( 0 );
		g_cMcuVcApp.SetPeriEqpStatus( tEqp.GetEqpId() , &tPeriEqpStatus );
		// 将此外设从会议占用vmp索引中清除
		RemoveVmpIdFromVmpList(tEqp.GetEqpId());
		g_cMcuVcApp.ClearVmpInfo(tEqp);
		//外设状态上报会控
		cServMsg.SetMsgBody( ( u8 * )&tPeriEqpStatus, sizeof( tPeriEqpStatus ) );
		SendMsgToAllMcs( MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg );
		//通知界面停止旧合成准备开启新合成
		cServMsg.SetMsgBody();
		cServMsg.SetEqpId(tEqp.GetEqpId());
		SendMsgToAllMcs( MCU_MCS_STOPVMP_NOTIF, cServMsg );//停止时不发MCU_MCS_VMPPARAM_NOTIF,停止消息体内容为空

		// 获得当前vmp单通道轮询信息,开启vmp时会清空轮询状态
		u8 byVmpPollState = m_tVmpPollParam.GetPollState();
		TMtPollParam tVmpPollParam = m_tVmpPollParam.GetMtPollParam();

		//找到的处理
		cServMsg.SetEqpId(byNewVmpId);
		cServMsg.SetEventId(MCS_MCU_STARTVMP_REQ);
		cServMsg.SetMsgBody( (u8 *)&tVMPParam, 	sizeof(tVMPParam) );
		
		VmpCommonReq(cServMsg);
		
		// 开启合成时会清除vmp单通道轮询状态,此处重设参数
		if (POLL_STATE_NONE != byVmpPollState)
		{
			// 此处只重设轮询参数,因m_tconf中vmpparam信息还未更新,不做轮询恢复
			// 统一在收到vmpstartnotify后做恢复轮询处理
			m_tVmpPollParam.SetPollState(byVmpPollState);
			m_tVmpPollParam.SetMtPollParam(tVmpPollParam);
		}

		// [7/21/2011 liuxu] Hdu功能重置
		TEqp tNewVmpEqp = g_cMcuVcApp.GetEqp(byNewVmpId);
		FindConfHduChnnlAndReplace( &tNewVmpEqp, &tLastVmpEqp, TW_MEMBERTYPE_NULL, MODE_VIDEO);
	}

	ConfStatusChange();	// xliang [5/4/2009] 会议状态上报

}

/*------------------------------------------------------------------*/
/*                          VMP TVWall                              */
/*------------------------------------------------------------------*/

/*====================================================================
    函数名      ：SetVmpChnnl
    功能        ：设置画面合成器通道 
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/10/08    4.0         libo          创建
====================================================================*/
void CMcuVcInst::SetVmpTwChnnl(TMt tMt, u8 byChnnl, u8 byMemberType, BOOL32 bMsgMcs)
{
    CServMsg cServMsg;

    TMt tLocalMt = GetLocalMtFromOtherMcuMt(tMt);

    //开始交换码流
    StartSwitchToPeriEqp(tLocalMt, 0, m_tVmpTwEqp.GetEqpId(),
                         byChnnl, MODE_VIDEO, SWITCH_MODE_SELECT);

    if (!tMt.IsLocal())
    {
        OnMMcuSetIn(tMt, 0, SWITCH_MODE_SELECT);
    }

    //改变状态
    TVMPMember tVMPMember;
    tVMPMember.SetMemberTMt(tMt);
    tVMPMember.SetMemberType(byMemberType);
    m_tConf.m_tStatus.m_tVmpTwParam.SetVmpMember(byChnnl, tVMPMember);

    //通知会控
    if (bMsgMcs)
    {
        cServMsg.SetMsgBody((u8*)&m_tConf.m_tStatus.m_tVmpTwParam, sizeof(TVMPParam));
        SendMsgToAllMcs(MCU_MCS_VMPTWPARAM_NOTIF, cServMsg);

        SendConfInfoToChairMt();	
    }
	
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
    if (tConfAttrb.IsResendLosePack())
    {
		BuildRtcpSwitchForSrcToDst(m_tVmpEqp, tMt, MODE_VIDEO, byChnnl);
    }
}

/*====================================================================
    函数名      ：ChangeVmpTwSwitch
    功能        ：改变复合电视墙交换参数
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt * ptNewSrc, 源,NULL为所有通道
                  u8 byState 是否是停止交换
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/10/08    4.0         libo          创建
	11/07/29	4.6			彭国锋		  移除参数bySrcType
====================================================================*/
void CMcuVcInst::ChangeVmpTwSwitch(u8 byState)
{

    TVMPParam tVMPParam = m_tConf.m_tStatus.GetVmpTwParam();
    u8 byMemberNum = tVMPParam.GetMaxMemberNum();

    //所有通道停止向VMP交换
    if (VMPTW_STATE_STOP == byState)
    {
        for (u8 byLoop = 0; byLoop < byMemberNum; byLoop++)
        {
            StopSwitchToPeriEqp(m_tVmpTwEqp.GetEqpId(), byLoop, FALSE, MODE_VIDEO);

			 TVMPMember tVMPMember = *(tVMPParam.GetVmpMember(byLoop));

            //Stop Resend Lose Pack
			TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
            if (tConfAttrb.IsResendLosePack())
            {                
                //把目的的Rtcp交换给源
                TLogicalChannel tLogicalChannel;
                m_ptMtTable->GetMtLogicChnnl(tVMPMember.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE);

                u32 dwDstIp = tLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
                u16 wDstPort = tLogicalChannel.GetSndMediaCtrlChannel().GetPort();

                g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwDstIp, wDstPort);
            }

			//ChangeMtVideoFormat( tVMPMember, &m_tLastVmpTwParam, FALSE );//临时方式，vmptw不支持
        }
        return;
    }

    //会控控制模式 
    TMt tMt;
    memset(&tMt, 0, sizeof(TMt));
    if (CONF_VMPTWMODE_CTRL == m_tConf.m_tStatus.GetVmpTwMode())
    {
        for(u8 byLoop = 0; byLoop < byMemberNum; byLoop++)
        {
            TVMPMember tVMPMember = *tVMPParam.GetVmpMember(byLoop);
            // 顾振华 [5/23/2006] 参考Vmp部分,增加 MemberType的判断
            if (0 == tVMPMember.GetMemberType() && tVMPMember.IsNull())
            {
                StopSwitchToPeriEqp(m_tVmpTwEqp.GetEqpId(), byLoop, FALSE, MODE_VIDEO);
            }
            else
            {
                switch(tVMPMember.GetMemberType()) 
                {
                case VMPTW_MEMBERTYPE_MCSSPEC:
                    if (m_tConfAllMtInfo.MtJoinedConf(tVMPMember.GetMtId()))
                    {
                        SetVmpTwChnnl((TMt)tVMPMember, byLoop, VMPTW_MEMBERTYPE_MCSSPEC);

						//ChangeMtVideoFormat( tVMPMember, &tVMPParam );临时方式，vmptw不支持
                    }
                    break;

                case VMPTW_MEMBERTYPE_SPEAKER://注意改变发言人时改变交换
                    // 顾振华 [5/23/2006] 只允许终端进入通道，不允许放像设备
					if( HasJoinedSpeaker()  && GetLocalSpeaker().GetType() != TYPE_MCUPERI )
					{
						SetVmpTwChnnl( GetLocalSpeaker(), byLoop, VMPTW_MEMBERTYPE_SPEAKER );

						//ChangeMtVideoFormat( tVMPMember, &tVMPParam );临时方式，vmptw不支持
					}
					else
					{
						StopSwitchToPeriEqp(m_tVmpTwEqp.GetEqpId(), byLoop, FALSE, MODE_VIDEO);
						
						tMt.SetNull();
						tVMPMember.SetMemberTMt(tMt);
						tVMPMember.SetMemberType(VMPTW_MEMBERTYPE_SPEAKER);
						m_tConf.m_tStatus.m_tVmpTwParam.SetVmpMember(byLoop, tVMPMember);
					}
					break;

				case VMPTW_MEMBERTYPE_CHAIRMAN://注意改变主席时改变交换
					if( HasJoinedChairman() )
					{
						SetVmpTwChnnl( m_tConf.GetChairman(), byLoop, VMPTW_MEMBERTYPE_CHAIRMAN );

						//ChangeMtVideoFormat( tVMPMember, &tVMPParam );临时方式，vmptw不支持
					}
					else
					{
						StopSwitchToPeriEqp( m_tVmpTwEqp.GetEqpId(), byLoop, FALSE, MODE_VIDEO );
						tMt.SetNull();
						tVMPMember.SetMemberTMt( tMt );
						tVMPMember.SetMemberType( VMPTW_MEMBERTYPE_CHAIRMAN );
						m_tConf.m_tStatus.m_tVmpTwParam.SetVmpMember( byLoop, tVMPMember);
					}
					break;

				case VMPTW_MEMBERTYPE_POLL://注意改变轮询广播源时改变交换
					if( m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_VIDEO ||
						m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_SPEAKER)
					{	
						tMt = (TMt)m_tConf.m_tStatus.GetMtPollParam();
						
						SetVmpTwChnnl( tMt, byLoop, VMPTW_MEMBERTYPE_POLL );

						//ChangeMtVideoFormat( tVMPMember, &tVMPParam );临时方式，vmptw不支持
					}
					else
					{
						StopSwitchToPeriEqp( m_tVmpTwEqp.GetEqpId(), byLoop, FALSE, MODE_VIDEO );

						tMt.SetNull();
						tVMPMember.SetMemberTMt( tMt );
						tVMPMember.SetMemberType( VMPTW_MEMBERTYPE_POLL );
						m_tConf.m_tStatus.m_tVmpTwParam.SetVmpMember( byLoop, tVMPMember);
					}
					break;

                default:
                    break;
                }
            }
        }
    }
	
	//更改合成分辨率参数
	if (VMP_STATE_CHANGE == byState)
    {
        if ( CONF_VMPMODE_NONE != m_tLastVmpTwParam.GetVMPMode() )
        {
            for( s32 nIndex = 0; nIndex < m_tLastVmpTwParam.GetMaxMemberNum(); nIndex ++ )
			{
				TMt tVMPMemberOld = (TMt)(*m_tLastVmpTwParam.GetVmpMember(nIndex));
            
				//对删除了的合成成员恢复其发送分辨率
				if ( !m_tConf.m_tStatus.m_tVmpTwParam.IsMtInMember(tVMPMemberOld) &&
					 m_tConfAllMtInfo.MtJoinedConf(tVMPMemberOld.GetMtId()) ) 
				{
					//ChangeMtVideoFormat( tVMPMemberOld, &m_tLastVmpTwParam, FALSE );临时方式，vmptw不支持
				}
			}                          
        }
    }

	//保存本次画面合成参数，用于动态分辨率恢复
	memcpy(&m_tLastVmpTwParam, &m_tConf.m_tStatus.m_tVmpTwParam, sizeof(TVMPParam));
	
    if(g_bPrintEqpMsg)
    {
        m_tConf.m_tStatus.m_tVmpTwParam.Print();
    }

	CServMsg cServMsg;
	cServMsg.SetMsgBody((u8 *)&m_tConf.m_tStatus.m_tVmpTwParam, sizeof(TVMPParam));
	SendMsgToAllMcs(MCU_MCS_VMPTWPARAM_NOTIF, cServMsg);

    SendConfInfoToChairMt();

	return;
}


/*====================================================================
    函数名      ：ChangeVmpTwChannelParam
    功能        ：改变会议画面合成方式
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/10/27    4.0         libo          创建
	2011-1-12               zhouyiliang    c风格和const修改
====================================================================*/
void CMcuVcInst::ChangeVmpTwChannelParam(const TMt * ptNewSrc, const u8& byMemberType)
{    
    //TVMPMember tTmpVmpMember;
    TVMPParam  tVmpTwParam;    
    BOOL32 bVmpTwParamChged = FALSE;
    tVmpTwParam = m_tConf.m_tStatus.GetVmpTwParam();
    u8 byMaxMemberNum = tVmpTwParam.GetMaxMemberNum();
	
    for (u8 byLoop = 0; byLoop < byMaxMemberNum; byLoop++)
    {
        if (tVmpTwParam.GetVmpMember(byLoop)->GetMemberType() == byMemberType)
        {
            StopSwitchToPeriEqp(m_tVmpTwEqp.GetEqpId(), byLoop, TRUE, MODE_VIDEO);
            tVmpTwParam.ClearVmpMember(byLoop);
			TMt  tMt;
			tMt.SetNull();
            // 顾振华 [5/23/2006] 只允许终端进入通道，不允许放像设备
            if (ptNewSrc == NULL || ptNewSrc->GetType() == TYPE_MCUPERI)
            {
                tMt.SetNull();
            }
            else
            {
                tMt = *ptNewSrc;
            }

			TVMPMember tVmpMember;
            tVmpMember.SetMemberTMt(tMt);
            tVmpMember.SetMemberType(byMemberType);
            tVmpTwParam.SetVmpMember(byLoop, tVmpMember);
			
            bVmpTwParamChged = TRUE;
        }
    }

    // zbq [06/05/2007] 通道参数发生了实际更改才修改通道参数
    if ( bVmpTwParamChged )
    {
        m_tConf.m_tStatus.SetVmpTwParam(tVmpTwParam);
        
        TPeriEqpStatus tPeriEqpStatus;
        g_cMcuVcApp.GetPeriEqpStatus(m_tVmpTwEqp.GetEqpId() , &tPeriEqpStatus);  
        tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(m_tConf.m_tStatus.GetVmpTwParam());
        g_cMcuVcApp.SetPeriEqpStatus(m_tVmpTwEqp.GetEqpId() , &tPeriEqpStatus);  
        
        ChangeVmpTwParam(&tVmpTwParam);
    }

    return;
}

/*====================================================================
    函数名      ：ChangeVmpTwParam
    功能        ：复合电视墙参数改变
    算法实现    ：
    引用全局变量：
    输入参数说明：TVMPParam *ptVMPParam, 复合电视墙合成参数
				  BOOL32 bStart 是否是开始画面合成
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/10/08    4.0         libo          创建
====================================================================*/
void CMcuVcInst::ChangeVmpTwParam(TVMPParam *ptVmpParam, const BOOL32& bStart)
{
	if (ptVmpParam == NULL)
	{
		return;
	}

    //设置参数
    CKDVVMPParam cVmpParam;
    memset(&cVmpParam, 0, sizeof(CKDVVMPParam));
    cVmpParam.m_byVMPStyle = ptVmpParam->GetVMPStyle();
    cVmpParam.m_byEncType = MEDIA_TYPE_H261;

    cVmpParam.m_wBitRate = htons(768);
    //CIF
    cVmpParam.m_wVideoWidth  = htons(352);
	cVmpParam.m_wVideoHeight = htons(288);
	cVmpParam.m_byMemberNum  = ptVmpParam->GetMaxMemberNum();

	for (u8 byLoop = 0; byLoop < ptVmpParam->GetMaxMemberNum(); byLoop++)
	{
		cVmpParam.m_atMtMember[byLoop].SetMember(*ptVmpParam->GetVmpMember(byLoop)) ;
		//清掉不与会终端
		if (!m_tConfAllMtInfo.MtJoinedConf(cVmpParam.m_atMtMember[byLoop].GetMtId()))
		{
			cVmpParam.m_atMtMember[byLoop].SetNull();
		}
	}

	//清掉其余通道的交换
	TVMPParam	tConfVmpParam = m_tConf.m_tStatus.GetVmpTwParam();
	for (u8 byLoop1 = ptVmpParam->GetMaxMemberNum(); byLoop1 < MAXNUM_SDVMP_MEMBER; byLoop1++)
	{
		StopSwitchToPeriEqp(m_tVmpTwEqp.GetEqpId(), byLoop1, TRUE, MODE_VIDEO);
		tConfVmpParam.ClearVmpMember(byLoop1);
	}
	m_tConf.m_tStatus.SetVmpTwParam(tConfVmpParam);

	TConfAttrb tTempConfAttrb = m_tConf.GetConfAttrb();
	u8 byNeedPrs = tTempConfAttrb.IsResendLosePack();

    //u8 byMtId = 1;
    for(u8 byIdx = 0; byIdx < ptVmpParam->GetMaxMemberNum(); byIdx++)
	{
        BOOL32 bRet = FALSE;
        TLogicalChannel tChnnl;

		TVMPMember tVMPMember = *ptVmpParam->GetVmpMember(byIdx);
		if (tVMPMember.GetMtId() != 0)
		{
            bRet = m_ptMtTable->GetMtLogicChnnl(tVMPMember.GetMtId(), LOGCHL_VIDEO, &tChnnl, FALSE);
            if (TRUE == bRet)
            {
                cVmpParam.m_tVideoEncrypt[byIdx] = tChnnl.GetMediaEncrypt();
                cVmpParam.m_tDoublePayload[byIdx].SetRealPayLoad(tChnnl.GetChannelType());
	            cVmpParam.m_tDoublePayload[byIdx].SetActivePayload(tChnnl.GetActivePayload());
            }
            //byMtId++;   
		}      
	}

	CServMsg cServMsg;
	cServMsg.SetConfId(m_tConf.GetConfId());
	cServMsg.SetMsgBody((u8*)&cVmpParam, sizeof(cVmpParam));
	cServMsg.CatMsgBody((u8 *)&byNeedPrs, sizeof(byNeedPrs));

	//发消息
	if (bStart)
	{
		// MCU前向纠错, zgc, 2007-09-27
		TCapSupportEx tCapSupportEx = m_tConf.GetCapSupportEx();
		cServMsg.CatMsgBody((u8*)&tCapSupportEx, sizeof(tCapSupportEx));

		//SetTimer(MCU_VMP_WAITVMPRSP_TIMER, 6*1000);
		SendMsgToEqp(m_tVmpTwEqp.GetEqpId(), MCU_VMPTW_STARTVIDMIX_REQ, cServMsg);
	}
	else
	{
		SendMsgToEqp(m_tVmpTwEqp.GetEqpId(), MCU_VMPTW_CHANGEVIDMIXPARAM_REQ, cServMsg);
	}
}


/*====================================================================
    函数名      ：ProcVmpTwMcuRsp
    功能        ：复合电视墙消息处理
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/10/08    4.0         libo          创建
====================================================================*/
void CMcuVcInst::ProcVmpTwMcuRsp(const CMessage * pcMsg)
{
    if (STATE_ONGOING != CurState())
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "Wrong message %u(%s) received in state %u!\n", 
                       pcMsg->event, ::OspEventDesc(pcMsg->event), CurState());
    }

    switch( pcMsg->event ) 
    {
    case VMPTW_MCU_STARTVIDMIX_ACK:       //VMPTW给MCU开始工作确认
    case VMPTW_MCU_STARTVIDMIX_NACK:      //VMPTW给MCU开始工作拒绝
    case VMPTW_MCU_STOPVIDMIX_ACK:        //VMPTW给MCU停止工作确认
    case VMPTW_MCU_STOPVIDMIX_NACK:       //VMPTW给MCU停止工作拒绝
    case VMPTW_MCU_CHANGEVIDMIXPARAM_ACK: //VMPTW给MCU改变复合参数确认
    case VMPTW_MCU_CHANGEVIDMIXPARAM_NACK://VMPTW给MCU改变复合参数拒绝			
    case VMPTW_MCU_GETVIDMIXPARAM_ACK:    //VMPTW给MCU回送复合参数确认			
    case VMPTW_MCU_GETVIDMIXPARAM_NACK:   //VMPTW给MCU回送复合参数拒绝
        break;

    default:
        break;
    }
}


/*====================================================================
    函数名      ：ProcVmpTwMcuNotif
    功能        ：处理Vmp给Mcu的通知
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/10/08    4.0         libo          创建
====================================================================*/
void CMcuVcInst::ProcVmpTwMcuNotif(const CMessage * pcMsg)
{
    if (STATE_ONGOING != CurState())
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "Wrong message %u(%s) received in state %u!\n", 
                       pcMsg->event, ::OspEventDesc(pcMsg->event), CurState());
    }

    CServMsg cServMsg(pcMsg->content, pcMsg->length);

    TVMPParam tVmpTwParam;
    memset(&tVmpTwParam, 0, sizeof(TVMPParam));

    TEqp tEqp;
    TPeriEqpStatus tPeriEqpStatus;
    TMt tSrcMt;
    u8  byChlIdx;
    TPeriEqpRegReq tRegReq;

    switch(pcMsg->event) 
    {
    case VMPTW_MCU_STARTVIDMIX_NOTIF:     //VMP给MCU开始工作通知
        //清除定时
        //KillTimer(MCU_VMP_WAITVMPRSP_TIMER);

        //设置状态			
        g_cMcuVcApp.GetPeriEqpStatus(m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus);  
        tVmpTwParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();
        tVmpTwParam.SetVMPStyle(m_tConf.m_tStatus.GetVmpTwStyle());
        m_tConf.m_tStatus.SetVmpTwParam(tVmpTwParam);
        m_tConf.m_tStatus.SetVmpTwMode(CONF_VMPTWMODE_CTRL);

        //开始交换数据 
        ChangeVmpTwSwitch();

        //同步外设复合状态
        tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(m_tConf.m_tStatus.m_tVmpTwParam);
        g_cMcuVcApp.SetPeriEqpStatus(m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus);

        //通知主席及所有会控
        cServMsg.SetMsgBody((u8*)&m_tConf.m_tStatus.m_tVmpTwParam, sizeof(TVMPParam));
        SendMsgToAllMcs(MCU_MCS_STARTVMPTW_NOTIF, cServMsg);  
        
        SendConfInfoToChairMt();

        NotifyFastUpdate(m_tVmpTwEqp, MODE_VIDEO);
        break;

    case VMPTW_MCU_STOPVIDMIX_NOTIF:      //VMP给MCU停止工作通知
        //设置状态			
        g_cMcuVcApp.GetPeriEqpStatus(m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus);
        tPeriEqpStatus.m_tStatus.tVmp.m_byUseState = TVmpStatus::IDLE;
        g_cMcuVcApp.SetPeriEqpStatus(m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus);

        m_tConf.m_tStatus.SetVmpTwMode(CONF_VMPTWMODE_NONE);

        //停止交换数据
        ChangeVmpTwSwitch(VMP_STATE_STOP);

        m_tConf.m_tStatus.SetVmpTwParam(tVmpTwParam);

        //同步外设复合状态
        tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(m_tConf.m_tStatus.m_tVmpTwParam);
        g_cMcuVcApp.SetPeriEqpStatus(m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus);

        //通知主席及所有会控
        cServMsg.SetMsgBody((u8 *)&tVmpTwParam, sizeof(TVMPParam));
        SendMsgToAllMcs(MCU_MCS_STOPVMPTW_NOTIF, cServMsg); 
        
        SendMsgToAllMcs(MCU_MCS_VMPTWPARAM_NOTIF, cServMsg);
        
        SendConfInfoToChairMt();

        // guzh [6/9/2007] 清除记录
        memcpy(&m_tLastVmpTwParam, &tVmpTwParam, sizeof(TVMPParam));
        break;

    case VMPTW_MCU_CHANGESTATUS_NOTIF:    //VMP给MCU改变复合参数通知 

        g_cMcuVcApp.GetPeriEqpStatus(m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus);
        tVmpTwParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();
        m_tConf.m_tStatus.SetVmpTwParam(tVmpTwParam);
        m_tConf.m_tStatus.SetVmpTwMode(CONF_VMPTWMODE_CTRL);

        //改变数据交换
        ChangeVmpTwSwitch( VMP_STATE_CHANGE );

        //同步外设复合状态
        tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(m_tConf.m_tStatus.m_tVmpTwParam);
        g_cMcuVcApp.SetPeriEqpStatus(m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus);        
        break;

    case MCU_VMPTWCONNECTED_NOTIF:
        tRegReq = *(TPeriEqpRegReq *)cServMsg.GetMsgBody();

        tEqp.SetMcuEqp((u8)tRegReq.GetMcuId(), tRegReq.GetEqpId(), tRegReq.GetEqpType());

        //g_cMcuVcApp.GetPeriEqpStatus(tRegReq.GetEqpId(), &tTvWallStatus);
        if (m_tVmpTwEqp.GetMtId() != tEqp.GetMtId() ||
            m_tVmpTwEqp.GetMcuId() != tEqp.GetMcuId() ||
            m_tVmpTwEqp.GetType() != tEqp.GetType())
        {
            return;
        }

        //设置状态			
        g_cMcuVcApp.GetPeriEqpStatus(m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus);  
        tVmpTwParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();

        cServMsg.SetEventId(MCS_MCU_STARTVMPTW_REQ);
        cServMsg.SetMsgBody((u8 *)&tVmpTwParam, sizeof(TVMPParam));
        VmpTwCommonReq(cServMsg);
        break;

    case MCU_VMPTWDISCONNECTED_NOTIF: //需要修改的

        tEqp = *(TEqp *)cServMsg.GetMsgBody();

        if (m_tVmpTwEqp.GetMtId() != tEqp.GetMtId() ||
            m_tVmpTwEqp.GetMcuId() != tEqp.GetMcuId() ||
            m_tVmpTwEqp.GetType() != tEqp.GetType())
        {
            return;
        }

        //停止交换数据
        ChangeVmpTwSwitch(VMP_STATE_STOP);

        //设置状态			
        g_cMcuVcApp.GetPeriEqpStatus(m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus);
        tPeriEqpStatus.m_tStatus.tVmp.m_byUseState = TVmpStatus::IDLE;
        g_cMcuVcApp.SetPeriEqpStatus(m_tVmpTwEqp.GetEqpId(), &tPeriEqpStatus);
        //m_tConf.m_tStatus.SetVmpTwParam(tVmpTwParam);
        m_tConf.m_tStatus.SetVmpTwMode(CONF_VMPTWMODE_NONE);

        //通知主席及所有会控 
        //cServMsg.SetMsgBody((u8*)&tVmpTwParam, sizeof(TVMPParam));
        cServMsg.SetMsgBody();
        SendMsgToAllMcs(MCU_MCS_STOPVMPTW_NOTIF, cServMsg);   
        
        memset(&tVmpTwParam, 0, sizeof(TVMPParam));
        tVmpTwParam.SetVMPMode(CONF_VMPTWMODE_NONE);
        cServMsg.SetMsgBody((u8*)&tVmpTwParam, sizeof(TVMPParam));
        SendMsgToAllMcs( MCU_MCS_VMPTWPARAM_NOTIF, cServMsg );
        
        SendConfInfoToChairMt();
        break;

    case VMPTW_MCU_NEEDIFRAME_CMD:

        byChlIdx = cServMsg.GetChnIndex();
        tVmpTwParam = m_tConf.m_tStatus.m_tVmpTwParam;
        tSrcMt = (TMt)(*tVmpTwParam.GetVmpMember(byChlIdx));
        //必须是终端
        NotifyMtFastUpdate(tSrcMt.GetMtId(), MODE_VIDEO);
        break;

    default:
        break;
    }
	
}

/*------------------------------------------------------------------*/
/*                           TV Wall                                */
/*------------------------------------------------------------------*/

/*====================================================================
    函数名      ：ChangeTvWallSwitch
    功能        ：开始向电视墙交换参数
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt * ptSrc, 源
                  u8 byEqpId,
                  u8 byChnlIdx, 
                  u8 byState 
                  BOOL32 bNotify :是否向电视墙外设发送停止消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    05/05/23    3.6         libo          创建
	11/07/12	4.6			彭国锋		  移除参数bEqpStop
====================================================================*/
void CMcuVcInst::ChangeTvWallSwitch(TMt * ptSrc, u8 byTvWallId, u8 byChnlIdx,u8 byTWMemberType, u8 byState,BOOL32 bNeedPreSetin, u8 byModeReq /*= MODE_BOTH*/ )
{
	if (byChnlIdx >= MAXNUM_PERIEQP_CHNNL)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,"[ChangeTvWallSwitch]byChnlIdx(%d) >= MAXNUM_PERIEQP_CHNNL(%d)\n",
			byChnlIdx , MAXNUM_PERIEQP_CHNNL );
		return;
	}
	
    CServMsg      cServMsg;
    TTWSwitchInfo tTWSwitchInfo;
    TPeriEqpStatus tTWStatus;    
    //BOOL32 bSndMtStatus = FALSE; 
    //BOOL32 bMultiInTv = FALSE;
	//20101021_tzy 将DEC5板子的输出模式获得，以便是否要求下级回传音频，原来的标清电视墙有的支持音频有的不支持音频
    u8 byMode = MODE_NONE;
    u8 byTvWallOutputMode = g_cMcuVcApp.GetTvWallOutputMode(byTvWallId);

    if (TW_OUTPUTMODE_AUDIO == byTvWallOutputMode && (byModeReq & MODE_AUDIO))
    {
        byMode = MODE_AUDIO;
    }
    else if (TW_OUTPUTMODE_VIDEO == byTvWallOutputMode && (byModeReq & MODE_VIDEO))
    {
        byMode = MODE_VIDEO;
    }
    else if (TW_OUTPUTMODE_BOTH == byTvWallOutputMode)
    {
        byMode = byModeReq;
    }
    else
    {
        byMode = MODE_VIDEO & byModeReq;
    }
	// [pengjie 2010/9/19] 处理发言人跟随逻辑 支持
	if( !g_cMcuVcApp.GetPeriEqpStatus(byTvWallId, &tTWStatus))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,"[ChangeTvWallSwitch]get tvw(%d) staus failed\n", byTvWallId );
		return;
	}

	if (!tTWStatus.m_byOnline
		&& ( ptSrc && !ptSrc->IsNull()) && byState != TW_STATE_STOP)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,"[ChangeTvWallSwitch]tvw(%d) is offline\n", byTvWallId );
		return;
	}

	TMt tOrgMt = (TMt)tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx]; 


	if (ptSrc != NULL 
		&& !ptSrc->IsNull() 
		&&  TW_STATE_STOP != byState
		&& !CheckTwAbility(*ptSrc,byTvWallId,byChnlIdx))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,"[ChangeTvWallSwitch]Mt(%d,%d) state(%d)  tw(%d,%d),So Return!!\n",
			ptSrc->GetMcuId(),ptSrc->GetMtId(),byState,byTvWallId,byChnlIdx);

		if( !tOrgMt.IsNull() 			
			&& ( TW_STATE_STOP == byState || ( TW_STATE_STOP != byState && NULL != ptSrc && !( tOrgMt == *ptSrc) ))
			)
		{			
			//zjj[20091222] vcs会议如果开启了电视墙混音，退出电视墙的终端也退出混音
			if( m_tConf.GetConfSource() == VCS_CONF 
				&& !tOrgMt.IsNull() 
				&& m_cVCSConfStatus.GetMtInTvWallCanMixing() 
				&& m_tConf.m_tStatus.IsMixing() 
				&& m_tConf.m_tStatus.IsSpecMixing()
				&& IsMtNotInOtherTvWallChnnl(tOrgMt, byTvWallId, byChnlIdx) 
				&& VCSMtNotInTvWallCanStopMixing(	tOrgMt )		
				)
			{
				RemoveSpecMixMember( &tOrgMt, 1, FALSE, TRUE );
			}
		}
		return;
	}

	
	// [9/28/2011 liuxu] tvwall 通道旧成员的实际模式保存在VcData中
	u8 byOldMode = g_cMcuVcApp.GetChnnlMMode( byTvWallId, byChnlIdx );
	
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ChangeTvWallSwitch]TvwSwitch Src[%d,%d] to [%d,%d], state.%d,mode.%d,oldmode.%d\n", 
		ptSrc ? ptSrc->GetMcuIdx() : 0, ptSrc ? ptSrc->GetMtId() : 0,
		byTvWallId, byChnlIdx,
		byState, byMode, byOldMode);
	
	if( bNeedPreSetin && TW_STATE_STOP != byState &&
		NULL != ptSrc && !ptSrc->IsLocal() )
	{
		if( IsLocalAndSMcuSupMultSpy(ptSrc->GetMcuId()) )
		{
			TPreSetInReq tSpySrcInitInfo;
			TMt tDstMt;
			tDstMt.SetNull();
			tDstMt.SetMcuEqp( LOCAL_MCUID, byTvWallId, EQP_TYPE_TVWALL );
			tDstMt.SetConfIdx( m_byConfIdx );
			tSpySrcInitInfo.m_tSpyMtInfo.SetSpyMt( *ptSrc );
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyTVWallInfo.m_tTvWall = tDstMt;
			tSpySrcInitInfo.m_bySpyMode = byMode;
			tSpySrcInitInfo.SetEvId(MCS_MCU_START_SWITCH_TW_REQ);
			//tSpySrcInitInfo.m_dwEvId = MCS_MCU_START_SWITCH_TW_REQ;
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyTVWallInfo.m_bySrcMtType = byTWMemberType;
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyTVWallInfo.m_bySchemeIdx = 0;
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyTVWallInfo.m_byDstChlIdx = byChnlIdx;

			// [pengjie 2010/10/15] 处理发言人跟随等伴随逻辑，这里带上释放的终端
			if( (TW_MEMBERTYPE_SPEAKER == tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType || 
				TW_MEMBERTYPE_POLL == tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType ||
				TW_MEMBERTYPE_TWPOLL == tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType||
				TW_MEMBERTYPE_VCSAUTOSPEC == tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType) &&
				!tOrgMt.IsNull() )
			{
				tSpySrcInitInfo.m_tReleaseMtInfo.m_tMt = tOrgMt;
				tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseMode	= byOldMode;
				tSpySrcInitInfo.m_tReleaseMtInfo.SetCount(0);
				if (TW_MEMBERTYPE_TWPOLL == tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType  ||
					TW_MEMBERTYPE_VCSAUTOSPEC == tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType )
				{
					if (byOldMode == MODE_BOTH)
					{
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = 1;
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = 1;
					}
					if (byOldMode == MODE_AUDIO)
					{
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = 1;
					}
					if (byOldMode == MODE_VIDEO)
					{
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = 1;
					}
				}
				else
				{
					tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = 0;
					tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = 0;
				}
				
				u8 byVmpSpeakerNum = 0;
				u8 byVmpPollNum = 0;
				u8 byTWSpeakerVNum = 0;
				u8 byTWSpeakerANum = 0;
				u8 byTWPollVNum = 0;
				u8 byTWPollANum = 0;
				u8 byHduSpeakerVNum = 0;
				u8 byHduSpeakerANum = 0;
				u8 byHduPollVNum = 0;
				u8 byHduPollANum = 0;
				BOOL32 bHasVmpMode = GetVmpCountInVmpList() > 0;
				
				// vmp所有跟随通道
				byVmpSpeakerNum = GetVmpChnnlNumBySpecMemberType(VMP_MEMBERTYPE_SPEAKER);
				byVmpPollNum = GetVmpChnnlNumBySpecMemberType(VMP_MEMBERTYPE_POLL);
				
				// tvWall所有跟随通道
				GetTvWallChnnlNumBySpecMemberType(TW_MEMBERTYPE_SPEAKER, byTWSpeakerVNum, byTWSpeakerANum);
				GetTvWallChnnlNumBySpecMemberType(TW_MEMBERTYPE_POLL, byTWPollVNum, byTWPollANum);
				
				// hdu所有跟随通道
				GetHduChnnlNumBySpecMemberType(TW_MEMBERTYPE_SPEAKER, byHduSpeakerVNum, byHduSpeakerANum);
				GetHduChnnlNumBySpecMemberType(TW_MEMBERTYPE_POLL, byHduPollVNum, byHduPollANum);
				
				if ( m_tConf.m_tStatus.GetPollMode() != CONF_POLLMODE_NONE)
				{
					// 轮询的计数，根据轮询的媒体模式来区别
					u8 byPollMode = m_tConf.m_tStatus.GetPollInfo()->GetMediaMode();
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "curren poll mode is %d\n", byPollMode);
					
					if ( byPollMode == MODE_BOTH || byPollMode == MODE_BOTH_BOTH)
					{
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum
							+ byTWSpeakerVNum + byTWPollVNum + byHduSpeakerVNum + byHduPollVNum;
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum
							+ byTWSpeakerANum + byTWPollANum + byHduSpeakerANum + byHduPollANum;
						
						if (bHasVmpMode)
						{
							tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum
								+ byVmpSpeakerNum + byVmpPollNum;
						}
					}
					else
					{
						// 其他轮询只考虑　轮询跟随即可
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum
							+ byTWPollVNum + byHduPollVNum;
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum
							+ byTWPollANum + byHduPollANum;
						
						if (bHasVmpMode)
						{
							tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum += byVmpPollNum;
						}
					}
				}
				else
				{
					// 没有轮询，根据通道的类型来取
					u8 byChnnlType = tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType;
					
					if ( byChnnlType == TW_MEMBERTYPE_SPEAKER)
					{
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum
							+ byTWSpeakerVNum + byHduSpeakerVNum;
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum
							+ byTWSpeakerANum + byHduSpeakerANum;
						
						if (bHasVmpMode)
						{
							tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum += byVmpSpeakerNum;
						}
					}
				}
			}
			// End
			
			// [pengjie 2010/9/13] 填目的端能力
			TSimCapSet tSimCapSet = GetMtSimCapSetByMode( GetFstMcuIdFromMcuIdx(ptSrc->GetMcuId()) );
			if(tSimCapSet.IsNull())
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_SPY, "[ChangeSpeaker] Get Mt(mcuid.%d, mtid.%d) SimCapSet Failed !\n",
					ptSrc->GetMcuId(), ptSrc->GetMtId() );
				return;
			}
			//  标清电视墙能力只有cif
			tSimCapSet.SetVideoResolution( VIDEO_FORMAT_CIF );
			//zjl20101116 如果当前终端已回传则能力集要与已回传目的能力集取小
			if(!GetMinSpyDstCapSet(*ptSrc, tSimCapSet))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_SPY, "[ChangeTvWallSwitch] GetMinSpyDstCapSet failed!!\n");
				return;
			}
			tSpySrcInitInfo.m_tSpyMtInfo.SetSimCapset( tSimCapSet );
		    // End

			OnMMcuPreSetIn( tSpySrcInitInfo );
			return;
		}
	}

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeTvWallSwitch] tvwall<EqpId:%d, ChnId:%d>'s old Mt<McuId:%d, MtId:%d> is null or it's in other tvwallchn!\n",
		byTvWallId, byChnlIdx, tOrgMt.GetMcuId(), tOrgMt.GetMtId());

	
    if (NULL != ptSrc && !ptSrc->IsNull() && TW_STATE_STOP != byState )
    {
		TLogicalChannel tSrcRvsChannl;
		if ( ptSrc->GetType() != TYPE_MCUPERI )
		{
			u8 byMtId = ptSrc->IsLocal() ? ptSrc->GetMtId() : GetFstMcuIdFromMcuIdx(ptSrc->GetMcuId());
			if (!m_ptMtTable->GetMtLogicChnnl( byMtId, LOGCHL_VIDEO, &tSrcRvsChannl, FALSE ) )
			{
				// [10/29/2011 liuxu] 需要释放回传带宽
				FreeRecvSpy(*ptSrc, byModeReq);

				CServMsg cMsg;
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangeTvWallSwitch]: Get Mt<McuId:%d, MtId:%d> LogicChnnl fail!\n",
													ptSrc->GetMcuId(), ptSrc->GetMtId());
				cMsg.SetErrorCode(ERR_MCU_GETMTLOGCHN_FAIL);
				SendReplyBack(cMsg, MCU_MCS_START_SWITCH_TW_NACK);
				return;
			}
		}

		//zjl [02/24/2010] 统一在ChangeTvWallSwitch 降分辨率
		if ( tSrcRvsChannl.GetChannelType() == MEDIA_TYPE_H264 &&
			( IsVidFormatHD( tSrcRvsChannl.GetVideoFormat() ) ||
			tSrcRvsChannl.GetVideoFormat() == VIDEO_FORMAT_4CIF ) )
		{
			if ( ptSrc->IsLocal() && 
				MT_MANU_KDC != m_ptMtTable->GetManuId(ptSrc->GetMtId()) &&
				MT_MANU_KDCMCU != m_ptMtTable->GetManuId(ptSrc->GetMtId()) 
				)
			{
				CServMsg cMsg;
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangeTvWallSwitch] Mt<McuId:%d, MtId:%d, ManuId:%d> is not kedaMt!\n",
									ptSrc->GetMcuId(), 
									ptSrc->GetMtId(),
									m_ptMtTable->GetManuId(ptSrc->GetMtId()));

				// [10/29/2011 liuxu] 需要释放回传带宽
				FreeRecvSpy(*ptSrc, byModeReq);
				cMsg.SetErrorCode(ERR_MT_MEDIACAPABILITY);
				SendReplyBack(cMsg, MCU_MCS_START_SWITCH_TW_NACK);
				return;
			}
			else
			{
				// force the mt to adjust its resolution to Cif 
				u8 byNewFormat = VIDEO_FORMAT_CIF;			
				if(!ptSrc->IsLocal())
				{	
					//级联调分辨率
					CascadeAdjMtRes( *ptSrc, byNewFormat, TRUE);
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ChangeTvWallSwitch] send videoformat<%d>(%s) change msg to casmt<McuId:%d, MtId:%d>!\n",
						byNewFormat, GetResStr(byNewFormat), ptSrc->GetMcuId(),ptSrc->GetMtId() );
				}
				else
				{
 					u8 byChnnlType = LOGCHL_VIDEO;					
					//20100708_tzy 如果此时上传通道中有高清终端需要调该终端分辨率
					if (MT_TYPE_SMCU == m_ptMtTable->GetMtType(ptSrc->GetMtId()))
					{
						// [pengjie 2010/10/13] 调该mcu的上传源的分辨率
						u8 byMcuId = u8(GetMcuIdxFromMcuId( ptSrc->GetMtId() ));
						TConfMcInfo *ptInfo = m_ptConfOtherMcTable->GetMcInfo( byMcuId );
						if( ptInfo != NULL )
						{
							CascadeAdjMtRes( ptInfo->m_tMMcuViewMt, byNewFormat, TRUE);
						}
 						ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ChangeTvWallSwitch] send videoformat<%d>(%s) change msg to mcuUploadChnMt<McuId:%d>!\n",
 						byNewFormat, GetResStr(byNewFormat),ptSrc->GetMtId() );
						// End
					}
					else
					{
						// [pengjie 2010/9/13] 多回传调分辨率逻辑调整
					    SendChgMtVidFormat( ptSrc->GetMtId(), byChnnlType, byNewFormat );
						//SendMsgToMt( ptSrc->GetMtId(), cMsg.GetEventId(), cMsg );
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ChangeTvWallSwitch] send videoformat<%d>(%s) change msg to mt<McuId:%d, MtId:%d>!\n",
						byNewFormat, GetResStr(byNewFormat), ptSrc->GetMcuId(),ptSrc->GetMtId() );
					}
				}	

				//按终端清除前适配通道,终端进TW降分辨率不清vmp前适配
				//m_tVmpChnnlInfo.ClearChnlByMt(*ptSrc);
			}
		 }
	}
	else
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeTvWallSwitch] ptSrc is null or bystate is stop!\n");
	}

    StopSwitchToPeriEqp(byTvWallId, byChnlIdx, FALSE, byOldMode);
	g_cMcuVcApp.SetChnnlMMode(byTvWallId, byChnlIdx, MODE_NONE);

	// [10/12/2011 liuxu] 先清空一下电视墙通道成员
	tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].SetNull();
    tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].SetConfIdx(m_byConfIdx);
	g_cMcuVcApp.SetPeriEqpStatus(byTvWallId, &tTWStatus);

    if(!tOrgMt.IsNull() && IsMtNotInOtherTvWallChnnl(tOrgMt, byTvWallId, byChnlIdx))
    {
		RefreshMtStatusInTw( tOrgMt, FALSE, FALSE );
    }
	
	TVMPParam_25Mem tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
	//[12/13/2011 liuxu] VCS中终端被清出电视墙时, 要考虑挂断挂断它
	if ( VCS_CONF == m_tConf.GetConfSource() && TW_STATE_STOP == byState)
	{
		if (!(m_cVCSConfStatus.GetCurVCMT() == tOrgMt )	&&
			IsMtNotInOtherTvWallChnnl(tOrgMt, byTvWallId, byChnlIdx) && 
			IsMtNotInOtherHduChnnl(tOrgMt, 0, 0) )
		{
			if (m_cVCSConfStatus.GetCurVCMode() == VCS_SINGLE_MODE)
			{
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VCS, "[ChangeTvWallSwitch]when ClearTvw(%d,%d) DropMT(%d,%d) in VcsMode.%d\n",
					byTvWallId, byChnlIdx, tOrgMt.GetMcuId(), tOrgMt.GetMtId(),  m_cVCSConfStatus.GetCurVCMode());
				
				// 挂断终端
				VCSDropMT( tOrgMt );
			}
			// 多方多画面下如果也不在画面合成中了, 也需要被挂断
			else if ( m_cVCSConfStatus.GetCurVCMode() == VCS_MULVMP_MODE ) 
				
			{
				if (!tConfVmpParam.IsMtInMember(tOrgMt))
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VCS, "[ChangeTvWallSwitch]when ClearTvw(%d,%d) DropMT(%d,%d) in VcsMode.%d\n",
						byTvWallId, byChnlIdx, tOrgMt.GetMcuId(), tOrgMt.GetMtId(),  m_cVCSConfStatus.GetCurVCMode());
					
					VCSDropMT( tOrgMt );
				}
			}
		}
	}

	FreeRecvSpy( tOrgMt, byOldMode );
       
    //更新新通道信息
    tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType = byTWMemberType;
    // 顾振华 [5/23/2006] 成员必须是终端，而不能是外设
    if (ptSrc != NULL && ptSrc->GetType() == TYPE_MCUPERI)
    {
        ptSrc->SetNull();
    }
    if (ptSrc == NULL || ptSrc->IsNull())
    {
        tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].SetNull();
        tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].SetConfIdx(m_byConfIdx);
    }
    else
    {
        tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].SetMt(*ptSrc);
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeTvWallSwitch] set new mt<McuId:%d, MtId:%d> in tw chn<%d>\n!",
					ptSrc->GetMcuId(), ptSrc->GetMtId(), byChnlIdx);
    }

	//zjj20090911
	if ( TW_STATE_STOP == byState 
		&&  (TW_MEMBERTYPE_VCSAUTOSPEC == byTWMemberType || 
			 TW_MEMBERTYPE_VCSSPEC == byTWMemberType ||
			 TW_MEMBERTYPE_MCSSPEC == byTWMemberType ||
			 TW_MEMBERTYPE_SWITCHVMP == byTWMemberType ||
			 TW_MEMBERTYPE_TWPOLL  == byTWMemberType) )
	{
		tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].SetNull();
		tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType = 0;
		tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].SetConfIdx( 0 );
	}

	if ( TW_STATE_STOP == byState 
		&& ( TW_MEMBERTYPE_CHAIRMAN == byTWMemberType  
		|| TW_MEMBERTYPE_SPEAKER == byTWMemberType
		|| TW_MEMBERTYPE_BATCHPOLL == byTWMemberType
		|| TW_MEMBERTYPE_VCSAUTOSPEC == byTWMemberType
		)
		)
	{
		tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].SetNull();
	}

    g_cMcuVcApp.SetPeriEqpStatus(byTvWallId, &tTWStatus);

    //status notification
    cServMsg.SetMsgBody((u8 *)&tTWStatus, sizeof(tTWStatus));
    SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);

	//zjl[20091207]如果被替换的终端是高清终端，则恢复其分辨率(包括当电视墙通道被关闭时，采取同样的恢复操作)
	if( !tOrgMt.IsNull() 
		&& IsMtNotInOtherTvWallChnnl(tOrgMt, byTvWallId, byChnlIdx) 
		&& ( TW_STATE_STOP == byState || ( TW_STATE_STOP != byState && NULL != ptSrc && !( tOrgMt == *ptSrc) ))
		)
	{		
		//RecoverMtResInMpu(tOrgMt);
		
		//zjj[20091222] vcs会议如果开启了电视墙混音，退出电视墙的终端也退出混音
		if( m_tConf.GetConfSource() == VCS_CONF 
			&& !tOrgMt.IsNull() 
			&& m_cVCSConfStatus.GetMtInTvWallCanMixing() 
			&& m_tConf.m_tStatus.IsMixing() 
			&& m_tConf.m_tStatus.IsSpecMixing() 
			&& VCSMtNotInTvWallCanStopMixing(	tOrgMt )		
			)
		{
			RemoveSpecMixMember( &tOrgMt, 1, FALSE, TRUE );
		}
		//vcs级联单回传下进墙终端如果非调度终端同时也不在画面合成中出墙时需将下级MCU踢出混音器，
		//以免下级未配混音器时还能听到下级上传通道的声音
		if (VCS_CONF == m_tConf.GetConfSource() 
			&& !tOrgMt.IsLocal() 
			&& !IsLocalAndSMcuSupMultSpy(tOrgMt.GetMcuIdx()) 
			&& m_cVCSConfStatus.GetMtInTvWallCanMixing())
		{
			TMt tLocalMt = GetLocalMtFromOtherMcuMt(tOrgMt);
			if (m_ptMtTable->IsMtInMixing(tLocalMt.GetMtId()) 
				&& GetLocalMtFromOtherMcuMt(m_cVCSConfStatus.GetCurVCMT()).GetMtId() != tLocalMt.GetMtId() 
				&& !tConfVmpParam.IsMtInMember(tOrgMt)
				&& IsMtNotInOtherTvWallChnnl(tOrgMt, byTvWallId, byChnlIdx) 
				&& IsMtNotInOtherHduChnnl(tOrgMt, 0 , 0)
				&& !IsHasMtInHduOrTwByMcuIdx(tOrgMt.GetMcuIdx()))
			{
				RemoveSpecMixMember( &tLocalMt, 1, FALSE, TRUE );
			}
		}
	}


    if ((TW_STATE_START == byState || TW_STATE_CHANGE == byState) && ptSrc != NULL)
    {
        TEqp tEqp = g_cMcuVcApp.GetEqp(byTvWallId);

        tTWSwitchInfo.SetSrcMt(*ptSrc);
        tTWSwitchInfo.SetDstMt(tEqp);
        tTWSwitchInfo.SetMode(byMode);
		g_cMcuVcApp.SetChnnlMMode(byTvWallId, byChnlIdx, byMode);

        tTWSwitchInfo.SetDstChlIdx(byChnlIdx);
        cServMsg.SetEventId(MCS_MCU_START_SWITCH_TW_REQ);	
		//20101118_tzy 通知下级建回传交换SpyNotify
		if (!ptSrc->IsNull() && !ptSrc->IsLocal() && IsLocalAndSMcuSupMultSpy(ptSrc->GetMcuIdx()))
		{
			TSimCapSet tSimCapSet = GetMtSimCapSetByMode( GetFstMcuIdFromMcuIdx(ptSrc->GetMcuId()));
			tSimCapSet.SetVideoResolution(VIDEO_FORMAT_CIF);
			SendMMcuSpyNotify( *ptSrc, MCS_MCU_START_SWITCH_TW_REQ, tSimCapSet);
		}
        SwitchSrcToDst(tTWSwitchInfo, cServMsg);
		
		if ( m_tConf.GetConfSource() == VCS_CONF 
			&& m_cVCSConfStatus.GetMtInTvWallCanMixing() 
			&& m_tConf.m_tStatus.IsSpecMixing())
		{
			AddSpecMixMember(ptSrc,1,TRUE);
		}	
    }
    	
	if(NULL != ptSrc 
		&& !ptSrc->IsNull() 
		&& ptSrc->GetType() != TYPE_MCUPERI 
		&& TW_STATE_STOP != byState)
    {
		RefreshMtStatusInTw( *ptSrc, TRUE, FALSE );
    }

    // 顾振华 [5/25/2006] 这里当传入的终端是NULL的情况下,请求停止本电视墙通道
    // 否则业务和电视墙内部记录的通道终端不一致
    // 当电视墙再次开始其他通道解码时,会给MCU发送错误的电视墙成员数组
    // 这个成员数组包含部分业务上已经置空但是电视并不知道停止的通道
    // FIXME: 现在的问题是请求Stop的开销是否很大, 为什么原来的代码
    //        只有在 bEqpStop 的情况下才去停止
    if ( (TW_STATE_STOP == byState ) || ptSrc == NULL )
    {
        cServMsg.SetChnIndex(byChnlIdx);
        cServMsg.SetEventId(MCU_TVWALL_STOP_PLAY_REQ);
        SendMsgToEqp(byTvWallId, MCU_TVWALL_STOP_PLAY_REQ, cServMsg);        
    }
	
	// 更新其它电视墙通道
	if ((TW_STATE_START == byState || TW_STATE_CHANGE == byState) && ptSrc != NULL)
	{
		// 只有单回传时需要更新
		if (!IsLocalAndSMcuSupMultSpy(ptSrc->GetMcuIdx()))
		{
			UpdateTvwOnSMcuViewMtChg(*ptSrc, FALSE);
		}
	}

    return;
}

/*------------------------------------------------------------------*/
/*                              HDU                                 */
/*------------------------------------------------------------------*/
/*====================================================================
    函数名      ：StopHduBatchPollSwitch
    功能        ：一个版面的轮询结束后拆交换
    算法实现    ：
    引用全局变量：
    输入参数说明：BOOL32 bStopPlay: 是否在拆交换的同时停止HDU解码
    返回值说明  ：void
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/04/13    4.6.1         江乐斌        创建
====================================================================*/
void   CMcuVcInst::StopHduBatchPollSwitch(const BOOL32 bStopPlay )
{
	u8 byHduEqpId = 0;
	u8 byChnlIdx = 0;
	u8 byChnlPollNum = m_tHduBatchPollInfo.GetChnlPollNum();
	TPeriEqpStatus tHduStatus;
	CServMsg cServMsg;
	u8 byHduChlNum = 0;
	for ( byHduChlNum = 0; byHduChlNum < min(byChnlPollNum, MAXNUM_HDUCFG_CHNLNUM); byHduChlNum ++ )
	{
		byHduEqpId = m_tHduBatchPollInfo.m_tChnlBatchPollInfo[byHduChlNum].GetEqpId();
		byChnlIdx = m_tHduBatchPollInfo.m_tChnlBatchPollInfo[byHduChlNum].GetChnlIdx();
		if ( byHduEqpId >= HDUID_MIN && byHduEqpId <= HDUID_MAX )
		{
			if (!g_cMcuVcApp.IsPeriEqpValid( byHduEqpId ))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StopHduBatchPollSwitch](hduid:%d) is not valide,so continue.\n", byHduEqpId);
				continue;
			}
			g_cMcuVcApp.GetPeriEqpStatus( byHduEqpId, &tHduStatus );
			if (bStopPlay)
			{
				tHduStatus.m_tStatus.tHdu.atHduChnStatus[byChnlIdx].SetSchemeIdx( 0 );
				g_cMcuVcApp.SetPeriEqpStatus( byHduEqpId, &tHduStatus );
			}
			
			if ( 0 == tHduStatus.m_byOnline )    // hdu不在线
			{
				tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].SetNull();
				g_cMcuVcApp.SetPeriEqpStatus( byHduEqpId, &tHduStatus );
				cServMsg.SetMsgBody( (u8*)&tHduStatus, sizeof(tHduStatus) );
				SendMsgToAllMcs( MCU_MCS_MCUPERIEQPSTATUS_NOTIF,  cServMsg);
			}
			else
			{
				//tMt = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx];
                
                if (bStopPlay)
                {
					// [2013/03/11 chenbing] HDU多画面目前不支持批量轮询,子通道置0
					ChangeHduSwitch( NULL, byHduEqpId, byChnlIdx, 0, TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP);	
                }
                else
                {
					// [2013/03/11 chenbing] HDU多画面目前不支持批量轮询,子通道置0
					//ChangeHduSwitch( NULL, byHduEqpId, byChnlIdx, 0, TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP, MODE_BOTH, TRUE );
                }
			}
		}
		else
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StopHduBatchPollSwitch] stop hdu(%d) batch poll error!\n", byHduEqpId);
			return;
		}
	}

	// [2013/08/02 chenbing] 停止批量轮询需要清除该会议对预案所有通道的占用 
	for ( byHduChlNum = 0; byHduChlNum < MAXNUM_HDUCFG_CHNLNUM; byHduChlNum++ )
	{
		byHduEqpId = m_tHduBatchPollInfo.m_tChnlBatchPollInfo[byHduChlNum].GetEqpId();
		byChnlIdx = m_tHduBatchPollInfo.m_tChnlBatchPollInfo[byHduChlNum].GetChnlIdx();
		if ( byHduEqpId >= HDUID_MIN && byHduEqpId <= HDUID_MAX )
		{
			if (!g_cMcuVcApp.IsPeriEqpValid( byHduEqpId ))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[StopHduBatchPollSwitch] Release HduChnl Occupy (HduId:%d) is not valide\n", byHduEqpId);
				continue;
			}

			g_cMcuVcApp.GetPeriEqpStatus( byHduEqpId, &tHduStatus );
			if (bStopPlay)
			{
				tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType = TW_MEMBERTYPE_NULL;
				tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].SetConfIdx(0);
				g_cMcuVcApp.SetPeriEqpStatus( byHduEqpId, &tHduStatus );
				CServMsg cSMsg;
				cSMsg.SetMsgBody((u8 *)&tHduStatus, sizeof(tHduStatus));
				SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cSMsg);
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopHduBatchPollSwitch] Release HduChnl Occupy HduId(%d) ChnlId(%d) Success!\n",
					byHduEqpId, byChnlIdx);
			}
		}
		else
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopHduBatchPollSwitch] Release HduChnl Occupy HduId(%d) no exist!\n", byHduEqpId);
		}
	}
}

/*====================================================================
函数名      ：RestoreMtInTvWallOrHdu
功能        ：恢复终端到电视墙交换
算法实现    ：
引用全局变量：
输入参数说明：const TMt& tMt 要恢复的终端
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/04/20    4.2         周晶晶         创建
====================================================================*/
void CMcuVcInst::RestoreMtInTvWallOrHdu( const TMt& tMt )
{
	u8 byEqpId = TVWALLID_MIN;
	TPeriEqpStatus tTvwallStatus;
	TMt tMtIn;
	while( byEqpId >= TVWALLID_MIN && byEqpId <= TVWALLID_MAX )
	{
		if (g_cMcuVcApp.IsPeriEqpValid(byEqpId))
		{
			g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tTvwallStatus);
			if (tTvwallStatus.m_byOnline == 1)
			{
				//u8 byTmpMtId = 0;
				u8 byMtConfIdx = 0;
				u8 byMemberNum = tTvwallStatus.m_tStatus.tTvWall.byChnnlNum;
				for(u8 byLoop = 0; byLoop < min(byMemberNum,MAXNUM_PERIEQP_CHNNL); byLoop++)
				{
					g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tTvwallStatus);
					//byTmpMtId = GetLocalMtFromOtherMcuMt().GetMtId();
					tMtIn = tTvwallStatus.m_tStatus.tTvWall.atVideoMt[byLoop];
					byMtConfIdx = tTvwallStatus.m_tStatus.tTvWall.atVideoMt[byLoop].GetConfIdx();
					if ( ( ( tMt.IsLocal() && tMtIn.IsLocal() && tMt.GetMtId() == tMtIn.GetMtId() )  || tMt == tMtIn )
						&& m_byConfIdx == byMtConfIdx								
						)
					{							
						tTvwallStatus.m_tStatus.tTvWall.atVideoMt[byLoop].SetNull();
						g_cMcuVcApp.SetPeriEqpStatus(byEqpId, &tTvwallStatus);
						ChangeTvWallSwitch( &tMtIn, byEqpId, byLoop, 
							tTvwallStatus.m_tStatus.tTvWall.atVideoMt[byLoop].byMemberType,
							TW_STATE_START );
					}
				}
			}
		}
		byEqpId++;
	}
	
	//zjj20091014 针对异常挂断的成员恢复hdu交换
	//异常挂断的成员虽然交换拆除，但在电视墙的成员信息中仍然存在
	u8 byHduId = HDUID_MIN;
	TPeriEqpStatus tHduStatus;
	while( byHduId >= HDUID_MIN && byHduId <= HDUID_MAX )
	{
		if (g_cMcuVcApp.IsPeriEqpValid(byHduId))
		{
			g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus);
			if (tHduStatus.m_byOnline == 1)
			{
				//u8 byTmpMtId = 0;
				u8 byMtConfIdx = 0;
				u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduId));
				if (0 == byHduChnNum)
				{
					byHduId++;
					ConfPrint(LOG_LVL_ERROR, MID_MCU_HDU, "[RestoreMtInTvWallOrHdu] GetHduChnNumAcd2Eqp failed!\n");
					continue;
				}
				
				for(u8 byLoop = 0; byLoop < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byLoop++)
				{
					g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus);

					// [2013/03/11 chenbing] 恢复四风格通道的交换
					if ( HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byLoop) )
					{
						for (u8 byIndex=0; byIndex<HDU_MODEFOUR_MAX_SUBCHNNUM; byIndex++)
						{
							tMtIn = tHduStatus.m_tStatus.tHdu.GetChnMt(byLoop, byIndex);
							byMtConfIdx = tHduStatus.m_tStatus.tHdu.GetConfIdx(byLoop, byIndex);

							if ( ( ( tMt.IsLocal() && tMtIn.IsLocal() && tMt.GetMtId() == tMtIn.GetMtId() ) || tMtIn == tMt)
								&& m_byConfIdx == byMtConfIdx )
							{
								ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_HDU, "[RestoreMtInTvWallOrHdu] Mt(%d,%d) restore tmt hdu switch \n", 
									tMt.GetMcuId(),tMt.GetMtId() );
								ChangeHduSwitch( &tMtIn, byHduId, byLoop, byIndex, tHduStatus.m_tStatus.tHdu.GetMemberType(byLoop, byIndex),
									TW_STATE_START, MODE_VIDEO, FALSE, FALSE, TRUE, HDUCHN_MODE_FOUR );
							}	
						}
					}
					else//一风格逻辑
					{
						tMtIn = tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop];
						byMtConfIdx = tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop].GetConfIdx();
						
						if ( ( ( tMt.IsLocal() && tMtIn.IsLocal() && tMt.GetMtId() == tMtIn.GetMtId() ) || tMtIn == tMt)
							&& m_byConfIdx == byMtConfIdx )
						{
							ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_HDU, "[RestoreMtInTvWallOrHdu] Mt(%d,%d) restore tmt hdu switch \n", 
								tMt.GetMcuId(),tMt.GetMtId() );
							ChangeHduSwitch( &tMtIn, byHduId, byLoop, 0,
								tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop].byMemberType,
								TW_STATE_START );
						}
					}
				}
			}
		}
		byHduId++;
	}	
}

/*====================================================================
    函数名      ：HduBatchPollOfOneCycle
    功能        ：hdu一个版面的批量轮询
    算法实现    ：
    引用全局变量：
    输入参数说明：bFirstCycle --> 是否是第一个版面的轮询
    返回值说明  ：TRUE --> 成功
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/04/13    4.6.1       江乐斌        创建
	20100808    4.6.1       彭杰          HDU批量轮询逻辑整理，多级批量轮询支持
====================================================================*/
BOOL32 CMcuVcInst::HduBatchPollOfOneCycle( const BOOL32 bFirstCycle )
{
	TMt tFstMt;
	u8 byLoop = 0;

	// 当前会议没用终端，批量轮询结束
	for ( byLoop = 1; byLoop<= MAXNUM_CONF_MT; byLoop++ )
	{
		if( m_tConfAllMtInfo.MtInConf( byLoop ) )
		{
			if (m_ptMtTable->GetMtType(byLoop) == MT_TYPE_VRSREC)
			{
				continue;
			}
			tFstMt = m_ptMtTable->GetMt( byLoop );
			break;
		}
	}
	if( MAXNUM_CONF_MT < byLoop )
	{
		return FALSE;
	}
	
	TPeriEqpStatus tHduStatus;
	THduChnlPollInfo *ptHduChnlPollInfo = (THduChnlPollInfo*)m_tHduBatchPollInfo.m_tChnlBatchPollInfo;
	u8 byChnlPollNum = m_tHduBatchPollInfo.GetChnlPollNum();
    u8 byChnlIdxTemp = 0;
	u8 byEqpIdTemp = 0;
	u8 byHduChnlIdx = 0;

	// 清一遍之前通道的成员
// 	while( byHduChnlIdx < byChnlPollNum )
// 	{
// 		byEqpIdTemp = ptHduChnlPollInfo[byHduChnlIdx].GetEqpId();
// 		byChnlIdxTemp = ptHduChnlPollInfo[byHduChnlIdx].GetChnlIdx();
// 		if (byChnlIdxTemp >= MAXNUM_HDU_CHANNEL)
// 		{
// 			continue;
// 		}
// 		g_cMcuVcApp.GetPeriEqpStatus( byEqpIdTemp, &tHduStatus );
// 		TMt tSrcMt = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdxTemp];
// 
// 		// [2013/03/11 chenbing] HDU多画面目前不支持批量轮询,子通道置0
// 		ChangeHduSwitch( &tSrcMt, byEqpIdTemp, byChnlIdxTemp, 0/*chenbing*/, 
// 			TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP, MODE_BOTH, TRUE );
// 		byHduChnlIdx ++;				
// 	}

	TMt tNextMt = m_tHduBatchPollInfo.GetNextPollMt();
	TMt tNextNewMt;
	BOOL32 bEnd = FALSE;
	BOOL32 bIsNoFirstPoll = FALSE;
	TMt tOldMt;

	byHduChnlIdx = 0;
	// 对各个通道进行设置
	while( byHduChnlIdx < byChnlPollNum )
	{
		tNextMt = m_tHduBatchPollInfo.GetNextPollMt();
		if( tNextMt.IsNull() )
		{
			tNextMt = tFstMt;
			m_tHduBatchPollInfo.SetNextPollMt( tNextMt );
		}		

		// 这里保证新的终端与会，不与会则取下一个与会终端
		if( tNextMt.IsLocal() )
		{
			if( !m_tConfAllMtInfo.MtInConf(tNextMt.GetMtId()) )
			{
				if( GetNextNeedPollMt( tNextMt, tNextNewMt ) )
				{
					m_tHduBatchPollInfo.SetNextPollMt( tNextNewMt );
				}
				else
				{
					bEnd = TRUE;
				}
			}
		}
		else
		{
			TConfMtInfo *ptConfMtInfo = m_tConfAllMtInfo.GetMtInfoPtr(tNextMt.GetMcuIdx());	
			// [pengjie 2010/10/12]
			if( ptConfMtInfo != NULL && ptConfMtInfo->GetMcuIdx() == tNextMt.GetMcuIdx())
			{
				if( !ptConfMtInfo->MtInConf(tNextMt.GetMtId()) )
				{
					if( GetNextNeedPollMt( tNextMt, tNextNewMt ) )
					{
						m_tHduBatchPollInfo.SetNextPollMt( tNextNewMt );
					}
					else
					{
						return FALSE;
					}
				}
			}
			else
			{
				// 取下级终端表失败，重新开始轮询
				byHduChnlIdx = 0;
				m_tHduBatchPollInfo.SetNextPollMt( tFstMt );
			}
			// End
	
		}
		// End

		// 此时NextPollMt 在上面的逻辑中可能已经发生变化，重新再取一次
		tNextMt = m_tHduBatchPollInfo.GetNextPollMt();

		if( (bFirstCycle == TRUE && byHduChnlIdx == 0) || bEnd )
		{
			tNextMt = tFstMt;
		}

		// 1、轮询次数控制
		if( bFirstCycle != TRUE && tFstMt == tNextMt && !tFstMt.IsNull() )
		{
			if( 0 != m_tHduBatchPollInfo.GetCycles() && 
				m_tHduBatchPollInfo.GetCurrentCycle() < m_tHduBatchPollInfo.GetCycles())
			{
				m_tHduBatchPollInfo.SetNextCycle();
				u8 byKeepCycles = m_tHduBatchPollInfo.GetCycles() - m_tHduBatchPollInfo.GetCurrentCycle();
				m_tHduPollSchemeInfo.SetCycles( byKeepCycles );
				
				CServMsg cServMsg;
				ConfStatusChange();
				cServMsg.SetMsgBody( (u8*)&m_tHduPollSchemeInfo, sizeof(m_tHduPollSchemeInfo) );
				SendMsgToAllMcs( MCU_MCS_HDUBATCHPOLL_STATUS_NOTIF, cServMsg );
				// 结束轮询
				if( byKeepCycles == 0 )
				{
					return TRUE;
				}
			}
		}
		
		// 2、HDU掉线，为该hdu通道预留对应终端，待hdu上线后自动恢复正常状态
		THduMember tHduMember;
		memset(&tHduMember, 0x0, sizeof(THduMember));
		memset( &tOldMt, 0x0, sizeof( TMt ) );
		tHduMember.byMemberType = TW_MEMBERTYPE_BATCHPOLL;
		byEqpIdTemp = ptHduChnlPollInfo[byHduChnlIdx].GetEqpId();
		byChnlIdxTemp = ptHduChnlPollInfo[byHduChnlIdx].GetChnlIdx();
		g_cMcuVcApp.GetPeriEqpStatus( byEqpIdTemp, &tHduStatus );

		if ( 0 == tHduStatus.m_byOnline )
		{
			BOOL32 bSendMtStatus = FALSE;
			tOldMt = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdxTemp];
			if( !tOldMt.IsNull() && IsMtNotInOtherHduChnnl(tOldMt, byEqpIdTemp, byChnlIdxTemp)
				&& TYPE_MT == tOldMt.GetType() )
			{
				m_ptMtTable->SetMtInHdu(tOldMt.GetMtId(), FALSE);
				bSendMtStatus = TRUE;
			}    
			
			if ( bSendMtStatus )
			{
				MtStatusChange(&tOldMt, TRUE);
			}
			
			memcpy( &(tHduMember), &tNextMt, sizeof(TMt) );
			tHduMember.byMemberType = TW_MEMBERTYPE_BATCHPOLL;
			tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdxTemp] = tHduMember;               
			g_cMcuVcApp.SetPeriEqpStatus( byEqpIdTemp, &tHduStatus );
		}
		// 3、HDU在线,设置该通道成员
		else
		{
			bEnd = (ProcHduBatchPollSwitch(tFstMt, tNextMt, ptHduChnlPollInfo[byHduChnlIdx], bFirstCycle, bIsNoFirstPoll) == FALSE) ? TRUE:FALSE; 
			if( bEnd )
			{
				byHduChnlIdx++;
				break;
			}
			//定义非第一次轮询
			bIsNoFirstPoll = TRUE;
		}
		byHduChnlIdx++;
	}

	byLoop = 0;
	u8 bySubChnIdx = 0;
	//停掉其他剩余HDU通道
	while( byLoop < byChnlPollNum )
	{
		byEqpIdTemp = ptHduChnlPollInfo[byLoop].GetEqpId();
		byChnlIdxTemp = ptHduChnlPollInfo[byLoop].GetChnlIdx();
		if (byChnlIdxTemp >= MAXNUM_HDU_CHANNEL)
		{
			++byLoop;
			continue;
		}
		g_cMcuVcApp.GetPeriEqpStatus( byEqpIdTemp, &tHduStatus );

		if (tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdxTemp) == HDUCHN_MODE_ONE)
		{
			if (byLoop >= byHduChnlIdx)
			{
				ChangeHduSwitch( NULL, byEqpIdTemp, byChnlIdxTemp, 0, 
						TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP, MODE_BOTH, TRUE );
			}
			else
			{
				//没有开启的通道需要重新停止一下
				if (tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnlIdxTemp) != THduChnStatus::eWAITSTART)
				{
					if (m_tConfAllMtInfo.MtJoinedConf(tHduStatus.m_tStatus.tHdu.GetChnMt(byChnlIdxTemp)))
					{
						ChangeHduSwitch( NULL, byEqpIdTemp, byChnlIdxTemp, 0, TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP);
					}
				}
			}
		}
		else if (tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdxTemp) == HDUCHN_MODE_FOUR)
		{
			if (byLoop >= byHduChnlIdx)
			{
				for ( bySubChnIdx = 0 ; bySubChnIdx < HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnIdx ++)
				{
					if (!tHduStatus.m_tStatus.tHdu.GetChnMt(byChnlIdxTemp,bySubChnIdx).IsNull())
					{
						ChangeHduSwitch( NULL, byEqpIdTemp, byChnlIdxTemp, bySubChnIdx,
							TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP, MODE_VIDEO, FALSE, TRUE, TRUE, HDUCHN_MODE_FOUR);
					}
				}
			}
			else
			{
				if (tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnlIdxTemp) != THduChnStatus::eWAITSTART)
				{
					if (m_tConfAllMtInfo.MtJoinedConf(tHduStatus.m_tStatus.tHdu.GetChnMt(byChnlIdxTemp)))
					{
						ChangeHduSwitch( NULL, byEqpIdTemp, byChnlIdxTemp, 0,
							TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP, MODE_VIDEO, FALSE, TRUE, TRUE, HDUCHN_MODE_FOUR);
					}
				} 
				for ( bySubChnIdx = 1 ; bySubChnIdx < HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnIdx ++)
				{
					if (!tHduStatus.m_tStatus.tHdu.GetChnMt(byChnlIdxTemp,bySubChnIdx).IsNull())
					{
						ChangeHduSwitch( NULL, byEqpIdTemp, byChnlIdxTemp, bySubChnIdx,
							TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP, MODE_VIDEO, FALSE, TRUE, TRUE, HDUCHN_MODE_FOUR);
					}
				}
			}

			//切换四风格为一风格
			u8 byHduMode = HDUCHN_MODE_ONE;
			CServMsg cSMsg;
			cSMsg.SetEqpId(byEqpIdTemp);
			cSMsg.SetChnIndex(byChnlIdxTemp);
			cSMsg.SetMsgBody((u8*)&byHduMode, sizeof(u8));
			SendChangeHduModeReq(cSMsg);
		}
		else
		{
		}	
		++byLoop;
	}
	// 轮询到了最后一个终端，重新设置第一个开始轮询的终端
	if (bEnd)
	{	
		m_tHduBatchPollInfo.SetNextPollMt( tFstMt );
		return TRUE;
	}

	return TRUE;	
}

/*====================================================================
    函数名      ：ProcHduBatchPollSwitch
    功能        ：处理HDU批量轮询各级终端进HDU个通道
    算法实现    ：采用递归算法，在得到一个将要轮询的终端后，判断其是否
	              为下级mcu，是则递归到下级，最后找到一个非mcu的终端进
				  如HDU通道.
    引用全局变量：
    输入参数说明：[IN] TMt tNextMt 即将轮询的终端
	              [IN] const THduChnlPollInfo &tHduChnlPollInfo 界面传下来的轮询信息
	              [IN] BOOL32 bFirstCycle 是否是第一次开始轮询
    返回值说明  ：BOOL32 FALSE:表示当前已经轮询到整个会议的最后一个终端
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	20100828    4.6         彭杰           create
====================================================================*/
BOOL32 CMcuVcInst::ProcHduBatchPollSwitch(  TMt tFirst, TMt tNextMt, 
										    const THduChnlPollInfo &tHduChnlPollInfo, 
										    const BOOL32 bFirstCycle,
											BOOL32 bIsNoFirstPoll)
{
	CServMsg cServMsg;
	u8 byEqpId = tHduChnlPollInfo.GetEqpId();
	u8 byChnlIdx = tHduChnlPollInfo.GetChnlIdx();
	TPeriEqpStatus tHduStatus;	
	g_cMcuVcApp.GetPeriEqpStatus( byEqpId, &tHduStatus );
	u16 wMcuIdx = tNextMt.GetMcuIdx();
	TMt tNextChlNeedPollMt;

	// 1、轮本地终端
	// [pengjie 2010/9/27] 如果会议不支持多回传，则不用轮询下级mcu下的终端
	if( tNextMt.IsLocal() || ( !tNextMt.IsLocal() && !IsLocalAndSMcuSupMultSpy(tNextMt.GetMcuId()) ) )
	{
		tNextMt = GetLocalMtFromOtherMcuMt( tNextMt );
	
		// 1.1 在线终端直接进
		if ( m_tConfAllMtInfo.MtJoinedConf( tNextMt.GetMtId() ) )
		{
			// 1.1.1 是本级终端(包括不支持多回传时的mcu)
			if( tNextMt.GetMtType() != MT_TYPE_SMCU || 
				( tNextMt.GetMtType() == MT_TYPE_SMCU && 
				!IsLocalAndSMcuSupMultSpy(GetMcuIdxFromMcuId(tNextMt.GetMtId()))) )
			{
				TEqp tHduEqp = g_cMcuVcApp.GetEqp(byEqpId);
				if (!IsSatMtCanContinue(tNextMt.GetMtId(),emHduBatch,&tHduEqp,byChnlIdx))
				{
					if( GetNextNeedPollMt( tNextMt, tNextChlNeedPollMt) )
					{
						m_tHduBatchPollInfo.SetNextPollMt( tNextChlNeedPollMt );
						return TRUE;
					}
					else
					{
						return FALSE;
					}
				}
				// 本地终端直接加入电视墙
// 				if ( bFirstCycle)
// 				{
// 					// [2013/03/11 chenbing] HDU多画面目前不支持批量轮询,子通道置0
// 					ChangeHduSwitch( &tNextMt, byEqpId, byChnlIdx, 0,\
// 						TW_MEMBERTYPE_BATCHPOLL, TW_STATE_START, MODE_BOTH, TRUE);
// 				}
// 				else
// 				{
					// [2013/03/11 chenbing] HDU多画面目前不支持批量轮询,子通道置0
					ChangeHduSwitch( &tNextMt, byEqpId, byChnlIdx, 0,\
						TW_MEMBERTYPE_BATCHPOLL, TW_STATE_START, MODE_BOTH, TRUE);
//				}	
				if( GetNextNeedPollMt( tNextMt, tNextChlNeedPollMt ) )
				{
					//tNextChlNeedPollMt;
					m_tHduBatchPollInfo.SetNextPollMt( tNextChlNeedPollMt );
					return TRUE;
				}
				else
				{
					// 表示重头开始轮询,并且本版面到此为止
					return FALSE;
				}
			}
			// 1.1.2 是下级MCU，递归到下级继续判断
			else
			{
				TMt tSubMt;
				wMcuIdx = GetMcuIdxFromMcuId( tNextMt.GetMtId() );
				tSubMt.SetMcuIdx( wMcuIdx );
				tSubMt.SetMtId( 1 );
				tSubMt.SetConfIdx(m_byConfIdx);
				return ProcHduBatchPollSwitch( tFirst, tSubMt, tHduChnlPollInfo, bFirstCycle, bIsNoFirstPoll );
			}
		}
		// 1.2 不在线终端也要占着通道
		if( m_tConfAllMtInfo.MtInConf(tNextMt.GetMtId()) && !m_tConfAllMtInfo.MtJoinedConf(tNextMt.GetMtId()))
		{
			ChangeHduSwitch( NULL, byEqpId, byChnlIdx, 0, TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP);
			TMt tOldMt = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx]; 
			tOldMt = GetLocalMtFromOtherMcuMt( tOldMt );
			if(!tOldMt.IsNull() && IsMtNotInOtherHduChnnl(tOldMt.GetMtId(), byEqpId, byChnlIdx)
				&& TYPE_MT == tOldMt.GetType())
			{					
				m_ptMtTable->SetMtInHdu(tOldMt.GetMtId(), FALSE);
				MtStatusChange(&tOldMt, TRUE);
			}    
			

			// [2013/03/11 chenbing] Mt不在线，也要切换当前模式为一风格
			CServMsg cSMg;
			u8 byHduMode = HDUCHN_MODE_ONE;
			cSMg.SetEqpId(byEqpId);
			cSMg.SetChnIndex(byChnlIdx);
			cSMg.SetMsgBody((u8 *)&byHduMode, sizeof(u8));
			SendChangeHduModeReq(cSMg);

			THduMember tHduMember;
	        memset(&tHduMember, 0x0, sizeof(THduMember));
			memcpy( &tHduMember, &tNextMt, sizeof(TMt) );
			tHduMember.byMemberType = TW_MEMBERTYPE_BATCHPOLL;
			tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx] = tHduMember;
			g_cMcuVcApp.SetPeriEqpStatus( byEqpId, &tHduStatus );
			cServMsg.SetMsgBody( (u8*)&tHduStatus, sizeof(tHduStatus) );
            SendMsgToAllMcs( MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg );

			// [pengjie 2010/9/27] 不在线终端上报状态刷图标
			RefreshMtStatusInTw(tNextMt, TRUE, TRUE);


			if( GetNextNeedPollMt( tNextMt, tNextChlNeedPollMt ) )
			{
				m_tHduBatchPollInfo.SetNextPollMt( tNextChlNeedPollMt );
				return TRUE;
			}
			else
			{
				// 表示重头开始轮询,并且本版面到此为止
				return FALSE;
			}
		}	
	}
	// 2、下级终端
	else
	{
		u8 byLoop = 0;
		TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(wMcuIdx);
		TConfMtInfo *ptConfMtInfo = m_tConfAllMtInfo.GetMtInfoPtr(wMcuIdx);
		if(ptMcInfo == NULL || (ptConfMtInfo == NULL /*&& ptConfMtInfo->GetMcuIdx() == wMcuIdx*/))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcHduMemberSwitchNew] GetMcInfo Or GetMtInfoPtr Failed! \n" );
			return FALSE;
		}

		// 如果终端不在受邀列表中，尝试下一个
		for( byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
		{
			if( ptConfMtInfo->MtInConf(tNextMt.GetMtId()) )
			{
				break;
			}
			else
			{
				tNextMt.SetMtId( byLoop+1 );
			}
		}
		TMt tSubMt;
		TMt tOldMt;
		THduMember tHduMember;
		for( byLoop = 0; byLoop < MAXNUM_CONF_MT; byLoop++ )
		{
			if( ptMcInfo->m_atMtExt[byLoop].GetMtId() == tNextMt.GetMtId() )
			{
				// 2.1 该级在线终端直接进
				if( ptConfMtInfo->MtJoinedConf(tNextMt.GetMtId()) )
				{
					// 该级在线终端直接进
					if( MT_TYPE_SMCU != ptMcInfo->m_atMtExt[byLoop].GetMtType() )
					{
						//Bug00161572:电视墙批量轮询无法轮询下级终端
						//yrl20131006下面注掉，因为TW_STATE_CHANGE状态全部改成TW_STATE_START状态
// 						// 直接进电视墙
// 						if ( bFirstCycle)
// 						{
// 							// [2013/03/11 chenbing] HDU多画面目前不支持批量轮询,子通道置0
// 							ChangeHduSwitch( &tNextMt, byEqpId, byChnlIdx, 0,\
// 								TW_MEMBERTYPE_BATCHPOLL, TW_STATE_START, MODE_BOTH, TRUE);
// 						}
// 						else
//						{
							// [2013/03/11 chenbing] HDU多画面目前不支持批量轮询,子通道置0
							ChangeHduSwitch( &tNextMt, byEqpId, byChnlIdx, 0,\
								TW_MEMBERTYPE_BATCHPOLL, TW_STATE_START, MODE_BOTH, TRUE);
//						}

						if( GetNextNeedPollMt( tNextMt, tNextChlNeedPollMt ) )
						{
							m_tHduBatchPollInfo.SetNextPollMt( tNextChlNeedPollMt );
							return TRUE;
						}
						else
						{
							// 表示重头开始轮询,并且本版面到此为止
							return FALSE;
						}
					}
					// 该终端为下级mcu，递归到下级去继续处理
					else
					{
						u8 abyMcuId[MAX_CASCADEDEPTH - 1];
						memset( &abyMcuId[0], 0, sizeof(abyMcuId) );
						if( m_tConfAllMcuInfo.GetMcuIdByIdx(ptMcInfo->m_atMtExt[byLoop].GetMcuIdx(), &abyMcuId[0]) )
						{
							abyMcuId[1] = ptMcInfo->m_atMtExt[byLoop].GetMtId();
							if( m_tConfAllMcuInfo.GetIdxByMcuId( &abyMcuId[0], MAX_CASCADEDEPTH - 1, &wMcuIdx ) )
							{
								tSubMt.SetMcuIdx(wMcuIdx);
								tSubMt.SetMtId(1);
								tSubMt.SetConfIdx(m_byConfIdx);
								return ProcHduBatchPollSwitch( tFirst, tSubMt, tHduChnlPollInfo, bFirstCycle, bIsNoFirstPoll );
							}
							else
							{
								ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "HduBatchPoll GetIdxByMcuId Failed mcu.%dmtid.%d\n", \
									tNextMt.GetMcuId(), tNextMt.GetMtId() );
								if( GetNextNeedPollMt( tNextMt, tNextChlNeedPollMt ) )
								{
									m_tHduBatchPollInfo.SetNextPollMt( tNextChlNeedPollMt );
									return TRUE;
								}
								else
								{
									return FALSE;
								}
							}
						}
						else
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "HduBatchPoll GetMcuIdByIdx Failed mcu.%dmt.id%d\n", \
								tNextMt.GetMcuId(), tNextMt.GetMtId() );
							if( GetNextNeedPollMt( tNextMt, tNextChlNeedPollMt ) )
							{
								m_tHduBatchPollInfo.SetNextPollMt( tNextChlNeedPollMt );
								return TRUE;
							}
							else
							{
								return FALSE;
							}
						}
					}
				}
				// 2.2 不在线的保留通道给它
				if( ptConfMtInfo->MtInConf(tNextMt.GetMtId()) && !ptConfMtInfo->MtJoinedConf(tNextMt.GetMtId()) )
				{
					ChangeHduSwitch( NULL, byEqpId, byChnlIdx, 0, TW_MEMBERTYPE_BATCHPOLL, TW_STATE_STOP);
					tOldMt = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx]; 
					if(!tOldMt.IsNull() && IsMtNotInOtherHduChnnl(tOldMt.GetMtId(), byEqpId, byChnlIdx)
						&& TYPE_MT == tOldMt.GetType())
					{					
						m_ptMtTable->SetMtInHdu(tOldMt.GetMtId(), FALSE);
						MtStatusChange(&tOldMt, TRUE);
					}    

					// [2013/03/11 chenbing] Mt不在线，也要切换当前模式为一风格
					CServMsg cSMsg;
					u8 byHduMode = HDUCHN_MODE_ONE;
					cSMsg.SetEqpId(byEqpId);
					cSMsg.SetChnIndex(byChnlIdx);
					cSMsg.SetMsgBody((u8 *)&byHduMode, sizeof(u8));
					SendChangeHduModeReq(cSMsg);
					
	                memset(&tHduMember, 0x0, sizeof(THduMember));
					memcpy( &tHduMember, &tNextMt, sizeof(TMt) );
					tHduMember.byMemberType = TW_MEMBERTYPE_BATCHPOLL;
					tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx] = tHduMember;
					g_cMcuVcApp.SetPeriEqpStatus( byEqpId, &tHduStatus );
					cServMsg.SetMsgBody( (u8*)&tHduStatus, sizeof(tHduStatus) );
					SendMsgToAllMcs( MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg );
					
					// [pengjie 2010/9/27] 不在线终端上报状态刷图标
					RefreshMtStatusInTw(tNextMt, TRUE, TRUE);

					if( GetNextNeedPollMt( tNextMt, tNextChlNeedPollMt ) )
					{
						m_tHduBatchPollInfo.SetNextPollMt( tNextChlNeedPollMt );
						return TRUE;
					}
					else
					{
						// 表示重头开始轮询,并且本版面到此为止
						return FALSE;
					}
				}
				break;
			}
		}
	}

	// [2013/07/30 chenbing] 修改Bug00149809
	// 没有查找到下级终端时，在上级继续向后查找,有可能新终端入会
	BOOL32 bRet = TRUE;
	if ( GetNextNeedPollMt( tNextMt, tNextChlNeedPollMt ))
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ProcHduBatchPollSwitch] PollNextMt(%d %d)\n", 
			tNextChlNeedPollMt.GetMcuId(), tNextChlNeedPollMt.GetMtId());
		// 查找到可轮询的终端则继续轮询
		m_tHduBatchPollInfo.SetNextPollMt( tNextChlNeedPollMt );
		bRet = ProcHduBatchPollSwitch( tFirst, tNextChlNeedPollMt, tHduChnlPollInfo, bFirstCycle, bIsNoFirstPoll );
	}
	else
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ProcHduBatchPollSwitch] Don't Find NextPollMt bIsNoFirstPoll(%d)\n", bIsNoFirstPoll);
		// 预案的第一个通道已经有终端占用，此次没有找到轮询的终端则直接返回
		if (bIsNoFirstPoll)
		{
			bRet = FALSE; 
		}
		else
		{
			// 当前查找的终端需要进预案的第一个通道,需要查找第一个轮询终端
			TMt tTmpFirst = tFirst;
			if (FindBatchPollMt(tTmpFirst))
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ProcHduBatchPollSwitch] PollFirstMt(%d %d)\n", tTmpFirst.GetMcuId(), tTmpFirst.GetMtId());
				//从查找到的终端开始轮询
				m_tHduBatchPollInfo.SetNextPollMt( tTmpFirst );
				ProcHduBatchPollSwitch( tFirst, tTmpFirst, tHduChnlPollInfo, bFirstCycle, bIsNoFirstPoll );
				bRet = TRUE;
			}
			else
			{
				// 没有可轮询的终端
				bRet = FALSE;
			}
		}
	}

	return bRet;
}

/*====================================================================
    函数名		：FindBatchPollMt
    功能		：查找可轮询的终端
    算法实现		：采用递归算法，若找到的为Mcu,则继续遍历此Mcu下有无可轮询终端，
				  没有找到可轮询终端则返回至上一级继续遍历
    引用全局变量：
    输入参数说明：[IN]const TMt &tCurrMt 当前轮询的终端
				  bIsFindNext: TRUE: 递归返回, FALSE: 正常调用
    返回值说明  ：BOOL32 TRUE：找到可轮询的终端，FALSE:没有找到可轮询的终端
	
	场景举例:
	第一级呼入二级Mcu(A),二级Mcu(A)下呼入三级Mcu(C),三级Mcu(C)下呼入终端,
	一级再呼入另一二级Mcu(B).第一次批量轮询完成后,有可能需要从头开始轮询,
	所以,需要遍历所有Mcu下是否有可轮询终端
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	20130730    4.7         陈兵           create
====================================================================*/
BOOL32 CMcuVcInst::FindBatchPollMt(TMt& tCurrt, BOOL32 bIsFindNext/* = FALAE*/)
{
	TMt tNextMt;
	TMt tTempPollMt = tCurrt;
	u16 wMcuIdx = 0xFFFF;

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[FindBatchPollMt] bIsFindNext(%d) IsLocal(%d) FirstMt(%d %d)\n", 
		bIsFindNext, tTempPollMt.IsLocal(),	tTempPollMt.GetMcuId(), tTempPollMt.GetMtId());

	if (tTempPollMt.IsLocal())
	{
		u8 byLoop = 1;
		if( (tTempPollMt.GetMtId() + 1) > MAXNUM_CONF_MT )
		{
			return FALSE;
		}

		// 下级递归返回上来的,需要给Mt+1,继续向后查找下一个
		if (bIsFindNext)
		{
			byLoop = tTempPollMt.GetMtId() + 1;
		}
		else
		{
			byLoop = tTempPollMt.GetMtId();
		}
				
		for( ; byLoop <= MAXNUM_CONF_MT; byLoop++ )
		{
			if ( m_tConfAllMtInfo.MtInConf(byLoop) )
			{
				if (MT_TYPE_SMCU == m_ptMtTable->GetMt(byLoop).GetMtType())
				{
					wMcuIdx = GetMcuIdxFromMcuId( byLoop );
					tTempPollMt.SetMcuIdx(wMcuIdx);
					tTempPollMt.SetMtId(1);
					tTempPollMt.SetConfIdx(m_byConfIdx);
					//递归到下级Mcu去查找有无轮询的终端
					if (FindBatchPollMt(tTempPollMt))
					{
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[FindBatchPollMt] LOCAL MCU PollMt(%d %d)\n", 
							 tTempPollMt.GetMcuId(), tTempPollMt.GetMtId());
						return TRUE;
					}
					else
					{
						continue;
					}
				}
				else if (m_ptMtTable->GetMtType(byLoop) == MT_TYPE_VRSREC)
				{
					// 过滤vrs新录播
					continue;
				}
				else
				{
					tCurrt = m_ptMtTable->GetMt( byLoop );
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[FindBatchPollMt] IsLocal PollMt(%d %d)\n", 
							 tCurrt.GetMcuId(), tCurrt.GetMtId());
					return TRUE;
				}
			}
		}

		return FALSE;
	}
	else
	{
		u8 byIndex = 1;
		TConfMtInfo *ptConfMtInfo = m_tConfAllMtInfo.GetMtInfoPtr(tCurrt.GetMcuIdx());
		TConfMcInfo *ptConfMcInfo = m_ptConfOtherMcTable->GetMcInfo(tCurrt.GetMcuIdx());

		// 下级递归返回上来的,需要给Mt+1,继续向后查找下一个
		if (bIsFindNext)
		{
			byIndex = tTempPollMt.GetMtId() + 1;
		}
		else
		{
			byIndex = tTempPollMt.GetMtId();
		}

		for( ; byIndex <= MAXNUM_CONF_MT; byIndex++ )
		{
			if( NULL != ptConfMtInfo
				&& NULL != ptConfMcInfo 
				&& ptConfMtInfo->GetMcuIdx() == tCurrt.GetMcuIdx() 
				&& ptConfMtInfo->MtJoinedConf( byIndex )
			  )
			{
				if(MT_TYPE_SMCU == ptConfMcInfo->m_atMtExt[byIndex].GetMtType())
				{
					u8 abyMcuId[MAX_CASCADEDEPTH - 1] = {0};
					if( m_tConfAllMcuInfo.GetMcuIdByIdx(ptConfMcInfo->m_atMtExt[byIndex].GetMcuIdx(), &abyMcuId[0]) )
					{
						abyMcuId[1] = ptConfMcInfo->m_atMtExt[byIndex].GetMtId();
						if( m_tConfAllMcuInfo.GetIdxByMcuId( &abyMcuId[0], MAX_CASCADEDEPTH - 1, &wMcuIdx ) )
						{
							tTempPollMt.SetMcuIdx(wMcuIdx);
							tTempPollMt.SetMtId(1);
							tTempPollMt.SetConfIdx(m_byConfIdx);
							//递归到下级Mcu去查找有无轮询的终端
							if (FindBatchPollMt(tTempPollMt))
							{
								ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[FindBatchPollMt] SMCU SMCU PollMt(%d %d)\n", 
										tTempPollMt.GetMcuId(), tTempPollMt.GetMtId());
								return TRUE;
							}
						}
					}
				}
				else
				{
					tNextMt = tCurrt;
					tNextMt.SetMtId( byIndex );
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[FindBatchPollMt] SMCU PollMt(%d %d)\n", 
							 tNextMt.GetMcuId(), tNextMt.GetMtId());
					return TRUE;
				}
			}
		}
		
		// 该级mcu已经没有要轮询的终端了，回到上级去找
		TMt tMt;
		tMt.SetConfIdx(m_byConfIdx);
		u8 bySize = MAX_CASCADEDEPTH - 1;
		u8 abyMcuMcuId[MAX_CASCADEDEPTH - 1];
		memset( abyMcuMcuId, 0 , sizeof(abyMcuMcuId) );
		if( !m_tConfAllMcuInfo.GetMcuIdByIdx( tCurrt.GetMcuIdx(), abyMcuMcuId ) )
		{
			return FALSE;
		}
		u8 byCascEdepth = 1;
		for( ; byCascEdepth < bySize; byCascEdepth++ )
		{
			if( abyMcuMcuId[bySize - byCascEdepth] != 0 )
			{
				tMt.SetMtId( abyMcuMcuId[bySize - byCascEdepth] );
				tMt.SetMcuIdx( GetMcuIdxFromMcuId(abyMcuMcuId[bySize - byCascEdepth - 1]) );
				break;
			}
			
			if( abyMcuMcuId[bySize - byCascEdepth] == 0 && abyMcuMcuId[bySize - byCascEdepth - 1] != 0  )
			{
				if( (bySize - byCascEdepth - 1) == 0 )
				{
					tMt.SetMtId( abyMcuMcuId[bySize - byCascEdepth - 1] );
					tMt.SetMcuIdx( LOCAL_MCUIDX );
					break;
				}
			}
		}

		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[FindBatchPollMt] return FindBatchPollMt(%d %d) byCascEdepth(%d) bySize(%d)\n", 
				tMt.GetMcuId(), tMt.GetMtId(), byCascEdepth, bySize);

		if( byCascEdepth == bySize )
		{
			return FALSE;
		}
		
		// 递归回到上级去找
		return FindBatchPollMt( tMt, TRUE );
	}
}

/*====================================================================
    函数名      ：GetNextNeedPollMt
    功能        ：得到下一个需要轮询的终端
    算法实现    ：采用递归算法，从当前终端往后遍历，找到下一个轮询终端
	              如果本级以及找完，就回到上级去找
    引用全局变量：
    输入参数说明：[IN]const TMt &tCurrMt 当前轮询的终端
	              [OUT] 下一个轮询的终端
    返回值说明  ：BOOL32 FALSE:当前已经轮询到整个会议的最后一个终端
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	20100828    4.6         彭杰           create
====================================================================*/
BOOL32 CMcuVcInst::GetNextNeedPollMt( const TMt &tCurrMt, TMt &tNextMt )
{
	TMt tMt;
	tMt.SetConfIdx(m_byConfIdx);

	u8 byLoop = 0;
	// 1、该终端为本地终端
	// [pengjie 2010/9/27] 如果会议不支持多回传，则不用轮询下级mcu下的终端
	if( tCurrMt.IsLocal() || ( !tCurrMt.IsLocal() && !IsLocalAndSMcuSupMultSpy(tCurrMt.GetMcuId()) ) )
	{
		if( (tCurrMt.GetMtId() + 1) > MAXNUM_CONF_MT )
		{
			return FALSE;
		}

		for( byLoop = (tCurrMt.GetMtId() + 1); byLoop <= MAXNUM_CONF_MT; byLoop++ )
		{
			if( m_tConfAllMtInfo.MtInConf(byLoop) )
			{
				if (m_ptMtTable->GetMtType(byLoop) == MT_TYPE_VRSREC)
				{
					continue;
				}

				tNextMt = m_ptMtTable->GetMt( byLoop );
				return TRUE;
			}
		}
		return FALSE;
	}
	// 2、该终端为下级
	else
	{
		//TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tCurrMt.GetMcuIdx());
		TConfMtInfo *ptConfMtInfo = m_tConfAllMtInfo.GetMtInfoPtr(tCurrMt.GetMcuIdx());

		for( byLoop = (tCurrMt.GetMtId() + 1); byLoop <= MAXNUM_CONF_MT; byLoop++ )
		{
			if( ptConfMtInfo != NULL 
				// [8/29/2011 liuxu] 如果tcurmt所在mcu被挂断了, 那么ptConfMtInfo的mcuidx将为非法值
				&& ptConfMtInfo->GetMcuIdx() == tCurrMt.GetMcuIdx() 
				&& ptConfMtInfo->MtInConf( byLoop) )
			{
				tNextMt = tCurrMt;
				tNextMt.SetMtId( byLoop );
				return TRUE;
			}
		}

		// 该级mcu已经没有要轮询的终端了，回到上级去找
		u8 bySize = MAX_CASCADEDEPTH - 1;
		u8 abyMcuMcuId[MAX_CASCADEDEPTH - 1];
		memset( abyMcuMcuId, 0 , sizeof(abyMcuMcuId) );
		if( !m_tConfAllMcuInfo.GetMcuIdByIdx( tCurrMt.GetMcuIdx(), abyMcuMcuId ) )
		{
			return FALSE;
		}
		for( byLoop = 1; byLoop < bySize; byLoop++ )
		{
			if( abyMcuMcuId[bySize - byLoop] != 0 )
			{
				tMt.SetMtId( abyMcuMcuId[bySize - byLoop] );
				tMt.SetMcuIdx( GetMcuIdxFromMcuId(abyMcuMcuId[bySize - byLoop - 1]) );
				break;
			}
			
			if( abyMcuMcuId[bySize - byLoop] == 0 && abyMcuMcuId[bySize - byLoop - 1] != 0  )
			{
				if( (bySize - byLoop - 1) == 0 )
				{
					tMt.SetMtId( abyMcuMcuId[bySize - byLoop - 1] );
					tMt.SetMcuIdx( LOCAL_MCUIDX );
					break;
				}
			}
		}
		if( byLoop == bySize )
		{
			return FALSE;
		}
		// 递归回到上级去找
		return GetNextNeedPollMt( tMt, tNextMt );
	}
}


/*====================================================================
函数名      ：FindConfHduHduChnnlAndStop
功能        ：按照通道成员类型或成员来停止到所在的电视墙通道的交换
算法实现    ：(1) 如果byTvwMemberType为TW_MEMBERTYPE_NULL，ptTvwMember为空，则停止会议所占用的所有电视墙交换
			  (2) 如果byTvwMemberType为TW_MEMBERTYPE_NULL，ptTvwMember不为空，则停ptTvwMember所在的所有通道交换
			  (3) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptTvwMember为空，则停通道类型为byTvwMemberType的所有交换
			  (4) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptTvwMember不为空，
			      则停通道类型为byTvwMemberType且成员为ptTvwMember的所有交换
引用全局变量：
输入参数说明：[IN]	byTvwMemberType : 电视墙通道成员类型
			  [IN]  ptTvwMember		: 电视墙通道成员
			  [IN]  bStopRunning	: 找到符合条件的通道时是否停止它的运行
返回值说明  ：无
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
12/06/15               周晶晶         创建
====================================================================*/
void CMcuVcInst::FindConfTvWallChnnlAndStop( TMt* const ptTvwMember /*= NULL*/, 
								  const u8 byTvwMemberType /*= TW_MEMBERTYPE_NULL*/,
								  const BOOL32 bStopRunning /*= FALSE*/ )
{
	TPeriEqpStatus tTwStatus;   
	u8 byChnId = 0;
	BOOL32 bNeedStop, bStatusChanged;				// 是否需要停止交换, 以及设备状态是否发生了变化 发送外设状态变化通知时需要用
	TTWMember tMember;
	CServMsg cServMsg;								
	u8 byTwOrHduChnNum = 0;

	for (u8 byTWId = TVWALLID_MIN; byTWId <=  TVWALLID_MAX; byTWId++)
	{		
		bStatusChanged = FALSE;
		if ( !g_cMcuVcApp.IsPeriEqpValid(byTWId)  )
		{
			continue;
		}

		if( !g_cMcuVcApp.GetPeriEqpStatus(byTWId, &tTwStatus))
		{
			continue;
		}
		if( tTwStatus.m_byOnline == 0 )
		{
			continue;
		}
		byTwOrHduChnNum = tTwStatus.m_tStatus.tTvWall.byChnnlNum;
		for (byChnId = 0; byChnId < min(byTwOrHduChnNum,MAXNUM_PERIEQP_CHNNL); byChnId++)
		{	
			// 获取成员会议号
			tMember = tTwStatus.m_tStatus.tTvWall.atVideoMt[byChnId];
					
			// 非本会议成员，continue
			if (m_byConfIdx != tMember.GetConfIdx())
			{
				continue;
			}

			bNeedStop = FALSE;					// ????bNeedStop

			if ( TW_MEMBERTYPE_NULL == byTvwMemberType)
			{
				if ( NULL == ptTvwMember || ptTvwMember->IsNull() )
				{
					// (1) 如果byTvwMemberType为TW_MEMBERTYPE_NULL，ptTvwMember为空，
					// 则停止会议所占用的所有电视墙交换
					bNeedStop = TRUE;
				}
				else
				{
					if ( *ptTvwMember == tMember)
					{
						// (2) 如果byTvwMemberType为TW_MEMBERTYPE_NULL，ptTvwMember不为空，
						// 则停ptTvwMember所在的所有通道交换
						bNeedStop = TRUE;
					}
				}
			}
			else
			{
				if ( byTvwMemberType != tMember.byMemberType)
				{
					continue;
				}

				if ( NULL == ptTvwMember || ptTvwMember->IsNull() )
				{
					// (3) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptTvwMember为空，
					// 则停通道类型为byTvwMemberType的所有交换
					bNeedStop = TRUE;
				}else
				{
					if ( *ptTvwMember == tMember)
					{
						//(4) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptTvwMember不为空，
						// 则停通道类型为byTvwMemberType且成员为ptTvwMember的所有交换
						bNeedStop = TRUE;
					}
				}
			}

			if (bNeedStop)
			{
				if (bStopRunning)
				{
					ChangeTvWallSwitch(ptTvwMember, byTWId, byChnId, byTvwMemberType, TW_STATE_STOP);

					// 这里不更改bStatusChanged, 因为ChangeHduSwitch内会发送该通知
				}else
				{
					// 仅停交换
					StopSwitchToPeriEqp(byTWId, byChnId);
					tTwStatus.m_tStatus.tTvWall.atVideoMt[byChnId].byMemberType = 0;
					tTwStatus.m_tStatus.tTvWall.atVideoMt[byChnId].SetNull();
					tTwStatus.m_tStatus.tTvWall.atVideoMt[byChnId].SetConfIdx(0);
					
					bStatusChanged |= TRUE;
				}
			}
		}

		if (bStatusChanged)
		{
			g_cMcuVcApp.SetPeriEqpStatus(byTWId, &tTwStatus);

			cServMsg.SetMsgBody((u8 *)&tTwStatus, sizeof(tTwStatus));
			SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
		}		
	}
}


/*====================================================================
函数名      ：FindConfHduHduChnnlAndStop
功能        ：按照通道成员类型或成员来停止到所在的电视墙通道的交换
算法实现    ：(1) 如果byTvwMemberType为TW_MEMBERTYPE_NULL，ptTvwMember为空，则停止会议所占用的所有电视墙交换
			  (2) 如果byTvwMemberType为TW_MEMBERTYPE_NULL，ptTvwMember不为空，则停ptTvwMember所在的所有通道交换
			  (3) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptTvwMember为空，则停通道类型为byTvwMemberType的所有交换
			  (4) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptTvwMember不为空，
			      则停通道类型为byTvwMemberType且成员为ptTvwMember的所有交换
引用全局变量：
输入参数说明：[IN]	byTvwMemberType : 电视墙通道成员类型
			  [IN]  ptTvwMember		: 电视墙通道成员
			  [IN]  bStopRunning	: 找到符合条件的通道时是否停止它的运行
返回值说明  ：无
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/07/21                刘旭          创建
====================================================================*/
void CMcuVcInst::FindConfHduHduChnnlAndStop( TMt* const ptTvwMember /*= NULL*/, 
								  const u8 byTvwMemberType /*= TW_MEMBERTYPE_NULL*/,
								  const BOOL32 bStopRunning /*= FALSE*/ )
{
	TPeriEqpStatus tHduStatus;						// Hdu设备状态
	u8 byHduChnNum;									// Hdu通道数目
	
	BOOL32 bNeedStop, bStatusChanged;				// 是否需要停止交换, 以及设备状态是否发生了变化
	CServMsg cServMsg;								// 发送外设状态变化通知时需要用
	THduMember tMember;
	// 依次遍历所有hdu的所有通道, 如果符合要求,则停止该通交换
	for( u8 byHduId = HDUID_MIN; byHduId <= HDUID_MAX; byHduId++ )
	{
		bStatusChanged = FALSE;						// 重置, 该设备状态未发生改变

		if (g_cMcuVcApp.IsPeriEqpValid(byHduId) 
			&& g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus))
		{
			if (tHduStatus.m_byOnline == 1)
			{
				byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduId));
				if (0 == byHduChnNum)
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[StopSpecTvwChnnl] GetHduChnNumAcd2Eqp failed!\n");
					continue;
				}
				
				for(u8 byLoop = 0; byLoop < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byLoop++)
				{
					// 获取成员会议号
					tMember = tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop];
					
					// 非本会议成员，continue
					if (m_byConfIdx != tMember.GetConfIdx())
					{
						continue;
					}

					bNeedStop = FALSE;					// 重置bNeedStop

					if ( TW_MEMBERTYPE_NULL == byTvwMemberType)
					{
						if ( NULL == ptTvwMember || ptTvwMember->IsNull() )
						{
							// (1) 如果byTvwMemberType为TW_MEMBERTYPE_NULL，ptTvwMember为空，
							// 则停止会议所占用的所有电视墙交换
							bNeedStop = TRUE;
						}else
						{
							if ( *ptTvwMember == tMember)
							{
								// (2) 如果byTvwMemberType为TW_MEMBERTYPE_NULL，ptTvwMember不为空，
								// 则停ptTvwMember所在的所有通道交换
								bNeedStop = TRUE;
							}
						}
					}else
					{
						if ( byTvwMemberType != tMember.byMemberType)
						{
							continue;
						}

						if ( NULL == ptTvwMember || ptTvwMember->IsNull() )
						{
							// (3) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptTvwMember为空，
							// 则停通道类型为byTvwMemberType的所有交换
							bNeedStop = TRUE;
						}else
						{
							if ( *ptTvwMember == tMember)
							{
								//(4) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptTvwMember不为空，
								// 则停通道类型为byTvwMemberType且成员为ptTvwMember的所有交换
								bNeedStop = TRUE;
							}
						}
					}

					if (bNeedStop)
					{
						if (bStopRunning)
						{
							// [2013/03/11 chenbing] HDU多画面不支持选看VMP
							ChangeHduSwitch(NULL, byHduId, byLoop, 0, byTvwMemberType, TW_STATE_STOP);

							// 这里不更改bStatusChanged, 因为ChangeHduSwitch内会发送该通知
						}else
						{
							// 仅停交换
							StopSwitchToPeriEqp(byHduId, byLoop);
							tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop].byMemberType = 0;
							tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop].SetNull();
							tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop].SetConfIdx(0);
							
							bStatusChanged |= TRUE;
						}
					}
				}

				if (bStatusChanged)
				{
					g_cMcuVcApp.SetPeriEqpStatus(byHduId, &tHduStatus);

					cServMsg.SetMsgBody((u8 *)&tHduStatus, sizeof(tHduStatus));
					SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
				}
			}
		}
	}					
}


/*====================================================================
函数名      ：FindConfHduChnnlAndReplace
功能        ：遍历所有电视墙通道,如果其成员符合ptOldTvwMember或byTvwMemberType,则更改交换
算法实现    ：(1) 如果byTvwMemberType为TW_MEMBERTYPE_NULL，ptOldTvwMember为空，
                  那么无任何动作
			  (2) 如果byTvwMemberType为TW_MEMBERTYPE_NULL，ptOldTvwMember不为空，
			      则用ptNewTvwMember替换ptOldTvwMember所在的通道
			  (3) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptOldTvwMember为空，
			      则用ptNewTvwMember替换所有通道类型为byTvwMemberType的通道
			  (4) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptOldTvwMember不为空，
			      则停通道类型为byTvwMemberType且成员为ptTvwMember的所有交换
引用全局变量：
输入参数说明：[IN]	ptNewTvwMember	: 新成员
			  [IN]  ptOldTvwMember	: 旧成员
			  [IN]  byTvwMemberType	: 通道成员类型
			  [IN]  byMediaMode		: 媒体模式
返回值说明  ：无
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/07/21                刘旭          创建
====================================================================*/
void CMcuVcInst::FindConfHduChnnlAndReplace( TMt* const ptNewTvwMember,
		TMt* const ptOldTvwMember /*= NULL*/, 		
		const u8 byTvwMemberType /*= TW_MEMBERTYPE_NULL*/,
		const u8 byMediaMode /*= MODE_BOTH*/ )
{
	if ( !ptNewTvwMember || ptNewTvwMember->IsNull() )
	{
		ConfPrint( LOG_LVL_WARNING, MID_MCU_HDU, "FindConfHduChnnlAndReplace: the ptNewTvwMember is null\n");
		return;
	}

	if (NULL != ptNewTvwMember)
	{
		ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_HDU, "tNewSrc(%d %d)\n", ptNewTvwMember->GetMcuId(), ptNewTvwMember->GetMtId());
	}

	if ( (!ptOldTvwMember || ptOldTvwMember->IsNull()) 
		&& TW_MEMBERTYPE_NULL == byTvwMemberType)
	{
		ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_HDU, "FindConfHduChnnlAndReplace: invalid type and old member\n");
		return;
	}

	if (NULL != ptOldTvwMember)
	{
		ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_HDU, "tOldSrc(%d %d)\n", ptOldTvwMember->GetMcuId(), ptOldTvwMember->GetMtId());
	}


	TPeriEqpStatus tHduStatus;						// Hdu设备状态
	u8 byHduChnNum;									// Hdu通道数目
	BOOL32 bNeedReplace;							// 是否可替换
	THduMember tMember;
	u8 byMemberType = byTvwMemberType;				//用于调用changehduswitch传参

	// 依次遍历所有hdu的所有通道, 如果符合要求,则替换
	for( u8 byHduId = HDUID_MIN; byHduId <= HDUID_MAX; byHduId++ )
	{
		if (g_cMcuVcApp.IsPeriEqpValid(byHduId) 
			&& g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus))
		{
			if (tHduStatus.m_byOnline == 1)
			{
				byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduId));
				if (0 == byHduChnNum)
				{
					ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "GetHduChnNumAcd2Eqp failed!\n");
					continue;
				}
				
				for(u8 byLoop = 0; byLoop < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byLoop++)
				{
					// 获取成员会议号
					tMember = tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop];
					
					// 非本会议成员，continue
					if (m_byConfIdx != tMember.GetConfIdx())
					{
						continue;
					}

					bNeedReplace = FALSE;					// 重置bNeedReplace

					if ( TW_MEMBERTYPE_NULL == byTvwMemberType)
					{
						if ( ptOldTvwMember 
							&& !ptOldTvwMember->IsNull() 
							&& *ptOldTvwMember == tMember )
						{
							// (2) 如果byTvwMemberType为TW_MEMBERTYPE_NULL，ptOldTvwMember不为空，
							// 则用ptNewTvwMember替换ptOldTvwMember所在的通道
							bNeedReplace = TRUE;
							byMemberType = tMember.byMemberType;	//传入空type时，替换通道成员，保留type
						}
						ConfPrint( LOG_LVL_DETAIL, MID_MCU_HDU, "byTvwMemberType == TW_MEMBERTYPE_NULL\n");
					}
					else
					{
						if ( byTvwMemberType != tMember.byMemberType)
						{
							continue;
						}

						if ( NULL == ptOldTvwMember || ptOldTvwMember->IsNull() )
						{
							// (3) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptOldTvwMember为空，
							// 则用ptNewTvwMember替换所有通道类型为byTvwMemberType的通道
							bNeedReplace = TRUE;
						}
						else
						{
							if ( *ptOldTvwMember == tMember)
							{
								// (4) 如果byTvwMemberType不为TW_MEMBERTYPE_NULL，ptOldTvwMember不为空，
								// 则停通道类型为byTvwMemberType且成员为ptTvwMember的所有交换
								bNeedReplace = TRUE;
							}
						}
					}

					ConfPrint( LOG_LVL_DETAIL, MID_MCU_HDU, "bNeedReplace(%d)\n", bNeedReplace);
					if (bNeedReplace)
					{
						// [2013/03/11 chenbing] HDU多画面不支持选看VMP
						ChangeHduSwitch(ptNewTvwMember, byHduId, byLoop, 0, byMemberType, TW_STATE_START, byMediaMode);
					}
				}
			}
		}
	}					
}

u8 CMcuVcInst::GetHduChnnlRealMode( const u8 byHduId, const u8 byChidx)
{
	u8 byRet = MODE_NONE;

    TPeriEqpStatus tHduStatus;    
	if (!g_cMcuVcApp.IsPeriEqpValid( byHduId ) || !g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus))
	{
		return MODE_NONE;
	}
	if (byChidx >= MAXNUM_HDU_CHANNEL)
	{
		return MODE_NONE;
	} 
	THduMember tHduMenber = tHduStatus.m_tStatus.tHdu.atVideoMt[byChidx];
    if (tHduMenber.GetConfIdx() != 0 && tHduMenber.GetConfIdx() != m_byConfIdx)
    {
        return MODE_NONE;
    }

	//u8 byHduOutputMode = tHduStatus.m_tStatus.tHdu.byOutputMode;
	return MODE_NONE;
}

/*====================================================================
    函数名      ：ChangeHduSwitch
    功能        ：开始向Hdu交换参数
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt * ptSrc, 源
                  u8 byEqpId,
                  u8 byChnlIdx, 
				  u8 byHduSubChnId,(添加子通道)
				  u8 byHduMemberType 成员类型
                  u8 byState 
                  BOOL32 bNotify :是否向电视墙外设发送停止消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/01/19    4.6.1       江乐斌        创建
	11/09/19    4.6.2       liuxu         修改
	2013/03/11  4.7.2       陈兵          修改(HDU多画面支持)
====================================================================*/
BOOL32 CMcuVcInst::ChangeHduSwitch(TMt* /*const*/ ptSrc, 
								 const u8 byHduId, 
								 const u8 byChnlIdx, 
								 const u8 byHduSubChnId,
								 const u8 byHduMemberType, 
								 const u8 byState, 
								 const u8 byMode/* = MODE_BOTH*/, 
								 const BOOL32 bBatchPoll/* = FALSE*/,
								 const BOOL32 bCanSendStopPlayMsg/* = TRUE*/,
								 const BOOL32 bNeedPreSetin /*= TRUE */,
								 const u8 byMulitModeHdu/*= HDUCHN_MODE_ONE */
								 )
{

	BOOL32	bIsDoubleStream = FALSE;

	if (byChnlIdx >= MAXNUM_HDU_CHANNEL)
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_HDU, "[ChangeHduSwitch]ptSrc is Null || byChnlIdx(%d) >= MAXNUM_HDU_CHANNEL(%d)!\n",
			byChnlIdx , MAXNUM_HDU_CHANNEL);
		return FALSE;
	}
	
    TPeriEqpStatus tHduStatus;    
	if (!g_cMcuVcApp.IsPeriEqpValid( byHduId ) || !g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus))
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[ChangeHduSwitch]fail to get status(hduid:%d)(IsValid:%d) \n", byHduId,g_cMcuVcApp.IsPeriEqpValid( byHduId ));
		return FALSE;
	}

	// [2013/03/11 chenbing]  
	u8 byConfIdx = tHduStatus.m_tStatus.tHdu.GetConfIdx(byChnlIdx, byHduSubChnId);
	if (byConfIdx != 0 && byConfIdx != m_byConfIdx)
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_HDU,"[CMcuVcInst] HDU(%d) CHN(%d) is used by ConfIdx(%d)",byHduId,byChnlIdx,tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].GetConfIdx());
        return FALSE;
    }

	//子通道是否合法
	if (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdx)
		|| HDUCHN_MODE_FOUR == byMulitModeHdu)
	{
		if (byHduSubChnId >= HDU_MODEFOUR_MAX_SUBCHNNUM)
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_HDU,"[CMcuVcInst] HDU(%d) SubChn(%d) is valid",byHduId, byHduSubChnId);
			return FALSE;
		}
	}
	
	// [2013/04/22 chenbing] HDU2不能两个通道同时开启多画面 
	if ( HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdx, TRUE)
		 && (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdx)
		    || HDUCHN_MODE_FOUR == byMulitModeHdu)
	   )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_HDU,"[CMcuVcInst] Two HDUChnnl Mode is same( HDU-VMP )!\n");
		//不能同时开启两个通道为画面合成
		NotifyMcsAlarmInfo(0, ERR_MCU_RESOURCES_NOT_ENOUGH);
		return FALSE;
	}

	if (!tHduStatus.m_byOnline)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_HDU,"HDU(%d) is offline\n", byHduId );
		return FALSE;
	}

//VCS会议下，先将终端进电视墙再呼叫终端，因为下面返回，则交换未建。
//yrl20131105此处将if整段注掉，主要是该处判断新旧源相同则返回，会造成很多bug。
//  CServMsg  cServMsg;
// 	TMt tOrgMt = (TMt)tHduStatus.m_tStatus.tHdu.GetChnMt( byChnlIdx, byHduSubChnId );
// 	if ( NULL != ptSrc
// 		&& !ptSrc->IsNull()
// 		&& ( *ptSrc == tOrgMt /*新源与通道源相同时的处理*/
// 		   || *ptSrc == GetSMcuViewMt(tOrgMt, TRUE)
// 		   || tOrgMt == GetSMcuViewMt(*ptSrc, TRUE)
// 		   )
// 		)
// 	{
// 		// 新的成员类型为选看双流模式 或 旧的成员类型为双流选看模式则进行正常切换
// 		if (  TW_MEMBERTYPE_DOUBLESTREAM == byHduMemberType
// 		   || TW_MEMBERTYPE_DOUBLESTREAM == tHduStatus.m_tStatus.tHdu.GetMemberType(byChnlIdx, byHduSubChnId)
// 		   )
// 		{
// 			ConfPrint(LOG_LVL_DETAIL, MID_MCU_HDU, "[ChangeHduSwitch] Change DoubleStreamSelect!\n");
// 		}
// 		else
// 		{
// 			// [2013/10/10 chenbing] 通道中的终端相同时直接return
// 			// 防止相同终端再次开启外设，致使外设调用SetLocalNetParam时会丢帧
// 			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_HDU, "[CMcuVcInst] NewMt and OldMt is same so return!\n");
// 			tHduStatus.m_tStatus.tHdu.SetMemberType(byHduMemberType, byChnlIdx, byHduSubChnId);
// 			tHduStatus.m_tStatus.tHdu.SetChnMt(*ptSrc, byChnlIdx, byHduSubChnId);
// 			g_cMcuVcApp.SetPeriEqpStatus( byHduId, &tHduStatus );
// 			cServMsg.SetMsgBody((u8 *)&tHduStatus, sizeof(tHduStatus));
// 			SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
// 			if(IsMcu(*ptSrc) && tOrgMt == GetSMcuViewMt(*ptSrc, TRUE))
// 			{
// 				RefreshMtStatusInTw(*ptSrc, TRUE, TRUE);
// 			}
// 			if (IsMcu(tOrgMt) && *ptSrc == GetSMcuViewMt(tOrgMt, TRUE))
// 			{
// 				RefreshMtStatusInTw(tOrgMt, FALSE, TRUE);
// 			}
// 			return FALSE;
// 		}
// 	}

	// [9/28/2011 liuxu] hdu通道的实际模式保存在VcData中
	u8 byOldMode = g_cMcuVcApp.GetChnnlMMode( byHduId, byChnlIdx );
	
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_HDU, "[ChangeHduSwitch] HduSwitch Src[%d,%d] to [%d,%d], state.%d, mode.%d, oldmode.%d\n", 
		ptSrc ? ptSrc->GetMcuIdx() : 0, ptSrc ? ptSrc->GetMtId() : 0,
		byHduId, byChnlIdx,	byState, byMode, byOldMode);

	CServMsg      cServMsg;
	u8 byVmpOutChl = 0xff;
	if (ptSrc != NULL 
		&& !ptSrc->IsNull() 
		&& TW_STATE_START == byState
		&& MODE_AUDIO != byMode)
	{
		//hdu能力检测
		bIsDoubleStream = (TW_MEMBERTYPE_DOUBLESTREAM == byHduMemberType)? TRUE:FALSE;
		if(!CheckHduAbility(*ptSrc, byHduId, byChnlIdx, &byVmpOutChl, bIsDoubleStream))
		{
			// [pengjie 2010/10/12] HDU能力校验不过时，释放本次及之前该通道的回传资源
			TMt tOldChlMt = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx];
			if(!tOldChlMt.IsNull()	
				&& TYPE_MT == tOldChlMt.GetType() 
				&& IsMtNotInOtherHduChnnl(tOldChlMt, byHduId, byChnlIdx))
			{
				TMtStatus tStatus;
				GetMtStatus(tOldChlMt, tStatus);
				tStatus.SetInHdu(FALSE);
				SetMtStatus(tOldChlMt, tStatus);
				MtStatusChange(&tOldChlMt, TRUE);
			}
			
			// [12/29/2010 liuxu][走读]不可能stop
			// 2011-7-8 modify by peng guofeng : 多余条件删除
			if( !( tOldChlMt == *ptSrc) )
			{
				// 尝试释放之前该通体内的回传资源（如果是多回传的话）
				if (!tOldChlMt.IsNull() && !tOldChlMt.IsLocal())
				{
					FreeRecvSpy( tOldChlMt, byOldMode );
				}

				// 尝试释放这次占用的回传资源
				//zjj20100104 这里要释放的原因是因为mcs的消息发过来进墙消息时会不调用这个函数
				//而是直接presetin一次，所以此时bNeedPreSetin为false表示已经presetin一次,所以
				//如果不能进墙也要相应free一次
				if( FALSE == bNeedPreSetin )
				{
					FreeRecvSpy( *ptSrc, byMode );
				}
			}
			// End

			TMt tOldMt = tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx];
			if(  TW_MEMBERTYPE_SPEAKER == byHduMemberType ||
				TW_MEMBERTYPE_CHAIRMAN == byHduMemberType ||
				TW_MEMBERTYPE_POLL == byHduMemberType ||
				TW_MEMBERTYPE_BATCHPOLL == byHduMemberType	||
				TW_MEMBERTYPE_TWPOLL == byHduMemberType	||
				TW_MEMBERTYPE_MCSSPEC == byHduMemberType ||
				TW_MEMBERTYPE_VCSSPEC == byHduMemberType ||
				TW_MEMBERTYPE_VCSAUTOSPEC == byHduMemberType ||
				TW_MEMBERTYPE_SWITCHVMP == byHduMemberType
				)
			{			
				//会控指定或vcs指定下不显示当前通道成员(规格)
				switch (byHduMemberType)
				{
				case TW_MEMBERTYPE_SPEAKER:
				case TW_MEMBERTYPE_CHAIRMAN:
				case TW_MEMBERTYPE_POLL:
				case TW_MEMBERTYPE_BATCHPOLL:
				case TW_MEMBERTYPE_TWPOLL:
					tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].SetNull();
					tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].SetConfIdx(m_byConfIdx);
					tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType = byHduMemberType;
					break;
					
				default:
					tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].SetNull();
					tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].SetConfIdx(0);
					tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType = TW_MEMBERTYPE_NULL;
					break;
				}

				// [10/28/2011 liuxu] 预览电视墙模式下终端显示在墙里面
				if ( m_tConf.GetConfSource() == VCS_CONF 
					&& ISGROUPMODE( m_cVCSConfStatus.GetCurVCMode() )
					&& m_cVCSConfStatus.GetTVWallManageMode() == VCS_TVWALLMANAGE_REVIEW_MODE)
				{
					tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].SetMt(*ptSrc);
					tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType = byHduMemberType;
				}

				g_cMcuVcApp.SetPeriEqpStatus(byHduId, &tHduStatus);	
				
				if( !tOldChlMt.IsNull() 
						&& ( TW_STATE_STOP == byState || ( TW_STATE_STOP != byState && NULL != ptSrc && !( tOldChlMt == *ptSrc) ))
					  )
				{
					//zjj[20091222] vcs会议如果开启了电视墙混音，退出电视墙的终端也退出混音
					if( m_tConf.GetConfSource() == VCS_CONF 						
						&& m_cVCSConfStatus.GetMtInTvWallCanMixing() 
						&& m_tConf.m_tStatus.IsMixing() 
						&& m_tConf.m_tStatus.IsSpecMixing() 
						&& IsMtNotInOtherHduChnnl(tOldChlMt, byHduId, byChnlIdx)
						&& VCSMtNotInTvWallCanStopMixing( tOldChlMt )
						)
					{						
						RemoveSpecMixMember( &tOldChlMt, 1, FALSE, TRUE );
					}
				}

				//状态通告
				cServMsg.SetMsgBody((u8 *)&tHduStatus, sizeof(tHduStatus));
				SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);

				StopSwitchToPeriEqp(byHduId, byChnlIdx, TRUE, byOldMode);
				g_cMcuVcApp.SetChnnlMMode( byHduId, byChnlIdx, MODE_NONE);
				if (m_tConf.GetConfSource() == MCS_CONF )
				{
					//旧成员出墙
					RefreshMtStatusInTw( tOldMt, FALSE, TRUE );
				}
			}

			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangeHduSwitch] CheckHduAbility failed!\n");		
			return FALSE;
		}
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_HDU, "[ChangeHduSwitch]src(mcuid:%d, mtId:%d) --> hdu(id:%d, chnl:%d)MediaMode :%d !\n",
			ptSrc->GetMcuId(), ptSrc->GetMtId(), byHduId, byChnlIdx, byMode);
	}
	//20130509_tzy  Bug00138780  HDU电视墙板卡解立体声音频有问题
	BOOL32 bIsRemoveAudioMode = FALSE;
	TLogicalChannel tLogicalChannel;
	u8 bySubEqpType = 0;
	//对于老的HDU板卡不能解AACLC和AACLD双声道的码流，那么就不建音频交换，多回传时也只回传视频即可
	if( g_cMcuAgent.GetHduSubTypeByEqpId(byHduId,bySubEqpType) && 
		(HDU_SUBTYPE_HDU_M == bySubEqpType ||
		HDU_SUBTYPE_HDU_H == bySubEqpType  ||
		HDU_SUBTYPE_HDU_L == bySubEqpType) &&
		ptSrc != NULL &&
		ptSrc->GetType() == TYPE_MT && 
		m_ptMtTable->GetMtLogicChnnl(GetLocalMtFromOtherMcuMt(*ptSrc).GetMtId(),LOGCHL_AUDIO,&tLogicalChannel,FALSE) &&
		(tLogicalChannel.GetChannelType() == MEDIA_TYPE_AACLC || tLogicalChannel.GetChannelType() == MEDIA_TYPE_AACLD) && 
		tLogicalChannel.GetAudioTrackNum() == 2)
	{
		ConfPrint( LOG_LVL_WARNING, MID_MCU_CONF, "[ChangeHduSwitch]HDU NOT SUPPORT AACLC OR AACLC DOUBLETRACK,SO REMOVE AUDIO!\n");
		bIsRemoveAudioMode = TRUE;
	}
	if( bNeedPreSetin 
		&& TW_STATE_START == byState 
		&& NULL != ptSrc 
		&& !ptSrc->IsLocal() )
	{
		if( IsLocalAndSMcuSupMultSpy(ptSrc->GetMcuId()) )
		{
			TMt tDstMt;
			tDstMt.SetNull(); 	

			tDstMt.SetMcuEqp( LOCAL_MCUID, byHduId, EQP_TYPE_HDU );
			tDstMt.SetConfIdx( m_byConfIdx );

			TPreSetInReq tSpySrcInitInfo;
			tSpySrcInitInfo.m_tSpyMtInfo.SetSpyMt( *ptSrc );
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyHduInfo.m_tHdu = tDstMt;
			tSpySrcInitInfo.m_bySpyMode = bIsRemoveAudioMode ? MODE_VIDEO : byMode;
			tSpySrcInitInfo.SetEvId(MCS_MCU_START_SWITCH_HDU_REQ);
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyHduInfo.m_bySrcMtType = byHduMemberType;
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyHduInfo.m_bySchemeIdx = 0;//tHduSwitchInfo.GetSchemeIdx();
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyHduInfo.m_byDstChlIdx = byChnlIdx;
			// [2013/03/11 chenbing] 追加子通道
			tSpySrcInitInfo.m_tSpyInfo.m_tSpyHduInfo.SetSubChnIdx(byHduSubChnId);

			// [pengjie 2010/10/15] 处理发言人跟随等伴随逻辑，这里带上释放的终端
			if( (TW_MEMBERTYPE_SPEAKER == tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType || 
				TW_MEMBERTYPE_POLL == tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType ||
				TW_MEMBERTYPE_TWPOLL == tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType||
				TW_MEMBERTYPE_VCSAUTOSPEC == tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType ) &&
				!tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].IsNull() )
			{
				tSpySrcInitInfo.m_tReleaseMtInfo.m_tMt = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx];
				tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseMode	= byOldMode/*MODE_BOTH*/;
				tSpySrcInitInfo.m_tReleaseMtInfo.SetCount(0);
				if (TW_MEMBERTYPE_TWPOLL == tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType  ||
					TW_MEMBERTYPE_VCSAUTOSPEC == tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType )
				{
					if (byOldMode == MODE_BOTH)
					{
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = 1;
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = 1;
					}
					if (byOldMode == MODE_AUDIO)
					{
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = 1;
					}
					if (byOldMode == MODE_VIDEO)
					{
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = 1;
					}
				}
				else
				{
					tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = 0;
					tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = 0;
				}
				
				u8 byVmpSpeakerNum = 0;
				u8 byVmpPollNum = 0;
				u8 byTWSpeakerVNum = 0;
				u8 byTWSpeakerANum = 0;
				u8 byTWPollVNum = 0;
				u8 byTWPollANum = 0;
				u8 byHduSpeakerVNum = 0;
				u8 byHduSpeakerANum = 0;
				u8 byHduPollVNum = 0;
				u8 byHduPollANum = 0;
				BOOL32 bHasVmpMode = GetVmpCountInVmpList() > 0;
				
				// vmp所有跟随通道
				byVmpSpeakerNum = GetVmpChnnlNumBySpecMemberType(VMP_MEMBERTYPE_SPEAKER);
				byVmpPollNum = GetVmpChnnlNumBySpecMemberType(VMP_MEMBERTYPE_POLL);
				
				// tvwall所有跟随通道
				GetTvWallChnnlNumBySpecMemberType(TW_MEMBERTYPE_SPEAKER, byTWSpeakerVNum, byTWSpeakerANum);
				GetTvWallChnnlNumBySpecMemberType(TW_MEMBERTYPE_POLL, byTWPollVNum, byTWPollANum);
				
				// hdu所有跟随通道
				GetHduChnnlNumBySpecMemberType(TW_MEMBERTYPE_SPEAKER, byHduSpeakerVNum, byHduSpeakerANum);
				GetHduChnnlNumBySpecMemberType(TW_MEMBERTYPE_POLL, byHduPollVNum, byHduPollANum);
				
				if ( m_tConf.m_tStatus.GetPollMode() != CONF_POLLMODE_NONE)
				{
					// 轮询的计数，根据轮询的媒体模式来区别
					u8 byPollMode = m_tConf.m_tStatus.GetPollInfo()->GetMediaMode();
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "curren poll mode is %d\n", byPollMode);
					
					if ( byPollMode == MODE_BOTH || byPollMode == MODE_BOTH_BOTH)
					{
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum
							+ byTWSpeakerVNum + byTWPollVNum + byHduSpeakerVNum + byHduPollVNum;
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum
							+ byTWSpeakerANum + byTWPollANum + byHduSpeakerANum + byHduPollANum;
						
						if (bHasVmpMode)
						{
							tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum
								+ byVmpSpeakerNum + byVmpPollNum;
						}
					}
					else
					{
						// 其他轮询只考虑　轮询跟随即可
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum
							+ byTWPollVNum + byHduPollVNum;
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum
							+ byTWPollANum + byHduPollANum;
						
						if (bHasVmpMode)
						{
							tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum += byVmpPollNum;
						}
					}
				}
				else
				{
					// 没有轮询，根据通道的类型来取
					u8 byChnnlType = tHduStatus.m_tStatus.tHdu.atVideoMt[byChnlIdx].byMemberType;
					
					if ( byChnnlType == TW_MEMBERTYPE_SPEAKER)
					{
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum
							+ byTWSpeakerVNum + byHduSpeakerVNum;
						tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum = tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseAudioDstNum
							+ byTWSpeakerANum + byHduSpeakerANum;
						
						if (bHasVmpMode)
						{
							tSpySrcInitInfo.m_tReleaseMtInfo.m_byCanReleaseVideoDstNum += byVmpSpeakerNum;
						}
					}
				}
			}
			// End

			// [pengjie 2010/9/13] 填目的端能力
			TSimCapSet tSimCapSet = GetMtSimCapSetByMode( GetFstMcuIdFromMcuIdx(ptSrc->GetMcuId()) );
			//zjl20101116 如果当前终端已回传则能力集要与已回传目的能力集取小
			
			if(!GetMinSpyDstCapSet(*ptSrc, tSimCapSet))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_SPY, "[ChangeHduSwitch] Get Mt(mcuid.%d, mtid.%d) SimCapSet Failed !\n",
					ptSrc->GetMcuId(), ptSrc->GetMtId() );
				return FALSE;
			}
			
			tSpySrcInitInfo.m_tSpyMtInfo.SetSimCapset( tSimCapSet );
		    // End

			OnMMcuPreSetIn( tSpySrcInitInfo );
			
			return TRUE;
		}
	}

	// [2013/01/29 chenbing] 卫星分散会议逻辑处理 
	// 用新接口判断 [pengguofeng 2/22/2013]
	if ( m_tConf.GetConfAttrb().IsSatDCastMode() && ptSrc != NULL 
		&& IsMultiCastMt(ptSrc->GetMtId())
		&& TW_MEMBERTYPE_BATCHPOLL != byHduMemberType)
	{
		//if ( IsSatMtOverConfDCastNum(*ptSrc, emHdu, 0xff, 0xff, 0xff, byHduId, byChnlIdx))
		TEqp tHduEqp = g_cMcuVcApp.GetEqp(byHduId);
		if (!IsSatMtCanContinue(GetLocalMtFromOtherMcuMt(*ptSrc).GetMtId(),emStartOrChangeHdu,&tHduEqp,byChnlIdx,byHduSubChnId))
		{
			// 关闭HDU通道
			if (TW_MEMBERTYPE_SPEAKER == byHduMemberType ||
				TW_MEMBERTYPE_CHAIRMAN == byHduMemberType)
			{
				ChangeHduSwitch( NULL,byHduId,byChnlIdx,byHduSubChnId,byHduMemberType,TW_STATE_STOP );
			}
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_CONF, "[ChangeHduSwitch] over max upload mt num. nack! by hdu\n");
			NotifyMcsAlarmInfo(0, ERR_MCU_DCAST_OVERCHNNLNUM);
			return TRUE;
		}
	}

	if ( NULL != ptSrc
		&& !ptSrc->IsNull() 
		&& ptSrc->GetType() != TYPE_MCUPERI 
		&& !ptSrc->IsLocal() 
		&& !IsLocalAndSMcuSupMultSpy(ptSrc->GetMcuId()))
	{	
		OnMMcuSetIn(*ptSrc, cServMsg.GetSrcSsnId(), SWITCH_MODE_SELECT);
    }

	TMt tOrgMt = (TMt)tHduStatus.m_tStatus.tHdu.GetChnMt( byChnlIdx, byHduSubChnId );

	// [2013/04/08 chenbing] 四风格下需要判断是否调整终端分辨率与帧率
	// 会议模板配置开启HDU需要校验：byMulitModeHdu，以决定是否需要调整分辨率
	if ( (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdx) || HDUCHN_MODE_FOUR == byMulitModeHdu) )
	{
 		BOOL32 bIsStartSwitch = FALSE;	// 是否可以建交换，TRUE：可以，FALSE：不能建交换(外厂商终端能力大于720p，30fps)
		BOOL32 bIsAdjust = FALSE;

		if( NULL != ptSrc && !ptSrc->IsNull() && TW_MEMBERTYPE_BATCHPOLL != byHduMemberType )
		{ 
			// 下调分辨率处理逻辑
			bIsAdjust = ChangeMtResFpsInHduVmp(*ptSrc, byHduId, byChnlIdx, byHduSubChnId, bIsStartSwitch);
			if ( !bIsStartSwitch )
			{
				//不能降分辨率的终端不能建交换
				NotifyMcsAlarmInfo(0, ERR_MCU_RESOURCES_NOT_ENOUGH);
				//不能建交换的终端需要Free
 				FreeRecvSpy( *ptSrc, byMode );
				return FALSE;
			}
		}

		//1、关闭通道需要恢复HDU通道源其能力
		//2、ptSrc不为空，需要判断新终端与旧终端是否相同(不相同时恢复)
		if ( ( NULL == ptSrc )
		  || ( NULL != ptSrc && !IsOldViewMtAndNewViewMtSame(*ptSrc, tOrgMt))
		   )
		{
			// 由于批量轮询是先将Mt设入通道中的，开启外设后会切换四风格为一风格，
			// 但在四风格还未切换下，会认为当前轮询的Mt在四风格0子通道中，导致无法恢复该终端分辨率
			// 所以批量轮询下需要跳过当前预案中的所有外设通道
			if (TW_MEMBERTYPE_BATCHPOLL == byHduMemberType)
			{
				tHduStatus.m_tStatus.tHdu.SetMemberType(TW_MEMBERTYPE_BATCHPOLL, byChnlIdx);
			}

			//恢复分辨率时需要先清除当前通道
			tHduStatus.m_tStatus.tHdu.SetChnNull(byChnlIdx, byHduSubChnId);
 			g_cMcuVcApp.SetPeriEqpStatus(byHduId, &tHduStatus);

			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_CONF, "[ChangeHduSwitch] Restore OldMt(%d, %d) Fps and Res!!!\n",tOrgMt.GetMcuId(), tOrgMt.GetMtId());
			// 是否需要恢复分辨率处理逻辑
			ChangeMtResFpsInHduVmp(tOrgMt, byHduId, byChnlIdx, byHduSubChnId, bIsStartSwitch, FALSE);
		}

		//ptSrc为下级Mcu时，上传通道成员不为空也需要return
		//调整下级分辨率需要等下级返回ACK后进行, 恢复不需要返回
		if ( NULL != ptSrc && !ptSrc->IsNull() && bIsAdjust
			 && ( ( !(ptSrc->IsLocal()) && !IsMcu(*ptSrc) )
				|| ( IsMcu(*ptSrc) && !GetSMcuViewMt(*ptSrc, TRUE).IsNull() )
			    )
			)
		{
			//刷老Mt出墙
			if( !tOrgMt.IsNull() )
			{
				RefreshMtStatusInTw( tOrgMt, FALSE, TRUE );
			}

 			//刷新Mt进墙
	  		RefreshMtStatusInTw( *ptSrc, TRUE, TRUE );

			tHduStatus.m_tStatus.tHdu.SetChnMt(*ptSrc, byChnlIdx, byHduSubChnId);
 			g_cMcuVcApp.SetPeriEqpStatus(byHduId, &tHduStatus);
			g_cMcuVcApp.SetChnnlMMode(byHduId, byChnlIdx, byMode);

			
			//替换操作，需要Free一次
 			FreeRecvSpy( tOrgMt, byOldMode );
			return TRUE;
		}
	}


	if ((NULL == ptSrc || (NULL != ptSrc && ptSrc->IsNull()))
		&& !bBatchPoll
		&& bCanSendStopPlayMsg)
	{
		u8 byTempMode = MODE_NONE;
		if (TW_MEMBERTYPE_BATCHPOLL == byHduMemberType && HDUCHN_MODE_FOUR == byMulitModeHdu)
		{
			byTempMode = byMode;
		}
		else
		{
			byTempMode = byOldMode;
		}
		StopSwitchToPeriEqp(byHduId, byChnlIdx, TRUE, byTempMode, SWITCH_MODE_BROADCAST, byHduSubChnId);
		// [2013/03/11 chenbing] 重新获取状态，可能已经在Stop中翻转了 
		g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus);
	}
	else
	{
		StopSwitchToPeriEqp(byHduId, byChnlIdx, FALSE, byOldMode, SWITCH_MODE_BROADCAST, byHduSubChnId);
		tHduStatus.m_tStatus.tHdu.SetChnStatus(byChnlIdx, byHduSubChnId, THduChnStatus::eREADY);
	}

	// [2013/03/11 chenbing]
	BOOL32 bIsChgMode = TRUE;
	if (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdx))
	{
		for (u8 byIndex=0; byIndex<HDU_MODEFOUR_MAX_SUBCHNNUM; byIndex++)
		{
			if (!tHduStatus.m_tStatus.tHdu.GetChnMt(byChnlIdx, byIndex).IsNull())
			{
				bIsChgMode = FALSE;
				break;
			}
		}
	}
	
	if (bIsChgMode)
	{
		g_cMcuVcApp.SetChnnlMMode( byHduId, byChnlIdx, MODE_NONE);
	}

	tHduStatus.m_tStatus.tHdu.SetChnNull(byChnlIdx, byHduSubChnId);
	//先将通道成员清空，以便在IsMtNotInOtherHduChnnl中判断终端已经不在HDU中
	g_cMcuVcApp.SetPeriEqpStatus(byHduId, &tHduStatus);


	if(!tOrgMt.IsNull()	
	&& TYPE_MT == tOrgMt.GetType() 
	&& IsMtNotInOtherHduChnnl(tOrgMt, byHduId, byChnlIdx)
	  )
	{
		RefreshMtStatusInTw( tOrgMt, FALSE, TRUE );
	}

	//yrl20131104清除非会控指定下的上传通道内终端的电视墙图标
	if( TW_STATE_START != byState && !tOrgMt.IsNull() && IsMcu(tOrgMt) 
		&& !IsHduChnnlMcsSpec(tOrgMt, byHduId, byChnlIdx, byHduSubChnId) )
	{
		TMt tMt = GetSMcuViewMt(tOrgMt,TRUE);
		if(!tMt.IsNull() && IsMtNotInOtherHduChnnl(tMt, byHduId, byChnlIdx))
		{
			TMtStatus tStatus;
			if( GetMtStatus( tMt, tStatus ) )
			{
				tStatus.SetInHdu(FALSE);
				SetMtStatus(tMt, tStatus);
				MtStatusChange(&tMt, TRUE);
			}
		}
	}

	TVMPParam_25Mem tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
	//[12/13/2011 liuxu] VCS中终端被清出电视墙时, 要考虑挂断挂断它
	if ( VCS_CONF == m_tConf.GetConfSource() && TW_STATE_STOP == byState)
	{
		if ( !(m_cVCSConfStatus.GetCurVCMT() == tOrgMt ) && 
			IsMtNotInOtherHduChnnl(tOrgMt, byHduId, byChnlIdx) &&
			IsMtNotInOtherTvWallChnnl(tOrgMt,0,0) )
		{
			if (m_cVCSConfStatus.GetCurVCMode() == VCS_SINGLE_MODE)
			{
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VCS, "[ChangeHduSwitch]when ClearTvw(%d,%d) DropMT(%d,%d) in VcsMode.%d\n",
						byHduId, byChnlIdx, tOrgMt.GetMcuId(), tOrgMt.GetMtId(),  m_cVCSConfStatus.GetCurVCMode());
				
				// 挂断终端
				VCSDropMT( tOrgMt );
			}
			// 多方多画面下如果也不在画面合成中了, 也需要被挂断
			else if ( m_cVCSConfStatus.GetCurVCMode() == VCS_MULVMP_MODE ) 
				
			{
				if (!tConfVmpParam.IsMtInMember(tOrgMt))
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VCS, "[ChangeHduSwitch]when ClearTvw(%d,%d) DropMT(%d,%d) in VcsMode.%d\n",
						byHduId, byChnlIdx, tOrgMt.GetMcuId(), tOrgMt.GetMtId(),  m_cVCSConfStatus.GetCurVCMode());
					
					VCSDropMT( tOrgMt );
				}
			}
		}
	}

 	//zjj20101122 这里无论新老是否一样都要将老的free一次
 	FreeRecvSpy( tOrgMt, byOldMode );

	//下级终端被Free后，上传路数为0的情况下会恢复下级Mt分辨率
	//但此时，当关闭的Mt为Mcu的上传源，并且Mcu在其他HDU多画面通道中时需要下调一次分辨率
	CRecvSpy cRecvSpyInfo;
	if( !m_cSMcuSpyMana.GetRecvSpy(tOrgMt, cRecvSpyInfo) )
	{
		if( ( IsLocalAndSMcuSupMultSpy(tOrgMt.GetMcuId()) )
			&& HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdx)
			&& ( IsMtInHduVmp(tOrgMt, byHduId, byChnlIdx, byHduSubChnId, TRUE)
				|| (NULL != ptSrc && !ptSrc->IsNull() && IsOldViewMtAndNewViewMtSame(*ptSrc, tOrgMt))
				)
		  )
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ChangeHduSwitch] FreeRecvSpy AdjustResAndFps\n");
			BOOL32 bIsStartSwitch;
			// 下调分辨率
			ChangeMtResFpsInHduVmp(tOrgMt, byHduId, byChnlIdx, byHduSubChnId, bIsStartSwitch, TRUE, TRUE);
		}
	}
	// [2013/03/11 chenbing]  
	tHduStatus.m_tStatus.tHdu.SetMemberType(byHduMemberType, byChnlIdx, byHduSubChnId);
	tHduStatus.m_tStatus.tHdu.SetChnIdx(byChnlIdx, byHduSubChnId);

    // 成员必须是终端，而不能是外设, VMP 除外
    if (ptSrc != NULL 
		&& ptSrc->GetType() == TYPE_MCUPERI 
		&& EQP_TYPE_VMP != ptSrc->GetEqpType())
    {
        ptSrc->SetNull();
    }

    if (NULL == ptSrc || ptSrc->IsNull())
    {
		// [2013/03/11 chenbing]  
		tHduStatus.m_tStatus.tHdu.SetChnNull(byChnlIdx, byHduSubChnId);
		tHduStatus.m_tStatus.tHdu.SetEqpType(byChnlIdx, byHduSubChnId, 0);
		tHduStatus.m_tStatus.tHdu.SetType(byChnlIdx, byHduSubChnId, 0);
		if (TW_MEMBERTYPE_CHAIRMAN == byHduMemberType
			|| TW_MEMBERTYPE_SPEAKER == byHduMemberType
			|| TW_MEMBERTYPE_POLL == byHduMemberType
			|| TW_MEMBERTYPE_DOUBLESTREAM == byHduMemberType
			|| TW_MEMBERTYPE_BATCHPOLL == byHduMemberType)
		{
			tHduStatus.m_tStatus.tHdu.SetConfIdx(m_byConfIdx, byChnlIdx, byHduSubChnId);
		}
		else
		{
			tHduStatus.m_tStatus.tHdu.SetSchemeIdx(0, byChnlIdx, byHduSubChnId);
			tHduStatus.m_tStatus.tHdu.SetMemberType(0, byChnlIdx, byHduSubChnId);
			if( HDUCHN_MODE_ONE == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdx)
				|| ( (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdx))
				&& 0 != byHduSubChnId)
				)
			{
				tHduStatus.m_tStatus.tHdu.SetConfIdx(0, byChnlIdx, byHduSubChnId);
			}
		}
    }
    else
    {
		if ( ptSrc->GetType() == TYPE_MCUPERI)
		{
			// [2013/03/11 chenbing]  
			tHduStatus.m_tStatus.tHdu.SetMcuEqp( byChnlIdx, byHduSubChnId, (u8)ptSrc->GetMcuId(), ptSrc->GetEqpId(), ptSrc->GetEqpType() );
			tHduStatus.m_tStatus.tHdu.SetConfIdx( m_byConfIdx, byChnlIdx, byHduSubChnId);
		}
		else
		{
			TMt tSrct = *ptSrc;
			tSrct.SetConfIdx(m_byConfIdx);
			if (tSrct.IsLocal())
			{
				m_ptMtTable->GetMt(tSrct.GetMtId());
			}
			else
			{
				tSrct.SetMtType(MT_TYPE_MT);				
			}

			tHduStatus.m_tStatus.tHdu.SetChnMt(tSrct, byChnlIdx, byHduSubChnId);
			tHduStatus.m_tStatus.tHdu.SetMemberType(byHduMemberType, byChnlIdx, byHduSubChnId);
		}
	}

	if( !tOrgMt.IsNull() 
		&& IsMtNotInOtherHduChnnl(tOrgMt, byHduId, byChnlIdx)				
		&& ( TW_STATE_STOP == byState || ( TW_STATE_STOP != byState && NULL != ptSrc && !( tOrgMt == *ptSrc) ))
	  )
	{
		//zjj[20091222] vcs会议如果开启了电视墙混音，退出电视墙的终端也退出混音
		if( m_tConf.GetConfSource() == VCS_CONF 
			&& m_cVCSConfStatus.GetMtInTvWallCanMixing() 
			&& m_tConf.m_tStatus.IsMixing() 
			&& m_tConf.m_tStatus.IsSpecMixing() 
			&& VCSMtNotInTvWallCanStopMixing( tOrgMt )
			)
		{
			// [12/29/2010 liuxu][走读] 其实上面这些判断应该放在RemoveSpecMixMember里处理
			RemoveSpecMixMember( &tOrgMt, 1, FALSE, TRUE );
		}
		//vcs级联单回传下进墙终端如果非调度终端同时也不在画面合成中出墙时需将下级MCU踢出混音器
		//以免下级未配混音器时还能听到下级上传通道的声音
		if (VCS_CONF == m_tConf.GetConfSource()
			&& !tOrgMt.IsLocal() 
			&& !IsLocalAndSMcuSupMultSpy(tOrgMt.GetMcuIdx()) 
			&& m_cVCSConfStatus.GetMtInTvWallCanMixing())
		{
			TMt tLocalMt = GetLocalMtFromOtherMcuMt(tOrgMt);
			if (m_ptMtTable->IsMtInMixing(tLocalMt.GetMtId()) 
				&& GetLocalMtFromOtherMcuMt(m_cVCSConfStatus.GetCurVCMT()).GetMtId() != tLocalMt.GetMtId() 
				&& !tConfVmpParam.IsMtInMember(tOrgMt)
				&& IsMtNotInOtherTvWallChnnl(tOrgMt, 0, 0) 
				&& IsMtNotInOtherHduChnnl(tOrgMt, byHduId, byChnlIdx)
				&& !IsHasMtInHduOrTwByMcuIdx(tOrgMt.GetMcuIdx()))
			{
				RemoveSpecMixMember( &tLocalMt, 1, FALSE, TRUE );
			}
		}
	}

	ConfPrint( LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeHduSwitch] ");
	ConfPrint( LOG_LVL_DETAIL, MID_MCU_EQP, "Mcs HduId(%d) ChnId(%d) HduSubChnId(%d) MeMber:(%d) Status(%d)!!!\n",
		byHduId, byChnlIdx, byHduSubChnId, tHduStatus.m_tStatus.tHdu.GetMemberType(byChnlIdx),
		tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnlIdx, byHduSubChnId) );
	
	//[2013/03/11 chenbing] 在SwitchSrcToDst前处理
	//防止在SwitchSrcToDst中跳转了状态又被置回去
	g_cMcuVcApp.SetPeriEqpStatus(byHduId, &tHduStatus);

	if ( NULL != ptSrc && !ptSrc->IsNull() && TW_STATE_START == byState)
    {
        TEqp tEqp = g_cMcuVcApp.GetEqp(byHduId);
		
		THduSwitchInfo tHduSwitchInfo;
        tHduSwitchInfo.SetSrcMt(*ptSrc);
        tHduSwitchInfo.SetDstMt(tEqp);
		// [2013/03/11 chenbing]  
        tHduSwitchInfo.SetDstChlIdx(byChnlIdx);
		tHduSwitchInfo.SetDstSubChn(byHduSubChnId);

		u8 bySrcChnnl = 0; 
		if(TW_MEMBERTYPE_SWITCHVMP == byHduMemberType)	// xliang [6/23/2009] 选看VMP
		{	
			u8 byVmpSubType = GetVmpSubType(ptSrc->GetEqpId());
			//VMP与MPU_SVMP保持原来,8KG与8KH同样保持原来的
			if (VMP == byVmpSubType || MPU_SVMP == byVmpSubType 
				|| VMP_8KE == byVmpSubType || VMP_8KH == byVmpSubType)
			{
				u8 byMediaType = m_tConf.GetMainVideoMediaType();
				u8 byRes = m_tConf.GetMainVideoFormat();
				u8 byFps = m_tConf.GetMainVidUsrDefFPS();
				emProfileAttrb emAtb = m_tConf.GetProfileAttrb();
				bySrcChnnl = GetVmpOutChnnlByRes(ptSrc->GetEqpId(), byRes, byMediaType, byFps, emAtb);
			}
			else //MPU2、8KIVMP处理
			{
				bySrcChnnl = byVmpOutChl;
			}
		}
		tHduSwitchInfo.SetSrcChlIdx(bySrcChnnl);
		
		cServMsg.SetEventId(MCS_MCU_START_SWITCH_HDU_REQ);

		if (byHduMemberType == TW_MEMBERTYPE_DOUBLESTREAM)
		{
			tHduSwitchInfo.SetMode(MODE_SECVIDEO);
		}
		else
		{
			// [2013/03/11 chenbing]  
			if (HDUCHN_MODE_FOUR == byMulitModeHdu || TW_MEMBERTYPE_SWITCHVMP == byHduMemberType)
			{
				tHduSwitchInfo.SetMode(MODE_VIDEO);
			}
			else
			{
				tHduSwitchInfo.SetMode(byMode);
			}
		}

		tHduStatus.m_tStatus.tHdu.SetConfIdx(m_byConfIdx, byChnlIdx);
		g_cMcuVcApp.SetChnnlMMode(byHduId, byChnlIdx, tHduSwitchInfo.GetMode());

		//20101118_tzy 通知下级建回传交换SpyNotify
		if (!ptSrc->IsNull() && !ptSrc->IsLocal() && IsLocalAndSMcuSupMultSpy(ptSrc->GetMcuIdx()))
		{
			TSimCapSet tSimCapSet;

			// 不判断当前源是否在HDU2多画面中，只要当前操作了四风格通道，分辨率就取HDU2多画面通道能力
			if( HDUCHN_MODE_FOUR == byMulitModeHdu || HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnlIdx) )
			{
				tSimCapSet = GetHduChnSupportCap(*ptSrc, byHduId);
			}
			else
			{
				tSimCapSet = GetMtSimCapSetByMode( GetFstMcuIdFromMcuIdx(ptSrc->GetMcuId()));
			}
			SendMMcuSpyNotify( *ptSrc, MCS_MCU_START_SWITCH_HDU_REQ, tSimCapSet);
		}

        SwitchSrcToDst(tHduSwitchInfo, cServMsg, bBatchPoll, &tHduSwitchInfo, byMulitModeHdu);
			
		// 电视墙自动混音
		if (m_tConf.GetConfSource() == VCS_CONF 
			&& m_cVCSConfStatus.GetMtInTvWallCanMixing() 
			&& m_tConf.m_tStatus.IsSpecMixing())
		{
			AddSpecMixMember(ptSrc,1,TRUE);
		}		
    }

//上报跟随状态
//	status notification
	cServMsg.SetMsgBody((u8 *)&tHduStatus, sizeof(tHduStatus));
	SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);

	
	if (NULL != ptSrc 
		&& !ptSrc->IsNull() 
		&& ptSrc->GetType() != TYPE_MCUPERI 
		&& TW_STATE_STOP != byState)
	{
		RefreshMtStatusInTw( *ptSrc, TRUE, TRUE, byHduMemberType );
	}
	
    return TRUE;
}

/*====================================================================
    函数名      : HasUnLocalMemberInEqp
    功能        : 该会议中的Eqp通道中是否有下级成员，并且该通道的成员类型不是传入的membertype值
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMemberType	[i]	
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	10/07/01    4.6.1       薛亮         创建
====================================================================*/
BOOL32 CMcuVcInst::HasUnLocalMemberInEqp(u8 byEqpId, u8 byMemberType)
{
	TMt tMtInTv;
	TPeriEqpStatus tStatus;
	if( HDUID_MIN <= byEqpId && byEqpId <= HDUID_MAX)
	{
		for(u8 byEqpHduId = HDUID_MIN; byEqpHduId <= HDUID_MAX; byEqpHduId++)
		{
			g_cMcuVcApp.GetPeriEqpStatus(byEqpHduId, &tStatus);
			if( tStatus.m_byOnline )
			{
				for(u8 byLp = 0; byLp < MAXNUM_HDU_CHANNEL; byLp++)
				{
					tMtInTv = (TMt)tStatus.m_tStatus.tHdu.atVideoMt[byLp];
					if(tMtInTv.GetConfIdx() == m_byConfIdx
						&& !tMtInTv.IsLocal()
						&& tStatus.m_tStatus.tHdu.atVideoMt[byLp].byMemberType != byMemberType)
					{					
						return TRUE;
					}							
				}
			}
		}
	}
	else if( TVWALLID_MIN <= byEqpId && byEqpId <= TVWALLID_MAX)
	{
		g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tStatus);
		if( tStatus.m_byOnline )
		{
			for(u8 byLp = 0; byLp < tStatus.m_tStatus.tTvWall.byChnnlNum; byLp++)
			{
				tMtInTv = (TMt)tStatus.m_tStatus.tTvWall.atVideoMt[byLp];
				if (tMtInTv.GetConfIdx() == m_byConfIdx
					&& !tMtInTv.IsLocal()
					&& tStatus.m_tStatus.tTvWall.atVideoMt[byLp].byMemberType != byMemberType)
				{					
					return TRUE;
				}				
			}
		}
	}
	    
	return FALSE;
}

/*====================================================================
    函数名      : IsMtNotInOtherHduChnnl
    功能        是否需要清除终端在hdu通道的状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtId   终端ID
	              u8 byHduId    HDUId
				  u8 byChnlId   通道ID
				  BOOL32 bIsIgnoreHduAllChn 是否忽略该HDU外设下所有通道
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/01/19    4.6.1        周晶晶        创建
	2013/03/11   4.7.2       陈兵           修改(HDU多画面支持)
====================================================================*/
BOOL32 CMcuVcInst::IsMtNotInOtherHduChnnl(const TMt tMt, const u8 byHduId, const u8 byChnlId,BOOL32 bIsIgnoreHduAllChn, BOOL32 bIsFakeInHdu)
{
	// [12/29/2010 liuxu][走读] 需要考虑复用

	TMt tMtInTv;
	TPeriEqpStatus tHduStatus;    
	
	//zjj20091102做保护
	if (!bIsIgnoreHduAllChn)
	{
		if( byHduId >= HDUID_MIN && byHduId <= HDUID_MAX )
		{
			u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduId));
			if (0 != byHduChnNum)
			{
				g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus);
				//是否在本电视墙的其他通道里
				for(u8 byLp = 0; byLp < min(byHduChnNum, MAXNUM_HDU_CHANNEL); byLp++)
				{
					u8 byChnNum = 1;
					// [2013/03/11 chenbing]  四风格下遍历子通道
					if (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byLp) )
					{
						byChnNum = HDU_MODEFOUR_MAX_SUBCHNNUM;
					}

					for (u8 byIndex = 0; byIndex < byChnNum; byIndex++)
					{
						tMtInTv = (TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byLp, byIndex);
						if(tMtInTv.GetConfIdx() == m_byConfIdx)
						{		
							// 增加判断终端所在会议号，否则会将其他会议的终端误判
							if(tMtInTv == tMt)
							{
								return FALSE;
							}
						}
					}
				}
			}
			else
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[IsMtNotInOtherHduChnnl] GetHduChnNumAcd2Eqp failed!\n");
			}
		}
	}
	
    //是否在其他电视墙的通道里
    for(u8 byEqpHduId = HDUID_MIN; byEqpHduId <= HDUID_MAX; byEqpHduId++)
    {
        if(byHduId == byEqpHduId)
        {
			continue;
        }

		u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpHduId));
		if (0 == byHduChnNum)
		{
			//ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_HDU, "[IsMtNotInOtherHduChnnl] GetHduChnNumAcd2Eqp2 failed!\n");		
			continue;
		}

        g_cMcuVcApp.GetPeriEqpStatus(byEqpHduId, &tHduStatus);
        if( tHduStatus.m_byOnline )
        {
            for(u8 byLp = 0; byLp < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byLp++)
            {
				// [2013/03/11 chenbing]  四风格下遍历子通道  
				if (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byLp) )
				{
					for (u8 byIndex = 0; byIndex < HDU_MODEFOUR_MAX_SUBCHNNUM; byIndex++)
					{
						tMtInTv = (TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byLp, byIndex);
						if( tMtInTv.GetConfIdx() == m_byConfIdx
							&& tMtInTv == tMt
   					      )
						{			
							return FALSE;
						}
					}
					continue;
				}

                tMtInTv = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byLp];
				if(tMtInTv.GetConfIdx() == m_byConfIdx)
				{					
					// 增加判断终端所在会议号，否则会将其他会议的终端误判
					if(tMtInTv == tMt)
					{
						//对于VCS会议来说增加通道模式判断，如果为MODE_NONE则表示为假进墙终端，实际墙中并无该终端图像
						if (bIsFakeInHdu && VCS_CONF == m_tConf.GetConfSource() && MODE_NONE == g_cMcuVcApp.GetChnnlMMode(byEqpHduId,byLp))
						{
							ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[IsMtNotInOtherHduChnnl]VCS_CONF Mt(%d,%d) Is Not In (%d,%d)!\n",
											tMt.GetMcuId(),tMt.GetMtId(),byEqpHduId,byLp);
						} 
						else
						{
							return FALSE;
						}
					}	
				}							
            }
        }
    }

	ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[IsMtNotInOtherHduChnnl] byChnlId:%d!\n", byChnlId);
	return TRUE;
}

/*====================================================================
    函数名      : IsMtNotInOtherHduChnnl
    功能        是否需要清除终端在hdu通道的状态
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtId   终端ID
	              u8 byHduId    HDUId
				  u8 byChnlId   通道ID
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/01/19    4.6.1         江乐斌        创建
====================================================================*/
BOOL32 CMcuVcInst::IsMtNotInOtherHduChnnl(const u8 byMtId, const u8 byHduId, const u8 byChnlId, const u8 bySubChnId)
{
	TMt tMtInTv;
	TPeriEqpStatus tHduStatus;    
	
	//zjj20091102做保护
	if( byHduId >= HDUID_MIN && byHduId <= HDUID_MAX )
	{
		u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduId));
		if (0 != byHduChnNum)
		{
			g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus);
			//是否在本电视墙的其他通道里
			for(u8 byLp = 0; byLp < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byLp++)
			{
				// [2013/03/11 chenbing] 四风格下子通道遍历 
				if (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byLp))
				{
					for (u8 byIndex=0; byIndex<HDU_MODEFOUR_MAX_SUBCHNNUM; byIndex++)
					{
						if(byLp == byChnlId && bySubChnId == byIndex)
						{
							continue;
						}
						else
						{
							tMtInTv = (TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byLp, byIndex);
							if(tMtInTv.GetConfIdx() == m_byConfIdx)
							{
								tMtInTv = GetLocalMtFromOtherMcuMt( tMtInTv );
								// 增加判断终端所在会议号，否则会将其他会议的终端误判
								if(tMtInTv.GetMtId() == byMtId)
								{
									return FALSE;
								}
							}				
						}
					}
					continue;
				}

				if(byLp != byChnlId)
				{
					tMtInTv = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byLp];
					if(tMtInTv.GetConfIdx() == m_byConfIdx)
					{
						tMtInTv = GetLocalMtFromOtherMcuMt( tMtInTv );
						// 增加判断终端所在会议号，否则会将其他会议的终端误判
						if(tMtInTv.GetMtId() == byMtId)
						{
							//对于VCS会议来说增加通道模式判断，如果为MODE_NONE则表示为假进墙终端，实际墙中并无该终端图像
							if (VCS_CONF == m_tConf.GetConfSource() && MODE_NONE == g_cMcuVcApp.GetChnnlMMode(byHduId,byLp))
							{
								ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[IsMtNotInOtherHduChnnl]VCS_CONF Mt(%d) Is Not In (%d,%d)!\n",
											byMtId,byHduId,byLp);
							} 
							else
							{
								return FALSE;
							}
						}
					}				
				}
			}
		}
		else
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[IsMtNotInOtherHduChnnl] GetHduChnNumAcdEqp-MtId failed!\n");
		}
	}
	
    //是否在其他电视墙的通道里
    for(u8 byEqpHduId = HDUID_MIN; byEqpHduId <= HDUID_MAX; byEqpHduId++)
    {
        if(byHduId == byEqpHduId)
            continue;
        
		u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpHduId));
		if (0 == byHduChnNum)
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[IsMtNotInOtherHduChnnl] GetHduChnNumAcd2Eqp-mtid2 failed!\n");
			continue;
		}

        g_cMcuVcApp.GetPeriEqpStatus(byEqpHduId, &tHduStatus);
        if( tHduStatus.m_byOnline )
        {
            for(u8 byLp = 0; byLp < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byLp++)
            {
				// [2013/03/11 chenbing] 四风格下子通道遍历 
				if (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byLp))
				{
					for (u8 byIndex=0; byIndex<HDU_MODEFOUR_MAX_SUBCHNNUM; byIndex++)
					{
						tMtInTv = (TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byLp, byIndex);
						if(tMtInTv.GetConfIdx() == m_byConfIdx)
						{
							tMtInTv = GetLocalMtFromOtherMcuMt( tMtInTv );
							// 增加判断终端所在会议号，否则会将其他会议的终端误判
							if(tMtInTv.GetMtId() == byMtId)
							{
								return FALSE;
							}
						}				
					}
					continue;
				}

                tMtInTv = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byLp];
				if(tMtInTv.GetConfIdx() == m_byConfIdx)
				{
					tMtInTv = GetLocalMtFromOtherMcuMt( tMtInTv );
					// 增加判断终端所在会议号，否则会将其他会议的终端误判
					if(tMtInTv.GetMtId() == byMtId)
					{
						//对于VCS会议来说增加通道模式判断，如果为MODE_NONE则表示为假进墙终端，实际墙中并无该终端图像
						if (VCS_CONF == m_tConf.GetConfSource() && MODE_NONE == g_cMcuVcApp.GetChnnlMMode(byEqpHduId,byLp))
						{
							ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[IsMtNotInOtherHduChnnl]VCS_CONF Mt(%d) Is Not In (%d,%d)!\n",
											byMtId,byEqpHduId,byLp);	
						} 
						else
						{
							return FALSE;
						}
					}	
				}							
            }
        }
    }
	
	return TRUE;
}

/*====================================================================
函数名      : IsHduChnnlMcsSpec
功能          是否有HDU通道为会控指定
算法实现    ：
引用全局变量：
输入参数说明：u8 byMtId     终端ID
			  u8 byHduId    HDUId
			  u8 byChnlId   通道ID
			  u8 bySubChnId 通道子ID
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
20131104    4.7.2       闫日亮          创建
====================================================================*/
BOOL32 CMcuVcInst::IsHduChnnlMcsSpec(const TMt tMt, const u8 byHduId, const u8 byChnlId, const u8 bySubChnId)
{
	TMt tMtInTv;
	TPeriEqpStatus tHduStatus;    

    //遍历所有电视墙通道
    for(u8 byEqpHduId = HDUID_MIN; byEqpHduId <= HDUID_MAX; byEqpHduId++)
    {
		u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpHduId));
		if (0 == byHduChnNum)
		{
			continue;
		}
		
		g_cMcuVcApp.GetPeriEqpStatus(byEqpHduId, &tHduStatus);		
		if( 0 == tHduStatus.m_byOnline )
		{
			return FALSE;
		}

		for(u8 byLp = 0; byLp < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byLp++)
		{	
			// 四风格下子通道遍历 
			if (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byLp))
			{
				for (u8 byIndex=0; byIndex<HDU_MODEFOUR_MAX_SUBCHNNUM; byIndex++)
				{
					if(byEqpHduId == byHduId && byLp == byChnlId && byIndex == bySubChnId)
					{
						continue;
					}
					else
					{
						tMtInTv = (TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byLp, byIndex);

						// 增加判断终端所在会议号，否则会将其他会议的终端误判
						if(tMtInTv.GetConfIdx() == m_byConfIdx
							&& tMtInTv == tMt && IsMcu(tMtInTv)
							&& TW_MEMBERTYPE_MCSSPEC == tHduStatus.m_tStatus.tHdu.GetHduMember(byLp, byIndex).byMemberType)
						{
							return TRUE;
						}				
					}
				}
			}
			else
			{
				if (byEqpHduId == byHduId && byLp == byChnlId)
				{
					continue;
				}
				else
				{
					tMtInTv = (TMt)tHduStatus.m_tStatus.tHdu.atVideoMt[byLp];
					
					// 增加判断终端所在会议号，否则会将其他会议的终端误判
					if(tMtInTv.GetConfIdx() == m_byConfIdx
						&& tMtInTv == tMt && IsMcu(tMtInTv)
						&& TW_MEMBERTYPE_MCSSPEC == tHduStatus.m_tStatus.tHdu.GetHduMember(byLp).byMemberType)
					{
						return TRUE;
					}	
				}
			}			
		}
    }
	
	return FALSE;
}

/*------------------------------------------------------------------*/
/*                              PRS                                 */
/*------------------------------------------------------------------*/
/*====================================================================
    函数名      ：OccupyPrsChnl
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/07/15    4.0         付秀华        创建
====================================================================*/
void CMcuVcInst::OccupyPrsChnl(u8 byPrsId, u8 byPrsChnl)
{
	TPeriEqpStatus tPrsStaus;
	g_cMcuVcApp.GetPeriEqpStatus(byPrsId, &tPrsStaus);
	tPrsStaus.m_tStatus.tPrs.SetChnConfIdx(byPrsChnl, m_byConfIdx);
	tPrsStaus.m_tStatus.tPrs.m_tPerChStatus[byPrsChnl].SetReserved(TRUE);
	g_cMcuVcApp.SetPeriEqpStatus(byPrsId, &tPrsStaus);

	CServMsg cServMsg;
	cServMsg.SetMsgBody((u8*)&tPrsStaus, sizeof(tPrsStaus));
	SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
}
/*====================================================================
    函数名      ：RlsPrsChnl
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/07/15    4.0         付秀华        创建
====================================================================*/
void CMcuVcInst::RlsPrsChnl(u8 byPrsId, u8 byPrsChnl)
{
	TPeriEqpStatus tPrsStaus;
	g_cMcuVcApp.GetPeriEqpStatus(byPrsId, &tPrsStaus);
	tPrsStaus.m_tStatus.tPrs.SetChnConfIdx(byPrsChnl, 0);
	tPrsStaus.m_tStatus.tPrs.m_tPerChStatus[byPrsChnl].SetReserved(FALSE);
	g_cMcuVcApp.SetPeriEqpStatus(byPrsId, &tPrsStaus);

	CServMsg cServMsg;
	cServMsg.SetMsgBody((u8*)&tPrsStaus, sizeof(tPrsStaus));
	SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);

	RemovePrsChn(byPrsId, byPrsChnl);
}
/*====================================================================
    函数名      ：ChangePrsSrc
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明：[IN] u8 byPrsId:      待更改的PRS设备号
	              [IN] u8 byPrsChnlPos: 待更改的PRS通道号
				  [IN] TMt& tEqp:       对应接收的信号源ID
				  [IN] u8 byEqpOutChnl: 对应信号源输出通道号
				  [IN] u8 byEqpInChnl:  对应信号源输入通道号
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/07/15    4.0         付秀华        创建
====================================================================*/
// BOOL CMcuVcInst::ChangePrsSrc(u8 byPrsId, u8 byPrsChnlPos, 
// 							  const TMt& tEqp,  u8 byEqpOutChnl /*= 0*/, u8 byEqpInChnl /*= 0*/, u8 byEqpChnMode /*= MODE_NONE*/)
// {
// 	u8 byChlNum = 0;
// 	TLogicalChannel tEqpLogChnl;
//     if (!g_cMcuVcApp.GetPeriEqpLogicChnnl(byPrsId, MODE_VIDEO, &byChlNum, &tEqpLogChnl, TRUE))
//     {
//         ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangePrsSrc] Can't get prs(%d) logic channel, ChangePrsSrc failure!\n",
// 			    byPrsId);
//         return FALSE;
//     }
// 
// 	TPrsParam tPrsParam;
// 	TTransportAddr tLocAddr;
// 	TTransportAddr tRemAddr;
// 	u32 dwRtcpSwitchIp;
// 	u16 wRtcpSwitchPort;
// 	u32 dwSrcIp;
// 
// 	switch(tEqp.GetEqpType())
// 	{
// 	case EQP_TYPE_VMP:
// 		{           
// 			g_cMpManager.GetSwitchInfo(tEqp, dwRtcpSwitchIp, wRtcpSwitchPort, dwSrcIp);
// 			tRemAddr.SetIpAddr(dwSrcIp);
// #ifdef _8KE_
// 			tRemAddr.SetPort(VMP_8KE_LOCALSND_PORT + byEqpOutChnl*PORTSPAN + 1);
// #else
// 			tRemAddr.SetPort(wRtcpSwitchPort + byEqpOutChnl*PORTSPAN + 1);
// #endif			
// 			tPrsParam.SetRemoteAddr(tRemAddr);
// 
// 			//设置丢包重传器接收RTP包的地址
// 			tLocAddr.SetIpAddr(tEqpLogChnl.GetRcvMediaChannel().GetIpAddr());
// 			tLocAddr.SetPort(tEqpLogChnl.GetRcvMediaChannel().GetPort() + PORTSPAN * byPrsChnlPos);
// 			tPrsParam.SetLocalAddr(tLocAddr);
// 		}
// 		break;
// 	// 目前只针对HDbas
// 	case EQP_TYPE_BAS:
// 		{
//         //bas 接收RTCP回馈包地址
// 	#ifdef _8KE_
// 			dwRtcpSwitchIp = 0;
// 			TPeriEqpStatus t8keStatus;
// 			g_cMcuVcApp.GetPeriEqpStatus(tEqp.GetEqpId() ,&t8keStatus);
// 			wRtcpSwitchPort = BAS_8KE_LOCALSND_PORT + (tEqp.GetEqpId()-BASID_MIN)*BAS_8KE_PORTSPAN 
// 								+ PORTSPAN * (BAS_8KE_PORTSPAN * byEqpInChnl + byEqpOutChnl) + 1; 
// // 			wRtcpSwitchPort = BAS_MCU_STARTPORT + (tEqp.GetEqpId()-BASID_MIN)*BAS_8KE_PORTSPAN 
// // 								+ PORTSPAN * (BAS_8KE_PORTSPAN * byEqpInChnl + byEqpOutChnl) + 1; 
// 			dwRtcpSwitchIp = g_cMcuVcApp.GetEqpIpAddr(tEqp.GetEqpId());
// 			tRemAddr.SetIpAddr(dwRtcpSwitchIp);
// 			tRemAddr.SetPort(wRtcpSwitchPort);
// 			tPrsParam.SetRemoteAddr(tRemAddr);
// 	#else
// 			//[nizhijun 2010/08/31] 修改
// 			/*TLogicalChannel  tEqpChnnl;*/
// // 			g_cMcuVcApp.GetPeriEqpLogicChnnl(tEqp.GetEqpId(), byEqpChnMode, &byEqpInChnl, &tEqpChnnl, TRUE);
// // 			dwRtcpSwitchIp = tEqpChnnl.GetRcvMediaChannel().GetIpAddr();
// 		//	wRtcpSwitchPort = tEqpChnnl.GetSndMediaCtrlChannel().GetPort();
// 			// tRemAddr.SetIpAddr(dwRtcpSwitchIp);
// 		/*	g_cMpManager.GetBasSwitchAddr(tEqp.GetEqpId(), dwRtcpSwitchIp, wRtcpSwitchPort);*/
// 			g_cMpManager.GetSwitchInfo(tEqp, dwRtcpSwitchIp, wRtcpSwitchPort, dwSrcIp);
// 			tRemAddr.SetIpAddr(dwSrcIp);
// 			tRemAddr.SetPort(wRtcpSwitchPort + PORTSPAN * byEqpOutChnl + 1);//这个port有问题
// 			tPrsParam.SetRemoteAddr(tRemAddr);
// 	#endif
//               
// 			//设置丢包重传器接收RTP包的地址
// 			tLocAddr.SetIpAddr(tEqpLogChnl.GetRcvMediaChannel().GetIpAddr());
// 			tLocAddr.SetPort(tEqpLogChnl.GetRcvMediaChannel().GetPort() + PORTSPAN * byPrsChnlPos);
// 			tPrsParam.SetLocalAddr(tLocAddr);
// 		}
// 		break;
// 	//[liu lijiu][20100812]增加全混音通道的prs支持
// 	//混音器
// 	case EQP_TYPE_EMIXER:
// 	case EQP_TYPE_MIXER:
// 		{
// 			TTransportAddr tEqpAddr;
// 			TLogicalChannel tEqpLogicalChannel;
// 			g_cMcuVcApp.GetPeriEqpLogicChnnl(m_tMixEqp.GetEqpId(), MODE_AUDIO, &byChlNum, &tEqpLogicalChannel, TRUE);
// 			tEqpAddr = tEqpLogicalChannel.GetRcvMediaCtrlChannel();		
// 			if(EQP_TYPE_EMIXER == tEqp.GetEqpType())
// 			{
// 				wRtcpSwitchPort = (tEqpAddr.GetPort() - 2) + MAXPORTSPAN_MIXER_GROUP * m_byMixGrpId 
// 		                            + PORTSPAN * GetMixerNModeChn() + 2;
// 			}
// 			else
// 			{
// 				wRtcpSwitchPort = (tEqpAddr.GetPort() - 2) + MAXPORTSPAN_MIXER_GROUP * m_byMixGrpId + 2;
// 			}
// 
// 			//设置远端接收rtcp的地址
// 			tRemAddr.SetIpAddr(tEqpAddr.GetIpAddr());
// 			tRemAddr.SetPort(wRtcpSwitchPort);
// 			tPrsParam.SetRemoteAddr(tRemAddr);
// 		
// 			//设置丢包重传器接收RTP包的地址
// 			tLocAddr.SetIpAddr(tEqpLogChnl.GetRcvMediaChannel().GetIpAddr());
// 			tLocAddr.SetPort(tEqpLogChnl.GetRcvMediaChannel().GetPort() + PORTSPAN * byPrsChnlPos);
// 			tPrsParam.SetLocalAddr(tLocAddr);
// 
// 			m_tConfInStatus.SetPrsChnlAudStart(TRUE);
// 
// 			break;
// 		}
// 	//[liu lijiu][20100812]ends
// 	default:
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,  "[ChangePrsSrc] unknown type(%d) of prssrc\n", tEqp.GetEqpType());
// 		return FALSE;
// 	    break;
// 	}
// 
// 	EqpLog("[ChangePrsSrc] Set src(id:%d, type:%d) for prs(id:%d, chnl:%d)\n", 
// 		   tEqp.GetEqpId(), tEqp.GetEqpType(), byPrsId, byPrsChnlPos);
// 	CServMsg cServMsg;
//     cServMsg.SetChnIndex(byPrsChnlPos);
//     cServMsg.SetMsgBody((u8*)&tPrsParam, sizeof(tPrsParam));
//     SendMsgToEqp(byPrsId, MCU_PRS_SETSRC_REQ, cServMsg);
// 	
// 	return TRUE;
// }

/*====================================================================
    函数名      GetPrsSrcAllegeAddr
    功能        :获取prs源的rtcp申述地址
    算法实现    ：
                  
    引用全局变量：
    输入参数说明： TMt tRtpSrc			RTP源(即RTCP目的，被申述者)
				   u8 byRtpSrcOutChn    RTP源通道
				   u8 byMediaMode		媒体类型
				   TTransportAddr	&tRemoteAddr 获得RTP源的RTCP信息,该信息为RTCP交换建立时的目的IP和端口
    返回值说明  ： 
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/04/15    4.6         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::GetRemoteRtcpAddr(TMt tRtpSrc, u8 byRtpSrcOutChn, u8 byMediaMode, TTransportAddr &tRemoteAddr)
{
	ConfPrint(LOG_LVL_DETAIL,MID_MCU_PRS,"[GetRemoteRtcpAddr]detail info:rtp src:%d-%d,srcoutchn:%d,mediamode:%d\n",
			  tRtpSrc.GetMcuId(),tRtpSrc.GetMtId(),byRtpSrcOutChn,byMediaMode
			 );
	if (tRtpSrc.IsNull() || 0xff == byRtpSrcOutChn)
	{
		return FALSE;
	}
	tRemoteAddr.SetNull();

	switch (tRtpSrc.GetType())
	{
	case TYPE_MT:
		{
			TMt tTempPrsSrc = GetLocalMtFromOtherMcuMt(tRtpSrc);
			if ( IsMultiCastMt(tTempPrsSrc.GetMtId()) )
			{
				ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_PRS,"[GetRemoteRtcpAddr]tTempPrsSrc:%d-%d is multicastmt!\n",tTempPrsSrc.GetMcuId(), tTempPrsSrc.GetMtId());
				return FALSE;
			}

			u8 byLogChnMode = 0;
			if (MODE_VIDEO == byMediaMode)
			{
				byLogChnMode = LOGCHL_VIDEO;
			}
			else if (MODE_AUDIO == byMediaMode)
			{
				byLogChnMode = LOGCHL_AUDIO;
			}
			else if (MODE_SECVIDEO == byMediaMode)
			{
				byLogChnMode = LOGCHL_SECVIDEO;
			}
			else 
			{
				return FALSE;
			}
				
			TLogicalChannel tLogicalChnl;
			if (tRtpSrc.IsLocal() || MODE_SECVIDEO == byMediaMode)
			{
				if (MODE_SECVIDEO == byMediaMode)
				{
					tRtpSrc = GetLocalMtFromOtherMcuMt(tRtpSrc);
				}

				if (m_ptMtTable->GetMtLogicChnnl(tRtpSrc.GetMtId(), byLogChnMode, &tLogicalChnl, FALSE))
				{
					tRemoteAddr = tLogicalChnl.GetSndMediaCtrlChannel();  
					return TRUE;
				}
				else
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[GetPrsSrcAllegeAddr] GetMtLogicChnnl Mt%d Mode:%d failed!\n",
									tRtpSrc.GetMtId(), byMediaMode);
				}		
			}
			else
			{
				//单回传
				if ( !IsLocalAndSMcuSupMultSpy(tRtpSrc.GetMcuId()) )
				{
					TMt tLocalMt = GetLocalMtFromOtherMcuMt(tRtpSrc);
					if (!tLocalMt.IsNull())
					{
						if (m_ptMtTable->GetMtLogicChnnl(tLocalMt.GetMtId(), byLogChnMode, &tLogicalChnl, FALSE))
						{
							tRemoteAddr = tLogicalChnl.GetSndMediaCtrlChannel();    
							return TRUE;
						}
					}
					else
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[ChangePrsSrc]GetLocalMtFromOtherMcuMt(Tmt:%d-%d) failed!\n",
										tRtpSrc.GetMcuId(), tRtpSrc.GetMtId());
					}
				}
				//多回传
				else
				{
					CRecvSpy tRrvSpyInfo;
					u32 dwRcvMpIp;
					if(m_cSMcuSpyMana.GetRecvSpy( tRtpSrc, tRrvSpyInfo ))
					{
						if (MODE_VIDEO == byMediaMode)
						{
							tRemoteAddr.SetPort(tRrvSpyInfo.m_tSpyAddr.GetPort() + 1);
						}
						else if(MODE_AUDIO == byMediaMode)
						{
							tRemoteAddr.SetPort(tRrvSpyInfo.m_tSpyAddr.GetPort() + 3);
						}	
											
						dwRcvMpIp = g_cMcuVcApp.GetMpIpAddr( 
							m_ptMtTable->GetMpId(GetLocalMtFromOtherMcuMt(tRtpSrc).GetMtId()) 
							);
						tRemoteAddr.SetIpAddr(dwRcvMpIp);
						return TRUE;
					}
					else
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[ChangePrsSrc] tPrsSrc<McuId:%d, MtId:%d>GetRecvSpy failed!\n",
										tRtpSrc.GetMcuId(), tRtpSrc.GetMtId());
					}
				}
			}
		}
		break;
	case TYPE_MCUPERI:
		{
			switch (tRtpSrc.GetEqpType())
			{
			//适配器
			case EQP_TYPE_BAS:
				{
					u32 dwRtcpSwitchIp  = 0;
					u16 wRtcpSwitchPort = 0;
					u32 dwBasIp = 0;
#if defined(_8KE_) || defined(_8KH_) || defined(_8KI_)
					dwRtcpSwitchIp  = 0;
				#ifdef _8KE_
					wRtcpSwitchPort = BAS_8KE_LOCALSND_PORT + (tRtpSrc.GetEqpId()-BASID_MIN)*BAS_8KE_PORTSPAN 
						+ PORTSPAN * byRtpSrcOutChn + 1; 
				#endif
					
				#if defined(_8KH_) || defined(_8KI_)
					if(MODE_VIDEO == byMediaMode || MODE_SECVIDEO == byMediaMode)
					{
						wRtcpSwitchPort = BAS_8KE_LOCALSND_PORT + (tRtpSrc.GetEqpId()-BASID_MIN)*BAS_8KH_PORTSPAN 
										+ PORTSPAN *  byRtpSrcOutChn + 1; 
					}
					else if(MODE_AUDIO == byMediaMode)
					{
						wRtcpSwitchPort = BAS_8KE_LOCALSND_PORT + (tRtpSrc.GetEqpId()-BASID_MIN)*BAS_8KH_PORTSPAN 
										+ PORTSPAN *  byRtpSrcOutChn + 3; 
					}
					
				#endif
				
				/*#ifdef _8KI_
					if (MODE_VIDEO == byMediaMode || MODE_SECVIDEO == byMediaMode)
					{
						wRtcpSwitchPort = BAS_8KE_LOCALSND_PORT + byRtpSrcOutChn*PORTSPAN +1;	//55601,55600为本地RTP发送
					}
					else if (MODE_AUDIO == byMediaMode)
					{
						wRtcpSwitchPort = BAS_8KE_LOCALSND_PORT + byRtpSrcOutChn*PORTSPAN +5;	//55605,55604为本地RTP发送
					}
				#endif*/
			
					dwRtcpSwitchIp = g_cMcuVcApp.GetEqpIpAddr(tRtpSrc.GetEqpId());
					tRemoteAddr.SetIpAddr(dwRtcpSwitchIp);
					tRemoteAddr.SetPort(wRtcpSwitchPort);
#else
					g_cMpManager.GetSwitchInfo(tRtpSrc, dwRtcpSwitchIp, wRtcpSwitchPort, dwBasIp);
					tRemoteAddr.SetIpAddr(dwBasIp);

					if (MODE_VIDEO == byMediaMode || MODE_SECVIDEO == byMediaMode)
					{
						tRemoteAddr.SetPort(wRtcpSwitchPort + PORTSPAN * byRtpSrcOutChn + 1);//这个port有问题
					}
					else if(MODE_AUDIO == byMediaMode)
					{
						tRemoteAddr.SetPort(wRtcpSwitchPort + PORTSPAN * byRtpSrcOutChn + 3);//这个port有问题
					}			
					else
					{
						return FALSE;
					}
#endif
					return TRUE;
				}
				break;
		    //放像机
			case EQP_TYPE_RECORDER:
				{
					TLogicalChannel tRecLogicalChannel;
					u8 byRecChnlNum;
					u32 dwRecEqpIP;
					u16 wRecEqpPort;
					u16 wPort;
					g_cMcuVcApp.GetPeriEqpLogicChnnl(m_tPlayEqp.GetEqpId(), MODE_VIDEO, &byRecChnlNum, &tRecLogicalChannel, FALSE);
					dwRecEqpIP  = tRecLogicalChannel.GetRcvMediaChannel().GetIpAddr();
					wRecEqpPort = tRecLogicalChannel.GetRcvMediaChannel().GetPort();
					wPort = wRecEqpPort + PORTSPAN * m_byPlayChnnl;
					
					if (MODE_VIDEO == byMediaMode)
					{
						tRemoteAddr.SetIpAddr(dwRecEqpIP);
						tRemoteAddr.SetPort(wPort + 1);
					}
					else if(MODE_AUDIO == byMediaMode)
					{
						tRemoteAddr.SetIpAddr(dwRecEqpIP);
						tRemoteAddr.SetPort(wPort + 3);
					}
					else if (MODE_SECVIDEO == byMediaMode)
					{
						tRemoteAddr.SetIpAddr(dwRecEqpIP);
						tRemoteAddr.SetPort(wPort + 5);
					}
					else
					{
						return FALSE;
					}
					return TRUE;
				}
				break;
			//vpu or mpu
			case EQP_TYPE_VMP:
				{
					u32 dwEqpIP  = 0;
					u32 dwRcvIp  = 0;
					u16 wRcvPort = 0;
					//[nizhijun 20120605]vpu 39000编码那一出，RTCP端口40691，39010对应RTCP端口40681
					if(VMP == GetVmpSubType(m_tVmpEqp.GetEqpId()))
					{    
						g_cMpManager.GetSwitchInfo(tRtpSrc, dwRcvIp, wRcvPort, dwEqpIP);
						
						TEqpVMPInfo tVmpInfo;
						g_cMcuAgent.GetEqpVMPCfg( tRtpSrc.GetEqpId(), &tVmpInfo);
						
						tRemoteAddr.SetIpAddr(dwEqpIP);     
						tRemoteAddr.SetPort(tVmpInfo.GetEqpRecvPort() - PORTSPAN*(byRtpSrcOutChn+1) + 1);          
					}	
					//mpu画面合成4路
					else
					{
						g_cMpManager.GetSwitchInfo(tRtpSrc, dwRcvIp, wRcvPort, dwEqpIP);
						
						tRemoteAddr.SetIpAddr(dwEqpIP);
#if defined(_8KE_) || defined(_8KH_)|| defined(_8KI_)
						tRemoteAddr.SetPort(VMP_8KEOR8KH_LOCALSND_PORT + PORTSPAN * byRtpSrcOutChn + 1);
#else
						tRemoteAddr.SetPort(wRcvPort + PORTSPAN * byRtpSrcOutChn+ 1);
#endif
					}
					return TRUE;
				}
				break;
			//混音器
			case EQP_TYPE_MIXER:
				{
					if (!(tRtpSrc == m_tMixEqp))
					{
						return FALSE;
					}
					u8 byMixerSubtype = UNKONW_MIXER;
					g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetEqpId(),byMixerSubtype);
					switch (byMixerSubtype)
					{
					case APU_MIXER:
					case MIXER_8KH:
						{
							u16 wRtcpSwitchPort = 0;
							TEqpMixerInfo tEqpMixerInfo;
							memset(&tEqpMixerInfo, 0, sizeof(TEqpMixerInfo));
							g_cMcuAgent.GetEqpMixerCfg( m_tMixEqp.GetEqpId(), &tEqpMixerInfo );
							
							//[nizhijun 2011/05/10] 8000H混音器和APU比较特殊，N模式被申述端口是以接受端口+3做为RTCP源端口
							//N-1还是使用+5
							if (byRtpSrcOutChn == GetMixerNModeChn())
							{
								/*N码流端口，此端口发给prs保存，如果PRS丢包向混音器此端口请求*/
								wRtcpSwitchPort = tEqpMixerInfo.GetEqpRecvPort() + MAXPORTSPAN_MIXER_GROUP * m_byMixGrpId 
									+ PORTSPAN * byRtpSrcOutChn + 2+ 1;
							}
							else
							{
								/*N-1码流端口，混音终端丢包向混音器此端口请求*/
								wRtcpSwitchPort = tEqpMixerInfo.GetEqpRecvPort() + MAXPORTSPAN_MIXER_GROUP * m_byMixGrpId 
									+ PORTSPAN * byRtpSrcOutChn + 4+ 1;
							}
							
							u8  byChlNum = 0;
							TLogicalChannel tEqpLogicalChannel;				
							if (!g_cMcuVcApp.GetPeriEqpLogicChnnl(m_tMixEqp.GetEqpId(), MODE_AUDIO, &byChlNum, &tEqpLogicalChannel, TRUE))
							{
								return FALSE;
							}
							
							TTransportAddr tEqpAddr = tEqpLogicalChannel.GetRcvMediaCtrlChannel();		
							
							tRemoteAddr.SetIpAddr(tEqpAddr.GetIpAddr());
							tRemoteAddr.SetPort(wRtcpSwitchPort);
							
							return TRUE;
						}
						break;
					case EAPU_MIXER:
					case APU2_MIXER:
						{
							if (!(tRtpSrc == m_tMixEqp))
							{
								return FALSE;
							}
							
							TPeriEqpStatus tMixStatus;
							if (!g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tMixStatus))
							{
								return FALSE;
							}
							u8 byOffChn = tMixStatus.m_tStatus.tMixer.m_byMixOffChnNum;
							//n模式通道数
							TEqpMixerInfo tEqpMixerInfo;
							g_cMcuAgent.GetEqpMixerCfg(m_tMixEqp.GetEqpId(), &tEqpMixerInfo);
							u16 dRcvPort = tEqpMixerInfo.GetEqpRecvPort();
							
							u8 byMixerRunBrdId = tEqpMixerInfo.GetRunBrdId();
							u8 byNModeChnNum  = 0;
							for (u8 byMixIdIndex = MIXERID_MIN; byMixIdIndex <= MIXERID_MAX ; byMixIdIndex++)
							{
								memset(&tEqpMixerInfo, 0, sizeof(TEqpMixerInfo));
								g_cMcuAgent.GetEqpMixerCfg(byMixIdIndex, &tEqpMixerInfo);
								if (byMixerRunBrdId == tEqpMixerInfo.GetRunBrdId())
								{
									if (byMixIdIndex == m_tMixEqp.GetEqpId())
									{
										break;
									}
									else if (byMixerSubtype == APU2_MIXER)
									{
										byNModeChnNum += 4;
									}
									else
									{
										byNModeChnNum++;
									}
								}
							}
							
							byRtpSrcOutChn = byOffChn + byNModeChnNum + byRtpSrcOutChn;
							
							u16 wRtcpSwitchPort = 0;
							//混音器本地等待远端申述的RTCP端口，是由下面公式计算得到的					
							wRtcpSwitchPort = MIXER_MCU_STARTPORT + PORTSPAN * byRtpSrcOutChn + 2 + 1;
							
							u8  byChlNum = 0;
							TLogicalChannel tEqpLogicalChannel;				
							if (!g_cMcuVcApp.GetPeriEqpLogicChnnl(m_tMixEqp.GetEqpId(), MODE_AUDIO, &byChlNum, &tEqpLogicalChannel, TRUE))
							{
								return FALSE;
							}
							
							TTransportAddr tEqpAddr = tEqpLogicalChannel.GetRcvMediaCtrlChannel();		
							tRemoteAddr.SetIpAddr(tEqpAddr.GetIpAddr());
							tRemoteAddr.SetPort(wRtcpSwitchPort);
							
							return TRUE;
						}
						break; 
					case MIXER_8KI:
						{
							if (!(tRtpSrc == m_tMixEqp))
							{
								return FALSE;
							}
							
							TEqpMixerInfo tEqpMixerInfo;
							g_cMcuAgent.GetEqpMixerCfg(m_tMixEqp.GetEqpId(), &tEqpMixerInfo);
							u16 dRcvPort = tEqpMixerInfo.GetEqpRecvPort();
							
							u16 wRtcpSwitchPort = 0;
							// 三种编码格式[8/2/2013 chendaiwei]
							if (byRtpSrcOutChn >= GetMixerNModeChn() && byRtpSrcOutChn < GetMixerNModeChn()+3)
							{
								wRtcpSwitchPort = dRcvPort + PORTSPAN * byRtpSrcOutChn + 2 + 1;
								
							}
							else
							{				
								wRtcpSwitchPort = dRcvPort + PORTSPAN * byRtpSrcOutChn + 4 + 1;
							}

							
							u8  byChlNum = 0;
							TLogicalChannel tEqpLogicalChannel;				
							if (!g_cMcuVcApp.GetPeriEqpLogicChnnl(m_tMixEqp.GetEqpId(), MODE_AUDIO, &byChlNum, &tEqpLogicalChannel, TRUE))
							{
								return FALSE;
							}
							
							TTransportAddr tEqpAddr = tEqpLogicalChannel.GetRcvMediaCtrlChannel();		
							tRemoteAddr.SetIpAddr(tEqpAddr.GetIpAddr());
							tRemoteAddr.SetPort(wRtcpSwitchPort);
							
							return TRUE;
						}
						break; 
					case MIXER_8KG:
						{
							u16 wRtcpSwitchPort = 0;
							u32 dwMixSwitchIp    = 0;
							u16 wMixMcuStartPort = 0;
							u16 wMixStartPort    = 0;
							g_cMpManager.GetSwitchInfo(m_tMixEqp.GetEqpId(), dwMixSwitchIp, wMixMcuStartPort, wMixStartPort);
							
							if (byRtpSrcOutChn == GetMixerNModeChn())
							{
								wRtcpSwitchPort = wMixStartPort + PORTSPAN * byRtpSrcOutChn+ 2;
							}
							else
							{
								wRtcpSwitchPort = wMixStartPort + PORTSPAN * byRtpSrcOutChn+ 4;
							}
							
							//对于APU本地等待远端申述的RTCP端口，底层由APU本地发送端口+1计算得到
							wRtcpSwitchPort += 1;
							
							u8  byChlNum = 0;
							TLogicalChannel tEqpLogicalChannel;				
							if (!g_cMcuVcApp.GetPeriEqpLogicChnnl(m_tMixEqp.GetEqpId(), MODE_AUDIO, &byChlNum, &tEqpLogicalChannel, TRUE))
							{
								return FALSE;
							}
							
							TTransportAddr tEqpAddr = tEqpLogicalChannel.GetRcvMediaCtrlChannel();		
							
							tRemoteAddr.SetIpAddr(tEqpAddr.GetIpAddr());
							tRemoteAddr.SetPort(wRtcpSwitchPort);
							
							return TRUE;
						}
						break;
					default:
						break;
					}
					return TRUE;
				}
				break;
			case EQP_TYPE_PRS:
				{
					byMediaMode = (byMediaMode == MODE_SECVIDEO) ? MODE_VIDEO : byMediaMode;
					
					TLogicalChannel tLogicalChannel;
					u8 byChnnlNum = 0;

					g_cMcuVcApp.GetPeriEqpLogicChnnl(tRtpSrc.GetEqpId(), byMediaMode, &byChnnlNum, &tLogicalChannel, TRUE);
					u16 wDstPort = tLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * byRtpSrcOutChn + 2;
					
					tRemoteAddr.SetIpAddr(tLogicalChannel.GetRcvMediaChannel().GetIpAddr());
					tRemoteAddr.SetPort(wDstPort);
					return TRUE;
				}
				break;
			default:
				ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[GetPrsSrcAllegeAddr] unexpected EqpType:%d!\n", tRtpSrc.GetEqpType());
				break;
			}
		}
		break;
	default:
		break;
	}

	return FALSE;
}
/*====================================================================
    函数名      ：ChangePrsSrc
    功能        ：改变丢包重传的接收源
    算法实现    ：
                  
    引用全局变量：
    输入参数说明： u8 byPrsId          改变源的prs外设
				   u8 byPrsChnId       改变源的Prs输入通道号
                   TMt tPrsSrc         prs通道对应新的源
				   u8 byPrsSrcOutChn   prs源的输出通道号
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/04/15    4.6         周嘉麟        创建
====================================================================*/
BOOL32 CMcuVcInst::ChangePrsSrc(u8 byPrsId, u8 byPrsChnId, u8 byMediaMode, TMt tPrsSrc, u8 byPrsSrcOutChn/* = 0*/)
{
	if (tPrsSrc.IsNull())
	{
		return FALSE;
	}

	//如果是MODE_VIDEO2SECOND模式，则远端RTCP地址为源的主视频信息
	if (MODE_VIDEO2SECOND == byMediaMode)
	{
		byMediaMode = MODE_VIDEO;
	}

	if (MODE_VIDEO != byMediaMode && 
		MODE_AUDIO != byMediaMode &&
		MODE_SECVIDEO != byMediaMode)
	{
		return FALSE;
	}

// 	//[2011/10/19/zhangli]tPrsSrc可能是下级终端，不能用m_ptMtTable->GetManuId获取
// 	if(TYPE_MT == tPrsSrc.GetType() && !IsKedaMt(tPrsSrc, TRUE))
// 	{
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[ChangePrsSrc] not keda mt or mcu mt(%d,%d)!\n", tPrsSrc.GetMcuId(), tPrsSrc.GetMtId());
// 		return FALSE;
// 	} 

	u8 byChlNum = 0;
	TLogicalChannel tPrsLogChnl;
    if (!g_cMcuVcApp.GetPeriEqpLogicChnnl(byPrsId, MODE_VIDEO, &byChlNum, &tPrsLogChnl, TRUE))
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[ChangePrsSrc] Can't get prs(%d) logic channel, ChangePrsSrc failure!\n",
			byPrsId);
        return FALSE;
    }

	TPrsParam tPrsParam;
	TTransportAddr tLocalAddr;

	//prs本地接收Rtp地址
	tLocalAddr.SetIpAddr(tPrsLogChnl.GetRcvMediaChannel().GetIpAddr());
	tLocalAddr.SetPort(tPrsLogChnl.GetRcvMediaChannel().GetPort() + PORTSPAN*byPrsChnId);
	tPrsParam.SetLocalAddr(tLocalAddr);     

	//prs远端申述rtcp地址
	TTransportAddr tRemoteAddr;
	// 如果源是卫星终端，还是设置占用该通道
	//等占用prs通道收到ACK后，建立交换时，会建立卫星终端到PRS的RTP交换，可以让PRS下行请求得到执行
	TMt tTempPrsSrc = GetLocalMtFromOtherMcuMt(tPrsSrc);
	if ( IsMultiCastMt(tTempPrsSrc.GetMtId()) )
	{
		ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_PRS,"[ChangePrsSrc]tTempPrsSrc:%d-%d is multicastmt!\n",tTempPrsSrc.GetMcuId(), tTempPrsSrc.GetMtId());
		tRemoteAddr.SetNull();
	}
	else
	{
		if (!GetRemoteRtcpAddr(tPrsSrc, byPrsSrcOutChn, byMediaMode, tRemoteAddr))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[ChangePrsSrc] GetPrsRemoteAddr failed!\n");
			return FALSE;
		}
	}


	//非科达终端也建立到prs的RTP交换，但tRemoteAddr中的IP填0，不让PRS请求
	if(TYPE_MT == tPrsSrc.GetType() && !IsKedaMt(tPrsSrc, TRUE))
	{
		tRemoteAddr.SetNull();
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_PRS, "[ChangePrsSrc] not keda mt or mcu mt(%d,%d)tRemoteAddr.SetNull!\n", tPrsSrc.GetMcuId(), tPrsSrc.GetMtId());
	} 

	tPrsParam.SetRemoteAddr(tRemoteAddr);

	CServMsg cServMsg;
	if(tPrsSrc.GetType() == TYPE_MT)
    {
		cServMsg.SetSrcMtId(tPrsSrc.GetMtId());
	}
	else
	{
		cServMsg.SetSrcMtId(0);
    }
	cServMsg.SetChnIndex(byPrsChnId);
	cServMsg.SetMsgBody((u8*)&tPrsParam, sizeof(tPrsParam));
    SendMsgToEqp(byPrsId, MCU_PRS_SETSRC_REQ, cServMsg);

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[ChangePrsSrc]RemotePrs--IP:%s  Port:%d  ChnlId:%d  PrsSrcOutChn:%d\n", 
		StrOfIP(tRemoteAddr.GetIpAddr()), tRemoteAddr.GetPort(), byPrsChnId, byPrsSrcOutChn);

	return TRUE;
}
/*====================================================================
    函数名      ：ChangePrsSrc
    功能        ：改变丢包重传的接收源(终端接收RTCP回馈包的地址, 丢包重传器接收RTP包的地址)
    算法实现    ：在ack中将广播源rtp -> prs, 各与会MT的RTCP -> PRS,这里只改变不需bas适配的prs源信息，
                  其他prs源信息与bas绑定处理,及开始bas时改变prs源，停止bas时
    引用全局变量：
    输入参数说明： TMt tMt 广播源终端
                    BOOL32 bSrcBas  源是否为bas
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/27    3.0         胡昌威        创建
====================================================================*/
// void CMcuVcInst::ChangePrsSrc(TMt tMt, u8 byPrsChanMode, BOOL32 bSrcBas)
// {
//     EqpLog("[ChangePrsSrc] Start MtId.%d PrsChanMode.%d\n", tMt.GetMtId(), byPrsChanMode);
// 
//     CServMsg  cServMsg;
//     TPrsParam tPrsParam;
//     TPrsParam tPrsParam2;
//     TPrsParam tPrsParamAud;
//     TPrsParam tPrsParamAudBas;
//     TPrsParam tPrsParamVidBas;
//     TPrsParam tPrsParamBrBas;
//     //TPrsParam tPrsParamHDVidBas;    // 高清适配主视频丢包重传参数, zgc, 2008-08-13
//     TLogicalChannel tMtLogicalChannel;
//     TLogicalChannel tMtLogicalChannel2;
//     TLogicalChannel tMtLogicalChannelAud;
//     TLogicalChannel tEqpLogicalChannel;
// 
//     u8  byEqpType;
//     u8  byChlNum;
//     u32 dwEqpIP;
//     TTransportAddr tLocalAddr;
//     TTransportAddr tDstAddr;
//     u32 dwRtcpSwitchIp;
//     u16 wRtcpSwitchPort;
// 
//     //是否有预留资源
//     if (m_tPrsEqp.IsNull())
//     {
//         ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangePrsSrc] End1 MtId.%d PrsChanMode.%d\n", tMt.GetMtId(), byPrsChanMode);
// 
//         return;
//     }
// 
//     if (!g_cMcuVcApp.GetPeriEqpLogicChnnl(m_tPrsEqp.GetEqpId(), MODE_VIDEO, &byChlNum, &tEqpLogicalChannel, TRUE))
//     {
//         ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangePrsSrc] Can't get mt logic channel, ChangePrsSrc failure!\n");
//         return;
//     }
// 
// 	//[nizhijun 2011/02/17]prs 外置化 dwEqpIP需要是网络序的
// #ifdef _8KE_
// 	dwEqpIP = htonl( g_cMcuVcApp.GetEqpIpAddr(m_tPrsEqp.GetEqpId()) );
// 	if (dwEqpIP>0)
// 	{
// 		tLocalAddr.SetNetSeqIpAddr(dwEqpIP);
//         tLocalAddr.SetPort(0 );
//         tPrsParam.SetLocalAddr(tLocalAddr);
//         tPrsParam2.SetLocalAddr(tLocalAddr);
//         tPrsParamAud.SetLocalAddr(tLocalAddr);
//         tPrsParamAudBas.SetLocalAddr(tLocalAddr);
//         tPrsParamVidBas.SetLocalAddr(tLocalAddr);
//         tPrsParamBrBas.SetLocalAddr(tLocalAddr);
// 	}
// 	else
// 	{
// 		EqpLog("[ChangePrsSrc] eqp:%d GetEqpIpAddr failed!\n",m_tPrsEqp.GetEqpId());
// 	}
// #else
//     //填IP地址
//     if (SUCCESS_AGENT == g_cMcuAgent.GetPeriInfo(m_tPrsEqp.GetEqpId(), &dwEqpIP, &byEqpType))
//     {
//         tLocalAddr.SetNetSeqIpAddr(dwEqpIP);
//         tLocalAddr.SetPort(0 );
//         tPrsParam.SetLocalAddr(tLocalAddr);
//         tPrsParam2.SetLocalAddr(tLocalAddr);
//         tPrsParamAud.SetLocalAddr(tLocalAddr);
//         tPrsParamAudBas.SetLocalAddr(tLocalAddr);
//         tPrsParamVidBas.SetLocalAddr(tLocalAddr);
//         tPrsParamBrBas.SetLocalAddr(tLocalAddr);
//     }
// #endif
//   
//     //数据源是否为bas
//     if(bSrcBas)
//     {
//         TLogicalChannel tSrcLogicalChannel;
//         
//         if(EQP_CHANNO_INVALID != m_byPrsChnnlVidBas && !m_tVidBasEqp.IsNull())
//         {                        
//             //bas 接收RTCP回馈包地址
//             g_cMpManager.GetBasSwitchAddr(m_tVidBasEqp.GetEqpId(), dwRtcpSwitchIp, wRtcpSwitchPort);
//             tDstAddr.SetIpAddr(dwRtcpSwitchIp);
//             tDstAddr.SetPort(wRtcpSwitchPort + PORTSPAN*m_byVidBasChnnl + 1);
//             tPrsParamVidBas.SetRemoteAddr(tDstAddr);
//             
//             //设置丢包重传器接收RTP包的地址
//             tLocalAddr = tPrsParam.GetLocalAddr();
//             tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVidBas);
//             tPrsParamVidBas.SetLocalAddr(tLocalAddr);
//         }
//         
//         if(EQP_CHANNO_INVALID != m_byPrsChnnlBrBas && !m_tBrBasEqp.IsNull())
//         {
//             //bas 接收RTCP回馈包地址
//             g_cMpManager.GetBasSwitchAddr(m_tBrBasEqp.GetEqpId(), dwRtcpSwitchIp, wRtcpSwitchPort);
//             tDstAddr.SetIpAddr(dwRtcpSwitchIp);
//             tDstAddr.SetPort(wRtcpSwitchPort + PORTSPAN*m_byBrBasChnnl + 1);
//             tPrsParamBrBas.SetRemoteAddr(tDstAddr);
//             
//             //设置丢包重传器接收RTP包的地址
//             tLocalAddr = tPrsParam.GetLocalAddr();
//             tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlBrBas);
//             tPrsParamBrBas.SetLocalAddr(tLocalAddr);
//         }
//         
//         if(EQP_CHANNO_INVALID != m_byPrsChnnlAudBas && !m_tAudBasEqp.IsNull())
//         {
//             //bas 接收RTCP回馈包地址
//             g_cMpManager.GetBasSwitchAddr(m_tAudBasEqp.GetEqpId(), dwRtcpSwitchIp, wRtcpSwitchPort);
//             tDstAddr.SetIpAddr(dwRtcpSwitchIp);
//             tDstAddr.SetPort(wRtcpSwitchPort + PORTSPAN*m_byAudBasChnnl + 3);
//             tPrsParamAudBas.SetRemoteAddr(tDstAddr);
//             
//             //设置丢包重传器接收RTP包的地址
//             tLocalAddr = tPrsParam.GetLocalAddr();
//             tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlAudBas);
//             tPrsParamAudBas.SetLocalAddr(tLocalAddr);
//         }
// 
//         //给丢包重传器发消息
//         if (PRSCHANMODE_AUDBAS == byPrsChanMode && EQP_CHANNO_INVALID != m_byPrsChnnlAudBas)
//         {
//             if (TYPE_MT == tMt.GetType())
//             {
//                 cServMsg.SetSrcMtId(tMt.GetMtId());
//                 cServMsg.SetChnIndex(m_byPrsChnnlAudBas);
//                 cServMsg.SetMsgBody((u8*)&tPrsParamAudBas, sizeof(tPrsParamAudBas));
//                 SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_SETSRC_REQ, cServMsg);
//                 m_tConfInStatus.SetPrsChnlAudBasStart(TRUE);
// 
//                 //把bas的Rtcp交换给源mt
//                 m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_AUDIO, &tSrcLogicalChannel, FALSE);                    
//                 u32 dwDstIp = tSrcLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
//                 u16 wDstPort = tSrcLogicalChannel.GetSndMediaCtrlChannel().GetPort();
//                 
//                 SwitchVideoRtcpToDst(dwDstIp, wDstPort, m_tAudBasEqp, m_byAudBasChnnl, MODE_AUDIO, SWITCH_MODE_BROADCAST);
//             }
//         }
//         
//         //给丢包重传器发消息
//         if (PRSCHANMODE_VIDBAS == byPrsChanMode && EQP_CHANNO_INVALID != m_byPrsChnnlVidBas)
//         {
//             if(TYPE_MT == tMt.GetType())
//             {
//                 cServMsg.SetSrcMtId(tMt.GetMtId());
//                 cServMsg.SetChnIndex(m_byPrsChnnlVidBas);
//                 cServMsg.SetMsgBody((u8*)&tPrsParamVidBas, sizeof(tPrsParamVidBas));
//                 SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_SETSRC_REQ, cServMsg);
//                 m_tConfInStatus.SetPrsChnlVidBasStart(TRUE);
// 
//                 //把bas的Rtcp交换给源mt
//                 m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tSrcLogicalChannel, FALSE);                    
//                 u32 dwDstIp = tSrcLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
//                 u16 wDstPort = tSrcLogicalChannel.GetSndMediaCtrlChannel().GetPort();
//                 
//                 SwitchVideoRtcpToDst(dwDstIp, wDstPort, m_tVidBasEqp, m_byVidBasChnnl, MODE_VIDEO, SWITCH_MODE_BROADCAST);
//             }
//         }
//         
//         //给丢包重传器发消息
//         if(PRSCHANMODE_BRBAS == byPrsChanMode && EQP_CHANNO_INVALID != m_byPrsChnnlBrBas)
//         {
//             if(TYPE_MT == tMt.GetType())
//             {
//                 cServMsg.SetSrcMtId(tMt.GetMtId());
//                 cServMsg.SetChnIndex(m_byPrsChnnlBrBas);
//                 cServMsg.SetMsgBody((u8*)&tPrsParamBrBas, sizeof(tPrsParamBrBas));
//                 SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_SETSRC_REQ, cServMsg);
//                 m_tConfInStatus.SetPrsChnlBrBasStart(TRUE);
// 
//                 //把bas的Rtcp交换给源mt
//                 m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tSrcLogicalChannel, FALSE);                    
//                 u32 dwDstIp = tSrcLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();
//                 u16 wDstPort = tSrcLogicalChannel.GetSndMediaCtrlChannel().GetPort();
//                 
//                 SwitchVideoRtcpToDst(dwDstIp, wDstPort, m_tBrBasEqp, m_byBrBasChnnl, MODE_VIDEO, SWITCH_MODE_BROADCAST);
//             }
//         }
// 
//         // FIXME：高清适配丢包重传未添加,zgc
//         if ( PRSCHANMODE_HDBAS_VID == byPrsChanMode /*&& m_cConfBasChnMgr.GetVidChnUseNum() > 0*/ )
//         {
//             if(TYPE_MT == tMt.GetType())
//             {
//                 cServMsg.SetSrcMtId(tMt.GetMtId());
//                 cServMsg.SetChnIndex(m_byPrsChnnlBrBas);
//                 cServMsg.SetMsgBody((u8*)&tPrsParamBrBas, sizeof(tPrsParamBrBas));
//                 SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_SETSRC_REQ, cServMsg);
//                 m_tConfIn		//[nizhijun 2011/02/16] dwEqpIP从GetSwitchInfo得到的本地序，故不需要再用ntohl接口转换
// 		//tDstAddr.SetIpAddr(ntohl(dwEqpIP));
// 		tDstAddr.SetPort(VMP_8KE_LOCALSND_PORT + PORTSPAN*1 + 1);
// #else
//         tDstAddr.SetPort(tVmpInfo.GetEqpRecvPort() - PORTSPAN*2 + 1);          
// #endif        
//         tPrsParam.SetRemoteAddr(tDstAddr);
//         
//         //设置丢包重传器接收RTP包的地址
//         tLocalAddr = tPrsParam.GetLocalAddr();
//         tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlBrBas);
//         tPrsParam.SetLocalAddr(tLocalAddr);
// 
//         cServMsg.SetSrcMtId(0);
//         cServMsg.SetChnIndex(m_byPrsChnnlBrBas);
//         cServMsg.SetMsgBody((u8*)&tPrsParam, sizeof(tPrsParam));
//         SendMsgToEqp(m_tPrsEqp.GetEqpId() , MCU_PRS_SETSRC_REQ, cServMsg);
//         m_tConfInStatus.SetPrsChnlBrBasStart(TRUE);
//         EqpLog("[ChangePrsSrc] Msg MCU_PRS_SETSRC_REQ send to prs eqp %d chl %d!\n", m_tPrsEqp.GetEqpId(), m_byPrsChnnlBrBas);
//     }
// 	
// 	// xliang [4/30/2009] 多路输出类广播源4出码流prs设置
//     if (PRSCHANMODE_VMPOUT1 == byPrsChanMode && EQP_CHANNO_INVALID != m_byPrsChnnlVmpOut1)
//     {
// 		//广播源接收RTCP回馈包地址            
//         u32 dwEqpIP,dwRcvIp;
//         u16 wRcvPort;
//         g_cMpManager.GetSwitchInfo(tMt, dwRcvIp, wRcvPort, dwEqpIP);
//         
//         //TEqpVMPInfo tVmpInfo;
//         //g_cMcuAgent.GetEqpVMPCfg( tMt.GetEqpId(), &tVmpInfo);      				
//         //tDstAddr.SetPort(tVmpInfo.GetEqpRecvPort() + 1);       
// 		
// // 		u16 wRtcpPort;		
// // 		g_cMpManager.GetVmpSwitchAddr(m_tVmpEqp.GetEqpId(), dwEqpIP, wRtcpPort);
// 
// 		tDstAddr.SetIpAddr(dwEqpIP);
// #ifdef _8KE_
// 		//[nizhijun 2011/02/16] dwEqpIP从GetSwitchInfo得到的本地序，故不需要再用ntohl接口转换
// 		//tDstAddr.SetIpAddr(ntohl(dwEqpIP));
// 		tDstAddr.SetPort(VMP_8KE_LOCALSND_PORT + 1);
// #else
//         tDstAddr.SetPort(wRcvPort + PORTSPAN * ( byPrsChanMode - PRSCHANMODE_VMPOUT1 ) + 1);
// #endif
//         tPrsParam.SetRemoteAddr(tDstAddr);
//         		
//         //设置丢包重传器接收RTP包的地址
//         tLocalAddr = tPrsParam.GetLocalAddr();
//         tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut1);
//         tPrsParam.SetLocalAddr(tLocalAddr);
// 		
//         cServMsg.SetSrcMtId(0);
//         cServMsg.SetChnIndex(m_byPrsChnnlVmpOut1);
//         cServMsg.SetMsgBody((u8*)&tPrsParam, sizeof(tPrsParam));
//         SendMsgToEqp(m_tPrsEqp.GetEqpId() , MCU_PRS_SETSRC_REQ, cServMsg);
//         m_tConfInStatus.SetPrsChnlVmpOut1Start(TRUE); 
//         EqpLog("[ChangePrsSrc] Msg MCU_PRS_SETSRC_REQ send to prs eqp %d chl %d(m_byPrsChnnlVmpOut1)!\n", m_tPrsEqp.GetEqpId(), m_byPrsChnnlVmpOut1);
// 		
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangePrsSrc] First_Vmp_Out LocalAddr<Ip:%s, Port:%d> RemoteAddr<Ip:%s, Port:%d>\n",
// 			StrOfIP(tLocalAddr.GetIpAddr()), tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut1,
// 					StrOfIP(dwEqpIP), wRcvPort + PORTSPAN * ( byPrsChanMode - PRSCHANMODE_VMPOUT1 ) + 1);
//     }
// 
// 	if (PRSCHANMODE_VMPOUT2 == byPrsChanMode && EQP_CHANNO_INVALID != m_byPrsChnnlVmpOut2)
//     {
//         //广播源接收RTCP回馈包地址            
// 		u32 dwEqpIP,dwRcvIp;
// 	    u16 wRcvPort;
// 	    g_cMpManager.GetSwitchInfo(tMt, dwRcvIp, wRcvPort, dwEqpIP);
// 		//         
// 		//         TEqpVMPInfo tVmpInfo;
// 		//         g_cMcuAgent.GetEqpVMPCfg( tMt.GetEqpId(), &tVmpInfo);
// 		// 		
// 		//         tDstAddr.SetIpAddr(dwEqpIP);          
// 		//         tDstAddr.SetPort(tVmpInfo.GetEqpRecvPort() + PORTSPAN*1 + 1);        
// 		
// 		
// // 		u16 wRtcpPort;		
// // 		g_cMpManager.GetVmpSwitchAddr(m_tVmpEqp.GetEqpId(), dwEqpIP, wRtcpPort);
// 		s8 achIp[64] = {0};
// 		memcpy(achIp, StrOfIP(dwEqpIP), 64);
// 		tDstAddr.SetIpAddr(dwEqpIP);
// #ifdef _8KE_
// 		//[nizhijun 2011/02/16] dwEqpIP从GetSwitchInfo得到的本地序，故不需要再用ntohl接口转换
// 		//tDstAddr.SetIpAddr(ntohl(dwEqpIP));
// 		tDstAddr.SetPort(VMP_8KE_LOCALSND_PORT + PORTSPAN *1 + 1);
// #else
//         tDstAddr.SetPort(wRcvPort + PORTSPAN * ( byPrsChanMode - PRSCHANMODE_VMPOUT1 ) + 1);
// #endif               
//         tPrsParam.SetRemoteAddr(tDstAddr);
//         
//         //设置丢包重传器接收RTP包的地址
//         tLocalAddr = tPrsParam.GetLocalAddr();
//         tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut2);
//         tPrsParam.SetLocalAddr(tLocalAddr);
// 		
//         cServMsg.SetSrcMtId(0);
//         cServMsg.SetChnIndex(m_byPrsChnnlVmpOut2);
//         cServMsg.SetMsgBody((u8*)&tPrsParam, sizeof(tPrsParam));
//         SendMsgToEqp(m_tPrsEqp.GetEqpId() , MCU_PRS_SETSRC_REQ, cServMsg);
// 		m_tConfInStatus.SetPrsChnlVmpOut2Start(TRUE);
//         EqpLog("[ChangePrsSrc] Msg MCU_PRS_SETSRC_REQ send to prs eqp %d chl %d(m_byPrsChnnlVmpOut2)!\n", m_tPrsEqp.GetEqpId(), m_byPrsChnnlVmpOut2);
// 		
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangePrsSrc] Second_Vmp_Out LocalAddr<Ip:%s, Port:%d> RemoteAddr<Ip:%s, Port:%d>\n",
// 			StrOfIP(tLocalAddr.GetIpAddr()), tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut2,
// 					StrOfIP(dwEqpIP), wRcvPort + PORTSPAN * ( byPrsChanMode - PRSCHANMODE_VMPOUT1 ) + 1);
//     }
// 
// 	if (PRSCHANMODE_VMPOUT3 == byPrsChanMode && EQP_CHANNO_INVALID != m_byPrsChnnlVmpOut3)
//     {
// 		//广播源接收RTCP回馈包地址            
// 		u32 dwEqpIP,dwRcvIp;
// 	    u16 wRcvPort;
// 	    g_cMpManager.GetSwitchInfo(tMt, dwRcvIp, wRcvPort, dwEqpIP);
// 		//         
// 		//         TEqpVMPInfo tVmpInfo;
// 		//         g_cMcuAgent.GetEqpVMPCfg( tMt.GetEqpId(), &tVmpInfo);
// 		// 		
// 		//         tDstAddr.SetIpAddr(dwEqpIP);          
// 		//         tDstAddr.SetPort(tVmpInfo.GetEqpRecvPort() + PORTSPAN*2 + 1);          
//         
// 		
// // 		u16 wRtcpPort;		
// // 		g_cMpManager.GetVmpSwitchAddr(m_tVmpEqp.GetEqpId(), dwEqpIP, wRtcpPort);
// 		tDstAddr.SetIpAddr(dwEqpIP);
// #ifdef _8KE_
// 		//[nizhijun 2011/02/16] dwEqpIP从GetSwitchInfo得到的本地序，故不需要再用ntohl接口转换
// 		//tDstAddr.SetIpAddr(ntohl(dwEqpIP));
// 		tDstAddr.SetPort(VMP_8KE_LOCALSND_PORT + PORTSPAN *2 + 1);
// #else
//         tDstAddr.SetPort(wRcvPort + PORTSPAN * ( byPrsChanMode - PRSCHANMODE_VMPOUT1 ) + 1);
// #endif		
//         tPrsParam.SetRemoteAddr(tDstAddr);
//         
//         //设置丢包重传器接收RTP包的地址
//         tLocalAddr = tPrsParam.GetLocalAddr();
//         tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut3);
//         tPrsParam.SetLocalAddr(tLocalAddr);
// 		
//         cServMsg.SetSrcMtId(0);
//         cServMsg.SetChnIndex(m_byPrsChnnlVmpOut3);
//         cServMsg.SetMsgBody((u8*)&tPrsParam, sizeof(tPrsParam));
//         SendMsgToEqp(m_tPrsEqp.GetEqpId() , MCU_PRS_SETSRC_REQ, cServMsg);
//         m_tConfInStatus.SetPrsChnlVmpOut3Start(TRUE); 
//         EqpLog("[ChangePrsSrc] Msg MCU_PRS_SETSRC_REQ send to prs eqp %d chl %d(m_byPrsChnnlVmpOut3)!\n", m_tPrsEqp.GetEqpId(), m_byPrsChnnlVmpOut3);
// 		
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangePrsSrc] Second_Vmp_Out LocalAddr<Ip:%s, Port:%d> RemoteAddr<Ip:%s, Port:%d>\n",
// 			StrOfIP(tLocalAddr.GetIpAddr()), tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut3,
// 					StrOfIP(dwEqpIP), wRcvPort + PORTSPAN * ( byPrsChanMode - PRSCHANMODE_VMPOUT1 ) + 1);
//     }
// 	
// 	if (PRSCHANMODE_VMPOUT4 == byPrsChanMode && EQP_CHANNO_INVALID != m_byPrsChnnlVmpOut4)
//     {
// 		//广播源接收RTCP回馈包地址 
// 		 u32 dwEqpIP,dwRcvIp;
// 		 u16 wRcvPort;
// 		 g_cMpManager.GetSwitchInfo(tMt, dwRcvIp, wRcvPort, dwEqpIP);
// 		//         
// 		//         TEqpVMPInfo tVmpInfo;
// 		//         g_cMcuAgent.GetEqpVMPCfg( tMt.GetEqpId(), &tVmpInfo);
// 		// 		
// 		//         tDstAddr.SetIpAddr(dwEqpIP);          
// 		//         tDstAddr.SetPort(tVmpInfo.GetEqpRecvPort() + PORTSPAN*3 + 1);          
//         
// // 		u16 wRtcpPort;		
// // 		g_cMpManager.GetVmpSwitchAddr(m_tVmpEqp.GetEqpId(), dwEqpIP, wRtcpPort);
// 		tDstAddr.SetIpAddr(dwEqpIP);
// #ifdef _8KE_
// 		//[nizhijun 2011/02/16] dwEqpIP从GetSwitchInfo得到的本地序，故不需要再用ntohl接口转换
// 		//tDstAddr.SetIpAddr(ntohl(dwEqpIP));
// 		tDstAddr.SetPort(VMP_8KE_LOCALSND_PORT + PORTSPAN *3 + 1);
// #else
//         tDstAddr.SetPort(wRcvPort + PORTSPAN * ( byPrsChanMode - PRSCHANMODE_VMPOUT1 ) + 1);
// #endif		
//         tPrsParam.SetRemoteAddr(tDstAddr);
//         
//         //设置丢包重传器接收RTP包的地址
//         tLocalAddr = tPrsParam.GetLocalAddr();
//         tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut4);
//         tPrsParam.SetLocalAddr(tLocalAddr);
// 		
//         cServMsg.SetSrcMtId(0);
//         cServMsg.SetChnIndex(m_byPrsChnnlVmpOut4);
//         cServMsg.SetMsgBody((u8*)&tPrsParam, sizeof(tPrsParam));
//         SendMsgToEqp(m_tPrsEqp.GetEqpId() , MCU_PRS_SETSRC_REQ, cServMsg);
//         m_tConfInStatus.SetPrsChnlVmpOut4Start(TRUE); 
//         EqpLog("[ChangePrsSrc] Msg MCU_PRS_SETSRC_REQ send to prs eqp %d chl. %d(m_byPrsChnnlVmpOut4)!\n", m_tPrsEqp.GetEqpId(), ( byPrsChanMode - PRSCHANMODE_VMPOUT1 ));
// 		
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangePrsSrc] Second_Vmp_Out LocalAddr<Ip:%s, Port:%d> RemoteAddr<Ip:%s, Port:%d>\n",
// 			StrOfIP(tLocalAddr.GetIpAddr()), tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut4,
// 					StrOfIP(dwEqpIP), wRcvPort + PORTSPAN * ( byPrsChanMode - PRSCHANMODE_VMPOUT1 ) + 1);
//     }
// 
//     if (!tMt.IsNull())
//     {	
//         //仅对科达终端有效
//         if (tMt.GetType() == TYPE_MT)
//         {
// 			//[liu lijiu][20101025]判断本级会议的终端是否是KEDA的终端或MCU
// 			//[liu lijiu][20101025]下级终端是否是keda产品或MCU，暂时无法判断
//             if (tMt.IsLocal())
//             {
// 				if(   m_ptMtTable->GetManuId(tMt.GetMtId()) != MT_MANU_KDC 
// 				   &&m_ptMtTable->GetManuId(tMt.GetMtId()) != MT_MANU_KDCMCU)
// 				{
// 					EqpLog("[ChangePrsSrc] End2 MtId.%d PrsChanMode.%d\n", tMt.GetMtId(), byPrsChanMode);
//                     return;
// 				} 
//             }
// 
//             //第一路视频[liu lijiu][20100820]增加回传模式
// 			if(tMt.IsLocal())
// 			{
// 				if (m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tMtLogicalChannel, FALSE))
// 				{
// 					
// 					//设置终端接收RTCP回馈包的地址
// 					tDstAddr = tMtLogicalChannel.GetSndMediaCtrlChannel();
// 					tPrsParam.SetRemoteAddr(tDstAddr);
// 					
// 					//设置丢包重传器接收RTP包的地址(与MCU接收该终端的RTP包地址一致)
// 					tLocalAddr = tPrsParam.GetLocalAddr();
// 					tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnl);
// 					tPrsParam.SetLocalAddr(tLocalAddr);                    
// 				}
// 			}
// 			else
// 			{
// 				//得到回传端口
// 				//[nizhijun 2011/01/19] 因此tmt是非local的，所以还要判断是多回传还是单回传
// 				if ( !IsLocalAndSMcuSupMultSpy(tMt.GetMcuId()) )
// 				{
// 					TMt tLocalMt = GetLocalMtFromOtherMcuMt(tMt);
// 					if (!tLocalMt.IsNull())
// 					{
// 						if (m_ptMtTable->GetMtLogicChnnl(tLocalMt.GetMtId(), LOGCHL_VIDEO, &tMtLogicalChannel, FALSE))
// 						{
// 							
// 							//设置终端接收RTCP回馈包的地址
// 							tDstAddr = tMtLogicalChannel.GetSndMediaCtrlChannel();
// 							tPrsParam.SetRemoteAddr(tDstAddr);
// 							
// 							//设置丢包重传器接收RTP包的地址(与MCU接收该终端的RTP包地址一致)
// 							tLocalAddr = tPrsParam.GetLocalAddr();
// 							tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnl);
// 							tPrsParam.SetLocalAddr(tLocalAddr);                    
// 						}
// 					}
// 					else
// 					{
// 						EqpLog("[ChangePrsSrc]GetLocalMtFromOtherMcuMt(Tmt:%d-%d) failed!\n",tMt.GetMcuId(), tMt.GetMtId());
// 					}
// 				}
// 				else
// 				{
// 					//得到回传端口
// 					CRecvSpy tRrvSpyInfo;
// 					u32 dwRcvMpIp;
// 					m_cSMcuSpyMana.GetRecvSpy( tMt, tRrvSpyInfo );
// 					tDstAddr.SetPort(tRrvSpyInfo.m_tSpyAddr.GetPort() + 1);
// 					
// 					dwRcvMpIp = g_cMcuVcApp.GetMpIpAddr( m_ptMtTable->GetMpId( GetLocalMtFromOtherMcuMt(tMt).GetMtId() ) );
// 					tDstAddr.SetIpAddr(dwRcvMpIp);
// 					tPrsParam.SetRemoteAddr(tDstAddr);
// 					
// 					//设置丢包重传器接收RTP包的地址(与MCU接收该终端的RTP包地址一致)
// 					tLocalAddr = tPrsParam.GetLocalAddr();
// 					tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnl);
// 					tPrsParam.SetLocalAddr(tLocalAddr);  
// 				}
// 				
// 			}
// 
// 			//第二路视频
// 			//[nizhijun 2011/01/19]对于双流，无论单回传还是多回传都用回传通道60000系列端口做RTCP申述
//             if (m_ptMtTable->GetMtLogicChnnl(GetLocalMtFromOtherMcuMt(tMt).GetMtId(), LOGCHL_SECVIDEO, &tMtLogicalChannel2, FALSE))
//             {
//                 //设置终端接收RTCP回馈包的地址
//                 tDstAddr = tMtLogicalChannel2.GetSndMediaCtrlChannel();
//                 tPrsParam2.SetRemoteAddr(tDstAddr);
// 
//                 //设置丢包重传器接收RTP包的地址(与MCU接收该终端的RTP包地址一致)
//                 tLocalAddr = tPrsParam2.GetLocalAddr();
//                 tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnl2);
//                 tPrsParam2.SetLocalAddr(tLocalAddr);
//             }
// 
//             //音频
// 			if ( tMt.IsLocal() )
// 			{
// 				if (m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_AUDIO, &tMtLogicalChannelAud, FALSE))
// 				{
// 					//设置终端接收RTCP回馈包的地址
// 					tDstAddr = tMtLogicalChannelAud.GetSndMediaCtrlChannel();
// 					tPrsParamAud.SetRemoteAddr(tDstAddr);
// 					
// 					//设置丢包重传器接收RTP包的地址(与MCU接收该终端的RTP包地址一致)
// 					tLocalAddr = tPrsParamAud.GetLocalAddr();
// 					tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlAud);
// 					tPrsParamAud.SetLocalAddr(tLocalAddr);                    
// 				}
// 			}
// 			else//增加回传模式
// 			{			
// 				//[nizhijun 2011/01/19] 因此tmt是非local的，所以还要判断是多回传还是单回传
// 				if ( !IsLocalAndSMcuSupMultSpy(tMt.GetMcuId()) )
// 				{
// 					TMt tLocalMt = GetLocalMtFromOtherMcuMt(tMt);
// 					if (!tLocalMt.IsNull())
// 					{
// 						if (m_ptMtTable->GetMtLogicChnnl(tLocalMt.GetMtId(), LOGCHL_AUDIO, &tMtLogicalChannelAud, FALSE))
// 						{
// 							//设置终端接收RTCP回馈包的地址
// 							tDstAddr = tMtLogicalChannelAud.GetSndMediaCtrlChannel();
// 							tPrsParamAud.SetRemoteAddr(tDstAddr);
// 							
// 							//设置丢包重传器接收RTP包的地址(与MCU接收该终端的RTP包地址一致)
// 							tLocalAddr = tPrsParamAud.GetLocalAddr();
// 							tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlAud);
// 							tPrsParamAud.SetLocalAddr(tLocalAddr);                    
// 						}
// 					}
// 					else
// 					{
// 						EqpLog("[ChangePrsSrc]GetLocalMtFromOtherMcuMt(Tmt:%d-%d) failed!\n",tMt.GetMcuId(), tMt.GetMtId());
// 					}
// 				}
// 				else
// 				{
// 					//得到回传端口
// 					CRecvSpy tRrvSpyInfo;
// 					u32 dwRcvMpIp;
// 					m_cSMcuSpyMana.GetRecvSpy( tMt, tRrvSpyInfo );
// 					tDstAddr.SetPort(tRrvSpyInfo.m_tSpyAddr.GetPort() + 3);
// 					
// 					dwRcvMpIp = g_cMcuVcApp.GetMpIpAddr( m_ptMtTable->GetMpId( GetLocalMtFromOtherMcuMt(tMt).GetMtId() ) );
// 					tDstAddr.SetIpAddr(dwRcvMpIp);
// 					tPrsParamAud.SetRemoteAddr(tDstAddr);
// 					
// 					//设置丢包重传器接收RTP包的地址(与MCU接收该终端的RTP包地址一致)
// 					tLocalAddr = tPrsParamAud.GetLocalAddr();
// 					tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnlAud);
// 					tPrsParamAud.SetLocalAddr(tLocalAddr);  
// 				}
// 				
// 			}
//         }
// 		//广播源为放像机
// 		else if( EQP_TYPE_RECORDER == tMt.GetEqpType() )
// 		{
// 			TLogicalChannel tRecLogicalChannel;
// 			u8 byRecChnlNum;
// 			u32 dwRecEqpIP;
//             u16 wRecEqpPort;
// 			u16 wPort;
// 			g_cMcuVcApp.GetPeriEqpLogicChnnl(m_tPlayEqp.GetEqpId(), MODE_VIDEO, &byRecChnlNum, &tRecLogicalChannel, FALSE);
// 			dwRecEqpIP = tRecLogicalChannel.GetRcvMediaChannel().GetIpAddr();
// 			wRecEqpPort = tRecLogicalChannel.GetRcvMediaChannel().GetPort();
// 			wPort = wRecEqpPort + PORTSPAN * m_byPlayChnnl;
// 
// 			//视频
// 			//放像机设置终端接收RTCP回馈包的地址
// 			tDstAddr.SetIpAddr(dwRecEqpIP);
// 			tDstAddr.SetPort(wPort + 1);
// 			tPrsParam.SetRemoteAddr(tDstAddr);
// 			
// 			//设置丢包重传器接收RTP包的地址(与MCU接收该终端的RTP包地址一致)
// 			tLocalAddr = tPrsParam.GetLocalAddr();
// 			tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnl);
// 			tPrsParam.SetLocalAddr(tLocalAddr); 
// 
// 
// 			//音频
// 			//放像机设置终端接收RTCP回馈包的地址
// 			tDstAddr.SetIpAddr(dwRecEqpIP);
// 			tDstAddr.SetPort(wPort + 3);
// 			tPrsParamAud.SetRemoteAddr(tDstAddr);
// 			
// 			//设置丢包重传器接收RTP包的地址(与MCU接收该终端的RTP包地址一致)
// 			tLocalAddr = tPrsParam.GetLocalAddr();
// 			tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnlAud);
// 			tPrsParamAud.SetLocalAddr(tLocalAddr);
// 
// 
// 			//双流
// 			//放像机设置终端接收RTCP回馈包的地址
// 			tDstAddr.SetIpAddr(dwRecEqpIP);
// 			tDstAddr.SetPort(wPort + 5);
// 			tPrsParam2.SetRemoteAddr(tDstAddr);
// 			
// 			//设置丢包重传器接收RTP包的地址(与MCU接收该终端的RTP包地址一致)
// 			tLocalAddr = tPrsParam.GetLocalAddr();
// 			tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnl2);
// 			tPrsParam2.SetLocalAddr(tLocalAddr);
// 		}
//         else
//         {
//             //设置终端接收RTCP回馈包的地址
//             u32 dwEqpIP,dwRcvIp;
//             u16 wRcvPort;
//             g_cMpManager.GetSwitchInfo(tMt, dwRcvIp, wRcvPort, dwEqpIP);
//             tDstAddr.SetIpAddr(dwEqpIP);            
//             if (tMt.GetEqpType() == EQP_TYPE_VMP)
//             {               
//                 TEqpVMPInfo tVmpInfo;
//                 g_cMcuAgent.GetEqpVMPCfg( tMt.GetEqpId(), &tVmpInfo);
//                     
//                 tDstAddr.SetPort(tVmpInfo.GetEqpRecvPort() - PORTSPAN + 1);
//             }
//             else
//             {
//                 tDstAddr.SetPort(wRcvPort + 1);
// 				EqpLog("[ChangePrsSrc] mcu perhical port:%d!\n", wRcvPort + 1);
//             }            
//             tPrsParam.SetRemoteAddr(tDstAddr);
// 
//             //设置丢包重传器接收RTP包的地址(与MCU接收该终端的RTP包地址一致)
//             tLocalAddr = tPrsParam.GetLocalAddr();
//             tLocalAddr.SetPort(tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnl);
//             tPrsParam.SetLocalAddr(tLocalAddr);			
//         }
//     }
//     else
//     {
//         memset(&tPrsParam, 0, sizeof(tPrsParam));
//         memset(&tPrsParam2, 0, sizeof(tPrsParam2));
//         memset(&tPrsParamAud, 0, sizeof(tPrsParamAud));
//     }
// 	
// 
//     //给丢包重传器发消息
//     if ((PRSCHANMODE_FIRST == byPrsChanMode || PRSCHANMODE_BOTH == byPrsChanMode) &&
//         (m_byPrsChnnl != EQP_CHANNO_INVALID))
//     {
//         if(tMt.GetType() == TYPE_MT)
//         {
//             cServMsg.SetSrcMtId(tMt.GetMtId());
//         }
//         else
//         {
//             cServMsg.SetSrcMtId(0);
//         }
//         cServMsg.SetChnIndex(m_byPrsChnnl);
//         cServMsg.SetMsgBody((u8*)&tPrsParam, sizeof(tPrsParam));
//         SendMsgToEqp(m_tPrsEqp.GetEqpId() , MCU_PRS_SETSRC_REQ, cServMsg);
//         m_tConfInStatus.SetPrsChnl1Start(TRUE);
//         EqpLog("[ChangePrsSrc] Msg MCU_PRS_SETSRC_REQ send to prs eqp %d chl %d!\n", m_tPrsEqp.GetEqpId(), m_byPrsChnnl);
//     }
// 
//     //给丢包重传器发消息
//     if ((PRSCHANMODE_SECOND == byPrsChanMode || PRSCHANMODE_BOTH == byPrsChanMode) &&
//         (m_byPrsChnnl2 != EQP_CHANNO_INVALID))
//     {
// //         //第二路视频
// //         if (TYPE_MT == tMt.GetType())
// //         {
// //             if (m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_SECVIDEO, &tMtLogicalChannel2, FALSE))
// //             {
//                 //给丢包重传器发消息
//                 cServMsg.SetSrcMtId(tMt.GetMtId());
//                 cServMsg.SetChnIndex(m_byPrsChnnl2);
//                 cServMsg.SetMsgBody((u8*)&tPrsParam2, sizeof(tPrsParam2));
//                 SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_SETSRC_REQ, cServMsg);
//                 m_tConfInStatus.SetPrsChnl2Start(TRUE);
// //             }
// //         }
//     }
// 
//     //给丢包重传器发消息
//     if ((PRSCHANMODE_AUDIO == byPrsChanMode) && EQP_CHANNO_INVALID != m_byPrsChnnlAud)
//     {
// 		   
//         //音频
// //         if (TYPE_MT == tMt.GetType())
// //         {
// //             if (m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_AUDIO, &tMtLogicalChannelAud, FALSE))
// //             {
//                 //给丢包重传器发消息
//                 cServMsg.SetSrcMtId(tMt.GetMtId());
//                 cServMsg.SetChnIndex(m_byPrsChnnlAud);
//                 cServMsg.SetMsgBody((u8*)&tPrsParamAud, sizeof(tPrsParamAud));
//                 SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_SETSRC_REQ, cServMsg);
//                 m_tConfInStatus.SetPrsChnlAudStart(TRUE);
// //             }
// //         }
//     }    
// }

/*====================================================================
    函数名      ：AddRemovePrsMember
    功能        ：增加移除丢包重传的成员(MT.RTCP -> PRS)打包，用于动态占prs接口
    算法实现    ：
    引用全局变量：
    输入参数说明
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/04/12    4.0         周嘉麟        创建
====================================================================*/
void CMcuVcInst::AddRemovePrsMember(u8 byDstMtNum,
									TMt *pDstMt,
									u8 byPrsId,
									u8 byPrsChl,
									u8 byPrsMode /* = MODE_VIDEO */, 
									u8 bAdd /* = TRUE */,
									u16 wSpyStartPort /* = SPY_CHANNL_NULL */)
{
	
	if (0 == byDstMtNum || NULL == pDstMt)
	{
		return;
	}

	TLogicalChannel tPrsLogChnl;
	u8 byChlNum = 0;
	u32 dwPrsRtcpIP = 0;
	u16 wPrsRtcpPort = 0;
	if (MODE_VIDEO == byPrsMode
		|| MODE_SECVIDEO == byPrsMode
		|| MODE_VIDEO2SECOND == byPrsMode)
	{
		if (g_cMcuVcApp.GetPeriEqpLogicChnnl(byPrsId, MODE_VIDEO, &byChlNum, &tPrsLogChnl, TRUE))
		{
			dwPrsRtcpIP  = tPrsLogChnl.GetRcvMediaChannel().GetIpAddr();
			wPrsRtcpPort = tPrsLogChnl.GetRcvMediaChannel().GetPort() + PORTSPAN*byPrsChl + 2;
		}
		else
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[AddRemovePrsMember:Vid] Fail to find prs(%d) logchnl\n", byPrsId);
			return;
		}
	}
	else if (MODE_AUDIO == byPrsMode)
	{
		if (g_cMcuVcApp.GetPeriEqpLogicChnnl(byPrsId, MODE_AUDIO, &byChlNum, &tPrsLogChnl, TRUE))
		{
			dwPrsRtcpIP  = tPrsLogChnl.GetRcvMediaChannel().GetIpAddr();
			wPrsRtcpPort = tPrsLogChnl.GetRcvMediaChannel().GetPort() + PORTSPAN*byPrsChl + 2;
		}
		else
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[AddRemovePrsMember:Aud] Fail to find prs(%d) logchnl\n", byPrsId);
			return;
		}
	}
	else
	{
		return;
	}
	

	TSwitchChannelExt atSwitchChnExt[MAXNUM_CONF_MT];
	TLogicalChannel tLogChnl;
	u32 dwSrcRtcpIP = 0;
	u32 dwMapIpAddr = 0;
	u16 wSrcRtcpPort = 0;
	u16 wMapPort  = 0;
	u8  byFindMemRtcpChnl = FALSE;
	u8  byVailedNum = 0;

	//[2011/08/11/zhangli]拆旧的
	TSwitchChannelExt atRemoveSwitchChn[MAXNUM_CONF_MT];
	u8  byRemoveNum = 0;
	u32 dwOldDstIp = 0;
	u16 wOldDstPort = 0;

	for (u8 byMtIdx = 0; byMtIdx < byDstMtNum; byMtIdx++)
	{			
		//仅对科达终端有效
		if(TYPE_MT == pDstMt[byMtIdx].GetType() && !IsKedaMt(pDstMt[byMtIdx], TRUE))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[ChangePrsSrc] not keda mt or mcu mt(%d,%d)!\n", pDstMt[byMtIdx].GetMcuId(), pDstMt[byMtIdx].GetMtId());
			continue;
		}

		dwSrcRtcpIP = 0;
		dwMapIpAddr = 0;
		wSrcRtcpPort = 0;
		wMapPort  = 0;
		byFindMemRtcpChnl = FALSE;
		tLogChnl.Clear();
		
		if (MODE_VIDEO == byPrsMode &&
			m_ptMtTable->GetMtLogicChnnl(pDstMt[byMtIdx].GetMtId(), LOGCHL_VIDEO, &tLogChnl, TRUE))
		{
			byFindMemRtcpChnl = TRUE;
		}
		else if ((MODE_SECVIDEO == byPrsMode || MODE_VIDEO2SECOND == byPrsMode) &&
			m_ptMtTable->GetMtLogicChnnl(pDstMt[byMtIdx].GetMtId(), LOGCHL_SECVIDEO, &tLogChnl, TRUE))
		{
			byFindMemRtcpChnl = TRUE;
		}
		else if (MODE_AUDIO == byPrsMode &&
			m_ptMtTable->GetMtLogicChnnl(pDstMt[byMtIdx].GetMtId(), LOGCHL_AUDIO, &tLogChnl, TRUE))
		{
			byFindMemRtcpChnl = TRUE;
		}
		
		if (byFindMemRtcpChnl)
		{
			dwSrcRtcpIP  = tLogChnl.GetSndMediaCtrlChannel().GetIpAddr();
			if( SPY_CHANNL_NULL == wSpyStartPort )
			{
				wSrcRtcpPort = tLogChnl.GetSndMediaCtrlChannel().GetPort();
			}
			else
			{
				if( !m_tCascadeMMCU.IsNull() && pDstMt[byMtIdx].GetMtId() == m_tCascadeMMCU.GetMtId() )
				{
					if( MODE_VIDEO == byPrsMode )
					{
						wSrcRtcpPort = wSpyStartPort + 1;
					}
					else if( MODE_AUDIO == byPrsMode )
					{
						wSrcRtcpPort = wSpyStartPort + 2 + 1;
					}
					else
					{
						wSrcRtcpPort = tLogChnl.GetSndMediaCtrlChannel().GetPort();
					}
				}
				else
				{
					wSrcRtcpPort = tLogChnl.GetSndMediaCtrlChannel().GetPort();
				}			
			}
			dwMapIpAddr  = tLogChnl.GetRcvMediaChannel().GetIpAddr();
			wMapPort     = tLogChnl.GetRcvMediaChannel().GetPort();
		}
		else
		{
// 			ConfPrint(LOG_LVL_WARNING, MID_MCU_PRS, "[AddRemovePrsMember] Fail to find the logchnl(%d) for mt(%d)\n",
// 				byPrsMode, pDstMt[byMtIdx].GetMtId());
			continue;
		}

		//[2011/08/16/zhangli]
		/*如果是添加，则要拆掉旧的，删除则不处理，建终端到PRS通道的RTCP交换时，会遍历所有终端，
		判断如果某终端应该建到此PRS通道，则建，否则拆一次该终端到该prs通道的RTCP交换。*/
		if (bAdd && byPrsMode != MODE_SECVIDEO && byPrsMode != MODE_VIDEO2SECOND
			&& m_ptMtTable->GetMtRtcpDstAddr(pDstMt[byMtIdx].GetMtId(), dwOldDstIp, wOldDstPort, byPrsMode))
		{	
			atRemoveSwitchChn[byRemoveNum].SetDisIp(0);
			atRemoveSwitchChn[byRemoveNum].SetSrcIp(dwSrcRtcpIP);
			atRemoveSwitchChn[byRemoveNum].SetRcvIP(dwSrcRtcpIP);
			atRemoveSwitchChn[byRemoveNum].SetRcvPort(wSrcRtcpPort);
			atRemoveSwitchChn[byRemoveNum].SetRcvBindIP(dwSrcRtcpIP);
			atRemoveSwitchChn[byRemoveNum].SetSndBindIP(dwSrcRtcpIP);
			atRemoveSwitchChn[byRemoveNum].SetDstIP(dwOldDstIp);
			atRemoveSwitchChn[byRemoveNum].SetDstPort(wOldDstPort);
			atRemoveSwitchChn[byRemoveNum].SetMapIp(dwMapIpAddr);
			atRemoveSwitchChn[byRemoveNum].SetMapPort(wMapPort);
			byRemoveNum++;
		}
		
		atSwitchChnExt[byVailedNum].SetDisIp(0);
		atSwitchChnExt[byVailedNum].SetSrcIp(dwSrcRtcpIP);
		atSwitchChnExt[byVailedNum].SetRcvIP(dwSrcRtcpIP);
		atSwitchChnExt[byVailedNum].SetRcvPort(wSrcRtcpPort);
		atSwitchChnExt[byVailedNum].SetRcvBindIP(dwSrcRtcpIP);
		atSwitchChnExt[byVailedNum].SetSndBindIP(dwSrcRtcpIP);
		atSwitchChnExt[byVailedNum].SetDstIP(dwPrsRtcpIP);
		atSwitchChnExt[byVailedNum].SetDstPort(wPrsRtcpPort);
		atSwitchChnExt[byVailedNum].SetMapIp(dwMapIpAddr);
		atSwitchChnExt[byVailedNum].SetMapPort(wMapPort);

		//双流不能存储在MODE_VIDEO下，会把其覆盖
		if (bAdd && byPrsMode != MODE_SECVIDEO && byPrsMode != MODE_VIDEO2SECOND)
		{
			m_ptMtTable->SetMtRtcpDstAddr(pDstMt[byMtIdx].GetMtId(), dwPrsRtcpIP, wPrsRtcpPort, byPrsMode);
		}

		byVailedNum++;
	}

 	//打包拆旧的rtcp交换，下面的拆可以删除
	if (byRemoveNum > 0)
	{
		g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, byRemoveNum, atRemoveSwitchChn);
	}

	//打包拆rtcp交换
	if (byVailedNum > 0)
	{
		g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, byVailedNum, atSwitchChnExt);
	}

	//打包建rtcp交换
	if (bAdd && byVailedNum > 0)
	{
		g_cMpManager.AddMultiToOneSwitch(m_byConfIdx, byVailedNum, atSwitchChnExt);
	}
	return;
}
/*====================================================================
    函数名      ：AddRemovePrsMember
    功能        ：增加移除丢包重传的成员(MT.RTCP -> PRS)
    算法实现    ：
    引用全局变量：
    输入参数说明
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/07/17    4.0         付秀华        创建
====================================================================*/
void CMcuVcInst::AddRemovePrsMember(u8 byMemId, u8 byPrsId, u8 byPrsChl, u8 byPrsMode, u8 bAdd,u16 wSpyStartPort)
{
	TMt tMt = m_ptMtTable->GetMt( byMemId );
	AddRemovePrsMember( 1,&tMt,byPrsId,byPrsChl,byPrsMode,bAdd,wSpyStartPort );
//	u32 dwSrcRtcpIP, dwPrsRtcpIP, dwMapIpAddr = 0;
//	u16 wSrcRtcpPort, wPrsRtcpPort, wMapPort  = 0;
//
//	u8 byChlNum = 0;
//	
//	TLogicalChannel tPrsLogChnl;
//	if (MODE_VIDEO == byPrsMode ||
//		MODE_SECVIDEO == byPrsMode)
//	{
//		if (g_cMcuVcApp.GetPeriEqpLogicChnnl(byPrsId, MODE_VIDEO, &byChlNum, &tPrsLogChnl, TRUE))
//		{
//			dwPrsRtcpIP  = tPrsLogChnl.GetRcvMediaChannel().GetIpAddr();
//			wPrsRtcpPort = tPrsLogChnl.GetRcvMediaChannel().GetPort() + PORTSPAN*byPrsChl + 2;
//		}
//		else
//		{
//			ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[AddRemovePrsMember:Vid] ERROR: Fail to find prs(%d) logchnl!\n", byPrsId);
//			return;
//		}
//	}
//	else if(MODE_AUDIO == byPrsMode)
//	{
//		if (g_cMcuVcApp.GetPeriEqpLogicChnnl(byPrsId, MODE_AUDIO, &byChlNum, &tPrsLogChnl, TRUE))
//		{
//			dwPrsRtcpIP  = tPrsLogChnl.GetRcvMediaChannel().GetIpAddr();
//			wPrsRtcpPort = tPrsLogChnl.GetRcvMediaChannel().GetPort() + PORTSPAN*byPrsChl + 2;
//		}
//		else
//		{
//			ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[AddRemovePrsMember:Aud] ERROR: Fail to find prs(%d) logchnl!\n", byPrsId);
//			return;
//		}
//	}
//	else
//	{
//		return;
//	}
//	
//
//	TLogicalChannel tLogChnl;
//	u8  byFindMemRtcpChnl = FALSE;
//	if (MODE_VIDEO == byPrsMode &&
//		m_ptMtTable->GetMtLogicChnnl(byMemId, LOGCHL_VIDEO, &tLogChnl, TRUE))
//	{
//		byFindMemRtcpChnl = TRUE;
//	}
//	else if (MODE_SECVIDEO == byPrsMode &&
//		     m_ptMtTable->GetMtLogicChnnl(byMemId, LOGCHL_SECVIDEO, &tLogChnl, TRUE))
//	{
//		byFindMemRtcpChnl = TRUE;
//	}
//	else if (MODE_AUDIO == byPrsMode &&
//		     m_ptMtTable->GetMtLogicChnnl(byMemId, LOGCHL_AUDIO, &tLogChnl, TRUE))
//	{
//		byFindMemRtcpChnl = TRUE;
//	}
//
//	if (byFindMemRtcpChnl)
//	{
//		dwSrcRtcpIP  = tLogChnl.GetSndMediaCtrlChannel().GetIpAddr();
//		if( SPY_CHANNL_NULL == wSpyStartPort )
//		{
//			wSrcRtcpPort = tLogChnl.GetSndMediaCtrlChannel().GetPort();
//		}
//		else
//		{
//			if( !m_tCascadeMMCU.IsNull() && byMemId == m_tCascadeMMCU.GetMtId() )
//			{
//				if( MODE_VIDEO == byPrsMode )
//				{
//					wSrcRtcpPort = wSpyStartPort + 1;
//				}
//				else if( MODE_AUDIO == byPrsMode )
//				{
//					wSrcRtcpPort = wSpyStartPort + 2 + 1;
//				}
//				else
//				{
//					wSrcRtcpPort = tLogChnl.GetSndMediaCtrlChannel().GetPort();
//				}
//			}
//			else
//			{
//				wSrcRtcpPort = tLogChnl.GetSndMediaCtrlChannel().GetPort();
//			}			
//		}
//        dwMapIpAddr  = tLogChnl.GetRcvMediaChannel().GetIpAddr();
//        wMapPort     = tLogChnl.GetRcvMediaChannel().GetPort();
//	}
//	else
//	{
//		ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[AddRemovePrsMember] ERROR: Fail to find the logchnl(%d) for mt(%d)!\n",
//			    byPrsMode, byMemId);
//		return;
//	}
//
//	//[2011/08/11/zhangli]拆旧的
//	u32 dwOldDstIp = 0;
//	u16 wOldDstPort = 0;
//	m_ptMtTable->GetMtRtcpDstAddr(byMemId, dwOldDstIp, wOldDstPort, byPrsMode);
//	if (bAdd && 0 != dwOldDstIp)
//	{
//		g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwSrcRtcpIP, wSrcRtcpPort, dwOldDstIp, wOldDstPort);
//		m_ptMtTable->SetMtRtcpDstAddr(byMemId, 0, 0, byPrsMode);
//	}
//
//	// 移除原交换
//    g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwSrcRtcpIP, wSrcRtcpPort, dwPrsRtcpIP, wPrsRtcpPort);
//
//	// 按源先清空已有多对一交换交换
//
//    if (bAdd)
//    {
//		m_ptMtTable->SetMtRtcpDstAddr(byMemId, dwPrsRtcpIP, wPrsRtcpPort, byPrsMode);
//
//		g_cMpManager.AddMultiToOneSwitch(m_byConfIdx, dwSrcRtcpIP, 0, dwSrcRtcpIP,wSrcRtcpPort, 
//					                     dwPrsRtcpIP, wPrsRtcpPort, 0, 0, dwMapIpAddr, wMapPort);
//		ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[AddRemovePrsMember](%s, %d)--->", 
//			   StrOfIP(dwSrcRtcpIP), wSrcRtcpPort);
//		ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "(%s, %d)!\n", StrOfIP(dwPrsRtcpIP), wPrsRtcpPort);
//    }

}
/*====================================================================
    函数名      ：AddRemovePrsMember
    功能        ：增加移除丢包重传的成员(MT.RTCP -> PRS)
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt tMt 广播源终端
				  BOOL32 bAdd TRUE-增加 FALSE-移除
				  BOOL32 bOnly2 是否为第二路
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/27    3.0         胡昌威        创建
====================================================================*/
// void CMcuVcInst::AddRemovePrsMember( TMt tMt, BOOL32 bAdd, u8 byPrsChanMode )
// {
//     //是否有预留资源
//     if (m_tPrsEqp.IsNull() || tMt.IsNull()/* || !m_tConf.m_tStatus.IsPrsing()*/)
//     {
//         return;
//     }
// 
//     u8  byChlNum  = 0;
//     u16 wRecvPort = 0;
//     u16 wMapPort  = 0;
//     u16 wDstPort  = 0;
//     u32 dwSrcIpAddr  = 0;
//     u32 dwRecvIpAddr = 0;
//     u32 dwDstIpAddr  = 0;
//     TLogicalChannel tMtLogicalChannel;
//     TLogicalChannel tMtLogicalChannel2;
//     TLogicalChannel tMtLogicalChannelAud;
//     TLogicalChannel tEqpLogicalChannel;
// 
//     //仅对科达终端有效
//     u8 byManuID = m_ptMtTable->GetManuId(tMt.GetMtId());
//     if (byManuID != MT_MANU_KDC && byManuID != MT_MANU_KDCMCU)
//     {
//         return;
//     }
// 
//     //对于PRS而言，一个PRS可支持多个音视频通道(默认总共16个),
//     //各通道接收端口统一为PRS起始接收端口，以通道号区分实际的接收端口
//     BOOL32 bPrsChan = g_cMcuVcApp.GetPeriEqpLogicChnnl(m_tPrsEqp.GetEqpId(), MODE_VIDEO, &byChlNum, &tEqpLogicalChannel, TRUE);
// 
//     if (PRSCHANMODE_FIRST == byPrsChanMode || PRSCHANMODE_BOTH == byPrsChanMode)
//     {
//         if (/*m_tConfInStatus.IsPrsChnl1Start() &&*/ bPrsChan &&
//             m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tMtLogicalChannel, TRUE))
//         {
//             dwSrcIpAddr  = tMtLogicalChannel.GetRcvMediaChannel().GetIpAddr();      //终端的rtp接收地址与端口
//             dwRecvIpAddr = tMtLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();  //转发板rtcp接收地址与端口
//             wRecvPort    = tMtLogicalChannel.GetSndMediaCtrlChannel().GetPort();
//             dwDstIpAddr  = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();     //prs的rtcp接收地址与端口
//             wDstPort     = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnl+2; //此端口分配与设置prs源时传入的端口有关（prs模块中:传入端口＋2）
// 
//             if (bAdd)
//             {
//                 //将 MT.RTCP -> PRS 时，考虑到防火墙支撑，需将交换包的源ip、port映射为 MT.RTP，以便PRS重传
//                 SwitchVideoRtcpToDst(dwDstIpAddr, wDstPort, tMt, 0, MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
//             }
//             else
//             {
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//             }
//         }
//     }
// 
//     if (PRSCHANMODE_SECOND == byPrsChanMode || PRSCHANMODE_BOTH == byPrsChanMode)
//     {
//         //第二路视频
//         if (m_tConfInStatus.IsPrsChnl2Start() && bPrsChan && 
//             m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_SECVIDEO, &tMtLogicalChannel2, TRUE))
//         {
//             dwSrcIpAddr  = tMtLogicalChannel2.GetRcvMediaChannel().GetIpAddr();
//             wMapPort     = tMtLogicalChannel2.GetRcvMediaChannel().GetPort();
//             dwRecvIpAddr = tMtLogicalChannel2.GetSndMediaCtrlChannel().GetIpAddr();
//             wRecvPort    = tMtLogicalChannel2.GetSndMediaCtrlChannel().GetPort();            
//             dwDstIpAddr  = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort     = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnl2+2;
// 
//             if (bAdd)
//             {
//                 //将 MT.RTCP -> PRS 时，考虑到防火墙支撑，需将交换包的源ip、port映射为 MT.RTP，以便PRS重传
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//                 g_cMpManager.AddMultiToOneSwitch(m_byConfIdx, dwSrcIpAddr, 0, dwRecvIpAddr,wRecvPort, 
// 					                             dwDstIpAddr, wDstPort, 0, 0, dwSrcIpAddr, wMapPort);
//             }
//             else
//             {
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//             }
//         }
//     }
// 
//     if (PRSCHANMODE_AUDIO == byPrsChanMode)
//     {
//         //音频
//         if (m_tConfInStatus.IsPrsChnlAudStart() && bPrsChan && 
//             m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_AUDIO, &tMtLogicalChannelAud, TRUE))
//         {
//             dwSrcIpAddr  = tMtLogicalChannelAud.GetRcvMediaChannel().GetIpAddr();
//             wMapPort     = tMtLogicalChannelAud.GetRcvMediaChannel().GetPort();
//             dwRecvIpAddr = tMtLogicalChannelAud.GetSndMediaCtrlChannel().GetIpAddr();
//             wRecvPort    = tMtLogicalChannelAud.GetSndMediaCtrlChannel().GetPort();            
//             dwDstIpAddr  = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort     = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlAud+2;
// 
//             if (bAdd)
//             {
//                 //将 MT.RTCP -> PRS 时，考虑到防火墙支撑，需将交换包的源ip、port映射为 MT.RTP，以便PRS重传
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//                 g_cMpManager.AddMultiToOneSwitch(m_byConfIdx, dwSrcIpAddr, 0, dwRecvIpAddr,wRecvPort, 
// 					                             dwDstIpAddr, wDstPort, 0, 0, dwSrcIpAddr, wMapPort);
//             }
//             else
//             {
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//             }
//         }
//     }
// 
//     if (PRSCHANMODE_VIDBAS == byPrsChanMode)
//     {
//         if (m_tConfInStatus.IsPrsChnlVidBasStart() && bPrsChan &&
//             m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tMtLogicalChannel, TRUE))
//         {
//             dwRecvIpAddr = tMtLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();  //转发板rtcp接收地址与端口
//             wRecvPort    = tMtLogicalChannel.GetSndMediaCtrlChannel().GetPort();
//             dwDstIpAddr  = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();     //prs的rtcp接收地址与端口
//             wDstPort     = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVidBas+2; //此端口分配与设置prs源时传入的端口有关（prs模块中:传入端口＋2）
//             
//             if (bAdd)
//             {
//                 //将 MT.RTCP -> PRS 时，考虑到防火墙支撑，需将交换包的源ip、port映射为 MT.RTP，以便PRS重传
//                 SwitchVideoRtcpToDst(dwDstIpAddr, wDstPort, tMt, 0, MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
//             }
//             else
//             {
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//             }
//         }
//     }
// 
//     //vmp.2
//     if (PRSCHANMODE_BRBAS == byPrsChanMode || PRSCHANMODE_VMP2 == byPrsChanMode)
//     {
//         if (m_tConfInStatus.IsPrsChnlBrBasStart() && bPrsChan &&
//             m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tMtLogicalChannel, TRUE))
//         {            
//             dwRecvIpAddr = tMtLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();  //转发板rtcp接收地址与端口
//             wRecvPort    = tMtLogicalChannel.GetSndMediaCtrlChannel().GetPort();
//             dwDstIpAddr  = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();     //prs的rtcp接收地址与端口
//             wDstPort     = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlBrBas+2; //此端口分配与设置prs源时传入的端口有关（prs模块中:传入端口＋2）
//             
//             if (bAdd)
//             {
//                 //将 MT.RTCP -> PRS 时，考虑到防火墙支撑，需将交换包的源ip、port映射为 MT.RTP，以便PRS重传
//                 SwitchVideoRtcpToDst(dwDstIpAddr, wDstPort, tMt, 0, MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
//             }
//             else
//             {
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//             }
//         }
//     }
// 
//     if (PRSCHANMODE_AUDBAS == byPrsChanMode)
//     {
//         if (m_tConfInStatus.IsPrsChnlAudBasStart() && bPrsChan &&
//             m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_AUDIO, &tMtLogicalChannel, TRUE))
//         {            
//             dwRecvIpAddr = tMtLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();  //转发板rtcp接收地址与端口
//             wRecvPort    = tMtLogicalChannel.GetSndMediaCtrlChannel().GetPort();
//             dwDstIpAddr  = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();     //prs的rtcp接收地址与端口
//             wDstPort     = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlAudBas+2; //此端口分配与设置prs源时传入的端口有关（prs模块中:传入端口＋2）
//             
//             if (bAdd)
//          ，考虑到防火墙支撑，需将交换包的源ip、port映射为 MT.RTP，以便PRS重传
//                 SwitchVideoRtcpToDst(dwDstIpAddr, wDstPort, tMt, 0, MODE_AUDIO, SWITCH_MODE_BROADCAST, TRUE);
//             }
//             else
//             {
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//             }
//         }
//     }
// 
//     // FIXME：高清适配丢包重传未添加,zgc
// 
// 	// xliang [4/30/2009] 多输出类的广播源丢包重传
// 	if (PRSCHANMODE_VMPOUT1 == byPrsChanMode)
//     {
//         if ( m_tConfInStatus.IsPrsChnlVmpOut1Start() 
// 			&& bPrsChan 
// 			&& m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tMtLogicalChannel, TRUE))
//         {            
//             dwRecvIpAddr = tMtLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();  //转发板rtcp接收地址与端口
//             wRecvPort    = tMtLogicalChannel.GetSndMediaCtrlChannel().GetPort();
//             dwDstIpAddr  = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();     //prs的rtcp接收地址与端口
//             wDstPort     = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut1+2; //此端口分配与设置prs源时传入的端口有关（prs模块中:传入端口＋2）
//             
//             if (bAdd)
//             {
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "begin to RTCP switch Mt.%u to PRS(Mode:%u, ip:%d, port:%d)!\n",tMt.GetMtId(), byPrsChanMode, dwDstIpAddr, wDstPort );
//                 //将 MT.RTCP -> PRS 时，考虑到防火墙支撑，需将交换包的源ip、port映射为 MT.RTP，以便PRS重传
//                 SwitchVideoRtcpToDst(dwDstIpAddr, wDstPort, tMt, 0, MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
// 
//             }
//             else
//             {
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//             }
//         }
//     }
// 
// 	if (PRSCHANMODE_VMPOUT2 == byPrsChanMode)
//     {
//         if ( m_tConfInStatus.IsPrsChnlVmpOut2Start() 
// 			&& bPrsChan 
// 			&& m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tMtLogicalChannel, TRUE))
//         {            
//             dwRecvIpAddr = tMtLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();  //转发板rtcp接收地址与端口
//             wRecvPort    = tMtLogicalChannel.GetSndMediaCtrlChannel().GetPort();
//             dwDstIpAddr  = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();     //prs的rtcp接收地址与端口
//             wDstPort     = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut2+2; //此端口分配与设置prs源时传入的端口有关（prs模块中:传入端口＋2）
//             
//             if (bAdd)
//             {
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "begin to RTCP switch Mt.%u to PRS(Mode:%u, ip:%d, port:%d)!\n",tMt.GetMtId(), byPrsChanMode, dwDstIpAddr, wDstPort );
//                 //将 MT.RTCP -> PRS 时，考虑到防火墙支撑，需将交换包的源ip、port映射为 MT.RTP，以便PRS重传
//                 SwitchVideoRtcpToDst(dwDstIpAddr, wDstPort, tMt, 0, MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
//             }
//             else
//             {
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//             }
//         }
//     }
// 
// 	if (PRSCHANMODE_VMPOUT3 == byPrsChanMode)
//     {
//         if ( m_tConfInStatus.IsPrsChnlVmpOut3Start() 
// 			&& bPrsChan 
// 			&& m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tMtLogicalChannel, TRUE))
//         {            
//             dwRecvIpAddr = tMtLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();  //转发板rtcp接收地址与端口
//             wRecvPort    = tMtLogicalChannel.GetSndMediaCtrlChannel().GetPort();
//             dwDstIpAddr  = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();     //prs的rtcp接收地址与端口
//             wDstPort     = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut3+2; //此端口分配与设置prs源时传入的端口有关（prs模块中:传入端口＋2）
//             
//             if (bAdd)
//             {
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "begin to RTCP switch Mt.%u to PRS(Mode:%u, ip:%d, port:%d)!\n",tMt.GetMtId(), byPrsChanMode, dwDstIpAddr, wDstPort );
//                 //将 MT.RTCP -> PRS 时，考虑到防火墙支撑，需将交换包的源ip、port映射为 MT.RTP，以便PRS重传
//                 SwitchVideoRtcpToDst(dwDstIpAddr, wDstPort, tMt, 0, MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
//             }
//             else
//             {
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//             }
//         }
//     }
// 	if (PRSCHANMODE_VMPOUT4 == byPrsChanMode)
//     {
//         if ( m_tConfInStatus.IsPrsChnlVmpOut4Start() 
// 			&& bPrsChan 
// 			&& m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_VIDEO, &tMtLogicalChannel, TRUE))
//         {            
//             dwRecvIpAddr = tMtLogicalChannel.GetSndMediaCtrlChannel().GetIpAddr();  //转发板rtcp接收地址与端口
//             wRecvPort    = tMtLogicalChannel.GetSndMediaCtrlChannel().GetPort();
//             dwDstIpAddr  = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();     //prs的rtcp接收地址与端口
//             wDstPort     = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnlVmpOut4+2; //此端口分配与设置prs源时传入的端口有关（prs模块中:传入端口＋2）
//             
//             if (bAdd)
//             {
// 				ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "begin to RTCP switch Mt.%u to PRS(Mode:%u, ip:%d, port:%d)!\n",tMt.GetMtId(), byPrsChanMode, dwDstIpAddr, wDstPort );
//                 //将 MT.RTCP -> PRS 时，考虑到防火墙支撑，需将交换包的源ip、port映射为 MT.RTP，以便PRS重传
//                 SwitchVideoRtcpToDst(dwDstIpAddr, wDstPort, tMt, 0, MODE_VIDEO, SWITCH_MODE_BROADCAST, TRUE);
//             }
//             else
//             {
//                 g_cMpManager.RemoveMultiToOneSwitch(m_byConfIdx, dwRecvIpAddr, wRecvPort, dwDstIpAddr, wDstPort);
//             }
//         }
//     }
// 
//     return;
// }
/*====================================================================
    函数名      ：ReRtcpSwithForPrs
    功能        ：更新到PRS的RTCP交换
    算法实现    ：
    引用全局变量：
    输入参数说明
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/07/17    4.0         付秀华        创建
====================================================================*/
void CMcuVcInst::BuildRtcpAndRtpSwithForPrs(u8 byPrsId, u8 byPrsChl)
{
	TMt tPrsSrc;
	u8  byPrsSrcOutChnl = 0;
	u8  byPrsMode       = MODE_NONE;
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS,"[BuildRtcpAndRtpSwithForPrs]start prsswitch byPrsId:%d byPrsChl:%d\n",byPrsId,byPrsChl);

	if (FindPrsChnlSrc(byPrsId, byPrsChl, byPrsMode, tPrsSrc, byPrsSrcOutChnl))
	{
		if (MODE_SECVIDEO == byPrsMode && !m_tSecVidBrdSrc.IsNull())
		{
			byPrsMode = MODE_VIDEO2SECOND;
		}

		StartSwitchToPeriEqp(tPrsSrc, byPrsSrcOutChnl, byPrsId, byPrsChl, byPrsMode, SWITCH_MODE_SELECT, FALSE, TRUE, FALSE, FALSE);

		//记录打包建rtcp目的
		u8  bySwitchRtcpNum = 0;
		TMt atSwitchRtcpDst[MAXNUM_CONF_MT];

		//记录打包拆rtcp目的
		u8  byStopRtcpNum = 0;
		TMt atStopRtcpDst[MAXNUM_CONF_MT];

		TMt tRealSrc;
		u8  byRealSrcOChnl = 0;

		TMtStatus tStatus;
		TMt tSelVidMt,tSelAudMt;
		TMt tSpyVidMt,tSpyAudMt;

		tSpyVidMt.SetNull();
		tSpyAudMt.SetNull();
		if( !m_tCascadeMMCU.IsNull() && m_ptMtTable->GetMtStatus(m_tCascadeMMCU.GetMtId(),&tStatus) )
		{
			tSpyVidMt = tStatus.GetVideoMt();
			tSpyAudMt = tStatus.GetAudioMt();
		}
		
		for( u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop++ )
		{                
			if(m_tConfAllMtInfo.MtJoinedConf(byLoop))
			{
				if ( IsMultiCastMt(byLoop) )
				{
					continue;
				}

				if (  VCS_CONF== m_tConf.GetConfSource() &&
					  m_cVCSConfStatus.GetCurVCMode() == VCS_GROUPROLLCALL_MODE && 
					  m_tConf.GetChairman().GetMtId() == byLoop 
					)
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[BuildRtcpAndRtpSwithForPrs]vcs conf GROUPROLLCALL_MODE, chairman(%d) not build rtcp to prs\n",
						byLoop
						);
					continue;
				}
				//主席选看，广播不冲，不要重建rtcp
				if ( m_tConf.GetChairman().GetMtId() == byLoop )
				{					
					tStatus.SetNull();
					m_ptMtTable->GetMtStatus(byLoop,&tStatus);
					tSelVidMt = tStatus.GetSelectMt(MODE_VIDEO);
					tSelAudMt = tStatus.GetSelectMt(MODE_AUDIO);
					if (!tSelVidMt.IsNull() && MODE_VIDEO ==  byPrsMode  )
					{
						continue;
					}
					if (!tSelAudMt.IsNull() && MODE_AUDIO == byPrsMode )
					{
						continue;
					}
					
				}

				if( !m_tCascadeMMCU.IsNull()  && m_tCascadeMMCU.GetMtId() == byLoop &&
					( (MODE_VIDEO ==  byPrsMode && !tSpyVidMt.IsNull() ) || 
					 ( MODE_AUDIO == byPrsMode && !tSpyAudMt.IsNull() ) )
					 )
				{
					continue;
				}


				if (GetMtRealSrc(byLoop, byPrsMode, tRealSrc, byRealSrcOChnl) &&
			        tRealSrc == tPrsSrc && byRealSrcOChnl == byPrsSrcOutChnl)
				{
					atSwitchRtcpDst[bySwitchRtcpNum] = m_ptMtTable->GetMt(byLoop);
					bySwitchRtcpNum ++;
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[BuildRtcpAndRtpSwithForPrs]byLoop:%d byPrsMode:%d SwitchRtcp Src.%d, Prs.%d, RealSrcChnl:%d, SrcOutChnl:%d\n",
					    byLoop,byPrsMode,tRealSrc.GetEqpId(), tPrsSrc.GetEqpId(), byRealSrcOChnl, byPrsSrcOutChnl);
				}
				else
				{
					atStopRtcpDst[byStopRtcpNum] = m_ptMtTable->GetMt(byLoop);
					byStopRtcpNum ++;
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[BuildRtcpAndRtpSwithForPrs]byLoop:%d byPrsMode:%d StopRtcp Src.%d, Prs.%d, RealSrcChnl:%d, SrcOutChnl:%d\n",
					    byLoop,byPrsMode,tRealSrc.GetEqpId(), tPrsSrc.GetEqpId(), byRealSrcOChnl, byPrsSrcOutChnl);
				}
			}
		}

		//打包拆rtcp交换
		if (byStopRtcpNum > 0)
		{
			AddRemovePrsMember(byStopRtcpNum, atStopRtcpDst, byPrsId, byPrsChl, byPrsMode, FALSE);
		}
		//打包建rtcp交换
		if (bySwitchRtcpNum > 0)
		{
			AddRemovePrsMember(bySwitchRtcpNum, atSwitchRtcpDst, byPrsId, byPrsChl, byPrsMode, TRUE);
		}
	}
	else
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_PRS, "[BuildRtcpAndRtpSwithForPrs]FindPrsChnlSrc <PrsId:%d, ChnId:%d> failed!\n",
					byPrsId, byPrsChl);
	}
}
/*====================================================================
    函数名      ：StopAllPrs
    功能        ：停止当前会议占用的所有prs通道
    算法实现    ：
    引用全局变量：
    输入参数说明
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/04/19    4.6         周嘉麟        创建
====================================================================*/
void CMcuVcInst::StopAllPrsChn()
{
	u8 abyPrsId[MAXNUM_CONF_PRS_CHNNL] = {0};
	u8 abyPrsChnId[MAXNUM_CONF_PRS_CHNNL] = {0};
	u8 byPrsChnNum = GetConfAllPrsChn(abyPrsId, abyPrsChnId);
	u8 byMediaMode = MODE_NONE;
	if (0 != byPrsChnNum)
	{
		for(u8 byIdx = 0; byIdx < byPrsChnNum; byIdx++)
		{
			if (!IsPrsChnStart(abyPrsId[byIdx], abyPrsChnId[byIdx]))
			{
				continue;
			}

			byMediaMode = MODE_NONE;
			byMediaMode = GetPrsChnMediaMode(abyPrsId[byIdx], abyPrsChnId[byIdx]);
			if (MODE_NONE != byMediaMode)
			{
				StopPrs(abyPrsId[byIdx], abyPrsChnId[byIdx], byMediaMode);
			}
		}
	}
	return;
}

/*====================================================================
    函数名      :ReleaseAllPrsChn
    功能        ：释放当前会议占用的所有prs通道
    算法实现    ：
    引用全局变量：
    输入参数说明
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/04/19    4.6         周嘉麟        创建
====================================================================*/
void CMcuVcInst::ReleaseAllPrsChn()
{
	u8 abyPrsId[MAXNUM_CONF_PRS_CHNNL] = {0};
	u8 abyPrsChnId[MAXNUM_CONF_PRS_CHNNL] = {0};
	u8 byPrsChnNum = GetConfAllPrsChn(abyPrsId, abyPrsChnId);
	//u8 byMediaMode = MODE_NONE;
	if (0 != byPrsChnNum)
	{
		for(u8 byIdx = 0; byIdx < byPrsChnNum; byIdx++)
		{
			RlsPrsChnl(abyPrsId[byIdx], abyPrsChnId[byIdx]);
		}
	}
	return;
}
/*====================================================================
    函数名      ：StopPrs
    功能        ：
    算法实现    ：
    引用全局变量：
    输入参数说明
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/07/17    4.0         付秀华        创建
	10/09/08    4.0			倪志俊		  修改，添加了byChnMode
====================================================================*/
void CMcuVcInst::StopPrs(u8 byPrsId, u8 byPrsChnl, u8 byChnMode)
{
	CServMsg cServMsg;
    cServMsg.SetChnIndex(byPrsChnl);
    SendMsgToEqp(byPrsId, MCU_PRS_REMOVEALL_REQ, cServMsg);

	//拆除到prs的Rtp交换
	StopSwitchToPeriEqp(byPrsId, byPrsChnl, FALSE, byChnMode, SWITCH_MODE_SELECT);

	//拆除所有到当前Prs通道的Rtcp交换
	u32 dwPrsRtcpIP  = 0;
	u16 wPrsRtcpPort = 0;
	u8 byChlNum = 0;
	TLogicalChannel tPrsLogChnl;
	BOOL32 bOpen = FALSE;
	if (MODE_VIDEO == byChnMode ||
		MODE_SECVIDEO == byChnMode)
	{
		if (g_cMcuVcApp.GetPeriEqpLogicChnnl(byPrsId, MODE_VIDEO,
											&byChlNum, &tPrsLogChnl, TRUE))
		{
			bOpen = TRUE;
		}
	}
	else if (MODE_AUDIO == byChnMode)
	{
		if (g_cMcuVcApp.GetPeriEqpLogicChnnl(byPrsId, MODE_AUDIO,
											&byChlNum, &tPrsLogChnl, TRUE))
		{
			bOpen = TRUE;
		}
	}

	if (bOpen)
	{
		dwPrsRtcpIP  = tPrsLogChnl.GetRcvMediaChannel().GetIpAddr();
		wPrsRtcpPort = tPrsLogChnl.GetRcvMediaChannel().GetPort() + PORTSPAN * byPrsChnl + 2;
		g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwPrsRtcpIP, wPrsRtcpPort);

		ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[StopPrs] Stop rtcp switch to (ip:%d port:%d) for prs(eqpid:%d, chnlid:%d)\n", 
				StrOfIP(dwPrsRtcpIP), wPrsRtcpPort, byPrsId, byPrsChnl);
	}

	return;
	
}
/*====================================================================
    函数名      ：StopPrs
    功能        ：停止丢包重传
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/27    3.0         胡昌威        创建
====================================================================*/
// void CMcuVcInst::StopPrs(u8 byPrsChanMode, BOOL32 bNotify)
// {
//     u8  byChlNum;
//     u16 wDstPort;
//     u32 dwDstIpAddr;
//     TLogicalChannel tEqpLogicalChannel;
// 
//     //是否有预留资源
//     if (m_tPrsEqp.IsNull() || !m_tConfInStatus.IsPrsChnStart(byPrsChanMode)/*|| !m_tConf.m_tStatus.IsPrsing()*/)
//     {
//         return;
//     }
// 
//     //给丢包重传器发消息
//     CServMsg cServMsg;
//     TPeriEqpStatus tStatus;
//     BOOL32 bLogicalChan = g_cMcuVcApp.GetPeriEqpLogicChnnl(m_tPrsEqp.GetEqpId(), MODE_VIDEO, &byChlNum, &tEqpLogicalChannel, TRUE);
//     g_cMcuVcApp.GetPeriEqpStatus( m_tPrsEqp.GetEqpId(), &tStatus );
// 
//     //第一路视频
//     if ((byPrsChanMode == PRSCHANMODE_FIRST || byPrsChanMode == PRSCHANMODE_BOTH) &&
//         m_tConfInStatus.IsPrsChnl1Start() && m_byPrsChnnl != EQP_CHANNO_INVALID)
//     {		
//         if(bNotify)
//         {
//             cServMsg.SetChnIndex(m_byPrsChnnl);
//             cServMsg.SetMsgBody();
//             SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_REMOVEALL_REQ, cServMsg);
//         }        
// 
//         StopSwitchToPeriEqp(m_tPrsEqp.GetEqpId(), m_byPrsChnnl, FALSE, MODE_VIDEO);
// 
//         if(bLogicalChan)
//         {
//             dwDstIpAddr = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnl+2;
//             g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwDstIpAddr, wDstPort);
//             ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopPrs-PrsChnnlVid] dwDstIpAddr = %d, wDstPort = %d\n", dwDstIpAddr, wDstPort);
//         }
//         m_tConfInStatus.SetPrsChnl1Start(FALSE);
//     }
// 
//     //第二路视频
//     if ((byPrsChanMode == PRSCHANMODE_SECOND || byPrsChanMode == PRSCHANMODE_BOTH ) &&
//         m_tConfInStatus.IsPrsChnl2Start() && m_byPrsChnnl2 != EQP_CHANNO_INVALID)
//     {
//         if(bNotify)
//         {
//             cServMsg.SetChnIndex(m_byPrsChnnl2);
//             cServMsg.SetMsgBody();
//             SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_REMOVEALL_REQ, cServMsg);
//         }
// 
//         StopSwitchToPeriEqp(m_tPrsEqp.GetEqpId(), m_byPrsChnnl2, FALSE, MODE_VIDEO);
// 
//         if (bLogicalChan)
//         {
//             dwDstIpAddr = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN*m_byPrsChnnl2+2;
//             g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwDstIpAddr, wDstPort);
//             ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopPrs-PrsChnnlVid2] dwDstIpAddr = %d, wDstPort = %d\n", dwDstIpAddr, wDstPort);
//         }
//         m_tConfInStatus.SetPrsChnl2Start(FALSE);
//     }
// 
//     //音频
//     if (byPrsChanMode == PRSCHANMODE_AUDIO && 
//         m_tConfInStatus.IsPrsChnlAudStart() && EQP_CHANNO_INVALID != m_byPrsChnnlAud)
//     {
//         if(bNotify)
//         {
//             cServMsg.SetChnIndex(m_byPrsChnnlAud);
//             cServMsg.SetMsgBody();
//             SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_REMOVEALL_REQ, cServMsg);
//         }
// 
//         StopSwitchToPeriEqp(m_tPrsEqp.GetEqpId(), m_byPrsChnnlAud, FALSE, MODE_AUDIO);
// 
//         if(bLogicalChan)
//         {
//             dwDstIpAddr = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnlAud + 2;
//             g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwDstIpAddr, wDstPort);
//             ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopPrs-PrsChnnlAud] dwDstIpAddr = %d, wDstPort = %d\n", dwDstIpAddr, wDstPort);
//         }
//         m_tConfInStatus.SetPrsChnlAudStart(FALSE);
//     }
// 
//     //需适配的音频重传
//     if (PRSCHANMODE_AUDBAS == byPrsChanMode && 
//         m_tConfInStatus.IsPrsChnlAudBasStart() && EQP_CHANNO_INVALID != m_byPrsChnnlAudBas)
//     {
//         if(bNotify)
//         {
//             cServMsg.SetChnIndex(m_byPrsChnnlAudBas);
//             cServMsg.SetMsgBody();
//             SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_REMOVEALL_REQ, cServMsg);
//         }
//         
//         StopSwitchToPeriEqp(m_tPrsEqp.GetEqpId(), m_byPrsChnnlAudBas, FALSE, MODE_AUDIO);
//         
//         if(bLogicalChan)
//         {
//             dwDstIpAddr = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnlAudBas + 2;
//             g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwDstIpAddr, wDstPort);
//             ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopPrs-PrsChnnlAudBas] dwDstIpAddr = %d, wDstPort = %d\n", dwDstIpAddr, wDstPort);
//         }
//         m_tConfInStatus.SetPrsChnlAudBasStart(FALSE);
//     }
// 
//     //需媒体适配的视频重传
//     if (PRSCHANMODE_VIDBAS == byPrsChanMode && 
//         m_tConfInStatus.IsPrsChnlVidBasStart() && EQP_CHANNO_INVALID != m_byPrsChnnlVidBas)
//     {
//         if(bNotify)
//         {
//             cServMsg.SetChnIndex(m_byPrsChnnlVidBas);
//             cServMsg.SetMsgBody();
//             SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_REMOVEALL_REQ, cServMsg);
//         }
//         
//         StopSwitchToPeriEqp(m_tPrsEqp.GetEqpId(), m_byPrsChnnlVidBas, FALSE, MODE_VIDEO);
//         
//         if(bLogicalChan)
//         {
//             dwDstIpAddr = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnlVidBas + 2;
//             g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwDstIpAddr, wDstPort);
//             ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopPrs-PrsChnnlVidBas] dwDstIpAddr = %d, wDstPort = %d\n", dwDstIpAddr, wDstPort);
//         }
//         m_tConfInStatus.SetPrsChnlVidBasStart(FALSE);
//     }
// 
//     //需码率适配的视频重传 or vmp.2
//     if ((PRSCHANMODE_BRBAS == byPrsChanMode || PRSCHANMODE_VMP2 == byPrsChanMode) &&
//         m_tConfInStatus.IsPrsChnlBrBasStart() && EQP_CHANNO_INVALID != m_byPrsChnnlBrBas)
//     {
//         if(bNotify)
//         {
//             cServMsg.SetChnIndex(m_byPrsChnnlBrBas);
//             cServMsg.SetMsgBody();
//             SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_REMOVEALL_REQ, cServMsg);
//         }
//         
//         StopSwitchToPeriEqp(m_tPrsEqp.GetEqpId(), m_byPrsChnnlBrBas, FALSE, MODE_VIDEO);
//         
//         if(bLogicalChan)
//         {
//             dwDstIpAddr = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnlBrBas + 2;
//             g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwDstIpAddr, wDstPort);
//             ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopPrs-PrsChnnlBrBas] dwDstIpAddr = %d, wDstPort = %d\n", dwDstIpAddr, wDstPort);
//         }
//         m_tConfInStatus.SetPrsChnlBrBasStart(FALSE);
//     }
// 
//     // FIXME：高清适配丢包重传未添加,zgc
// 	
// 	// xliang [4/30/2009] 多路输出类广播源视频重传
//     if (PRSCHANMODE_VMPOUT1 == byPrsChanMode 
// 		&& m_tConfInStatus.IsPrsChnlVmpOut1Start()  
// 		&& EQP_CHANNO_INVALID != m_byPrsChnnlVmpOut1
// 		)
//     {
//         if(bNotify)
//         {
//             cServMsg.SetChnIndex(m_byPrsChnnlVmpOut1);
//             cServMsg.SetMsgBody();
//             SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_REMOVEALL_REQ, cServMsg);
//         }
//         
//         StopSwitchToPeriEqp(m_tPrsEqp.GetEqpId(), m_byPrsChnnlVmpOut1, FALSE, MODE_VIDEO);
//         
//         if(bLogicalChan)
//         {
//             dwDstIpAddr = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnlVmpOut1 + 2;
//             g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwDstIpAddr, wDstPort);
//             ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopPrs-PrsChnnlBrd1080] dwDstIpAddr = %d, wDstPort = %d\n", dwDstIpAddr, wDstPort);
//         }
//         m_tConfInStatus.SetPrsChnlVmpOut1Start(FALSE);
//     }
// 
// 	if (PRSCHANMODE_VMPOUT2 == byPrsChanMode 
// 		&& m_tConfInStatus.IsPrsChnlVmpOut2Start()  
// 		&& EQP_CHANNO_INVALID != m_byPrsChnnlVmpOut2
// 		)
//     {
//         if(bNotify)
//         {
//             cServMsg.SetChnIndex(m_byPrsChnnlVmpOut2);
//             cServMsg.SetMsgBody();
//             SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_REMOVEALL_REQ, cServMsg);
//         }
//         
//         StopSwitchToPeriEqp(m_tPrsEqp.GetEqpId(), m_byPrsChnnlVmpOut2, FALSE, MODE_VIDEO);
//         
//         if(bLogicalChan)
//         {
//             dwDstIpAddr = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnlVmpOut2 + 2;
//             g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwDstIpAddr, wDstPort);
//             ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopPrs-PrsChnnlBrd720] dwDstIpAddr = %d, wDstPort = %d\n", dwDstIpAddr, wDstPort);
//         }
//         m_tConfInStatus.SetPrsChnlVmpOut2Start(FALSE);
//     }
// 
// 	if (PRSCHANMODE_VMPOUT3 == byPrsChanMode 
// 		&& m_tConfInStatus.IsPrsChnlVmpOut3Start()  
// 		&& EQP_CHANNO_INVALID != m_byPrsChnnlVmpOut3
// 		)
//     {
//         if(bNotify)
//         {
//             cServMsg.SetChnIndex(m_byPrsChnnlVmpOut3);
//             cServMsg.SetMsgBody();
//             SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_REMOVEALL_REQ, cServMsg);
//         }
//         
//         StopSwitchToPeriEqp(m_tPrsEqp.GetEqpId(), m_byPrsChnnlVmpOut3, FALSE, MODE_VIDEO);
//         
//         if(bLogicalChan)
//         {
//             dwDstIpAddr = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnlVmpOut3 + 2;
//             g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwDstIpAddr, wDstPort);
//             ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopPrs-PrsChnnlBrd4Cif] dwDstIpAddr = %d, wDstPort = %d\n", dwDstIpAddr, wDstPort);
//         }
//         m_tConfInStatus.SetPrsChnlVmpOut3Start(FALSE);
//     }
// 
// 	if (PRSCHANMODE_VMPOUT4 == byPrsChanMode 
// 		&& m_tConfInStatus.IsPrsChnlVmpOut4Start()  
// 		&& EQP_CHANNO_INVALID != m_byPrsChnnlVmpOut4
// 		)
//     {
//         if(bNotify)
//         {
//             cServMsg.SetChnIndex(m_byPrsChnnlVmpOut4);
//             cServMsg.SetMsgBody();
//             SendMsgToEqp(m_tPrsEqp.GetEqpId(), MCU_PRS_REMOVEALL_REQ, cServMsg);
//         }
//         
//         StopSwitchToPeriEqp(m_tPrsEqp.GetEqpId(), m_byPrsChnnlVmpOut4, FALSE, MODE_VIDEO);
//         
//         if(bLogicalChan)
//         {
//             dwDstIpAddr = tEqpLogicalChannel.GetRcvMediaChannel().GetIpAddr();
//             wDstPort = tEqpLogicalChannel.GetRcvMediaChannel().GetPort() + PORTSPAN * m_byPrsChnnlVmpOut4 + 2;
//             g_cMpManager.StopMultiToOneSwitch(m_byConfIdx, dwDstIpAddr, wDstPort);
//             ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[StopPrs-PrsChnnlBrdCifOrOther] dwDstIpAddr = %d, wDstPort = %d\n", dwDstIpAddr, wDstPort);
//         }
//         m_tConfInStatus.SetPrsChnlVmpOut4Start(FALSE);
//     }
// 
//     g_cMcuVcApp.SetPeriEqpStatus(m_tPrsEqp.GetEqpId(), &tStatus);
// 
//     
// // 	if ( (IsHDConf(m_tConf) && !m_tConfInStatus.IsHDPrsChnlAnyStart() )
// // 		|| ( !IsHDConf(m_tConf) && !m_tConfInStatus.IsPrsChnlAnyStart() )
// // 		)
// //     {
// //         m_tConf.m_tStatus.SetPrsing(FALSE);
// //     }
// 
//     //移除所有数据交换
// 
// }

/*====================================================================
    函数名      ：ProcPrsMcuRsp
    功能        ：丢包重传器应答处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/27    3.0         胡昌威        创建
====================================================================*/
void CMcuVcInst::ProcPrsConnectedNotif(const CMessage * pcMsg)
{
    //TPeriEqpRegReq tEqp = *(TPeriEqpRegReq *)cServMsg.GetMsgBody();

	switch(CurState())
	{
	case STATE_ONGOING:
		{
			TConfAttrb tConfAttrb = m_tConf.GetConfAttrb(); 
			if (tConfAttrb.IsResendLosePack())
			{				
				//广播vmp
				if (!GetLocalVidBrdSrc().IsNull() &&
					!m_tVmpEqp.IsNull() && 
					GetLocalVidBrdSrc() == m_tVmpEqp)
				{
					StartPrsForVmp(m_tVmpEqp);
				}
				else
				{
					//广播视频
					StartBrdPrs(MODE_VIDEO);
				}

				//广播双流
				StartBrdPrs(MODE_SECVIDEO);
				//广播音频
				StartBrdPrs(MODE_AUDIO);
				//多格式MIXER
				if (!m_tMixEqp.IsNull() && GetLocalAudBrdSrc() == m_tMixEqp)
				{
					StartPrsForMixer();
				}
				
				//广播适配
				StartBasPrsSupportEx(MODE_VIDEO);
				StartBasPrsSupportEx(MODE_AUDIO);
				StartBasPrsSupportEx(MODE_SECVIDEO);
			}
		}		
		break;

	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			            pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState());
		break;
	}
}


/*====================================================================
    函数名      ：ProcPrsMcuRsp
    功能        ：丢包重传器应答处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/27    3.0         胡昌威        创建
====================================================================*/
void CMcuVcInst::ProcPrsDisconnectedNotif( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	TEqp	    tPrs = *( TEqp * )cServMsg.GetMsgBody();
	switch( CurState() )
	{
	case STATE_ONGOING:
		{
			TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
			if( tConfAttrb.IsResendLosePack()/*m_tConf.m_tStatus.IsPrsing()*/ )
			{
				u8 abyPrsChnId[MAXNUM_PRS_CHNNL] = {0};
				u8 byUseNum = GetSpecPrsIdAllChnForConf(tPrs.GetEqpId(), abyPrsChnId);
				if (0 != byUseNum)
				{
					for (u8 byChnIdx = 0; byChnIdx < byUseNum; byChnIdx++)
					{
						u8 byMediaMode = GetPrsChnMediaMode(tPrs.GetEqpId(), abyPrsChnId[byChnIdx]);
						if (MODE_VIDEO != byMediaMode &&
							MODE_AUDIO != byMediaMode &&
							MODE_SECVIDEO != byMediaMode)
						{
							continue;
						}
						//停止prs
						StopPrs(tPrs.GetEqpId(), abyPrsChnId[byChnIdx], byMediaMode);
						//释放占用的prs通道(包括外设状态和详细信息)
						RlsPrsChnl(tPrs.GetEqpId(), abyPrsChnId[byChnIdx]);
					}
				}

// 				if (m_tConfInStatus.IsPrsChnl1Start())
// 				{
// 					StopPrs(PRSCHANMODE_FIRST);
// 				}
// 				if (m_tConfInStatus.IsPrsChnl2Start())
// 				{
// 					StopPrs(PRSCHANMODE_SECOND);
// 				}
// 				if (m_tConfInStatus.IsPrsChnlAudStart())
// 				{
// 					StopPrs(PRSCHANMODE_AUDIO);
// 				}
// 				//PRSCHANMODE_VMP2和PRSCHANMODE_BRBAS目前没用
// 				if (m_tConfInStatus.IsPrsChnlBrBasStart())
// 				{	
// 					StopPrs(PRSCHANMODE_BRBAS);
// 					StopPrs(PRSCHANMODE_VMP2);
// 				}	
// 				
// 				TPeriEqpStatus tStatus;
// 				g_cMcuVcApp.GetPeriEqpStatus( m_tPrsEqp.GetEqpId(), &tStatus );
// 				tStatus.m_tStatus.tPrs.m_tPerChStatus[m_byPrsChnnl].SetReserved( FALSE );
// 				tStatus.m_tStatus.tPrs.m_tPerChStatus[m_byPrsChnnl2].SetReserved( FALSE );
// 				tStatus.m_tStatus.tPrs.m_tPerChStatus[m_byPrsChnnlAud].SetReserved( FALSE );
// 				g_cMcuVcApp.SetPeriEqpStatus( m_tPrsEqp.GetEqpId(), &tStatus );
// 				
// 				//zjl[20101026] 释放广播适配器占用的PRS通道 
// 				for (u8 byPrsChnIdx = 0; byPrsChnIdx < MAXNUM_PRS_CHNNL; byPrsChnIdx++)
// 				{
// 					if (!m_tConfPrsInfo.GetPrsChnInfo(byPrsChnIdx).IsNull())
// 					{
// 						StopPrs(m_tConfPrsInfo.GetPrsChnInfo(byPrsChnIdx).GetPrsId(), 
// 							m_tConfPrsInfo.GetPrsChnInfo(byPrsChnIdx).GetPrsChnId(),
// 							m_tConfPrsInfo.GetPrsChnInfo(byPrsChnIdx).GetPrsMode());
// 						
// 						RlsPrsChnl(m_tConfPrsInfo.GetPrsChnInfo(byPrsChnIdx).GetPrsId(), m_tConfPrsInfo.GetPrsChnInfo(byPrsChnIdx).GetPrsChnId());
// 						
// 					}
// 				}
// 				
// 				//释放画面合成占用prs通道
// 				StopPrsForVmp();
// 				
// 				memset(&m_tConfPrsInfo, 0, sizeof(m_tConfPrsInfo));			
			}
		}
		break;
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "CMcuVcInst: Wrong message %u(%s) received in state %u!\n", 
			pcMsg->event, ::OspEventDesc( pcMsg->event ), CurState() );
		break;
	}
}

/*====================================================================
    函数名      ：ProcPrsMcuRsp
    功能        ：丢包重传器应答处理函数
    算法实现    ：
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	04/03/27    3.0         胡昌威        创建
====================================================================*/
void CMcuVcInst::ProcPrsMcuRsp( const CMessage * pcMsg )
{
	CServMsg	cServMsg( pcMsg->content, pcMsg->length );
	u8          byPrsChnId = cServMsg.GetChnIndex();
	u8          byPrsId    = *cServMsg.GetMsgBody();

	switch( pcMsg->event ) 
	{
	case PRS_MCU_SETSRC_ACK:			//PRS给MCU保存信息源确认
		{
			//设置通道开启
			SetPrsChnStart(byPrsId, byPrsChnId, TRUE);
			//建交换
			BuildRtcpAndRtpSwithForPrs(byPrsId, byPrsChnId);		
			break;
		}
	case PRS_MCU_REMOVEALL_ACK:			//PRS给MCU改变复合参数确认	
		{
			SetPrsChnStart(byPrsId, byPrsChnId, FALSE);
		}
		break;

	case PRS_MCU_SETSRC_NACK:			//PRS给MCU保存信息源拒绝
//	case PRS_MCU_ADDRESENDCH_NACK:		//PRS给MCU停止工作拒绝
//	case PRS_MCU_REMOVERESENDCH_NACK:	//PRS给MCU改变复合参数拒绝
	case PRS_MCU_REMOVEALL_NACK:		//PRS给MCU改变复合参数拒绝
		break;

	default:
		break;
	}
}

/*====================================================================
    函数名      ：RestoreMtSelectStatus
    功能        ：选看状态的恢复
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtId   : 要恢复的终端ID
                  u8 bySelMode: 选看模式 MODE_AUDIO, MODE_VIDEO
    返回值说明  ：void
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/04/20    4.0         张宝卿          创建
====================================================================*/
// void CMcuVcInst::RestoreMtSelectStatus( u8 byMtId, u8 bySelMode )
// {
// /*    TSwitchInfo tSwitchInfo;
//     TMtStatus tMtStatus;
//     
//     //判断恢复原选看交换
//     if ( m_ptMtTable->GetMtStatus(byMtId, &tMtStatus) )
//     {        
//         TMt tMtSelect;
//         tMtSelect = tMtStatus.GetSelectMt(bySelMode);
// 
//         //选看信息非空
//         if ( !tMtSelect.IsNull() )
//         {
//             //被选看终端在线，把交换恢复到选看模式
//             if (m_tConfAllMtInfo.MtJoinedConf(tMtSelect.GetMtId()))
//             {
//                 tSwitchInfo.SetSrcMt( tMtSelect );
//                 tSwitchInfo.SetDstMt( m_ptMtTable->GetMt(byMtId) );
//                 tSwitchInfo.SetMode( bySelMode );
//                 
//                 CServMsg cServMsg;
//                 
//                 //这里将 EventId 设为 MCS_MCU_STARTSWITCHMT_REQ 没有实际意义，
//                 //  只是为了适应 SwitchSrcToDst() 中交换的正常开启，也可以设为
//                 //  MT_MCU_STARTSELMT_CMD 或 MCS_MCU_STARTSWITCHMT_REQ. 
//                 cServMsg.SetEventId( MCS_MCU_STARTSWITCHMT_REQ );
//                 
//                 SwitchSrcToDst( tSwitchInfo, cServMsg );
//             }
//             //被选看终端掉线，清空选看信息
//             else
//             {
//                 tMtSelect.SetNull();
//                 tMtStatus.SetSelectMt(tMtSelect, bySelMode);
//                 m_ptMtTable->SetMtStatus(byMtId, &tMtStatus);
//             }
//         }                        
//     }*/
// 
//     return;
// }

BOOL32 CMcuVcInst::CheckSelSrcVmpAdaptChnl(TMt tSrcMt, TMt tDstMt, u8 SelMode, TEqp &tVmpEqp)
{
	if(SelMode == MODE_AUDIO)
	{
		return TRUE;
	}

	// 终端选看预判
	TMtStatus tTempMtStatus;
	TMt tTempMt = tDstMt;
	m_ptMtTable->GetMtStatus(tTempMt.GetMtId(), &tTempMtStatus);
	TMt tBkupSrc = tTempMtStatus.GetSelectMt(MODE_VIDEO);
	tTempMtStatus.SetSelectMt( tSrcMt,MODE_VIDEO );
	// 临时设置，判断结束后更新回来
	m_ptMtTable->SetMtStatus( tTempMt.GetMtId(), &tTempMtStatus );
	TExInfoForResFps tExInfoForRes;
	tExInfoForRes.m_byEvent = EvMask_BeSelected;
	tExInfoForRes.m_byOccupy = Occupy_BeSelected;
	tExInfoForRes.m_bConsiderVmpBrd = FALSE;	//忽略vmp广播
	tExInfoForRes.m_bSeizePromt = TRUE;	//需要抢占提示
	BOOL32 bIsNeedAjsRes = IsNeedAdjustMtVidFormat(tSrcMt, tExInfoForRes);
	
	// 判断结束后恢复回来
	tTempMtStatus.SetSelectMt( tBkupSrc,MODE_VIDEO );
	m_ptMtTable->SetMtStatus( tTempMt.GetMtId(), &tTempMtStatus );
	BOOL32 bSeizePromt = tExInfoForRes.m_bResultSeizePromt; //获得是否有抢占
	if (bSeizePromt)
	{
		u8 byVmpId = tExInfoForRes.m_byEqpid;
		if (IsValidVmpId(byVmpId))
		{
			tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );//记录要抢占的合成器
			// 发送抢占消息,选看时,终端已在vmp中,无需记录抢占终端位置
			SendVmpPriSeizeReq(byVmpId, tSrcMt);
			return FALSE;
		}
	}

	return TRUE;
	/*if( ChgMtVidFormatRequired(tSrcMt) )
	{
		TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
		// 终端在多个通道中,不考虑进前适配
		u8 byChnlNum = 0;
		GetChlOfMtInVmpParam(tVmpParam, tSrcMt, byChnlNum);
		LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[CheckSelSrcVmpAdaptChnl]Mtid:%u,AllChnlCount:%u.\n",
			tSrcMt.GetMtId(), byChnlNum);
		if (byChnlNum > 1)
		{
			return TRUE;
		}

		u8 byNewFormat;
		CVmpChgFormatResult cVmpChgFormatResult;
		BOOL32 bNoNeedSeize = TRUE;
		if (!GetMtFormat(tSrcMt, &tVmpParam, byNewFormat, cVmpChgFormatResult, TRUE, FALSE, FALSE, TRUE))
		{
			if(cVmpChgFormatResult.IsSeizePromt())
			{
				// [9/15/2010 xliang] take replace operation into consideration. 
				bNoNeedSeize = FALSE;
				u8 byChnnlIdx = 0;
				u8 bySeizeCount = byChnlNum;//要抢占的前适配个数
				LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[CheckSelSrcVmpAdaptChnl]MaxHdChnnlNo:%u, SeizedHdChnnlNo:%u.\n",
					m_tVmpChnnlInfo.GetMaxNumHdChnnl(), m_tVmpChnnlInfo.GetHDChnnlNum());
				LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[CheckSelSrcVmpAdaptChnl]Mtid:%u,SeizeCount:%u.\n",
					tSrcMt.GetMtId(), bySeizeCount);

				TMtStatus tDstMtStatus;
				TMt tPreviousMt;	
				m_ptMtTable->GetMtStatus( tDstMt.GetMtId(), &tDstMtStatus );
				tPreviousMt = tDstMtStatus.GetSelectMt(MODE_VIDEO);
				u8 byPreviousCount = 0; //之前被选看终端占前适配数
				if( tPreviousMt.GetType() == TYPE_MT && !(tPreviousMt == tSrcMt) 
					&& (SelMode == MODE_VIDEO || SelMode == MODE_BOTH)
				)
				{
					// 旧的选看源在前适配中
					byPreviousCount = m_tVmpChnnlInfo.GetChnlCountByMt(tPreviousMt);
					if (byPreviousCount > 0)
					{
						bNoNeedSeize = TRUE;
					} 
				}
				
				if(!bNoNeedSeize)
				{
					// 发送抢占消息,选看时,终端已在vmp中,无需记录抢占终端位置
					SendVmpPriSeizeReq(tSrcMt);
				}
			}
		}
		return bNoNeedSeize;
	}
	else
	{
		return TRUE;
	}*/

}

/*==============================================================================
函数名    :  IsVmpSupportBackup
功能      :  判断选择的vip是否能备份旧的vmp
算法实现  :  
参数说明  :  TVMPParam &tVmpParam [i]
			 u8 byOldVmpId [i]
			 u8 byNewVmpId [i]
返回值说明:  BOOL32
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-12-09                 杨怀志
==============================================================================*/
BOOL32 CMcuVcInst::IsVmpSupportBackup(TVMPParam_25Mem &tVmpParam, u8 byOldVmpId, u8 byNewVmpId)
{
	if (!IsValidVmpId(byOldVmpId))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[IsVmpSupportBackup]Old VmpId is wrong,id:%u.\n", byOldVmpId);
		return FALSE;
	}
	
	if (!IsValidVmpId(byNewVmpId))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[IsVmpSupportBackup]New VmpId is wrong,id:%u.\n", byNewVmpId);
		return FALSE;
	}

	TPeriEqpStatus tOldVmpEqpStatus; 
	g_cMcuVcApp.GetPeriEqpStatus( byOldVmpId, &tOldVmpEqpStatus );
	u8 byOldVmpSubType = tOldVmpEqpStatus.m_tStatus.tVmp.m_bySubType;
	//旧vmp在线,不做备份处理
	if (ISTRUE(tOldVmpEqpStatus.m_byOnline))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[IsVmpSupportBackup]New VmpId is wrong,id:%u.\n", byNewVmpId);
		return FALSE;
	}

	//旧vmp掉线,备份旧vmp,判断新找到的vmp是否可以备份旧vmp
	TEqp tOldVmpEqp = (TMt)tOldVmpEqpStatus;
	TVmpChnnlInfo tVmpChnnlInfo = g_cMcuVcApp.GetVmpChnnlInfo(tOldVmpEqp);
	u8 byVmpMaxMemNum = 0;	//获得目前风格下支持最大成员数
	u8 byOldHdChnnlNum = tVmpChnnlInfo.GetHDChnnlNum();		//获得旧vmp前适配通道内成员数
	u8 byOldMaxHdChnnlNum = tVmpChnnlInfo.GetMaxNumHdChnnl();	//获得旧vmp支持最大前适配个数
	u8 byOldMaxStyleNum = tVmpChnnlInfo.GetMaxStyleNum();		//获得旧vmp最大支持多少风格不降分辨率
	u8 byNeedHdChnlNum = 0;	//需要的前适配通道数
	u8 byNewMaxHdChnnlNum = 0;	//新vmp支持最大前适配个数
	u8 byNewVmpSubtype = GetVmpSubType(byNewVmpId); //新vmp子类型
	u8 byNewMaxStyleNum = 0;	//新vmp最大支持多少风格不降分辨率

	// 自动画面合成模式
	if (tVmpParam.IsVMPAuto())
	{
		TVMPParam_25Mem tTmpVmpParam = tVmpParam;
		// 调整当前合成成员
		AdjustVmpParamMember(byOldVmpId, &tTmpVmpParam, byOldVmpSubType, FALSE);
		byVmpMaxMemNum = tTmpVmpParam.GetMaxMemberNum();	//获得目前风格下支持最大成员数
		
		// MPU时,4画面及以下,前适配通道为4个
		//if (MPU_SVMP == byOldVmpSubType && 4 >= byVmpMaxMemNum)
		if (byOldMaxStyleNum >= byVmpMaxMemNum)
		{
			byOldMaxHdChnnlNum = byOldMaxStyleNum;
		}

		if (0 == byOldHdChnnlNum)
		{
			// 最大支持前适配个数大于等于当前风格下支持的最大成员数时,需要的前适配数为当前通道总数
			if (byOldMaxHdChnnlNum >= byVmpMaxMemNum)
			{
				byNeedHdChnlNum = byVmpMaxMemNum;
			}
			else
			{
				byNeedHdChnlNum = 0;
				LogPrint(LOG_LVL_WARNING, MID_MCU_VMP, "[IsVmpSupportBackup]There is no Mt in m_tVmpChnnlInfo.\n");
			}
		}
		else
		{
			byNeedHdChnlNum = byOldHdChnnlNum;
		}
	}
	else //非自动合成模式
	{
		byVmpMaxMemNum = tVmpParam.GetMaxMemberNum();	//获得目前风格下支持最大成员数
		
		// MPU时,4画面及以下,前适配通道为4个
		//if (MPU_SVMP == byOldVmpSubType && 4 >= byVmpMaxMemNum)
		if (byOldMaxStyleNum >= byVmpMaxMemNum)
		{
			byOldMaxHdChnnlNum = byOldMaxStyleNum;
		}

		if (0 == byOldHdChnnlNum)
		{
			// 最大支持前适配个数大于等于当前风格下支持的最大成员数时,需要的前适配数为当前通道总数
			if (byOldMaxHdChnnlNum >= byVmpMaxMemNum)
			{
				byNeedHdChnlNum = byVmpMaxMemNum;
			}
			else
			{
				byNeedHdChnlNum = 0;
				LogPrint(LOG_LVL_WARNING, MID_MCU_VMP, "[IsVmpSupportBackup]There is no Mt in m_tVmpChnnlInfo.\n");
			}
		}
		else
		{
			byNeedHdChnlNum = byOldHdChnnlNum;
		}
	}
	
	byNewMaxHdChnnlNum = GetMaxHdChnlNumByVmpId(m_tConf, byNewVmpId, byNewMaxStyleNum);
	// MPU时,4画面及以下,前适配通道为4个
	//if (MPU_SVMP == byOldVmpSubType && 4 >= byVmpMaxMemNum)
	if (byNewMaxStyleNum >= byVmpMaxMemNum)
	{
		// 小于等于4画面时,按4个前适配
		byNewMaxHdChnnlNum = byNewMaxStyleNum;
	}

	// 前适配不足时,备份失败
	if (byNeedHdChnlNum > byNewMaxHdChnnlNum)
	{
		LogPrint(LOG_LVL_WARNING, MID_MCU_VMP, "[IsVmpSupportBackup]HdChnnl is not enough.\n");
		LogPrint(LOG_LVL_WARNING, MID_MCU_VMP, "[IsVmpSupportBackup]NewVmpId:%u,have HdChnnlNo:%u.\n",
			byNewVmpId, byNewMaxHdChnnlNum);
		LogPrint(LOG_LVL_WARNING, MID_MCU_VMP, "[IsVmpSupportBackup]OldVmpId:%u,Need HdChnnlNo:%u.\n",
			byOldVmpId, byNeedHdChnlNum);
		return FALSE;
	}

	//如果旧的是MPU2且有终端在多个通道中,新选择到的vmp不是MPU2类型的,如果配置不支持1终端进多通道,也不能备份
	//8kg与8kh只有1个vmp,不支持vmp备份,此处不判断,此处只判配置文件用g_cMcuVcApp.IsAllowVmpMemRepeated()
	if (IsAllowVmpMemRepeated(byOldVmpId) && // 原vmp允许终端进多通道,新vmp不支持时处理,vpu不支持终端进多通道,mpu与mpu2读配置
		!IsAllowVmpMemRepeated(byNewVmpId)
		)
	{
		TVMPMember* ptTmpMt = NULL;
		u8 byChnlNum = 0;
		for (u8 byNum=0; byNum<byVmpMaxMemNum; byNum++)
		{
			ptTmpMt = tVmpParam.GetVmpMember(byNum);
			if (NULL == ptTmpMt || ptTmpMt->IsNull())
			{
				continue;
			}
			GetChlOfMtInVmpParam(tVmpParam, *ptTmpMt, byChnlNum);
			LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[IsVmpSupportBackup]Mtid:%u,AllChnlCount:%u.\n",
				ptTmpMt->GetMtId(), byChnlNum);
			// 如果在vmp多个通道中,返回FALSE
			if (1 < byChnlNum)
			{
				LogPrint(LOG_LVL_WARNING, MID_MCU_VMP, "[IsVmpSupportBackup]Newvmp is not allow member repeated.\n");
				return FALSE;
			}
			// 可能是无上传通道终端的mcu在多通道,GetChlOfMtInVmpParam会记录不到
			if (IsMcu(*ptTmpMt))
			{
				if (byNum != tVmpParam.GetChlOfMtInMember(*ptTmpMt, TRUE))
				{
					LogPrint(LOG_LVL_WARNING, MID_MCU_VMP, "[IsVmpSupportBackup]Newvmp is not allow member repeated.\n");
					return FALSE;
				}
			}
		}
	}

	return TRUE;
}

/*==============================================================================
函数名    :  GetMaxHdChnlNumByVmpId
功能      :  根据vmpid获得其支持最大前适配个数,支持MPU2
算法实现  :  
参数说明  :  TConfInfo &tConfInfo [i]
			 u8 byVmpId [i]
返回值说明:  BOOL32
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-12-09                 杨怀志
==============================================================================*/
u8 CMcuVcInst::GetMaxHdChnlNumByVmpId(const TConfInfo &tConfInfo, u8 byVmpId, u8 &byMaxStyleNum)
{
	u8 byMaxHdChnnlNum = 0;
	byMaxStyleNum = 0;
	if (VMPID_MIN > byVmpId || VMPID_MAX < byVmpId)
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[IsVmpSupportBackup]VmpId is wrong.\n");
		return byMaxHdChnnlNum;
	}

	TPeriEqpStatus tVmpEqpStatus; 
	g_cMcuVcApp.GetPeriEqpStatus( byVmpId, &tVmpEqpStatus );
	u8 byVmpSubType = tVmpEqpStatus.m_tStatus.tVmp.m_bySubType;
	u8 byMpuBoardVer = tVmpEqpStatus.m_tStatus.tVmp.m_byBoardVer;
	switch (byVmpSubType)
	{
	case VMP:
		byMaxHdChnnlNum = MAXNUM_DVMP_HDCHNNL; 
		break;
	case MPU_SVMP:
		byMaxHdChnnlNum = (byMpuBoardVer == MPU_BOARD_A128) ? MAXNUM_SVMP_HDCHNNL : MAXNUM_SVMPB_HDCHNNL;
		byMaxStyleNum = 4; //mpu四画面以下不降分辨率
		break;
	case MPU2_VMP_BASIC://VMP(Basic) 模式下最大支持4路画面合成前适配
		{
			if (tConfInfo.GetMainVideoMediaType() == MEDIA_TYPE_H264
				&& tConfInfo.GetMainVideoFormat() == VIDEO_FORMAT_HD1080
				&& tConfInfo.GetMainVidUsrDefFPS() >= 50)
			{
				if (BRD_TYPE_MPU2ECARD == g_cMcuAgent.GetMPU2TypeByVmpEqpId(byVmpId))
				{
					// Basic*2 板子性能问题，1080p50/60fps会议，4风格以下不降分辨率，1个前适配
					byMaxHdChnnlNum = 1;
				}
				else
				{
					// 1080p50/60fps会议，4风格以下不降分辨率，2个前适配
					byMaxHdChnnlNum = MAXNUM_MPU2VMP_BS_HDCHNNL;
				}
				byMaxStyleNum = 4;//mpu2 basic模式4画面以下不降分辨率
			}
			else
			{
				if (BRD_TYPE_MPU2ECARD == g_cMcuAgent.GetMPU2TypeByVmpEqpId(byVmpId))
				{
					// Basic*2 板子性能问题，1080p30fps会议，4风格以下不降分辨率，2个前适配
					byMaxHdChnnlNum = 2;
					byMaxStyleNum = 4;
				}
				else
				{
					// 主格式1080p30fps会议及以下，单Basic板子5风格以下不降分辨率，4个前适配
					byMaxHdChnnlNum = 4;
					byMaxStyleNum = 5;
				}
			}
		}
		break;
	case MPU2_VMP_ENHACED:
		{
			// 1080p50/60fps会议，9风格以下不降分辨率，8个前适配
			if (tConfInfo.GetMainVideoMediaType() == MEDIA_TYPE_H264
				&& tConfInfo.GetMainVideoFormat() == VIDEO_FORMAT_HD1080
				&& tConfInfo.GetMainVidUsrDefFPS() >= 50)
			{
				//根据媒控当前的性能，8个前适配，9画面以下不降分辨率
				byMaxHdChnnlNum = 8;
				byMaxStyleNum = 9;
			}
			else// 主格式1080p30fps会议及以下，20风格以下不降分辨率，19个前适配
			{
				byMaxHdChnnlNum = MAXNUM_MPU2VMP_E20_HDCHNNL - 1;
				byMaxStyleNum = 20;
			}
		}
		break;
	case VMP_8KE://8kg 0前适配
		byMaxHdChnnlNum = MAXNUM_8KEVMP_HDCHNNL;
		byMaxStyleNum = 0;//8kg所有风格全降分辨率
		break;
	case VMP_8KH://8kh 最大前适配通道个数看会议
		{
			BOOL32 bAdpConf = IsConfExcludeDDSUseAdapt();//是否适配会议
			byMaxHdChnnlNum = MAXNUM_SDVMP_MEMBER;//先给个默认值,4cif,cif other 都用这个默认值
			//适配会议
			if ( bAdpConf )
			{
				if ( tConfInfo.GetMainVideoMediaType() == MEDIA_TYPE_H264 ) //主格式h264
				{
					//1080p 60/50fps会议前适配个数为0					
					if ( tConfInfo.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 && 
						tConfInfo.GetMainVidUsrDefFPS() >= 50 ) 
					{
						byMaxHdChnnlNum = MAXNUM_8KHVMP_ADPCONF1080P60_HDCHNNL	;
					}	
					else if ( tConfInfo.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 &&
						tConfInfo.GetMainVidUsrDefFPS() >= 25 
						)  //1080 30/25fps前适配通道个数为1 
					{
						// 20120327 yhz 1080 30/25fps HP会议,前适配个数为0
						if (emHpAttrb == tConfInfo.GetProfileAttrb())
						{
							byMaxHdChnnlNum = MAXNUM_8KHVMP_ADPCONF1080P60_HDCHNNL;//与1080p60fps会议前适配数一致
						} else {
							byMaxHdChnnlNum = MAXNUM_8KHVMP_ADPCONF1080P30_HDCHNNL;
						}
					}
					else if (tConfInfo.GetMainVideoFormat() == VIDEO_FORMAT_HD720)//720p30/25,前适配通道个数为9
					{
						if (emHpAttrb == tConfInfo.GetProfileAttrb())
						{
							// 720 60fps HP会议,前适配个数为0
							if (tConfInfo.GetMainVidUsrDefFPS() >= 50)
							{
								byMaxHdChnnlNum = MAXNUM_8KHVMP_ADPCONF1080P60_HDCHNNL;//与1080p60fpsBP会议前适配数一致
							} // 720 60fps HP会议,前适配个数为1
							else
							{
								byMaxHdChnnlNum = MAXNUM_8KHVMP_ADPCONF1080P30_HDCHNNL;//与1080p30fpsBP会议前适配数一致
							}
						} else {
							byMaxHdChnnlNum = MAXNUM_8KHVMP_CONF720P_HDCHNNL;
						}
					}
				}
				else if ( MEDIA_TYPE_H264 == tConfInfo.GetSecVideoMediaType() ) //主格式非h264,辅格式h264
				{// 辅格式264目前仅支持标清,不支持高清HP,暂不改动
					//1080p 60/50fps会议前适配个数为0					
					if ( tConfInfo.GetSecVideoFormat() == VIDEO_FORMAT_HD1080 && 
						tConfInfo.GetSecVidUsrDefFPS() >= 50 ) 
					{
						byMaxHdChnnlNum = MAXNUM_8KHVMP_ADPCONF1080P60_HDCHNNL;
					}	
					else if ( tConfInfo.GetSecVideoFormat() == VIDEO_FORMAT_HD1080 &&
						tConfInfo.GetSecVidUsrDefFPS() >= 25 
						)  ////1080 30/25fps，前适配通道个数为1 
					{
						byMaxHdChnnlNum = MAXNUM_8KHVMP_ADPCONF1080P30_HDCHNNL;
					}
					else if (tConfInfo.GetSecVideoFormat() == VIDEO_FORMAT_HD720)//720p30/25,前适配通道个数为9
					{
						byMaxHdChnnlNum = MAXNUM_8KHVMP_CONF720P_HDCHNNL;
					}
					
				}
			}
			else //非适配会议
			{
				if ( tConfInfo.GetMainVideoMediaType() == MEDIA_TYPE_H264 ) //主格式h264
				{					
					if ( tConfInfo.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 && 
						tConfInfo.GetMainVidUsrDefFPS() >= 50 ) 
					{
						//20120327 yhz 1080p 60/50fps HP会议前适配个数为0
						if (emHpAttrb == tConfInfo.GetProfileAttrb())
						{
							u8 byTempHdChnNum = MAXNUM_8KHVMP_CONF1080P60_HDCHNNL;
							byMaxHdChnnlNum = byTempHdChnNum - 1;
						} 
						else
						{
							//1080p 60/50fps BP会议前适配个数为1
							byMaxHdChnnlNum = MAXNUM_8KHVMP_CONF1080P60_HDCHNNL;
						}
					}	
					else if (tConfInfo.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 &&
						tConfInfo.GetMainVidUsrDefFPS() >= 25 
						)  
					{
						//1080 30/25fps HP，前适配通道个数为2 
						if (emHpAttrb == tConfInfo.GetProfileAttrb())
						{
							byMaxHdChnnlNum = MAXNUM_8KHVMP_CONF1080P30_HDCHNNL - 1;
						} else {
							//1080 30/25fps BP，前适配通道个数为3
							byMaxHdChnnlNum = MAXNUM_8KHVMP_CONF1080P30_HDCHNNL;
							byMaxStyleNum = 4; //最大支持4画面不降分辨率
						}
					}
					else if (tConfInfo.GetMainVideoFormat() == VIDEO_FORMAT_HD720)//720p30/25,前适配通道个数为9
					{
						// 720 HP,前适配通道个数为4
						if (emHpAttrb == tConfInfo.GetProfileAttrb())
						{
							byMaxHdChnnlNum = MAXNUM_8KHVMP_CONF1080P30_HDCHNNL + 1;
						} else {
							// 720 BP,前适配通道个数为9
							byMaxHdChnnlNum = MAXNUM_8KHVMP_CONF720P_HDCHNNL;
						}
					}
					
				}
			}
			// 无特殊情况,支持最大风格数与最大前适配数保持一致
			if (0 == byMaxStyleNum)
			{
				byMaxStyleNum = byMaxHdChnnlNum;
			}
		}
		break;
	case VMP_8KI://8ki 最大前适配通道个数看会议
		{
			if (tConfInfo.GetMainVideoMediaType() == MEDIA_TYPE_H264 && IsVidFormatHD(tConfInfo.GetMainVideoFormat()))
			{
				if (tConfInfo.GetMainVideoFormat() == VIDEO_FORMAT_HD1080)
				{
					if (tConfInfo.GetMainVidUsrDefFPS() >= 50)
					{
						//1080P/i 50/60fps会议 前适配2个
						byMaxHdChnnlNum = MAXNUM_8KIVMP_ADPHDCHL_2;
					}
					else
					{
						//1080P/i 25/30fps会议 前适配5个
						byMaxHdChnnlNum = MAXNUM_8KIVMP_ADPHDCHL_4;
					}
				}
				else if (tConfInfo.GetMainVideoFormat() == VIDEO_FORMAT_HD720)
				{
					if (tConfInfo.GetMainVidUsrDefFPS() >= 50)
					{
						//720P 50/60fps会议 前适配5个
						byMaxHdChnnlNum = MAXNUM_8KIVMP_ADPHDCHL_4;
					}
					else
					{
						//720P 25/30fps会议 前适配9个
						byMaxHdChnnlNum = MAXNUM_8KIVMP_ADPHDCHL_9;
					}
				}
			}
			else
			{
				// 标清会议前适配16个
				byMaxHdChnnlNum = MAXNUM_8KIVMP_ADPHDCHL_16;
			}
			// 支持最大风格数与最大前适配数保持一致
			byMaxStyleNum = byMaxHdChnnlNum;
		}
		break;
	default :
		byMaxHdChnnlNum = 0; 
		LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[IsVmpSupportBackup]VmpSubtype is wrong.\n");
		break;
		}

	return byMaxHdChnnlNum;
}

/*==============================================================================
函数名    :  Is8khVmpInConf1080p30fps
功能      :  (8KH移植)判断是否是8kh1080p/30fps非适配会议开启的vmp
算法实现  :  
参数说明  :  TConfInfo &tConfInfo [i]
			 u8 byVmpId [i]
返回值说明:  BOOL32
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2012-02-15                 杨怀志
==============================================================================*/
BOOL32 CMcuVcInst::Is8khVmpInConf1080p30fps(const TConfInfo &tConfInfo, u8 byVmpId)
{
	//8KH 1080p/30fps BP 非适配会议vmp
	BOOL32 bIs8khConf1080p30 = FALSE;
	if (VMP_8KH == GetVmpSubType(byVmpId) &&
		!IsConfExcludeDDSUseAdapt())
	{
		//判断主格式
		if (tConfInfo.GetMainVideoMediaType() == MEDIA_TYPE_H264 &&
			tConfInfo.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 &&
			tConfInfo.GetMainVidUsrDefFPS() >= 25 &&
			tConfInfo.GetMainVidUsrDefFPS() <= 30 &&
			tConfInfo.GetProfileAttrb() == emBpAttrb)
		{
			bIs8khConf1080p30 = TRUE;
		}
		//判断辅格式
		if (tConfInfo.GetSecVideoMediaType() == MEDIA_TYPE_H264 &&
			tConfInfo.GetSecVideoFormat() == VIDEO_FORMAT_HD1080 &&
			tConfInfo.GetSecVidUsrDefFPS() >= 25 &&
			tConfInfo.GetSecVidUsrDefFPS() <= 30 &&
			tConfInfo.GetProfileAttrb() == emBpAttrb)
		{
			bIs8khConf1080p30 = TRUE;
		}
	}

	return bIs8khConf1080p30;
}

/*==============================================================================
函数名    :  PrepareVmpOutCap
功能      :  根据模版准备vmp的后适配能力列表,并判断是否超出最大能力
算法实现  :  
参数说明  :  u8 byVmpId [i]
			 BOOL32 bBrd [i] 针对8ki
返回值说明:  BOOL32
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-12-01                 杨怀志
==============================================================================*/
BOOL32 CMcuVcInst::PrepareVmpOutCap(u8 byVmpId, BOOL32 bBrd)
{
	if (!IsValidVmpId(byVmpId))
	{
		return FALSE;
	}

	BOOL32 bRet = FALSE;
	u8 bySubType = GetVmpSubType(byVmpId);
	// VMP/MPU/8KG/8KEvmp时,不做此处理,目前仅针对MPU2,8kivmp
	if (MPU2_VMP_BASIC == bySubType
		|| MPU2_VMP_ENHACED == bySubType)
	{
		bRet = PrepareMpu2VmpOutCap(byVmpId);
	}
	else if (VMP_8KI == bySubType)
	{
		bRet = Prepare8kiVmpOutCap(byVmpId, bBrd);
	}
	else
	{
		bRet = TRUE;
	}

	return bRet;
}

/*==============================================================================
函数名    :  PrepareMpu2VmpOutCap
功能      :  根据模版准备MPU2的后适配能力列表,并判断是否超出最大能力
算法实现  :  
参数说明  :  u8 byVmpId [i]
返回值说明:  BOOL32
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-12-01                 杨怀志
==============================================================================*/
BOOL32 CMcuVcInst::PrepareMpu2VmpOutCap(u8 byVmpId)
{
	if (!IsValidVmpId(byVmpId))
	{
		return FALSE;
	}
	if ((MPU2_VMP_BASIC != GetVmpSubType(byVmpId) && MPU2_VMP_ENHACED != GetVmpSubType(byVmpId)))
	{
		LogPrint(LOG_LVL_WARNING, MID_MCU_VMP, "[PrepareMpu2VmpOutCap]Err,VmpId.%d is not mpu2.\n", byVmpId);
		return FALSE;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );

	TKDVVMPOutParam tVmpOutParam;
	u8 bySubType = GetVmpSubType(byVmpId);
	TVideoStreamCap tTmpStrCap;
	//初始化后适配列表
	tVmpOutParam.Initialize();
	if (MEDIA_TYPE_H264 != m_tConf.GetMainVideoMediaType())
	{
		if (MEDIA_TYPE_H264 == m_tConf.GetSecVideoMediaType())
		{
			//获得会议辅格式能力
			tTmpStrCap = m_tConf.GetSecSimCapSet().GetVideoCap();
			tVmpOutParam.AddVmpOutMember(tTmpStrCap);//加1路264能力
		}
		// 获得会议主能力
		tTmpStrCap = m_tConf.GetMainSimCapSet().GetVideoCap();
		tVmpOutParam.AddVmpOutMember(tTmpStrCap);//加1路Other能力

		if (MEDIA_TYPE_NULL != m_tConf.GetSecVideoMediaType() &&
			MEDIA_TYPE_H264 != m_tConf.GetSecVideoMediaType())
		{
			//获得会议辅格式能力,辅格式同样是非264情况
			tTmpStrCap = m_tConf.GetSecSimCapSet().GetVideoCap();
			tVmpOutParam.AddVmpOutMember(tTmpStrCap);//加1路Other能力
		}
		g_cMcuVcApp.SetVMPOutParam(tVmpEqp, tVmpOutParam);
		return TRUE;
	}
	
	//主格式H264处理
	u8 byCapNum = MAX_CONF_CAP_EX_NUM;
	TVideoStreamCap atCapArry[MAX_CONF_CAP_EX_NUM];
	u8 byNum = 0;
	for (;byNum<MAX_CONF_CAP_EX_NUM;byNum++)
	{
		atCapArry[byNum].Clear();
	}
	//获得会议主能力
	tTmpStrCap = m_tConf.GetMainSimCapSet().GetVideoCap();
	tVmpOutParam.AddVmpOutMember(tTmpStrCap);//加1路264主能力
	//获得主扩展能力集
	if (!m_tConfEx.GetMainStreamCapEx(atCapArry, byCapNum))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[CheckVmpOutCap]Err,Get m_tConfEx MainStreamCapEx error.\n");
		return FALSE;
	}

	for (byNum=0; byNum<byCapNum; byNum++)
	{
		if (MEDIA_TYPE_NULL == atCapArry[byNum].GetMediaType())
		{
			break;
		}
		//获得遍历到的Idx对应的能力集
		tTmpStrCap = atCapArry[byNum];
		// 720p 30fps时特殊处理
		if( VIDEO_FORMAT_HD720 == tTmpStrCap.GetResolution() &&
			(30 == tTmpStrCap.GetUserDefFrameRate() || 25 == tTmpStrCap.GetUserDefFrameRate() )
			)
		{
			if( 30 == tTmpStrCap.GetUserDefFrameRate() )
			{
				tTmpStrCap.SetUserDefFrameRate(60);//查找60帧720的是否添加过
			}
			else
			{
				tTmpStrCap.SetUserDefFrameRate(50);//查找50帧720的是否添加过
			}
			
			u8 byChlNum = tVmpOutParam.GetVmpOutChnnlByStrCap(tTmpStrCap);
			// 列表里已添加过720p60fps
			if (0XFF != byChlNum)
			{
				//更新此通道为720p 30fps
				tVmpOutParam.UpdateVmpOutMember(byChlNum, atCapArry[byNum]);
				continue;
			}
		}
		//添加勾选能力
		if (!tVmpOutParam.AddVmpOutMember(atCapArry[byNum]))
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[CheckVmpOutCap]Err,channels of VMPOutParam is not enough.\n");
			return FALSE;
		}
	}

	// 添加辅格式能力
	if (MEDIA_TYPE_NULL != m_tConf.GetSecVideoMediaType())
	{
		//获得辅格式能力
		tTmpStrCap = m_tConf.GetSecSimCapSet().GetVideoCap();
		if (!tVmpOutParam.AddVmpOutMember(tTmpStrCap))//加1路Other能力Idx
		{
			LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[CheckVmpOutCap]Err,channels of VMPOutParam is not enough.\n");
			return FALSE;
		}
	}
	// 获得占用的最大vicp资源
	s32 nMaxVicp = 0; //MAXNUM_MPU2_VICP_RES;//MPU2支持最大vicp资源
	// BASIC资源为3,ENHACED资源为4,不打折
	if (MPU2_VMP_BASIC == bySubType)
	{
		nMaxVicp = 3000;
	}
	else if (MPU2_VMP_ENHACED == bySubType)
	{
		nMaxVicp = 4000;
	}
	s32 nUsedVicp = GetVicpResByVmpOutParam(tVmpOutParam);

	LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[CheckVmpOutCap]MPU2MaxVicp:%d\nNeedVicp:%d.\n",
		nMaxVicp, nUsedVicp);

	// 资源充足,返回
	if (nUsedVicp <= nMaxVicp)
	{
		g_cMcuVcApp.SetVMPOutParam(tVmpEqp, tVmpOutParam);
		return TRUE;
	}

	//针对BASIC,资源不够时,需将1080p60fps降为30fps再做统计
	if (MPU2_VMP_BASIC == bySubType)
	{
		u8 byFrameRate = m_tConf.GetMainSimCapSet().GetUserDefFrameRate();
		TVideoStreamCap tHD108060BPStrCap(MEDIA_TYPE_H264,VIDEO_FORMAT_HD1080,byFrameRate,emBpAttrb,m_tConf.GetBitRate());
		TVideoStreamCap tHD108030BPStrCap(MEDIA_TYPE_H264,VIDEO_FORMAT_HD1080,byFrameRate/2,emBpAttrb,m_tConf.GetBitRate());
		u8 by108060BPChlNum = tVmpOutParam.GetVmpOutChnnlByStrCap(tHD108060BPStrCap);
		u8 by108030BPChlNum = tVmpOutParam.GetVmpOutChnnlByStrCap(tHD108030BPStrCap);
		// 查找1080p30fps能力集是否存在,若存在,则只需删除108060BP能力,若不存在,则需将108060BP能力更新为108030BP能力
		if (0XFF != by108030BPChlNum)
		{
			tVmpOutParam.ClearOneVmpOutChnnl(by108060BPChlNum);//删除108060BP能力,后面能力会前移
		}
		else
		{
			TVideoStreamCap tHD108030HPStrCap(MEDIA_TYPE_H264,VIDEO_FORMAT_HD1080,byFrameRate/2,emHpAttrb,m_tConf.GetBitRate());
			u8 by108030HPChlNum = tVmpOutParam.GetVmpOutChnnlByStrCap(tHD108030HPStrCap);
			//1080P30fps BP未勾选时,1080P30fps HP一定勾选了,将1080P60fps BP更新为1080P30fps BP后需要跟1080P30fps HP通道互换位置
			//保证能力按大小顺序存储.
			tVmpOutParam.UpdateVmpOutMember(by108060BPChlNum, tHD108030HPStrCap);//将1080P30fps HP放到1080P60fps BP位置
			tVmpOutParam.UpdateVmpOutMember(by108030HPChlNum, tHD108030BPStrCap);//将1080P30fps BP放到原1080P30fps HP位置
		}

		nUsedVicp = GetVicpResByVmpOutParam(tVmpOutParam);
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[CheckVmpOutCap]MPU2BASIC MaxVicp:%d\nNeedVicp:%d.\n",
			nMaxVicp, nUsedVicp);
		// 再判资源是否足够
		if (nUsedVicp <= nMaxVicp)
		{
			g_cMcuVcApp.SetVMPOutParam(tVmpEqp, tVmpOutParam);
			return TRUE;
		}
	}
	
	LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[CheckVmpOutCap]Err,There is not enough vicp.\nMaxVicp:%d\nNeedVicp:%d.\n",
		nMaxVicp, nUsedVicp);

	return FALSE;
}

/*==============================================================================
函数名    : Prepare8kiBrdVmpOutCap
功能      : 根据模版准备8kivmp的广播后适配能力列表，8KIVMP广播与非广播编码不同
算法实现  : 8ki画面合成最大支持6路编码
			a. 1080P60fps BP
			b. 1080P30fps BP
			c. 720P30 BP
			d. 4CIF BP
			e. CIF BP
			f. Other（MPEG4 4CIF/CIF、H.263 CIF、H.261 CIF）
			单格式会议只出一路，适配会议根据会议主辅格式出多路
参数说明  :  u8 byVmpId [i]
			 BOOL32 bBrd [i]
返回值说明:  BOOL32
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2013-08-01                 杨怀志
==============================================================================*/
BOOL32 CMcuVcInst::Prepare8kiVmpOutCap(u8 byVmpId, BOOL32 bBrd)
{
	if (!IsValidVmpId(byVmpId) || VMP_8KI != GetVmpSubType(byVmpId))
	{
		return FALSE;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	
	TKDVVMPOutParam tVmpOutParam;
	TVideoStreamCap tTmpStrCap;
	//初始化后适配列表
	tVmpOutParam.Initialize();

	// 定义需要的能力
	u8 byMainFrameRate = m_tConf.GetMainSimCapSet().GetUserDefFrameRate();
	u8 byFrameRate = 0;
	// 会议主帧率为30或60时，按60帧算能力，若为其它按50帧算能力
	if (byMainFrameRate == 30 || byMainFrameRate == 60)
	{
		byFrameRate = 60;
	}
	else
	{
		byFrameRate = 50;
	}
	// 8kh不支持HP编码，非H264格式单独添加
	TVideoStreamCap t108030StrCap(MEDIA_TYPE_H264,VIDEO_FORMAT_HD1080,byFrameRate/2,emBpAttrb,m_tConf.GetBitRate());
	TVideoStreamCap t72030StrCap(MEDIA_TYPE_H264,VIDEO_FORMAT_HD720,byFrameRate/2,emBpAttrb,m_tConf.GetBitRate());
	TVideoStreamCap t4CIFStrCap(MEDIA_TYPE_H264,VIDEO_FORMAT_4CIF,25,emBpAttrb,m_tConf.GetBitRate());// 4cif与cif统一为25帧
	TVideoStreamCap tCIFStrCap(MEDIA_TYPE_H264,VIDEO_FORMAT_CIF,25,emBpAttrb,m_tConf.GetBitRate());

	// 区分单格式会议与适配会议
	TVideoStreamCap tConfMainStrCap = m_tConf.GetMainSimCapSet().GetVideoCap();
	u8 byMainRes = tConfMainStrCap.GetResolution();
	BOOL32 bIsConfExcludeDDSUseAdapt = IsConfExcludeDDSUseAdapt();//是否适配会议

	if (MEDIA_TYPE_H264 != m_tConf.GetMainVideoMediaType())
	{
		if (MEDIA_TYPE_H264 == m_tConf.GetSecVideoMediaType())
		{
			//获得会议辅格式能力
			tTmpStrCap = m_tConf.GetSecSimCapSet().GetVideoCap();
			tVmpOutParam.AddVmpOutMember(tTmpStrCap);//加1路264能力,辅格式能力只可能是4cif或cif，直接添加
		}
		// 获得会议主能力
		tTmpStrCap = tConfMainStrCap;
		tVmpOutParam.AddVmpOutMember(tTmpStrCap);//加1路Other能力
		
		if (MEDIA_TYPE_NULL != m_tConf.GetSecVideoMediaType() &&
			MEDIA_TYPE_H264 != m_tConf.GetSecVideoMediaType())
		{
			//获得会议辅格式能力,辅格式同样是非264情况
			tTmpStrCap = m_tConf.GetSecSimCapSet().GetVideoCap();
			tVmpOutParam.AddVmpOutMember(tTmpStrCap);//加1路Other能力
		}
		g_cMcuVcApp.SetVMPOutParam(tVmpEqp, tVmpOutParam);
		return TRUE;
	}
	else
	{
		// 添加1080P/i 50/60fps编码能力，会议主格式为1080P/i 50/60fpsHP/BP时才需要
		if (byMainRes == VIDEO_FORMAT_HD1080 &&
			byMainFrameRate > 30)
		{
			// 添加会议主格式能力，1080P/i 50/60fps编码
			//tVmpOutParam.AddVmpOutMember(tConfMainStrCap);
		}
		// 添加1080P/i 25/30fps能力
		if (byMainRes == VIDEO_FORMAT_HD1080)
		{
			// 新规格：8kivmp没有编1080p60fps的能力，1080对应只编码1路，根据需要出bp编码或hp编码

			// 若会议含有1080P/i 25/30fpsBP能力，则添加1080P/i 25/30fpsBP编码
			// 判断：主格式是1080P/i 25/30fpsBP 或 有勾选 1080P/i 25/30fpsBP
			if ((/*byMainFrameRate <= 30 &&*/ tConfMainStrCap.GetH264ProfileAttrb() == emBpAttrb)
				|| IsMSSupportCapEx(VIDEO_FORMAT_HD1080,byFrameRate/2,emBpAttrb))
			{
				tVmpOutParam.AddVmpOutMember(t108030StrCap);
			}
			// 若会议不含1080P/i 25/30fpsBP能力，但含1080P/i 25/30fpsHP能力，则添加1080P/i 25/30fpsHP编码
			// 判断：主格式是1080P/i 25/30fpsHP 或 有勾选 1080P/i 25/30fpsHP
			/*else if ((byMainFrameRate <= 30 && tConfMainStrCap.GetH264ProfileAttrb() == emHpAttrb)
				|| IsMSSupportCapEx(VIDEO_FORMAT_HD1080,byFrameRate/2,emHpAttrb))*/
			else if (tConfMainStrCap.GetH264ProfileAttrb() == emHpAttrb)
			{
				t108030StrCap.SetH264ProfileAttrb(emHpAttrb);
				tVmpOutParam.AddVmpOutMember(t108030StrCap);
			}
		}
		// 添加1080P/i 25/30fps能力与720P 50/60fps能力勾选互斥，不会同时存在
		// 添加720P 50/60fps能力,会议主格式为720P 50/60fpsHP/BP时才需要
		if (byMainRes == VIDEO_FORMAT_HD720 &&
			byMainFrameRate > 30)
		{
			// 添加会议主格式能力，720P 50/60fps编码
			tVmpOutParam.AddVmpOutMember(tConfMainStrCap);
		}
		// 添加720P 25/30fps能力
		if (IsVidFormatHD(byMainRes))
		{
			// 若会议含有720P 25/30fpsBP能力，则添加720P 25/30fpsBP编码
			// 判断：主格式是720P 25/30fpsBP 或 有勾选 720P 25/30fpsBP
			if ((byMainRes == VIDEO_FORMAT_HD720 && byMainFrameRate <= 30 && tConfMainStrCap.GetH264ProfileAttrb() == emBpAttrb)
				|| IsMSSupportCapEx(VIDEO_FORMAT_HD720,byFrameRate/2,emBpAttrb))
			{
				tVmpOutParam.AddVmpOutMember(t72030StrCap);
			}
			// 若会议不含720P 25/30fpsBP能力，但含720P 25/30fpsHP能力，则添加720P 25/30fpsHP编码
			// 判断：主格式是720P 25/30fpsHP 或 有勾选 720P 25/30fpsHP
			else if ((byMainRes == VIDEO_FORMAT_HD720 && byMainFrameRate <= 30 && tConfMainStrCap.GetH264ProfileAttrb() == emHpAttrb)
				|| IsMSSupportCapEx(VIDEO_FORMAT_HD720,byFrameRate/2,emHpAttrb))
			{
				t72030StrCap.SetH264ProfileAttrb(emHpAttrb);
				tVmpOutParam.AddVmpOutMember(t72030StrCap);
			}
		}
		// 添加4cif能力,主格式为4cif或有4cif勾选，添加4cif编码
		if (byMainRes == VIDEO_FORMAT_4CIF
			|| IsMSSupportCapEx(VIDEO_FORMAT_4CIF))
		{
			tVmpOutParam.AddVmpOutMember(t4CIFStrCap);
		}
		// 添加cif能力,主格式为cif或有cif勾选，添加cif编码
		if (byMainRes == VIDEO_FORMAT_CIF
			|| IsMSSupportCapEx(VIDEO_FORMAT_CIF))
		{
			tVmpOutParam.AddVmpOutMember(tCIFStrCap);
		}
		// 添加辅格式能力
		if (MEDIA_TYPE_NULL != m_tConf.GetSecVideoMediaType())
		{
			tTmpStrCap = m_tConf.GetSecSimCapSet().GetVideoCap();
			tVmpOutParam.AddVmpOutMember(tTmpStrCap);
		}
	}

	// 会议主格式为1080P/i 25/30fps或720P 50/60fps的适配会议时，若合成为非广播，停第0路编码，码率置0
	if (IsConfExcludeDDSUseAdapt() && !bBrd && MEDIA_TYPE_H264 == m_tConf.GetMainVideoMediaType())
	{
		if ((byMainRes == VIDEO_FORMAT_HD1080 && byMainFrameRate <= 30)
			|| (byMainRes == VIDEO_FORMAT_HD720 && byMainFrameRate > 30))
		{
			tVmpOutParam.GetStrCapByVmpOutChnnl(0, tTmpStrCap);
			tTmpStrCap.SetMaxBitRate(0);
			tVmpOutParam.UpdateVmpOutMember(0, tTmpStrCap);
		}
	}

	// 更新编码能力
	g_cMcuVcApp.SetVMPOutParam(tVmpEqp, tVmpOutParam);

	return TRUE;
}

/*==============================================================================
函数名    :  GetVicpResByVmpOutParam
功能      :  根据vmpoutparam获得当前vmp需要的vicp资源
算法实现  :  
参数说明  :  
返回值说明:  BOOL32
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-12-12                yanghuaizhi
==============================================================================*/
s32 CMcuVcInst::GetVicpResByVmpOutParam(const TKDVVMPOutParam &tVMPOutParam)
{
	s32 nNeedVicp = 0;
	TVideoStreamCap tCap;
	for (u8 byIdx=0; byIdx<MAXNUM_MPU2_OUTCHNNL; byIdx++)
	{
		tCap = tVMPOutParam.GetVmpOutCapIdx(byIdx);
		if (MEDIA_TYPE_H264 != tCap.GetMediaType())
		{
			break;
		}
		// 根据能力获得其占用vicp资源
		nNeedVicp += GetResourceUnitAcd2Cap(tCap);
	}

	return nNeedVicp;
}

/*==============================================================================
函数名    :  AdjustVmpHdChnlInfo
功能      :  调整前适配信息,有需要占但还未占到前适配的成员,
			 如果有空余前适配,抢占前适配,抢不到时继续等待,不发送抢占消息
算法实现  :  
参数说明  :  TVMPParam &tVmpParam [i]
			 TVmpChnnlInfo &tVmpChnlInfo [o]
返回值说明:  void
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-12-19                yanghuaizhi
==============================================================================*/
void CMcuVcInst::AdjustVmpHdChnlInfo(const TEqp &tVmpEqp)
{
	TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
	TVmpChnnlInfo tVmpChnlInfo = g_cMcuVcApp.GetVmpChnnlInfo(tVmpEqp);
	u8 byMaxHdChnlNo = tVmpChnlInfo.GetMaxNumHdChnnl();	//最大前适配数
	u8 byHdChnlNo = tVmpChnlInfo.GetHDChnnlNum();		//当前占用前适配数
	u8 byMaxStyleNo = tVmpChnlInfo.GetMaxStyleNum();	//获得当前vmp最大支持几风格下终端不降分辨率进vmp
	u8 byVmpMemberNo = tVmpParam.GetMaxMemberNum();
	if (byVmpMemberNo <= byMaxStyleNo)
	{
		LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpHdChnlInfo]Don't need to adjust, MaxStyleNo:%u,MaxVmpMemberNo:%u.\n",
			byMaxStyleNo, byVmpMemberNo);
		return;
	}
	//如果当前前适配无空闲,不做处理
	if (byHdChnlNo == byMaxHdChnlNo)
	{
		LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpHdChnlInfo]VmpHdChnlInfo is full, MaxHdChnlNo:%u,SeizedHdChnlNo:%u.\n",
			byMaxHdChnlNo, byHdChnlNo);
		return;
	}
	
	//获得tmt在vmp中所有位置
	//u8 abyChnlNo[MAXNUM_VMP_MEMBER];
	u8 byChnlNum = 0;
	TMt tSpeaker;
	TMt tLocalVmpMt;
	u8 byChnnlType = LOGCHL_VIDEO;
	TLogicalChannel tLogicChannel;
	u8 byReqRes = VIDEO_FORMAT_INVALID;
	BOOL32 bNeedAdjustRes = FALSE;
	TExInfoForResFps tExInfoForRes;// 用来获得发言人在唯一通道时的vmpid与pos
	//先考虑发言人,若有发言人,发言人在非广播的vmp中,且不在前适配中,如果发言人仅在1个通道中,将发言人加入前适配
	if (m_tConf.HasSpeaker() && TYPE_MCUPERI != GetVidBrdSrc().GetType())
	{
		tSpeaker = m_tConf.GetSpeaker();
		TMt tRealMt = tSpeaker;
		if (IsMcu(tRealMt))
		{
			tRealMt = GetSMcuViewMt(tRealMt, TRUE);
		}
		// 终端在多个通道中,不考虑进前适配
		IsMtNeedAdjustResInConfVmp(tSpeaker, tExInfoForRes, byReqRes, byChnlNum);
		LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpHdChnlInfo]Mtid:%u,AllChnlCount:%u.\n",
				tSpeaker.GetMtId(), byChnlNum);
		if (!tSpeaker.IsNull() &&
			byChnlNum > 0 &&	//发言人(包括mcu与上传终端情况)在vmp中
			tVmpChnlInfo.GetChnlCountByMt(tRealMt) == 0)
		{
			if (byChnlNum == 1 && tVmpEqp.GetEqpId() == tExInfoForRes.m_byEqpid)
			{
				tLocalVmpMt = GetLocalMtFromOtherMcuMt( tSpeaker );
				if ( m_ptMtTable->GetMtLogicChnnl( tLocalVmpMt.GetMtId(), byChnnlType, &tLogicChannel, FALSE ) )
				{
					bNeedAdjustRes = VidResAdjust(tVmpEqp.GetEqpId(), tVmpParam.GetVMPStyle(), tExInfoForRes.m_byPos, tLogicChannel.GetVideoFormat(), byReqRes);
					if (bNeedAdjustRes)
					{
						BOOL32 bRet = FALSE;
						bRet = ChangeMtVideoFormat( tSpeaker, FALSE );
						if (bRet)
						{
							LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpHdChnlInfo]put speaker in HdChnlInfo, speaker Mtid:%u.\n",
								tSpeaker.GetMtId());
						}
					}
				}
			}
		}
	}

	//更新占用前适配通道数,恢复外厂商终端
	TVMPMember tVMPMember;
	TChnnlMemberInfo tChnnlMemInfo;
	TVMPParam_25Mem tLastVmpParam;
	TVMPMember tLastVMPMember;
	for (u8 byLoop=0; byLoop<tVmpParam.GetMaxMemberNum(); byLoop++)
	{
		// 重新获得前适配信息
		tVmpChnlInfo = g_cMcuVcApp.GetVmpChnnlInfo(tVmpEqp);
		byHdChnlNo = tVmpChnlInfo.GetHDChnnlNum();
		//已无前适配
		if (byHdChnlNo >= byMaxHdChnlNo)
		{
			break;
		}
		
		tLastVmpParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
		tVMPMember = *tVmpParam.GetVmpMember( byLoop );
		tLastVMPMember = *tLastVmpParam.GetVmpMember( byLoop );
		// 新旧成员相等，表示交换已建
		if (tVMPMember == tLastVMPMember)
		{
			continue;
		}
		// 跳过空成员
		if (tVMPMember.IsNull())
		{
			continue;
		}

		// 调合成成员补建交换
		ChangeMtResFpsInVmp(tVmpEqp.GetEqpId(), tVMPMember, &tVmpParam, TRUE, tVMPMember.GetMemberType(), byLoop);

		/*TMt tRealMt = (TMt)tVMPMember;
		if (IsMcu(tRealMt))
		{
			tRealMt = GetSMcuViewMt(tRealMt, TRUE);
		}
		//是被选看终端,且不在前适配中
		if (IsSelectedbyOtherMtInMultiCas(tVMPMember) &&
			tVmpChnlInfo.GetChnlCountByMt(tRealMt) == 0)
		{
			GetChlOfMtInVmpParam(tVmpParam, tVMPMember, byChnlNum, abyChnlNo);
			LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpHdChnlInfo]Mtid:%u,ChnlCount:%u.\n",
				tVMPMember.GetMtId(), byChnlNum);
			if (byChnlNum == 1)
			{
				tLocalVmpMt = GetLocalMtFromOtherMcuMt( tVMPMember );
				if ( m_ptMtTable->GetMtLogicChnnl( tLocalVmpMt.GetMtId(), byChnnlType, &tLogicChannel, FALSE ) )
				{
					bNeedAdjustRes = VidResAdjust(tVmpEqp.GetEqpId(), tVmpParam.GetVMPStyle(), abyChnlNo[0], tLogicChannel.GetVideoFormat(), byReqRes);
					if (bNeedAdjustRes)
					{
						BOOL32 bRet = FALSE;
						bRet = ChangeMtVideoFormat( (TMt)tVMPMember, FALSE );
						if (bRet)
						{
							LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpHdChnlInfo]put selected Mt in HdChnlInfo, Mtid:%u.\n",
								tVMPMember.GetMtId());
						}
					}
				}
			}
		}*/
	}
}
/*==============================================================================
函数名    :  IsAllowVmpMemRepeated
功能      :  是否允许同一终端进多个通道,支持MPU2外设
算法实现  :  
参数说明  :  
返回值说明:  BOOL32
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-12-01                yanghuaizhi
==============================================================================*/
BOOL32 CMcuVcInst::IsAllowVmpMemRepeated(const u8 byVmpId)
{
	if (!IsValidVmpId(byVmpId))
	{
		return FALSE;
	}
	
	// 加保护,VCS会议都是自动合成,不支持终端进多通道
	if (m_tConf.GetConfSource() == VCS_CONF)
	{
		return FALSE;
	}

	u8 byVmpSubType = GetVmpSubType(byVmpId);
	// VPU不支持终端进多通道,不支持读配置文件
	if (VMP == byVmpSubType)
	{
		LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[IsAllowVmpMemRepeated]IsAllowVmpMemRepeated is false, vmp eqpid:%d, subtype:%d.\n",
			byVmpId, byVmpSubType);
		return FALSE;
	}
	/* MPU2类型vmp支持1个终端进过个通道,为支持后续新mpu,判当前所有类型以外返回TRUE
	// 除了(vpu,8kgvmp,8khvmp,mpu)这些旧vmp不支持,之后新vmp默认支持进多通道
	if (VMP != byVmpSubType && VMP_8KE != byVmpSubType 
		&& VMP_8KH != byVmpSubType && MPU_SVMP != byVmpSubType)
	{
		LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[IsAllowVmpMemRepeated]IsAllowVmpMemRepeated is true, vmp eqpid:%d, subtype:%d.\n",
			m_tVmpEqp.GetEqpId(), byVmpSubType);
		return TRUE;
	}*/

	// 新策略,vmp不再读配置,vpu以外合成器都支持终端进多通道
	return TRUE;//g_cMcuVcApp.IsAllowVmpMemRepeated();
}

/*==============================================================================
函数名    :  ChgMtVidFormatRequired
功能      :  是否有必要changeMtVideoFormat
算法实现  :  
参数说明  :  
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2009-10-28                   薛亮
==============================================================================*/
BOOL32 CMcuVcInst::ChgMtVidFormatRequired(TMt tMt, BOOL32 bNeglectVmpSubType /* =FALSE */)
{
	BOOL32 bRet = FALSE;

	// 在不改变外设通道成员情况下判断终端是否有调分辨率的必要
	// 目前仅vmp前适配影响到终端分辨率
	// 终端只有仅在vmp的1个通道时，有可能需要占用前适配，才需要调整分辨率，不在vmp中或在多通道都无需调整vmp分辨率
	TExInfoForResFps tExInfoForRes;
	u8 byVmpChlRes;
	u8 byChlCount;
	BOOL32 bIsNeedAdjust = IsMtNeedAdjustResInConfVmp(tMt, tExInfoForRes, byVmpChlRes, byChlCount);
	if (bIsNeedAdjust && 1 == byChlCount)
	{
		// 获得终端所在vmp
		TEqp tVmpEqp = g_cMcuVcApp.GetEqp( tExInfoForRes.m_byEqpid );
		TVmpChnnlInfo tVmpChnnlInfo = g_cMcuVcApp.GetVmpChnnlInfo(tVmpEqp);
		if(0 == tVmpChnnlInfo.GetMaxStyleNum())//所有风格都要降分辨率的合成器如8ke/vpu,依赖bNeglectVmpSubType
		{
			bRet = bNeglectVmpSubType;
		}
		else
		{
			bRet = TRUE;
		}
		
		// 切换发言人时,m_tLastSpeaker与新Speaker不统一,两者一致时表示不是改变发言人处理,跳过下面处理
		// 针对切发言人时调整旧发言人分辨率，加判传参bNeglectVmpSubType为TRUE才处理，只有切发言人时调旧发言人分辨率才会传TRUE
		if(bNeglectVmpSubType && m_tLastSpeaker == tMt && !(m_tLastSpeaker == m_tConf.GetSpeaker()))
		{
			u8 byVmpSpeakerCount = GetVmpChnnlNumBySpecMemberType(VMP_MEMBERTYPE_SPEAKER);//发言人跟随通道数
			if (byVmpSpeakerCount > 0)
			{
				//该情况会重新ChangeVMPParam, 之后全体来一次分辨率调整，所以这里就不进行单独调整了
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "no need to change format for old Speaker Mt.%, because the channel it occupied is【VMP_MEMBERTYPE_SPEAKER】.\n", tMt.GetMtId());
				bRet = FALSE;
			}
		}
	}

	return bRet;
}
/*====================================================================
    函数名      ：ChangeMtVideoFormat
    功能        ：H264会议画面合成，分辨率的调整
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt&              tMt: 要调整的终端
                  TVMPParam* ptVMPParam: 调整后的分辨率
				  BOOL32         bStart: 调整或恢复
				  u8       byMemberType: 要调整通道类型,用于双流跟随通道调整
				  u8			  byPos: 对指定通道调分辨率,通道无效时对其所在第一个通道调分辨率
    返回值说明  ：void
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	09/04/29    4.0         付秀华        创建
	09/11/20	4.6			薛亮		  增加参数
	11/01/21	4.6			xl			  调整mpu分辨率和帧率实现，参数调整
====================================================================*/
BOOL32 CMcuVcInst::ChangeMtVideoFormat( TMt tMt, 
									 BOOL32 bConsiderVmpBrd /* = TRUE */,
									 BOOL32 bNonKeda /* = FALSE ,*/,
									 BOOL32 bSeizePromt /*= FALSE*/)
{
	// 要调整的终端不为空
	if (tMt.IsNull())
	{
		return FALSE;
	}
	// 终端调整分辨率，外设成员不变时使用
	BOOL32 bRet = TRUE;
	TExInfoForResFps tExInfoForResFps;
	tExInfoForResFps.m_bConsiderVmpBrd = bConsiderVmpBrd;
	tExInfoForResFps.m_bSeizePromt = bSeizePromt;
	BOOL32 bIsNeedAjsRes = IsNeedAdjustMtVidFormat(tMt, tExInfoForResFps);
	u8 byNewRes = tExInfoForResFps.m_byNewFormat;	//获得要调整到的分辨率
	BOOL32 bResultSeizePromt = tExInfoForResFps.m_bResultSeizePromt; //获得是否有抢占
	BOOL32 bStart = tExInfoForResFps.m_bResultStart; //获得给下级发送调整还是恢复分辨率	// 有抢占，则不做后续处理,此函数不做抢占处理，此返回值不会为TRUE
	// 有抢占提示
	if (bResultSeizePromt)
	{
		u8 byVmpId = tExInfoForResFps.m_byEqpid;
		if (IsValidVmpId(byVmpId))
		{
			// 若要调整的是发言人，则弹的抢占框不能取消，保证发言人优先权限
			u8 byForceSeize = (tMt == m_tConf.GetSpeaker());
			// 发送抢占消息,选看时,终端已在vmp中,无需记录抢占终端位置
			SendVmpPriSeizeReq(byVmpId, tMt, byForceSeize);
			TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );//记录要抢占的合成器
			TVmpPriSeizeInfo tPriSeiInfo = g_cMcuVcApp.GetVmpPriSeizeInfo(tVmpEqp);
			//记录抢占回来的后续操作
			if(tPriSeiInfo.m_tPriSeizeMember.IsNull())
			{
				tPriSeiInfo.m_tPriSeizeMember.SetMt(tMt);
				g_cMcuVcApp.SetVmpPriSeizeInfo(tVmpEqp, tPriSeiInfo);
			}
			return FALSE;
		}
	}
	if (bIsNeedAjsRes)
	{
		ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_VMP,"[ChangeMtVideoFormat]tMt(%d,%d) bStart:%d NewRes:%d!\n", 
			tMt.GetMcuId(), tMt.GetMtId(), bStart, byNewRes);
		// 发送调分辨率消息
		ChangeVFormat(tMt, bStart, byNewRes);
	}

	BOOL32 bIsNeedAjsFps = IsNeedAdjustMtVidFps(tMt, tExInfoForResFps);
	BOOL32 bSetVmpChlFps = tExInfoForResFps.m_bResultSetVmpChl; //获得是否Setvmpchnl
	u8 byNewFps = tExInfoForResFps.m_byNewFps;
	if (bIsNeedAjsFps)
	{
		// 发送调帧率消息
		SendChgMtFps(tMt, LOGCHL_VIDEO, byNewFps, bStart);
	}

/*
	u8 byVmpSubType = GetVmpSubType(byVmpId);
	BOOL32 bRet = TRUE;
	if(byVmpSubType == VMP)
	{
		bRet = ChgMtFormatInSdVmp(tMt, ptVMPParam, bStart, byMemberType);
	}
	else
	{
		TExInfoForInVmpRes tExInfoForInVmpRes;
		tExInfoForInVmpRes.m_bConsiderVmpBrd = bConsiderVmpBrd;
		tExInfoForInVmpRes.m_bNonKeda = bNonKeda;
		tExInfoForInVmpRes.m_byMemberType = byMemberType;
		tExInfoForInVmpRes.m_byPos = byPos;
		tExInfoForInVmpRes.m_byVmpId = byVmpId;
		u8 byNewFormat = 0;
		bRet = ChgMtFormatInMpu(tMt, ptVMPParam, bStart, tExInfoForInVmpRes, byNewFormat);
		// 双流源不调帧率
		if (VMP_MEMBERTYPE_DSTREAM == byMemberType)
		{
			ConfPrint(LOG_LVL_DETAIL,MID_MCU_VMP,"[ChangeMtVideoFormat]DoubleStream channel donot change Fps in vmp!\n");
		}
		else
		{
			bRet &= ChgMtFpsInVmp(byVmpId, tMt, bStart, byNewFormat);
		}
	}*/

	return bRet;
}


/*=============================================================================
函 数 名： IsRecordSrcBas
功    能： 获取会议录像真正的源，判断是否是适配器
算法实现： 缺省认为会议录像永远录主格式，通过比较广播源的能力集及录像的参数计算
全局变量： 
参    数： u8 byType        [In]  MODE_VIDEO, MODE_AUDIO
           TMt &tRetRecSrc  [Out]
           //u8  &byBasType   [Out] ADAPT_TYPE_VID, ADAPT_TYPE_BR 等/
           [IN/OUT]u8&   byRecChnlIdx:录像机实际接收通道 

返 回 值： BOOL32 是否从Bas录像
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
07/06/12    4.0         顾振华         重写
09/07/13    4.0         付秀华         兼容HD bas
=============================================================================*/
BOOL32 CMcuVcInst::IsRecordSrcBas(  u8 byType, TMt &tRecSrc, u8 &byChnId, u8 &byRecInIdx)
{
	TBasOutInfo tOutInfo;
	if ( g_cMcuVcApp.IsBrdstVMP(m_tVmpEqp) && byType == MODE_VIDEO)
    {
        //[nizhijun 2012/06/29]画面合成广播时不需要过BAS，对于适配录像，根据适配录像找合适的那一出
		//mpu存在某一出不出的情况，故可能导致发言人和VMP广播切换时，适配录像会发生切文件情况
		tRecSrc = m_tVmpEqp;
		if ( IsRecNeedAdapt(byType) )
		{
			TVideoStreamCap tTempVidCap;
			m_cRecAdaptMgr.GetRecVideoCapSet(byType,tTempVidCap);

			if( tTempVidCap.GetMediaType() == MEDIA_TYPE_MP4 )
			{
				if(m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_MP4 && 
					m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_AUTO )
				{
					tTempVidCap.SetResolution( VIDEO_FORMAT_AUTO );
				}
				else if( m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_MP4 &&
					m_tConf.GetSecVideoFormat() == VIDEO_FORMAT_AUTO )
				{
					tTempVidCap.SetResolution( VIDEO_FORMAT_AUTO );
				}
			}
			
			byRecInIdx = GetVmpOutChnnlByRes(m_tVmpEqp.GetEqpId(), 
				tTempVidCap.GetResolution(),
				tTempVidCap.GetMediaType(),
				tTempVidCap.GetUserDefFrameRate(),
				tTempVidCap.GetH264ProfileAttrb()
				);
			ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_REC,"[IsRecordSrcBas]vmp byRecInIdx:%d\n",byRecInIdx);
		}
		else
		{
			TVideoStreamCap tStrCap;
			//8ki适配录像走广播适配，所以IsRecNeedAdapt函数返回false，所以要再用GetRecVideoCapSet再确认一次
			if ( m_cRecAdaptMgr.GetRecVideoCapSet(MODE_VIDEO,tStrCap) )
			{
				
			}
			else 
			{
				tStrCap = m_tConf.GetMainSimCapSet().GetVideoCap();
			
			}
			byRecInIdx = GetVmpOutChnnlByRes(m_tVmpEqp.GetEqpId(), 
							tStrCap.GetResolution(), 
							tStrCap.GetMediaType(),
							tStrCap.GetUserDefFrameRate(),
							tStrCap.GetH264ProfileAttrb());
		}
        return FALSE;
    }
    if ( m_tConf.m_tStatus.IsMixing() && byType == MODE_AUDIO)
    {
        //在混音不需要
        tRecSrc = m_tMixEqp;
		byRecInIdx = GetMixerNModeChn();
		if ( IsRecNeedAdapt(MODE_AUDIO) )
		{
			TAudioTypeDesc tTempDstAudDesc;
			m_cRecAdaptMgr.GetRecAudCapSet(tTempDstAudDesc);
			byRecInIdx =  byRecInIdx + m_tConfEx.GetPosInConfByAudioCap(tTempDstAudDesc);
		}
        return FALSE;
    }

    if (byType == MODE_SECVIDEO&&!IsRecNeedAdapt(MODE_SECVIDEO))
    {
        //双流不需要
		byRecInIdx = 0;
        tRecSrc = m_tDoubleStreamSrc;
        return FALSE;
    }
	
	//主流和双流适配录像
	if ( ( MODE_VIDEO == byType && IsRecAdaptUseBas() ) ||
		 ( MODE_SECVIDEO == byType&&IsRecNeedAdapt(MODE_SECVIDEO) )
	   )
	{
		TRecBasChn tRecBasChn;
		u8 byFrontOutNum = 0;
		u8 byOutIdx = 0;
		if (  m_cRecAdaptMgr.IsExistRecBasChn(byType,tRecBasChn) )
		{
			TVideoStreamCap tTempVidCap;
			m_cRecAdaptMgr.GetRecVideoCapSet( byType, tTempVidCap );
			
			if ( !FindBasOutIdxByVidCapSet(tRecBasChn.m_tBas, tRecBasChn.m_byChnId, byType, tTempVidCap, byOutIdx, byFrontOutNum) )
			{
				ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[IsRecordSrcBas]FindBasOutIdxBySimCapSet byType:%d for rec failed\n",byType);
				return FALSE;
			}
			tRecSrc = tRecBasChn.m_tBas;
			byChnId = tRecBasChn.m_byChnId;
			byRecInIdx   = byFrontOutNum + byOutIdx;
			return TRUE;
		}
		return FALSE;
	}

	if (byType == MODE_VIDEO)
	{
		tRecSrc = GetVidBrdSrc();
	}
	else if (byType == MODE_AUDIO)
	{
		tRecSrc = GetAudBrdSrc();
	}
	
    if (!m_tConf.GetConfAttrb().IsUseAdapter())
    {
		// [pengjie 2010/9/20] 这里需要取非local的广播源
		return FALSE;
    }
	
	TSimCapSet tConfMainSCS = m_tConf.GetCapSupport().GetMainSimCapSet();
	TSimCapSet tSrcMtSCS;
	TAudioTypeDesc tSrcAudDesc;
	
	// 终端
    if (tRecSrc.GetType() == TYPE_MT)
    {
		TMt tLocalMt;
		tLocalMt = GetLocalMtFromOtherMcuMt( tRecSrc );
		tSrcMtSCS = m_ptMtTable->GetSrcSCS(tLocalMt.GetMtId());

		if ( byType == MODE_AUDIO )
		{
			TLogicalChannel tAudLogicChn;
			if ( !m_ptMtTable->GetMtLogicChnnl( tLocalMt.GetMtId(), LOGCHL_AUDIO, &tAudLogicChn,FALSE) )
			{
				ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[IsRecordSrcBas]GetMtLogicChnnl for mt:%d failed\n",tLocalMt.GetMtId() );
				return FALSE;
			}
			tSrcAudDesc.SetAudioMediaType( tAudLogicChn.GetChannelType() );
			tSrcAudDesc.SetAudioTrackNum( tAudLogicChn.GetAudioTrackNum() );
		}

		byRecInIdx = 0;
    }
    else
    {
        // 放像器(放像器直接默认主格式、主码率)
        tSrcMtSCS.SetAudioMediaType( tConfMainSCS.GetAudioMediaType() );
        tSrcMtSCS.SetVideoMediaType( tConfMainSCS.GetVideoMediaType() );
        tSrcMtSCS.SetVideoResolution( tConfMainSCS.GetVideoResolution() );
		
		tSrcAudDesc.SetAudioMediaType( m_tPlayEqpAttrib.GetAudioType() );
		tSrcAudDesc.SetAudioTrackNum( m_tPlayEqpAttrib.GetAudTrackNum() );

		byRecInIdx = m_byPlayChnnl;
    }  
	
	TEqp tBas;
	tBas.SetNull();
	byChnId  = 0;
	switch (byType)
	{
	case MODE_AUDIO:
		{
			if ( IsRecNeedAdapt( MODE_AUDIO) ) //音频适配录像也走广播
			{
				TAudioTypeDesc tTempDstAudDesc;
				m_cRecAdaptMgr.GetRecAudCapSet(tTempDstAudDesc);
				if (  tTempDstAudDesc.GetAudioMediaType() != MEDIA_TYPE_NULL &&
					tSrcAudDesc.GetAudioMediaType() != MEDIA_TYPE_NULL
					)
				{
					if (  tTempDstAudDesc.GetAudioMediaType() == tSrcAudDesc.GetAudioMediaType() &&
						tTempDstAudDesc.GetAudioTrackNum() == tSrcAudDesc.GetAudioTrackNum()
						)
					{
						tRecSrc = GetAudBrdSrc();
						return FALSE;
					}
					else
					{
						
						if ( FindBasChnForAudBrd(tTempDstAudDesc,tOutInfo) )
						{
							tRecSrc = tOutInfo.m_tBasEqp;
							tRecSrc.SetConfIdx(m_byConfIdx);
							byChnId = tOutInfo.m_byChnId;
							byRecInIdx = tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx;
							return TRUE;
						}
					}
				}				
				return FALSE;
			}
			else
			{
				TAudioTypeDesc tMainAudCap = m_tConfEx.GetMainAudioTypeDesc();			
				if ( tMainAudCap.GetAudioMediaType() != MEDIA_TYPE_NULL &&
					tSrcAudDesc.GetAudioMediaType()  != MEDIA_TYPE_NULL &&
					( 	tMainAudCap.GetAudioMediaType() != tSrcAudDesc.GetAudioMediaType()
					|| tMainAudCap.GetAudioTrackNum() != tSrcAudDesc.GetAudioTrackNum()
					)
					)
				{
					
					if ( FindBasChnForAudBrd(tMainAudCap,tOutInfo) )
					{
						tRecSrc = tOutInfo.m_tBasEqp;
						tRecSrc.SetConfIdx(m_byConfIdx);
						byChnId = tOutInfo.m_byChnId;
						byRecInIdx = tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx;
						return TRUE;
					}
				}
				else
				{
					ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[IsRecordSrcBas]FindBasChnByCapForBrd byType:%d for rec failed\n",byType);
					return FALSE;
				}
			}
		}
		break;
	case MODE_VIDEO:
		{
			TVideoStreamCap  tTempSimCapSet;
			

			//自定义适配录像不会走到此处，已经在上面逻辑中return
			if ( m_cRecAdaptMgr.GetRecVideoCapSet(MODE_VIDEO,tTempSimCapSet) )
			{
				if( FindBasChnByCapForVidBrd(tTempSimCapSet,byType,tOutInfo,TRUE) )
				{
					tRecSrc = tOutInfo.m_tBasEqp;
					tRecSrc.SetConfIdx(m_byConfIdx);
					byChnId = tOutInfo.m_byChnId;
					byRecInIdx = tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx;
					return TRUE;
				}
			}
			else if (tConfMainSCS.GetVideoMediaType() != tSrcMtSCS.GetVideoMediaType() ||
				//低速录像需要判断当前发言人的码率高于会议第二码率，否则导致从适配器建交换到终端，而没有源到适配器的交换
				( m_tRecPara.IsRecLowStream() && m_tConf.GetSecBitRate() < tSrcMtSCS.GetVideoMaxBitRate() )
			   )
			{			
				 if ( GetProximalGrp(tTempSimCapSet) &&
					FindBasChnByCapForVidBrd(tTempSimCapSet,byType,tOutInfo,TRUE) 
				   )
				{
					tRecSrc = tOutInfo.m_tBasEqp;
					tRecSrc.SetConfIdx(m_byConfIdx);
					byChnId = tOutInfo.m_byChnId;
					byRecInIdx = tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx;
					return TRUE;
				}
				else
				{
					ConfPrint(LOG_LVL_ERROR,MID_MCU_REC,"[IsRecordSrcBas]FindBasChnByCapForBrd byType:%d for rec failed\n",byType);
					return FALSE;
				}
			}
			else
			{
				return FALSE;
			}
		}
	case MODE_SECVIDEO:
		{
			TVideoStreamCap  tTempSecVidCap;
			
			if ( m_cRecAdaptMgr.GetRecVideoCapSet(MODE_SECVIDEO,tTempSecVidCap) )
			{
				if( FindBasChnByCapForVidBrd(tTempSecVidCap,MODE_SECVIDEO, tOutInfo,TRUE) )
				{
					tRecSrc = tOutInfo.m_tBasEqp;
					tRecSrc.SetConfIdx(m_byConfIdx);
					byChnId = tOutInfo.m_byChnId;
					byRecInIdx = tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx;
					return TRUE;
				}
			}			
		}
		break;

	default:
		break;
	}
	return FALSE;
}

/*=============================================================================
函 数 名： IsRecordSrcHDBas
功    能： 
算法实现： 
全局变量： 
参    数： void
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
2008/8/27   4.0		    周广程                  创建
=============================================================================*/
// BOOL32 CMcuVcInst::IsRecordSrcHDBas( void )
// {
//     BOOL32 bNeedBas = FALSE;
//     TSimCapSet tConfMainSCS = m_tConf.GetCapSupport().GetMainSimCapSet();    
//     TSimCapSet tSrcMtSCS;
//     TMt tRecSrc;
// 
// #define END_RET_VALUE( bVal ) \
//     {   \
//         bNeedBas = bVal; \
//         goto lbl_EndIsRecordSrcBas;    \
//     }
// 
//     if ( !IsHDConf(m_tConf) )
//     {
//         // 非高清会议不需要
//         END_RET_VALUE(FALSE);
//     }
// 
//     if ( m_tConf.m_tStatus.IsBrdstVMP() )
//     {
//         // 画面合成广播不需要
//         END_RET_VALUE(FALSE);
//     }
// 
//     if ( !m_tConf.GetConfAttrb().IsUseAdapter() )
//     {
//         //没有启用适配（单速单格式）不需要
//         END_RET_VALUE(FALSE);
//     }
//     
//     // 默认是会议视频广播源（可能是终端或者会议放像）
//     tRecSrc = GetLocalVidBrdSrc();
//     
//     if ( tRecSrc.GetType() == TYPE_MT )
//     {
//         // 终端
//         tSrcMtSCS = m_ptMtTable->GetSrcSCS(tRecSrc.GetMtId());
//     }
//     else
//     {
//         // 放像器(放像器直接默认主格式、主码率)
//         tSrcMtSCS.SetAudioMediaType( tConfMainSCS.GetAudioMediaType() );
//         tSrcMtSCS.SetVideoMediaType( tConfMainSCS.GetVideoMediaType() );
//         tSrcMtSCS.SetVideoResolution( tConfMainSCS.GetVideoResolution() );
//     }   
// 
//     // 单速
//     if (m_tConf.GetSecBitRate() == 0)
//     {
//         END_RET_VALUE(FALSE);                     
//     }
//     
//     // 双速单格式
//     if (MEDIA_TYPE_NULL == m_tConf.GetSecVideoMediaType()) 
//     {
//         if ( !m_tRecPara.IsRecLowStream() )
//         {
//             END_RET_VALUE(FALSE);
//         }
// 		// 如果源的发送码率等于会议第二速率，则不需要适配
// 		else if ( tRecSrc.GetType() == TYPE_MT && m_ptMtTable->GetMtSndBitrate(tRecSrc.GetMtId()) == m_tConf.GetSecBitRate() )
// 		{
// 			END_RET_VALUE(FALSE);
// 		}
//         else
//         {
//             END_RET_VALUE(TRUE);
//         }
//     }
// 
//     // 双速双格式
//     // FIXME：目前高清会议不支持存在非H264双格式的会议, zgc, 2008-08-27
// 
// 
// lbl_EndIsRecordSrcBas:
// 
//     return bNeedBas;
// 
// #undef END_RET_VALUE
// }

/*=============================================================================
    函 数 名： IsDSSrcH263p
    功    能： 双流源是否为H263p
    算法实现： 
    全局变量： 
    参    数： void
    返 回 值： 
    ----------------------------------------------------------------------
    修改记录    ：
    日  期		版本		修改人		走读人    修改内容
    2008/12/12  4.5		    张宝卿                  创建
=============================================================================*/
BOOL32 CMcuVcInst::IsDSSrcH263p(void)
{
    TDStreamCap tDSrcCap;
    GetDSBrdSrcSim(tDSrcCap);
    return tDSrcCap.GetMediaType() == MEDIA_TYPE_H263PLUS ? TRUE : FALSE;
}
/*====================================================================
    函数名      ：ShowConfEqp
    功能        ：打印会议外设
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    04/03/11    3.0         胡昌威          创建
====================================================================*/
void CMcuVcInst::ShowConfEqp(void)
{
    //多画面电视墙
    if (CONF_VMPTWMODE_NONE != m_tConf.m_tStatus.GetVmpTwMode())
    {
        StaticLog("  VMPTW: VmpTw eqp id %d\n", m_tVmpTwEqp.GetEqpId());
    }

    //混音
    if (m_tConf.m_tStatus.IsMixing() || m_tConf.m_tStatus.IsVACing())
    {
        StaticLog( "  MIXER: Mixer eqp id %d, Mixer group id %d, MixMode %d \n",
                m_tMixEqp.GetEqpId(), m_byMixGrpId, m_tConf.m_tStatus.GetMixerMode());
        
        // guzh [6/8/2007]         
        if ( m_tConf.m_tStatus.IsSpecMixing() )
        {
            StaticLog("  MIXER: Specified Mix Member List: \n");
            for (u8 byLoop = 0; byLoop < MAXNUM_MIXER_CHNNL+1; byLoop ++)
            {
                if ( m_abyMixMtId[byLoop] != 0)
                {
                    StaticLog( "\t\tIndex.%d Mt.%d\n",
                                            byLoop, m_abyMixMtId[byLoop]);
                }
            }
        }
    }

    //录像
    if (!m_tConf.m_tStatus.IsNoRecording())
    {
        StaticLog("  REC:   Recorder eqp id %d, recorder channel %d \n  REC:   Recorder param:\n",
                m_tRecEqp.GetEqpId(), m_byRecChnnl);
        m_tRecPara.Print();
    }

    //放像
    if (!m_tConf.m_tStatus.IsNoPlaying())
    {
        StaticLog("  REC:   Player eqp id %d, player channel %d \n  REC:   Player Attrib:\n",
                m_tPlayEqp.GetEqpId(), m_byPlayChnnl);
        m_tPlayEqpAttrib.Print();
    }

	PrintVrsInfo();

    //音频适配
//     if (m_tConf.m_tStatus.IsAudAdapting())
//     {
//         StaticLog("  BAS:   Audio adapter eqp id %d, Audio adapter channel %d \n",
//                 m_tAudBasEqp.GetEqpId(), m_byAudBasChnnl);
//     }
// 
//     //视频适配
//     if (m_tConf.m_tStatus.IsVidAdapting())
//     {
//         StaticLog("  BAS:   Video adapter eqp id %d, Video adapter channel %d, bitrate %d \n",
//                 m_tVidBasEqp.GetEqpId(), m_byVidBasChnnl, m_wVidBasBitrate);
//     }
// 
//     //码率适配
//     if (m_tConf.m_tStatus.IsBrAdapting())
//     {
//         StaticLog("  BAS:   BitRate adapter eqp id %d, BitRate adapter channel %d, bitrate %d \n",
//                 m_tBrBasEqp.GetEqpId(), m_byBrBasChnnl, m_wBasBitrate);
//     }
// 
//     //级联音频适配
//     if (m_tConf.m_tStatus.IsCasdAudAdapting())
//     {
//         StaticLog("  BAS:   Cascade Audio adapter eqp id %d, Audio adapter channel %d\n",
//             m_tCasdAudBasEqp.GetEqpId(), m_byCasdAudBasChnnl);
//     }
//     
//     //级联视频适配
//     if (m_tConf.m_tStatus.IsCasdVidAdapting())
//     {
//         StaticLog("  BAS:   Cascade Video adapter eqp id %d, Video adapter channel %d\n",
//             m_tCasdVidBasEqp.GetEqpId(), m_byCasdVidBasChnnl);
//     }

    //丢包重传
//     if( m_tConf.m_tStatus.IsPrsing())
//     {
//         StaticLog("  PRS:   Prs eqp id %d, VidChnnl %d, VidChnnl2 %d, AudChnnl %d, AudBasChnnl %d, VidBasChnnl %d, BrBasChnnl %d \n",
//                 m_tPrsEqp.GetEqpId(), m_byPrsChnnl, m_byPrsChnnl2, m_byPrsChnnlAud, 
//                 m_byPrsChnnlAudBas, m_byPrsChnnlVidBas, m_byPrsChnnlBrBas);
//     }

    if ( m_tConf.GetConfAttrb().GetDataMode() != CONF_DATAMODE_VAONLY )
    {
        StaticLog("  DCS:   DcsIdx.%d, DataConfOnGoing.%d, DataConfReCreated.%d\n",
                m_byDcsIdx, m_tConfInStatus.IsDataConfOngoing(), m_tConfInStatus.IsDataConfRecreated());        
    }
	
    //画面合成
	u8 byVmpId;
	TEqp tVmpEqp;
	TVMPParam_25Mem tVMPParam;
	TKDVVMPOutParam tVMPOutParam;
	StaticLog("BRD-VMP:   eqp id %d\n", m_tVmpEqp.GetEqpId()); 
	StaticLog("MODULE-VMP:   eqp id %d\n", m_tModuleVmpEqp.GetEqpId()); 
	for (u8 byIdx=0; byIdx<MAXNUM_CONF_VMP; byIdx++)
	{
		if (!IsValidVmpId(m_abyVmpEqpId[byIdx]))
		{
			continue;
		}
		byVmpId = m_abyVmpEqpId[byIdx];
		tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
		
		StaticLog("\n  VMP:   Vmp eqp id %d\n", byVmpId); 
		tVMPParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
		//if (tVMPParam.GetVMPMode() != CONF_VMPMODE_NONE )
		{
			StaticLog("        tConfVmpParam:");  
			tVMPParam.Print(LOG_LVL_KEYSTATUS);
		}  

		if (CONF_VMPMODE_NONE != tVMPParam.GetVMPMode())
		{ 
			u8 byVmpSubType = GetVmpSubType(tVmpEqp.GetEqpId());
			tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
			// MPU2时,有后适配通道列表,打印后适配通道列表
			if (VMP != byVmpSubType && MPU_SVMP != byVmpSubType
				&& VMP_8KE != byVmpSubType && VMP_8KH != byVmpSubType)
			{
				StaticLog("  VMPOutParam:\n"); 
				tVMPOutParam.print();
			}
			else if (VMP != byVmpSubType)
			{
				u8 byMediaType = VIDEO_FORMAT_H264;
				u8 byRes = VIDEO_FORMAT_INVALID;
				u8 byFrameRate = 0;
				u8 byAttrb = emBpAttrb;
				u16 byBitrate = 0;
				StaticLog("  VMPOutParam:\n"); 
				for (u8 byChnnl=0; byChnnl<MAXNUM_MPU_OUTCHNNL; byChnnl++)
				{
					byRes = GetResByVmpOutChnnl(byVmpId, byMediaType, byFrameRate, byAttrb, byChnnl);
					byBitrate = GetVMPOutChlBitrate(tVmpEqp, byChnnl);
					StaticLog("ChnlIdx:%d, MediaType:%d, Res:%d, BitRate:%d\n", byChnnl, byMediaType, byRes, byBitrate); 
				}
			}
			/*StaticLog("\n        VmpPollParam:"); 
			m_tVmpPollParam.GetVmpPollInfo().Print();
			if ( m_tVmpPollParam.GetPollState() != POLL_STATE_NONE )
			{
				m_tVmpPollParam.Print();
			}*/
		}
		
		tVMPParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
		if (tVMPParam.GetVMPMode() != CONF_VMPMODE_NONE )
		{
			StaticLog("        tLastVmpParam:");  
			tVMPParam.Print(LOG_LVL_KEYSTATUS);
		}   
	}
    if (m_tLastVmpTwParam.GetVMPMode() != CONF_VMPMODE_NONE )
    {
        StaticLog("        m_tLastVmpTwParam:\n");  
        m_tLastVmpTwParam.Print();
    }      
}

/*====================================================================
    函数名      ：SwitchDiscuss2SpecMix
    功能        ：自动把会议讨论(或者VAC)切换成定制混音(或者停止VAC)
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/01/31    4.0         顾振华          创建
    10/07/08    4.0         田志勇          修改
====================================================================*/
void CMcuVcInst::SwitchDiscuss2SpecMix()
{
    if ( !m_tConfInStatus.IsSwitchDiscuss2Mix() )
    {
        // Step.1 先停止智能混音
        if ( !m_tConf.m_tStatus.IsMixing() )
        {
            return;
        }
         
        if ( m_tConf.m_tStatus.IsAutoMixing() && !m_tConf.IsDiscussAutoStop())
        {
            // 标记需要自动切换
            m_tConfInStatus.SetSwitchDiscuss2Mix(TRUE);
			// guzh [11/7/2007] 即使有VAC也只能被停止
			StopMixing();
        } 
    }
    else
    {
		// miaoqingsong [05/12/2011] 倘若当前混音器状态不为READY,不允许切换为定制混音
		if( m_tConf.GetConfSource() == MCS_CONF )
		{
			TPeriEqpStatus tPeriEqpStatus;
			if (g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus)
				&& tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState != TMixerGrpStatus::READY)
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[SwitchDiscuss2SpecMix]MIXER(%d) STATUS(%d) is not READY,So Return!\n",
					m_tMixEqp.GetEqpId(), tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState);
				return;
			}
		}

        // Step.2 切换到定制混音,自动选择前 n 个终端
        m_tConfInStatus.SetSwitchDiscuss2Mix(FALSE);
        
        // 增加终端

        u8 byCount = 0;
        u16 wError = 0;
        u8 byMaxCount = 0;
#ifdef _MINIMCU_
        byMaxCount = CMcuPfmLmt::GetMaxOprMixNum( m_tConf, wError );
#else
        byMaxCount = GetMaxMixNum(m_tMixEqp.GetEqpId());
#endif
        if (byMaxCount == 0)
        {
            NotifyMcsAlarmInfo(0, wError);
            return;
        }

		for ( u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId ++ )
		{
			//增加终端后向发送音频逻辑通道是否打开的判断，如果没有打开根本没必要进混音器
			if ( !m_tConfAllMtInfo.MtJoinedConf(byMtId) || !m_ptMtTable->IsLogicChnnlOpen(byMtId, LOGCHL_AUDIO, FALSE))
				continue;
			if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
			{
				// 过滤vrs新录播
				continue;
			}
			m_ptMtTable->SetMtInMixing( byMtId,TRUE ,FALSE);
			byCount ++ ;

			if ( byCount >= byMaxCount )
				break;
		}
		u8 byMixerId = m_tMixEqp.GetEqpId();
		m_tMixEqp.SetNull();
		if( !StartMixing(mcuPartMix,byMixerId) )
		{
			//20100708_tzy 开启原来混音器失败，将之前加入混音器的终端剔除出混音器
			for ( u8 byLoop = 1; byLoop <= MAXNUM_CONF_MT; byLoop ++ )
			{
				if ( !m_tConfAllMtInfo.MtJoinedConf(byLoop) )
					continue;
				m_ptMtTable->SetMtInMixing( byLoop,FALSE ,FALSE);
				byCount ++ ;

				if ( byCount >= byMaxCount )
					break;
			}
			m_byLastMixMode = mcuPartMix;
		}
    }     
}

/*====================================================================
    函数名      ：GetMaxMixerDepth
    功能        ：获取混音器的最大混音深度
    算法实现    ：
    引用全局变量：
    输入参数说明：无
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/01/31    4.0         顾振华          创建
====================================================================*/
u8 CMcuVcInst::GetMaxMixerDepth( u8 byMixerId ) const
{
#ifdef _MINIMCU_
    if ( MEDIA_TYPE_G729 == m_tConf.GetMainAudioMediaType() )
        return MAXNUM_MIXER_DEPTH_8000B_G729;
    else
        return MAXNUM_MIXER_DEPTH_8000B;
#else
	u8 byMixerSubtype = UNKONW_MIXER;
	g_cMcuAgent.GetMixerSubTypeByEqpId(byMixerId,byMixerSubtype);
	if (byMixerSubtype == APU2_MIXER || byMixerSubtype == MIXER_8KI)
	{
		return MAXNUM_MIXER_APU2_DEPTH;
	}
    return MAXNUM_MIXER_DEPTH;
#endif
}

/*====================================================================
    函数名      ：ChgMtFormatInSdVmp
    功能        ：H264会议画面合成，分辨率的调整
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtId    : 要调整的终端ID
                  u8 byNewFormt: 调整后的分辨率
    返回值说明  ：void
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/05    4.0         张宝卿          创建
	09/04/29    4.0         付秀华          支持调整下级MCU中回传终端的分辨率
====================================================================*/
void CMcuVcInst::ChgMtFormatInSdVmp(	u8 byMtId,
										TVMPParam *ptVmpParam,
										BOOL32 bStart
										)
{

	

	if ( NULL == ptVmpParam )
    {
        return;
    }
    
    // guzh [9/1/2006] 会议不要求自适应分辨率
    if ( !m_tConf.IsVmpAutoAdapt() )
    {
        return;
    }

    TMt tMt = m_ptMtTable->GetMt(byMtId);
    if (tMt.IsNull()) 
    {
        return;
    }

    if ((tMt.GetType() != TYPE_MT && tMt.GetType() != TYPE_MCU) ||
		(m_ptMtTable->GetManuId(tMt.GetMtId()) != MT_MANU_KDC && m_ptMtTable->GetManuId(tMt.GetMtId()) != MT_MANU_KDCMCU))
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[ChangeMtVideoFormat] dstmt.%d is not mt(mcu) or kdc mt(mcu). type.%d manu.%d\n",
                tMt.GetMtId(), tMt.GetType(), m_ptMtTable->GetManuId(tMt.GetMtId()));
        return;
    }

    //目前只改变第一路视频通道的分辨率
    u8 byChnnlType = LOGCHL_VIDEO;   
   
    TLogicalChannel tLogicChannel;
    if ( !m_tConfAllMtInfo.MtJoinedConf( byMtId ) ||
         !m_ptMtTable->GetMtLogicChnnl( byMtId, byChnnlType, &tLogicChannel, FALSE ) )
    {
        return;
    }

    u8 byMtStandardFormat = tLogicChannel.GetVideoFormat(); // 查找原来建立的分辨率

    u8 byLogicChannlType = tLogicChannel.GetChannelType(); // 信道类型 xliang [080731] 下面判断多次用到
    //u8 byChannlVidFPS = tLogicChannel.GetChanVidFPS();// 通道码流帧率 xliang [080731]

    u8 byNewFormat; //分辨率类型
    u8 byVmpType = ptVmpParam->GetVMPStyle();   
    
    //若终端还在多画面电视墙里或vmp里且不是发言人，则不恢复分辨率
    //BOOL32 bSpeaker = (GetLocalSpeaker() == tMt);
    
    // 8000B 
    // H264:          sqcif<-->原来(cif)
    // MPEG4, MPEG2:  四画面以上qcif<-->原来
    // 一画面不改，1－3画面发言人不改
#ifdef _MINIMCU_
    //FIXME: MINIMCU暂未处理高清VMP
    if (MEDIA_TYPE_H264 == byLogicChannlType)
    {     
        if (VMP_STYLE_ONE == byVmpType)
        {
            byNewFormat = bStart ? VIDEO_FORMAT_CIF:byMtStandardFormat;
        }
        else if (VMP_STYLE_VTWO == byVmpType || VMP_STYLE_HTWO == byVmpType || 
                VMP_STYLE_THREE == byVmpType || VMP_STYLE_FOUR == byVmpType || 
                VMP_STYLE_SPECFOUR == byVmpType)
        {
                //zbq[12/27/2007]通用恢复到原分辨率
                byNewFormat = bStart ? VIDEO_FORMAT_QCIF:byMtStandardFormat;
        }
        else
        {
            u8 byResSqcif = (VMP_STYLE_NINE == byVmpType ? VIDEO_FORMAT_SQCIF_112x96 : VIDEO_FORMAT_SQCIF_96x80);            

            //zbq[12/27/2007]通用恢复到原分辨率
            byNewFormat = bStart ? byResSqcif : byMtStandardFormat;
        }       

        // xsl [11/1/2006] 8000b mcu h264会议四画面及以上发言人也要改变分辨率
        if (VMP_STYLE_ONE == byVmpType || VMP_STYLE_VTWO == byVmpType || VMP_STYLE_THREE == byVmpType)
        {
            //zbq[04/07/2008] 发言人统一调整 分辨率
            //byNewFormat = bSpeaker ? byMtStandardFormat : byNewFormat;
        }        
    }
    else if (MEDIA_TYPE_MP4  == byLogicChannlType ||
             MEDIA_TYPE_H262 == byLogicChannlType )
    {
        if (VMP_STYLE_ONE == byVmpType)
        {
            byNewFormat = byMtStandardFormat;
        }
        else if (VMP_STYLE_VTWO == byVmpType || VMP_STYLE_HTWO == byVmpType || 
                VMP_STYLE_THREE == byVmpType || VMP_STYLE_FOUR == byVmpType || 
                VMP_STYLE_SPECFOUR == byVmpType)
        {
            byNewFormat = bStart ? VIDEO_FORMAT_CIF:byMtStandardFormat;
        }
        else
        {
            byNewFormat = bStart ? VIDEO_FORMAT_QCIF:byMtStandardFormat;
        }

        //zbq[04/07/2008] 发言人统一调整 分辨率
        //发言人保持原来的分辨率
        //byNewFormat = bSpeaker ? byMtStandardFormat : byNewFormat;
    }
    else
    {
        return;
    }
#else
    // 8000 
    // 四画面: CIF及以下不调，H264的HD/4CIF调到CIF
    // H264:         qcif<-->原来(cif)
    // MPEG4, MPEG2: cif<-->原来

	

    if (MEDIA_TYPE_H264 == byLogicChannlType)
    {        
        if (VMP_STYLE_ONE == byVmpType || VMP_STYLE_VTWO == byVmpType ||
            VMP_STYLE_HTWO == byVmpType || VMP_STYLE_THREE == byVmpType ||
            VMP_STYLE_FOUR == byVmpType || VMP_STYLE_SPECFOUR == byVmpType ||
			//fxh [02/05/2009] 针对VCS特殊动态VMP的临时调整 
			(VCS_CONF == m_tConf.GetConfSource() &&
			 VMP_STYLE_DYNAMIC == byVmpType && IsHDConf(m_tConf)) )
        {

            //zbq[12/27/2007] 降到CIF
            if (VIDEO_FORMAT_CIF != m_tConf.GetMainVideoFormat())
            {
                byNewFormat = bStart ? VIDEO_FORMAT_CIF : byMtStandardFormat;
            }
            else
            {
                byNewFormat = byMtStandardFormat;
            }                
        }
        else
        {
            //zbq[12/27/2007]通用恢复到原分辨率
            byNewFormat = bStart ? VIDEO_FORMAT_QCIF:byMtStandardFormat;
        }        
    }
    else if (MEDIA_TYPE_MP4  == byLogicChannlType ||
             MEDIA_TYPE_H262 == byLogicChannlType )
    {       
        if (VMP_STYLE_ONE == byVmpType || VMP_STYLE_VTWO == byVmpType ||
            VMP_STYLE_HTWO == byVmpType || VMP_STYLE_THREE == byVmpType ||
            VMP_STYLE_FOUR == byVmpType || VMP_STYLE_SPECFOUR == byVmpType)
        {
            byNewFormat = byMtStandardFormat;

			//zjj20091031 			
			if( MEDIA_TYPE_MP4  == byLogicChannlType && VIDEO_FORMAT_4CIF == byMtStandardFormat )
			{
				byNewFormat =  bStart ? VIDEO_FORMAT_CIF:byMtStandardFormat;
			}
        }
        else
        {
            byNewFormat = bStart ? VIDEO_FORMAT_CIF:byMtStandardFormat;
        }        
    }
    else
    {
        return;   
    }  

    //发言人保持原来的分辨率
    //byNewFormat = bSpeaker ? byMtStandardFormat : byNewFormat;
#endif
    
	if ( !bStart )    
	{
		TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
		TVMPParam tTwParam = m_tConf.m_tStatus.GetVmpTwParam();
		if ( ((tVmpParam.GetVMPMode() != CONF_VMPMODE_NONE && tVmpParam.IsMtInMember(tMt)) ||
			 (m_tConf.m_tStatus.GetVmpTwMode() != CONF_VMPTWMODE_NONE && tTwParam.IsMtInMember(tMt))) )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "mt.%d is still in VMP or MPW, keep its format !\n", tMt.GetMtId());
			return;
		}
		
		//zjj20091102既然已经在标清电视墙中，就不要再恢复终端分辨率了
		//因为如果是高清终端，再恢复成高清码流，电视墙就无法解了
		if( m_ptMtTable->IsMtInTvWall( tMt.GetMtId() ) )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "mt.%d is still in TVwall, keep its format !\n", tMt.GetMtId());
			return;
		}
	}   

    // 调节高清主视频适配, zgc, 2008-08-21
    //if ( m_tVidBrdSrc == tMt )
    //{
        //zbq[12/11/2008] 视频源分辨率切换后，适配不作调整
        //AdjustHDVidAdapt();
    //}
    
	// fxh 针对下级MCU调整分辨率,实际为对其回传通道中的终端调整
	if (MT_TYPE_SMCU == tMt.GetMtType())
	{
        //[5/9/2011 zhushengze] GetMcInfo()参数修正
		TConfMcInfo* ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(tMt.GetMtId())/*tMt.GetMtId()*/);
		if (ptMcInfo != NULL)
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "change mt(mcuid:%d, mtid:%d) in sub mcu%d\n", 
				   ptMcInfo->m_tMMcuViewMt.GetMcuId(), ptMcInfo->m_tMMcuViewMt.GetMtId(), tMt.GetMtId());
		}

		if (ptMcInfo != NULL &&
			!ptMcInfo->m_tMMcuViewMt.IsNull())
		{
			CascadeAdjMtRes(ptMcInfo->m_tMMcuViewMt, byNewFormat, bStart);			
		}
	}
	else
	{
		// [pengjie 2010/9/13] 多回传调分辨率逻辑调整
        SendChgMtVidFormat( byMtId, byChnnlType, byNewFormat );
	}

    ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP,  "[ChangeMtVideoFormat] chnnl type: %d, send videoformat<%d> change msg to mt<mcuid:%d, mtid:%d, mttype:%d>!\n",
            tLogicChannel.GetChannelType(), byNewFormat, tMt.GetMcuId(), tMt.GetMtId(), tMt.GetMtType() );

    return;
}

BOOL32 CMcuVcInst::GetMtFormat(u8 byVmpId,
							   const TMt &tMt,
							   TVMPParam_25Mem *ptVmpParam,
							   u8 &byNewFormat,
							   BOOL32 bConsiderVmpBrd /*= TRUE*/,
							   BOOL32 bNonKeda /*= FALSE*/,
							   BOOL32 bForceVip /*= FALSE*/
								)
{
	
	// 获得成员在vmp中的分辨率
	BOOL32 bRet = TRUE;
	TExInfoForResFps tExInfoForResFps;
	tExInfoForResFps.m_byEvent = EvMask_VMP;
	tExInfoForResFps.m_byOccupy = Occupy_InChannel;
	tExInfoForResFps.m_bConsiderVmpBrd = bConsiderVmpBrd;
	tExInfoForResFps.m_byEqpid = byVmpId;
	if (ptVmpParam != NULL)
	{
		tExInfoForResFps.m_tVmpParam = *ptVmpParam;
	}
	BOOL32 bIsNeedAjsRes = IsNeedAdjustMtVidFormat(tMt, tExInfoForResFps);
	byNewFormat = tExInfoForResFps.m_byNewFormat;	//获得要调整到的分辨率
	BOOL32 bSetVmpChl = tExInfoForResFps.m_bResultSetVmpChl;
	if (!bSetVmpChl)
	{
		//若不能建交换，表示终端分辨率有问题，返回FALSE
		return FALSE;
	}

	return TRUE;
}

BOOL32 CMcuVcInst::GetMtFormat(const TMt &tMt, u8 &byNewFormat, BOOL32 bConsiderVmpBrd)
{
	// 在无任何操作时，获得该终端在当前状况下的分辨率。
	TExInfoForResFps tExInfoForResFps;
	tExInfoForResFps.m_byEvent = EvMask_Invalid;
	tExInfoForResFps.m_bConsiderVmpBrd = bConsiderVmpBrd;
	BOOL32 bIsNeedAjsRes = IsNeedAdjustMtVidFormat(tMt, tExInfoForResFps);
	byNewFormat = tExInfoForResFps.m_byNewFormat;	//获得要调整到的分辨率
	
	return TRUE;
}

BOOL32 CMcuVcInst::GetMtFormatInSdVmp(const TMt &tMt, TVMPParam *ptVmpParam, u8 &byNewFormat, BOOL32 bStart)
{
	byNewFormat = 0;

	if ( NULL == ptVmpParam )
    {
        return FALSE;
    }

    if (tMt.IsNull()) 
    {
        return FALSE;
    }

	//目前只改变第一路视频通道的分辨率
    u8 byChnnlType = LOGCHL_VIDEO;   
	
	TMt tLocalMt = GetLocalMtFromOtherMcuMt( tMt );
    TLogicalChannel tLogicChannel;
    if ( !m_tConfAllMtInfo.MtJoinedConf( tMt ) ||
		!m_ptMtTable->GetMtLogicChnnl( tLocalMt.GetMtId(), byChnnlType, &tLogicChannel, FALSE ) )
    {
        return FALSE;
    }

    u8 byMtStandardFormat	= tLogicChannel.GetVideoFormat();	// 查找原来建立的分辨率
    u8 byLogicChannlType	= tLogicChannel.GetChannelType();	// 信道类型 
    //u8 byChannlVidFPS		= tLogicChannel.GetChanVidFPS();	// 通道码流帧率 

    u8 byVmpType = ptVmpParam->GetVMPStyle();   
    //u8 byPos	 = ptVmpParam->GetChlOfMtInMember(tMt);			//pos
    
    // 8000B 
    // H264:          sqcif<-->原来(cif)
    // MPEG4, MPEG2:  四画面以上qcif<-->原来
    // 一画面不改，1－3画面发言人不改
#ifdef _MINIMCU_
    //FIXME: MINIMCU暂未处理高清VMP
    if (MEDIA_TYPE_H264 == byLogicChannlType)
    {     
        if (VMP_STYLE_ONE == byVmpType)
        {
            byNewFormat = bStart ? VIDEO_FORMAT_CIF:byMtStandardFormat;
        }
        else if (VMP_STYLE_VTWO == byVmpType || VMP_STYLE_HTWO == byVmpType || 
                VMP_STYLE_THREE == byVmpType || VMP_STYLE_FOUR == byVmpType || 
                VMP_STYLE_SPECFOUR == byVmpType)
        {
                //zbq[12/27/2007]通用恢复到原分辨率
                byNewFormat = bStart ? VIDEO_FORMAT_QCIF:byMtStandardFormat;
        }
        else
        {
            u8 byResSqcif = (VMP_STYLE_NINE == byVmpType ? VIDEO_FORMAT_SQCIF_112x96 : VIDEO_FORMAT_SQCIF_96x80);            

            //zbq[12/27/2007]通用恢复到原分辨率
            byNewFormat = bStart ? byResSqcif : byMtStandardFormat;
        }       

        // xsl [11/1/2006] 8000b mcu h264会议四画面及以上发言人也要改变分辨率
        if (VMP_STYLE_ONE == byVmpType || VMP_STYLE_VTWO == byVmpType || VMP_STYLE_THREE == byVmpType)
        {
            //zbq[04/07/2008] 发言人统一调整 分辨率
            //byNewFormat = bSpeaker ? byMtStandardFormat : byNewFormat;
        }        
    }
    else if (MEDIA_TYPE_MP4  == byLogicChannlType ||
             MEDIA_TYPE_H262 == byLogicChannlType )
    {
        if (VMP_STYLE_ONE == byVmpType)
        {
            byNewFormat = byMtStandardFormat;
        }
        else if (VMP_STYLE_VTWO == byVmpType || VMP_STYLE_HTWO == byVmpType || 
                VMP_STYLE_THREE == byVmpType || VMP_STYLE_FOUR == byVmpType || 
                VMP_STYLE_SPECFOUR == byVmpType)
        {
            byNewFormat = bStart ? VIDEO_FORMAT_CIF:byMtStandardFormat;
        }
        else
        {
            byNewFormat = bStart ? VIDEO_FORMAT_QCIF:byMtStandardFormat;
        }

        //zbq[04/07/2008] 发言人统一调整 分辨率
        //发言人保持原来的分辨率
        //byNewFormat = bSpeaker ? byMtStandardFormat : byNewFormat;
    }
    else
    {
    }
#else
    // 8000 
    // 四画面: CIF及以下不调，H264的HD/4CIF调到CIF
    // H264:         qcif<-->原来(cif)
    // MPEG4, MPEG2: cif<-->原来

    if (MEDIA_TYPE_H264 == byLogicChannlType)
    {        
        if (VMP_STYLE_ONE == byVmpType || VMP_STYLE_VTWO == byVmpType ||
            VMP_STYLE_HTWO == byVmpType || VMP_STYLE_THREE == byVmpType ||
            VMP_STYLE_FOUR == byVmpType || VMP_STYLE_SPECFOUR == byVmpType ||
			//fxh [02/05/2009] 针对VCS特殊动态VMP的临时调整 
			(VCS_CONF == m_tConf.GetConfSource() &&
			 VMP_STYLE_DYNAMIC == byVmpType && IsHDConf(m_tConf)) )
        {

            //zbq[12/27/2007] 降到CIF
            if (VIDEO_FORMAT_CIF != m_tConf.GetMainVideoFormat())
            {
                byNewFormat = bStart ? VIDEO_FORMAT_CIF : byMtStandardFormat;
            }
            else
            {
                byNewFormat = byMtStandardFormat;
            }                
        }
        else
        {
            //zbq[12/27/2007]通用恢复到原分辨率
            byNewFormat = bStart ? VIDEO_FORMAT_QCIF:byMtStandardFormat;
        }        
    }
    else if (MEDIA_TYPE_MP4  == byLogicChannlType ||
             MEDIA_TYPE_H262 == byLogicChannlType )
    {       
        if (VMP_STYLE_ONE == byVmpType || VMP_STYLE_VTWO == byVmpType ||
            VMP_STYLE_HTWO == byVmpType || VMP_STYLE_THREE == byVmpType ||
            VMP_STYLE_FOUR == byVmpType || VMP_STYLE_SPECFOUR == byVmpType)
        {
            byNewFormat = byMtStandardFormat;

			//zjj20091031 			
			if( MEDIA_TYPE_MP4  == byLogicChannlType && VIDEO_FORMAT_4CIF == byMtStandardFormat )
			{
				byNewFormat =  bStart ? VIDEO_FORMAT_CIF:byMtStandardFormat;
			}
        }
        else
        {
            byNewFormat = bStart ? VIDEO_FORMAT_CIF:byMtStandardFormat;
        }        
    }
    else
    {
    }
#endif

	return TRUE;
}

/*====================================================================
    函数名      ：ChgMtFormatInSdVmp
    功能        ：H264会议画面合成，分辨率的调整
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtId    : 要调整的终端ID
                  u8 byNewFormt: 调整后的分辨率
				  u8 byMemberType: 通道属性,用于双流跟随支持
    返回值说明  ：void
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	06/06/05    4.0         张宝卿          创建
	09/04/29    4.0         付秀华          支持调整下级MCU中回传终端的分辨率
	10/02/22	4.6         薛亮			参数，返回值，注释重整，支持多回传
====================================================================*/
BOOL32 CMcuVcInst::ChgMtFormatInSdVmp(  TMt &tMt,
										TVMPParam *ptVmpParam,
										BOOL32 bStart,
										u8 byMemberType
										)
{

	
	
	if ( NULL == ptVmpParam )
    {
        return FALSE;
    }
    
    // guzh [9/1/2006] 会议不要求自适应分辨率
    if ( !m_tConf.IsVmpAutoAdapt() )
    {
        return TRUE;
    }
	
    if (tMt.IsNull()) 
    {
        return FALSE;
    }
	
	// [pengjie 2010/3/30] 对于多回传，这里不需要判断是否是科达，在上级presetin中已经处理，并且这里的tmt信息是一个下级的，
	//                     所以使用GetManuId不能去判断下级的终端。
	if( !tMt.IsLocal() )
	{
		if ((tMt.GetType() != TYPE_MT && tMt.GetType() != TYPE_MCU))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangeMtVideoFormat] dstmt.%d is not mt(mcu), type.%d \n",
                tMt.GetMtId(), tMt.GetType());
			return FALSE;
		}
	}
	else
	{
		if ((tMt.GetType() != TYPE_MT && tMt.GetType() != TYPE_MCU) ||
			(m_ptMtTable->GetManuId(tMt.GetMtId()) != MT_MANU_KDC && m_ptMtTable->GetManuId(tMt.GetMtId()) != MT_MANU_KDCMCU))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChangeMtVideoFormat] dstmt.%d is not mt(mcu) or kdc mt(mcu). type.%d manu.%d\n",
                tMt.GetMtId(), tMt.GetType(), m_ptMtTable->GetManuId(tMt.GetMtId()));
			return FALSE;
		}
	}

	//目前只改变第一路视频通道的分辨率,双流跟随支持
    u8 byChnnlType = LOGCHL_VIDEO; 
	if (VMP_MEMBERTYPE_DSTREAM == byMemberType)
	{
		byChnnlType = LOGCHL_SECVIDEO;
	}
	
	TMt tLocalMt = GetLocalMtFromOtherMcuMt( tMt );
    TLogicalChannel tLogicChannel;
    if ( !m_tConfAllMtInfo.MtJoinedConf( tMt ) ||
		!m_ptMtTable->GetMtLogicChnnl( tLocalMt.GetMtId(), byChnnlType, &tLogicChannel, FALSE ) )
    {
        return FALSE;
    }

	//zjj20101021 h263只有cif分辨率，不用调整
	if( MEDIA_TYPE_H263 == tLogicChannel.GetChannelType() )
	{
		return TRUE;
	}

	//双流源不降分辨率,直接返回
	if (VMP_MEMBERTYPE_DSTREAM == byMemberType)
	{
		return TRUE;
	}

	u8 byNewFormat = 0;
	u8 byPos = ptVmpParam->GetChlOfMtInMember(tMt);
	u8 byVmpType = ptVmpParam->GetVMPStyle();

	if (!GetMtFormatInSdVmp(tMt, ptVmpParam, byNewFormat, bStart))
	{
		return FALSE;
	}
	
    //发言人保持原来的分辨率
    //byNewFormat = bSpeaker ? byMtStandardFormat : byNewFormat;
    
	if ( !bStart )    
	{
		TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
		TVMPParam tTwParam = m_tConf.m_tStatus.GetVmpTwParam();
		if ( ((tVmpParam.GetVMPMode() != CONF_VMPMODE_NONE && tVmpParam.IsMtInMember(tMt)) ||
			 (m_tConf.m_tStatus.GetVmpTwMode() != CONF_VMPTWMODE_NONE && tTwParam.IsMtInMember(tMt))) )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeMtVideoFormat] mt.%d is still in VMP or MPW, keep its format !\n", tMt.GetMtId());
			return TRUE;
		}
		
		//zjj20091102既然已经在标清电视墙中，就不要再恢复终端分辨率了
		//因为如果是高清终端，再恢复成高清码流，电视墙就无法解了
		if( m_ptMtTable->IsMtInTvWall( tMt.GetMtId() ) )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeMtVideoFormat] mt.%d is still in TVwall, keep its format !\n", tMt.GetMtId());
			return TRUE;
		}
	}   

    // 调节高清主视频适配, zgc, 2008-08-21
    //if ( m_tVidBrdSrc == tMt )
    //{
        //zbq[12/11/2008] 视频源分辨率切换后，适配不作调整
        //AdjustHDVidAdapt();
    //}
    
	// [2/22/2010 xliang] 级联调分辨率及PreSetIn
	if( !tMt.IsLocal() )
	{
		// [2/22/2010 xliang] 兼容非多回传版本
		
		// xliang [4/29/2009] FIXME目前只有一个回传通道,所以先(2,2)在VMP，后上级选看下级(2,1) 会有问题. 
		// 可用新加的回传源变量标示tSrcMt. (FIXME:参VCS流,变量保持统一)
		// 回传源变化不仅要降(2,1)分辨率，还得恢复(2,2)分辨率。
		
		// [2/5/2010 xliang] 这里无需这么复杂，仅需处理当前终端即可。如这次是要调(2,1),就单调(2,1)即可。
		// 恢复(2,2)之后会再次触发。
		//FIXME: 对于拖下级mcu进合成，下级自己切换发言人这种情况，是否有问题？待验证
		CascadeAdjMtRes( tMt, byNewFormat, bStart, byVmpType, byPos);
	}
	else
	{
		// [pengjie 2010/9/13] 多回传调分辨率逻辑调整
        SendChgMtVidFormat( tMt.GetMtId(), byChnnlType, byNewFormat );
// 		CServMsg cServMsg;
// 		cServMsg.SetEventId( MCU_MT_VIDEOPARAMCHANGE_CMD );
// 		cServMsg.SetMsgBody( &byChnnlType, sizeof(u8) );
// 		cServMsg.CatMsgBody( &byNewFormat, sizeof(u8) );
// 		SendMsgToMt( tMt.GetMtId(), cServMsg.GetEventId(), cServMsg );
		
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ChgMtFormatInMpu] chnnl type: %d, send videoformat<%d>(%s) change msg to mt<%d>!\n",
			tLogicChannel.GetChannelType(), byNewFormat, GetResStr(byNewFormat), tMt.GetMtId() );
	}




	// fxh 针对下级MCU调整分辨率,实际为对其回传通道中的终端调整
// 	if (MT_TYPE_SMCU == tMt.GetMtType())
// 	{
// 		TConfMcInfo* ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tMt.GetMtId());
// 		if (ptMcInfo != NULL)
// 		{
// 			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChangeMtVideoFormat]change mt(mcuid:%d, mtid:%d) in sub mcu%d\n", 
// 				   ptMcInfo->m_tMMcuViewMt.GetMcuId(), ptMcInfo->m_tMMcuViewMt.GetMtId(), tMt.GetMtId());
// 		}
// 
// 		if (ptMcInfo != NULL &&
// 			!ptMcInfo->m_tMMcuViewMt.IsNull())
// 		{
// 			CascadeAdjMtRes(ptMcInfo->m_tMMcuViewMt, byNewFormat, bStart);			
// 		}
// 	}
// 	else
// 	{
// 		CServMsg cServMsg;
// 
// 		cServMsg.SetEventId( MCU_MT_VIDEOPARAMCHANGE_CMD );
// 		cServMsg.SetMsgBody( &byChnnlType, sizeof(u8) );
// 		cServMsg.CatMsgBody( &byNewFormat, sizeof(u8) );
// 		SendMsgToMt( byMtId, cServMsg.GetEventId(), cServMsg );
// 	}

//     ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ChangeMtVideoFormat] chnnl type: %d, send videoformat<%d> change msg to mt<mcuid:%d, mtid:%d, mttype:%d>!\n",
//             tLogicChannel.GetChannelType(), byNewFormat, tMt.GetMcuId(), tMt.GetMtId(), tMt.GetMtType() );

    return TRUE;
}

/*====================================================================
    函数名      ：GetChlOfMtInVmpParam
    功能        ：获得终端在vmp中的所有位置,包含mcu上传终端特殊处理
				  仅适用于前适配抢占
    算法实现    ：
    引用全局变量：
    输入参数说明：TVMPParam& tVmpParam	[in]
				  tMt : 终端的TMt结构	[in]
				  u8 &byPosNum			[out]
				  u8 *pbyPos			[out]
    返回值说明  ：无
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    11/12/07    1.0       yanghuaizhi         创建
====================================================================*/
void CMcuVcInst::GetChlOfMtInVmpParam(const TVMPParam_25Mem& tVmpParam, TMt tMt, u8 &byPosNum, u8 *pbyPos)
{
	byPosNum = 0;
	// 终端不在列表中,做保护
	if (tMt.IsNull() || !m_tConfAllMtInfo.MtJoinedConf(tMt))
	{
		return;
	}
	
	TMt tRealTmt = tMt;
	BOOL32 bIsMMcu = (tMt == m_tCascadeMMCU) || IsNotSupportCascadeMcu(tMt);
	if (IsMcu(tRealTmt) && !bIsMMcu)
	{
		//找到此MCU最底层上传终端
		tRealTmt = GetSMcuViewMt(tRealTmt, TRUE);
		if (tRealTmt.IsNull() || !m_tConfAllMtInfo.MtJoinedConf(tRealTmt))
		{
			//无上传终端或不在终端列表中,无需进前适配
			return;
		}
	}
	
	u8 abyChnlNo[MAXNUM_VMP_MEMBER];
	u8 byChnlNum = 0;
	u8 *pbyTmp = NULL;
	tVmpParam.GetChlOfMtInMember(tRealTmt,FALSE,MAXNUM_VMP_MEMBER,abyChnlNo,&byChnlNum);
	if (NULL != pbyPos)
	{
		pbyTmp = pbyPos;
		memcpy(pbyTmp,abyChnlNo,byChnlNum);
	}
	byPosNum = byChnlNum;

	TMt tTmpMt = tRealTmt;
	//有上级mcu
	while (!tTmpMt.IsNull() && !tTmpMt.IsLocal()
		&& (TYPE_MT == tTmpMt.GetType() || TYPE_MCU == tTmpMt.GetType()))
	{
		//判断终端是否是上级mcu的上传通道终端,计算上级mcu在通道内个数
		TMt tMcu = GetDirectMcuFromMt(tTmpMt);
		if (tRealTmt == GetSMcuViewMt(tMcu, TRUE))
		{
			tVmpParam.GetChlOfMtInMember(tMcu,FALSE,MAXNUM_VMP_MEMBER,abyChnlNo,&byChnlNum);
			if (NULL != pbyPos)
			{
				pbyTmp = pbyPos+byPosNum;
				memcpy(pbyTmp,abyChnlNo,byChnlNum);
			}
			byPosNum += byChnlNum;
		}
		tTmpMt = tMcu;
	}
	
}

/*====================================================================
    函数名      ：GetMtFormatInMpu
    功能        ：对于终端进MPU，获取所需调整的分辨率
    算法实现    ：
    引用全局变量：
    输入参数说明：TMt &tMt								[i]
				  TVMPParam *ptVmpParam					[i]
				  u8 &byNewFormat						[o] 所需的新分辨率值
				  CVmpChgFormatResult &cVmpChgFormatRes [o] 获取新分辨率后的后续处理导向结果	
				  BOOL32 bStart							[i] 是调整还是恢复
                  BOOL32 bConsiderVmpBrd				[i] 是否考虑合成广播
				  BOOL32 bNonkeda						[i] 是否认定该终端是非科达的终端(无条件)
				  u8 byMemberType						[i] 要调整通道类型,用于双流跟随通道调整
    返回值说明  ：BOOL32
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	10/02/22	4.6         薛亮		   修整创建
====================================================================*/
BOOL32 CMcuVcInst::GetMtFormatInMpu(const TMt &tMt,
							TVMPParam_25Mem *ptVmpParam,
							u8 &byNewFormat,
							CVmpChgFormatResult &cVmpChgFormatRes,
							BOOL32 bStart,
							BOOL32 bConsiderVmpBrd,
							BOOL32 bNonKeda,
							BOOL32 bForceVip,
							u8 byMemberType)
{
	if ( NULL == ptVmpParam )
    {
        return FALSE;
    }
	
    if (tMt.IsNull()) 
    {
        return FALSE;
    }
	
	if (tMt.GetType() != TYPE_MT)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[GetMtFormatInMpu] dstmt.%d is not mt. type.%d manu.%d\n",
			tMt.GetMtId(), tMt.GetType(), m_ptMtTable->GetManuId(tMt.GetMtId()));
        return FALSE;
	}

	TVmpChnnlInfo tVmpChnnlInfo;
	//目前只改变第一路视频通道的分辨率
	BOOL32 bDStream = FALSE;
    u8 byChnnlType = LOGCHL_VIDEO; 
	if (VMP_MEMBERTYPE_DSTREAM == byMemberType)
	{
		bDStream = TRUE;
		byChnnlType = LOGCHL_SECVIDEO;
	}
	
	TMt tLocalMt = GetLocalMtFromOtherMcuMt( tMt );
    TLogicalChannel tLogicChannel;
    if ( !m_tConfAllMtInfo.MtJoinedConf( tMt ) ||
		!m_ptMtTable->GetMtLogicChnnl( tLocalMt.GetMtId(), byChnnlType, &tLogicChannel, FALSE ) )
    {
        return FALSE;
    }

	// 要调的终端是MMCU
	BOOL32 bIsMMcu = (m_tCascadeMMCU == tMt);

	//会议不要求自适应分辨率
	if (!m_tConf.IsVmpAutoAdapt())
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[GetMtFormatInMpu] vmp is not AutoAdapt.\n");
		byNewFormat = tLogicChannel.GetVideoFormat(); // 原来建立的分辨率
		return TRUE;
	}

	u8 byVmpSubType = GetVmpSubType(m_tVmpEqp.GetEqpId());
	u8 byVmpStyle = ptVmpParam->GetVMPStyle();
	BOOL32 bIsNewMpu = FALSE;
	// 经测试,MPU2仍然不支持MPEG4 4CIF不降分辨率进VMP,为以后新vmp设备保留
	/*if (MPU2_VMP_BASIC == byVmpSubType || MPU2_VMP_ENHACED == byVmpSubType)
	{
		bIsNewMpu = TRUE;
	}*/
	
	// 若是mcu,则取其上传通道终端,用于前适配处理
	TMt tRealMt = tMt;
	if (IsMcu(tRealMt) && !bDStream && !bIsMMcu) //双流源不做映射,MMCU也不做映射
	{
		tRealMt = GetSMcuViewMt(tRealMt, TRUE);
	}
	// 找到tMt所在最小通道的位置,包含统计Mcu及其上传通道终端
	u8 abyChnlNo[MAXNUM_VMP_MEMBER];
	u8 byChnlCount = 0;
	u8 byPos = MAXNUM_VMP_MEMBER;
	memset(abyChnlNo,0,sizeof(abyChnlNo));
	// 双流跟随时,取双流跟随通道
	if (bDStream)
	{
		byPos = ptVmpParam->GetChlOfMemberType(VMP_MEMBERTYPE_DSTREAM);
		if (MAXNUM_VMP_MEMBER != byPos)
		{
			byChnlCount = 1;
			abyChnlNo[0] = byPos;
		}
	}
	// 如果tMt是mcu,且其上传通道终端为空,就无需获取通道位置
	else if (!tRealMt.IsNull())
	{
		// 获得tMt所在vmp通道的个数和所有位置,包含统计Mcu与上传终端
		GetChlOfMtInVmpParam(*ptVmpParam, tRealMt, byChnlCount, abyChnlNo);
		LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]Mtid:%u,AllChnlCount:%u.\n",
			tRealMt.GetMtId(), byChnlCount);

		for (u8 byNum=0;byNum<byChnlCount;byNum++)
		{
			// 因为大风格通道都靠前，小风格的通道位置都靠后。此时所需的分辨率以小风格的为准
			// 上述情况有个特例：10风格,如果只在通道5内,也不能忽略
			if (byVmpStyle == VMP_STYLE_TEN && abyChnlNo[byNum] == 5 && byChnlCount > 1)
			{
				continue;
			}
			// 找到最后一个通道
			if (byPos < abyChnlNo[byNum] || MAXNUM_VMP_MEMBER == byPos)
			{
				byPos = abyChnlNo[byNum];
			}
		}
	} 

    u8 byMtStandardFormat = tLogicChannel.GetVideoFormat(); // 查找原来建立的分辨率
    u8 byLogicChannlType = tLogicChannel.GetChannelType();	// 信道类型 
    u8 byChannlVidFPS = tLogicChannel.GetChanVidFPS();		// 通道码流帧率 
	BOOL32 bNeedAdjustRes = FALSE;							// 是否真的需要调整分辨率
	
	// 追加用tRealMt来判断其是否是非keda终端,可能tMt是mcu,其上传终端是非科达终端
	BOOL32 bNoneKeda = ( (!IsKedaMt(tMt, TRUE)) || (!tRealMt.IsNull() && !IsKedaMt(tRealMt, FALSE)) || bNonKeda );	//是否非keda终端(该特殊身份提前判)
	BOOL32 bG400IPCMt = IsG400IPCMt(tRealMt); // 8000H-M特有需求: IPC前端进前适配通道 [pengguofeng 10/31/2012]
	
	// [2/4/2010 xliang] TMtStatus.InTvWall并不能适用于下级终端，故用新接口判之
	BOOL32 bInTw = IsMtInTvWall(tMt) && !bDStream;

	TMtStatus tMtStatus;
	m_ptMtTable->GetMtStatus( tMt.GetMtId(), &tMtStatus );  	
	if(!bStart) //恢复分辨率
	{
		// 恢复分辨率依赖当前会议VmpParam中此终端是否还在
		u8 byConfChnlCount = 0;
		GetChlOfMtInVmpParam(g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp), tMt, byConfChnlCount);
		
		TVMPParam tTwParam = m_tConf.m_tStatus.GetVmpTwParam();
		// 双流源不降分辨率,恢复分辨率直接返回TRUE
		if (bDStream)
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu] mt.%d is DoubleStreamSrc!\n",tMt.GetMtId());
		}
		else if ( ((g_cMcuVcApp.GetVMPMode(m_tVmpEqp) != CONF_VMPMODE_NONE && byConfChnlCount > 0) ||
			(m_tConf.m_tStatus.GetVmpTwMode() != CONF_VMPTWMODE_NONE && tTwParam.IsMtInMember(tMt))) )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu] mt.(%d,%d) is still in VMP or MPW, keep its format !\n", tMt.GetMcuId(), tMt.GetMtId());
			return FALSE; 
		}
		else
		{
			//zjj20091102既然已经在标清电视墙中，就不要再恢复终端分辨率了
			//因为如果是高清终端，再恢复成高清码流，电视墙就无法解了
			//if(tMtStatus.IsInTvWall()) // [1/19/2010 xliang] 下级终端在tvWall中是否也能从该接口获取？--不能
			if(bInTw)
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu] mt.%d is still in TvWall, keep its format !\n", tMt.GetMtId());
				byNewFormat = VIDEO_FORMAT_CIF;
				cVmpChgFormatRes.SetSendMsg2Mt(FALSE);	//no need to send msg to mt to change format
				return TRUE;
			}
			else
			{
				byNewFormat = byMtStandardFormat;
			}
			
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu] mt.(%d,%d) recover it's format!\n",tMt.GetMcuId(), tMt.GetMtId());
			// 将此终端清除出前适配
			tVmpChnnlInfo.ClearChnlByMt(tRealMt);
		}
	}
	else //调整MT分辨率
	{
		// [2/28/2010 xl]8KE 无需下面特殊处理  
//#if !defined(_8KE_)
		if (0 == byChnlCount)
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_VMP, "[GetMtFormatInMpu] SMCU(%d.%d)-tViewMt(%d.%d) is null or not in any vmp channel.\n",
				tMt.GetMcuIdx(), tMt.GetMtId(), tRealMt.GetMcuIdx(), tRealMt.GetMtId());
		}
		//特殊处理
		u8 byMaxMemberNum = ptVmpParam->GetMaxMemberNum();
		u8 byMaxHdNum = tVmpChnnlInfo.GetMaxNumHdChnnl();
		u8 byMaxStyleNum = tVmpChnnlInfo.GetMaxStyleNum(); //最大支持多少风格下不降分辨率进vmp
		if ((byMaxStyleNum >= byMaxMemberNum)//MPU四画面及以下不用进前适配,MPU2有不同支持前适配个数
			|| bInTw
			)
		{
			//if(tMtStatus.IsInTvWall())
			if(bInTw)
			{
						
				if( MEDIA_TYPE_H264 != byLogicChannlType && byMtStandardFormat == VIDEO_FORMAT_4CIF) 
				{
					byNewFormat = VIDEO_FORMAT_CIF;	//mp4 auto 的直接调成CIF
					bNeedAdjustRes = TRUE;
				}
				else
				{
					// [8/2/2010 xliang] 仅记录分辨率值(该值一定要记录)，并没必要发送分辨率消息
					byNewFormat = VIDEO_FORMAT_CIF;
					
					cVmpChgFormatRes.SetSendMsg2Mt(FALSE);
					return TRUE;	
				}
			}
			else
			{
				// 新vmp用原分辨率
				if (bIsNewMpu)
				{
					byNewFormat = byMtStandardFormat;
				}
				else // 旧画面合成器(mpu or 8kh-mpu)<MPU2仍然不支持MPEG4 4CIF不降分辨率进VMP>
				{
					byNewFormat = byMtStandardFormat;
					if (!bDStream && MEDIA_TYPE_H264 != byLogicChannlType)
					{
						byNewFormat = VIDEO_FORMAT_CIF;	//mp4 auto 的直接调成CIF
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu] 1 vmp adjust resolution CIF for none h264!\n");
					}
				}
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu] %u vmp style and below need not adjust resolution!\n", byMaxStyleNum);
			}
		}
		else
//#endif	//!8KE
		{
			u8 byReqRes	= 0;										//某风格中某位置所允许的最大分辨率	
			//u16 wBR		= 0;										//码率，不由mcu触发调整码率
			//s32 nResCmpRst = 3;										//分辨率比较结果，初始化3,表征比较无意义
			u8 byIdx = 0; //循环用参数
			
			//获得真正的发言人,mcu时,发言人应该是其上传通道终端
			TMt tRealSpeaker = m_tConf.GetSpeaker();
			if (IsMcu(tRealSpeaker))
			{
				tRealSpeaker = GetSMcuViewMt(tRealSpeaker, TRUE);
			}
			//特殊身份判断 (非keda的在之前判)
			BOOL32 bSpeaker = (!tRealSpeaker.IsNull() && tRealSpeaker == tRealMt);							//是否是发言人
			BOOL32 bSelected = IsSelectedbyOtherMtInMultiCas(tRealMt);						//是否被选看
			if (bG400IPCMt)
			{
				LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[GetMtFormatInMpu] tMt<%d %d> is IPC from G400: %d\n",
					tRealMt.GetMcuId(), tRealMt.GetMtId(), bG400IPCMt);
			}

			BOOL32 bSelectedByRoll = FALSE;		// xliang [5/7/2009] 点名造成的选看。因为时序问题，这里特殊处理下
			if( ROLLCALL_MODE_VMP == m_tConf.m_tStatus.GetRollCallMode() 
				&& ( m_tRollCaller == tMt 
				|| m_tRollCallee == tMt ) )  
			{
				bSelectedByRoll = TRUE;
			}
			
			// [2/28/2010 xliang] 非264格式的处理（区分8000E）  
			if(!bDStream && byLogicChannlType != MEDIA_TYPE_H264) 
			{
				//新vmp支持按原分辨率解非H264终端.标清电视墙只支持cif,支援以后新的vmp
				if (bIsNewMpu && !bInTw)
				{
					byNewFormat = byMtStandardFormat;
					cVmpChgFormatRes.SetSendMsg2Mt(FALSE);
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu] none h264 mt.(%u,%u) not need adjust resolution in mpu2!\n", 
						tMt.GetMcuId(), tMt.GetMtId() );
				}
				else//老vmp(mpu or 8kg-vmp or 8kh-vmp) 或 在标清电视墙<MPU2仍然不支持MPEG4 4CIF不降分辨率进VMP>
				{
					if (byMtStandardFormat == VIDEO_FORMAT_4CIF && bNoneKeda)
					{
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu] NoneKeda Mt.(%u,%u) which is MPEG4 with 4CIF in format is not support by VMP!\n",
							tMt.GetMcuId(), tMt.GetMtId() );
						return FALSE;
					}
					
					byNewFormat = VIDEO_FORMAT_CIF;
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu] Force to change Mt.(%u,%u) 's format to CIF as media type other than H264!\n", 
						tMt.GetMcuId(), tMt.GetMtId() );
				}
				//清除当前此终端所有通道前适配,可能旧的vmp成员在前适配,新Mt不在前适配,按通道清
				for (byIdx=0;byIdx<byChnlCount;byIdx++)
				{
					tVmpChnnlInfo.ClearChnlByVmpPos(abyChnlNo[byIdx]);
				}
//#endif 
			}
			else // H264格式的处理
			{

				if( bInTw )
				{
					// [8/2/2010 xliang] 仅记录分辨率值(该值一定要记录)，并没必要发送分辨率消息
					byNewFormat = VIDEO_FORMAT_CIF;
					
					cVmpChgFormatRes.SetSendMsg2Mt(FALSE);
					return TRUE;
				}
				
				TVMPParam_25Mem tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
				//判断是否要调整分辨率以及给出要调整到的分辨率大小
				bNeedAdjustRes = VidResAdjust(m_tVmpEqp.GetEqpId(), byVmpStyle, byPos, byMtStandardFormat, byReqRes);
//#if !defined(_8KE_)
				BOOL32 bNeedAdjust = bNeedAdjustRes;	//不考虑进前适配通道，分辨率是否需要调整

				// xliang [4/7/2009] Res 比较下来没必要调分辨率的MT，即使是特殊身份的也不占前适配通道
				//但切风格可能会造成频繁抢占，有风险
				if( bNeedAdjust && (1 == byChnlCount || bNoneKeda || bIsMMcu || bG400IPCMt) //仅支持单独占1个通道进前适配,非科达与MMCU/IPCMt例外
					&&
					(  ( bSpeaker && !tConfVmpParam.IsVMPBrdst() )
					|| ( bSelected && (!tConfVmpParam.IsVMPBrdst() || !bConsiderVmpBrd) )
					|| bNoneKeda 
					|| bDStream
					|| bIsMMcu
					|| bSelectedByRoll 
					|| bForceVip
					|| bG400IPCMt)
					)
				{
					TChnnlMemberInfo tChnnlMemInfo;
					// 标识不能调分辨率的终端，前适配不足时不抢占场景下，不能建交换
					BOOL32 bUnableAjustResMt = bNoneKeda || bDStream || bIsMMcu || bG400IPCMt;
					
					u8 byHdChnnlNum = tVmpChnnlInfo.GetHDChnnlNum();
					tChnnlMemInfo.SetMt(tRealMt);
					// 8000H-M需求:监控IPC前端必须进前适配通道 [pengguofeng 11/2/2012]
					if ( bG400IPCMt)
					{
						tChnnlMemInfo.SetAttrIPC();
					}
					// 双流源不考虑其它vip属性
					else if (bDStream)
					{
						tChnnlMemInfo.SetAttrDstream();
					}
					// 上级MMCU进vmp也不考虑其它vip属性
					else if (bIsMMcu)
					{
						tChnnlMemInfo.SetAttrMMcu();
					}
					else
					{
						if(bSpeaker && !tConfVmpParam.IsVMPBrdst())
						{
							tChnnlMemInfo.SetAttrSpeaker();
						}
						if(bNoneKeda)
						{
							tChnnlMemInfo.SetAttrNoneKeda();
						}
						if( ( bSelected 
							&& ( (!tConfVmpParam.IsVMPBrdst() && !bSpeaker)	//非VMP广播下发言人会冲走被选看
							|| !bConsiderVmpBrd ) )
							|| bSelectedByRoll									//点名造成的选看，同VMP广播与否无关
							)
						{
							tChnnlMemInfo.SetAttrSelected();
						}
					}
					// 计算通道个数
					u8 byRemainChnlNum = tVmpChnnlInfo.GetMaxNumHdChnnl() - byHdChnnlNum; //剩余前适配个数
					u8 byUsedChnlCount = 0; //本通道已占用的前适配个数,可能要替换的终端在前适配中
					TChnnlMemberInfo tTmpMemInfo;
					for (byIdx=0; byIdx<byChnlCount; byIdx++)
					{
						tVmpChnnlInfo.GetHdChnnlInfoByPos(abyChnlNo[byIdx], &tTmpMemInfo);
						// 被替换终端在前适配中,已占用前适配+1
						if (!tTmpMemInfo.GetMt().IsNull())
						{
							byUsedChnlCount++;
						}
					}
					u8 bySeizeCount = byChnlCount - byUsedChnlCount; //要抢占的前适配个数
					LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]MaxHdChnnlNo:%u,HdChnnlNo:%u,RemainChnlNo:%u.\n",
						tVmpChnnlInfo.GetMaxNumHdChnnl(), byHdChnnlNum, byRemainChnlNum);
					LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]Mtid:%u,AllChnlNo:%u,UsedChnlNo:%u.\n",
					tRealMt.GetMtId(), byChnlCount, byUsedChnlCount);
					if (byRemainChnlNum >= bySeizeCount)	//有剩余HD前适配通道可用则占之
					{
						// [9/17/2010 xliang] 对于预判型强假设VIP的情况，不进行实际的通道加成员
						if(!bForceVip)
						{	
							/*if (0 == bySeizeCount && m_tVmpChnnlInfo.GetChnlCountByMt(tRealMt) > 0) //已在前适配中,已是原分辨率
							{
								cVmpChgFormatRes.SetSendMsg2Mt(FALSE);
							}*/
							//更新前适配信息
							for (byIdx = 0; byIdx<byChnlCount; byIdx++)
							{
								tVmpChnnlInfo.UpdateInfoToHdChnl(&tChnnlMemInfo,abyChnlNo[byIdx]);
							}
						}
						
						//进vmp高清前适配通道，分辨率不用降
						bNeedAdjustRes = FALSE;
						cVmpChgFormatRes.SetKeepResInAdpChnnl(TRUE);
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]Mt.(%u,%u) -> HD adapter channel, no need to change it's video format.\n",
							tMt.GetMcuId(), tMt.GetMtId() );
					}
					else
					{
						if(tConfVmpParam.IsVMPBatchPoll())
						{
							//vmp轮询永远不进行抢占
							if (bUnableAjustResMt)
							{
								ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]The Mt.(%u,%u) is UnableAjustResMt and VMP VIP channel is full! \
										Since VMP mode is [Batch Poll] mode, the Mt will not enter any channel.\n",
										tMt.GetMcuId(), tMt.GetMtId() );
								return FALSE;	
							}
						}
						else if(tConfVmpParam.IsVMPAuto())
						{
							//自动画面合成不抢占
							ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]no seize operation in VMP Auto mode!\n");
							if (bUnableAjustResMt)
							{
								ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChgMtFormatInMpu] The Mt.(%u,%u) is UnableAjustResMt and VMP VIP channel is full! \
										Since VMP mode is [AUTO VMP] mode, the Mt will not enter any channel.\n",
										tMt.GetMcuId(), tMt.GetMtId() );
								return FALSE;	
							}
						}
						else if( CONF_SPEAKERSRC_CHAIR == m_tConf.GetConfAttrb().GetSpeakerSrc() 
							&& HasJoinedChairman() && (m_tConf.GetChairman() == tMt) && !(tMt == m_tConf.GetSpeaker())
							&& HasJoinedSpeaker()
								)
						{
							ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]Speaker select see chairman mode, in this mode, no seize prompt is required.\n");
							if (bUnableAjustResMt)
							{
								ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]The Mt.(%u,%u) is UnableAjustResMt and VMP VIP channel is full! \
									Since VMP mode is [SpeakerSrc Chair] mode, the Mt will not enter any channel.\n",
									tMt.GetMcuId(), tMt.GetMtId() );
								return FALSE;	
							}
						}
						else if (ptVmpParam->GetVMPStyle() != g_cMcuVcApp.GetLastVmpParam(m_tVmpEqp).GetVMPStyle())
						{
							//切换vmp风格时,不抢占
							//如MPU四画面切多画面时,前适配减少,都是vip的话,最后一个不抢占,直接降分辨率.
							//如之前有1个vip终端是降分辨率的,前适配已满,切风格时会全调整,此vip仍按降分辩率处理
							if (bUnableAjustResMt)
							{
								ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]The Mt.(%u,%u) is UnableAjustResMt and VMP VIP channel is full! \
									Since VMP mode is [Batch Poll] mode, the Mt will not enter any channel.\n",
									tMt.GetMcuId(), tMt.GetMtId() );
								return FALSE;	
							}
						}
						else if (bSelectedByRoll)
						{
							//点名开启的画面合成不抢占
							if (bUnableAjustResMt)
							{
								ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]The Mt.(%u,%u) is UnableAjustResMt and VMP VIP channel is full! \
									Since VMP mode is [Batch Poll] mode, the Mt will not enter any channel.\n",
									tMt.GetMcuId(), tMt.GetMtId() );
								return FALSE;	
							}
						}
						else if (0 == tVmpChnnlInfo.GetMaxNumHdChnnl())
						{
							//前适配通道个数为0时,不抢占
							ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]no seize operation in 0 vip vmp chnnl!\n");
							//0前适配时，跟随通道可能跟入不可降分辨率终端，不能建交换
							if (bUnableAjustResMt)
							{
								ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]The Mt.(%u,%u) is UnableAjustResMt and VMP VIP channel is 0!\n",
									tMt.GetMcuId(), tMt.GetMtId() );
								return FALSE;	
							}
						}
						else if (byChnlCount > 1 && bUnableAjustResMt)
						{
							//非科达终端因特殊情况占用多通道时,前适配不足,不做抢占
							ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]The Mt.(%u,%u) is UnableAjustResMt and VMP VIP channel is full! \
								Since the mt is in %d channels of vmp, the Mt will not enter any channel.\n",
								tMt.GetMcuId(), tMt.GetMtId(), byChnlCount);
							return FALSE;
						}
						else	
						{	
							// 需要抢占提示
							cVmpChgFormatRes.SetSeizePromt(TRUE);
							return FALSE;
						}
						// 占此通道但不占前适配时,清空此通道前适配信息
						tVmpChnnlInfo.ClearChnlByVmpPos(abyChnlNo[0]);
					}
				}
				else //非特殊身份的高清MT，则根据合成风格及通道位置调整分辨率
				{
					//原来是特殊身份，被抢占的情况：释放原来占用的前向适配通道
					if (!bDStream)
					{
						tVmpChnnlInfo.ClearChnlByMt(tRealMt);
					}
					//清除当前此终端所有通道前适配,可能旧的vmp成员在前适配,新Mt不在前适配,按通道清
					for (byIdx=0;byIdx<byChnlCount;byIdx++)
					{
						tVmpChnnlInfo.ClearChnlByVmpPos(abyChnlNo[byIdx]);
					}
					/*if(nRet)
					{
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[GetMtFormatInMpu]Mt.(%u,%u)'s format change: get out of the Hd Channel.\n",
							tMt.GetMcuId(), tMt.GetMtId() );
					}
					else
					{
						// Do nothing
					}*/
				}
//#endif
				if(bNeedAdjustRes)
				{
					byNewFormat = byReqRes;
				}
				else
				{
					byNewFormat = byMtStandardFormat;
				}
				
				//res compare print
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "--------【Mt.(%u,%u) (Channel.%u): Resolution compare】------\n",tMt.GetMcuId(), tMt.GetMtId(), byPos);
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "Original Res: \t%s\n",GetResStr(byMtStandardFormat));
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "Require Res: \t%s\n",GetResStr(byReqRes));
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "======================================================\n");
/*#if defined(_8KE_)
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "Need Adjust: %d \n", bNeedAdjustRes);
#else*/
				if( bNeedAdjust && !bNeedAdjustRes )
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "Need Adjust: \t0 (Enter HD adapter channel)\n");
				}
				else if(!bNeedAdjust)
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "Need Adjust: \t0 \n");
				}
				else
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP,  "Need Adjust: \t1 \n");
				}	
//#endif
			}
		}
    }

	//非科达的就不需发送调分辨率消息了,双流源/IPCMt同样不发送调分辨率消息
	if(bNoneKeda || bDStream || bG400IPCMt)
	{
		cVmpChgFormatRes.SetSendMsg2Mt(FALSE);
	}
	return TRUE;
}


/*====================================================================
    函数名      ：GetMtFpsInVmp
    功能        ：对于进VMP的终端，获取所需调整的帧率
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt						[i] 
				  u8 byRes								[i] 该mt进vmp的分辨率
				  BOOL32 bStart							[i] 是调整还是恢复(default: TRUE)
    返回值说明  ：u8  要调整的帧率（为0表示没有获取到，或不需要调整）
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/01/17	4.6         薛亮		   创建
====================================================================*/
u8 CMcuVcInst::GetMtFpsInVmp(const TMt &tMt, u8 byRes, BOOL32 bStart)
{
	u8 byNewFps = 0;
	TMt tLocalMt = GetLocalMtFromOtherMcuMt( tMt );

	//获得终端帧率
	u8 byChnnlType = LOGCHL_VIDEO;
	TLogicalChannel tLogicChannel;
	if (!m_tConfAllMtInfo.MtJoinedConf( tMt ) ||
		!m_ptMtTable->GetMtLogicChnnl( tLocalMt.GetMtId()/*tMt*/, byChnnlType, &tLogicChannel, FALSE ) )
	{
		return byNewFps;
	}
	u8 byChannlVidFPS = tLogicChannel.GetChanVidFPS();

	//8kh 60/50fps 终端进画面合成,调帧率
	BOOL32 b8KHNeedChangeFps = FALSE;
	if (VMP_8KH == GetVmpSubType(m_tVmpEqp.GetEqpId()))
	{
		if (byChannlVidFPS >= 50)
		{
			b8KHNeedChangeFps = TRUE;
		}
	}
	
	if( b8KHNeedChangeFps || 
		(VIDEO_FORMAT_HD1080 == byRes
		&& byChannlVidFPS >= 50 
		&& ( ( tMt.IsLocal() && IsNeedChangeFpsMt(tMt.GetMtId()) ) 
		|| !tMt.IsLocal()))
		)
	{
		if( !bStart )
		{
			// 恢复帧率
			// [pengjie 2010/9/8] 取会议帧率修改，对于非264的要把MPI值转下
			if( m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H264 )
			{
				byNewFps = m_tConf.GetMainVidUsrDefFPS();
			}
			else
			{
				byNewFps = m_tConf.GetMainVidFrameRate();
				byNewFps = FrameRateMac2Real(byNewFps);
			}
			
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[GetMtFpsInVmp] Recover Fps for mt: %d, Fps: %d !\n",
			tMt.GetMtId(), byNewFps );
		}
		else
		{
			// 降帧率
			byNewFps = byChannlVidFPS/2; // 降为25/30帧
		}
	}

	return byNewFps;
}


/*====================================================================
    函数名      ：GetMtFpsInVmp
    功能        ：对于进VMP的终端，获取所需调整的帧率
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMt						[i] 
				  BOOL32 bStart							[i] 是调整还是恢复

    返回值说明  ：BOOL32 
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	11/01/17	4.6         薛亮		   创建
====================================================================*/
BOOL32 CMcuVcInst::ChgMtFpsInVmp(u8 byVmpId, const TMt &tMt,
								 BOOL32 bStart,
								 u8 byNewFormat
									)
{
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	// 恢复帧率时,无需判断vmpMode
	if (bStart && CONF_VMPMODE_NONE == g_cMcuVcApp.GetVMPMode(tVmpEqp))
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ChgMtFpsInVmp] VMP mode is none.\n");
		return FALSE;
	}

	// MPU2无需降帧率,VPU不走此逻辑
	u8 bySubType = GetVmpSubType(byVmpId);
	if (!tVmpEqp.IsNull() &&
		!(MPU_SVMP == bySubType || VMP_8KE == bySubType || VMP_8KH == bySubType) )
	{
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ChgMtFpsInVmp] tMt do not need to change fps in MPU2.\n");
		return TRUE;
	}
	
	//TMt tMt = m_ptMtTable->GetMt(byMtId);
    if (tMt.IsNull()) 
    {
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ChgMtFpsInVmp] tMt is none.\n");
        return FALSE;
    }
	
    if ( !m_tConf.IsVmpAutoAdapt() )	//当前会议不是画面合成自适应
    {
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ChgMtFpsInVmp] vmp is not AutoAdapt.\n");
        return TRUE;					//无过滤操作，返回之后照进通道，所以返回TURE
    }
	
	if (tMt.GetType() != TYPE_MT)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ChgMtFpsInVmp] dstmt.%d is not mt. type.%d manu.%d\n",
			tMt.GetMtId(), tMt.GetType(), m_ptMtTable->GetManuId(tMt.GetMtId()));
        return FALSE;
	}
	
	u8 byChnnlType = LOGCHL_VIDEO;
	TMt tLocalMt = GetLocalMtFromOtherMcuMt( tMt );
	TLogicalChannel tLogicChannel;
    if ( !m_tConfAllMtInfo.MtJoinedConf( tMt ) ||
		!m_ptMtTable->GetMtLogicChnnl( tLocalMt.GetMtId()/*tMt*/, byChnnlType, &tLogicChannel, FALSE ) )
    {
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ChgMtFpsInVmp] dstmt.%d is not open MtLogicChnnl.\n",tLocalMt.GetMtId());
        return FALSE;
    }
	

	//u8 byNewFormat = tLogicChannel.GetVideoFormat();
	//CVmpChgFormatResult cVmpChgResult;
	//GetMtFormatInMpu(tMt, ptVmpParam, byNewFormat, cVmpChgResult, bStart, bConsiderVmpBrd, bNonKeda);
	u8 byNewFps = GetMtFpsInVmp(tMt, byNewFormat, bStart);
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[ChgMtFpsInVmp] dstmt(%d,%d), NewFps:%d.\n",
		tMt.GetMcuId(), tMt.GetMtId(), byNewFps);
	if( byNewFps != 0 )
	{
		SendChgMtFps(tMt, byChnnlType, byNewFps, bStart);
	}
	
	
	return TRUE;

}
/*====================================================================
    函数名      ChgMtFormatInMpu
    功能        ：分辨率的调整
    算法实现    ：
    引用全局变量：
    输入参数说明：u8 byMtId				:[in] 要调整的终端ID
                  TVMPParam &tVmpParam	:[in] VMP Param
				  BOOL32 bStart			:[in] 是否开始调（区别与恢复分辨率）
				  const TExInfoForInVmpRes &tExInfoForInVmpRes	[in]为确定进画面合成要求分辨率而所需的额外信息
				  u8 &byNewFormat		:[o]  调整成的分辨率 

    返回值说明  ：BOOL32
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	12/10/2008				薛亮	        创建          
====================================================================*/
BOOL32 CMcuVcInst::ChgMtFormatInMpu( TMt &tMt,
									 TVMPParam_25Mem *ptVmpParam,
									 BOOL32 bStart,
                                     const TExInfoForInVmpRes &tExInfoForInVmpRes,
									 u8 &byNewFormat
									 )
{
	
	if ( NULL == ptVmpParam )
    {
        return FALSE;
    }

	//TMt tMt = m_ptMtTable->GetMt(byMtId);
    if (tMt.IsNull()) 
    {
        return FALSE;
    }

    if ( !m_tConf.IsVmpAutoAdapt() )	//当前会议不是画面合成自适应
    {
        return TRUE;					//无过滤操作，返回之后照进通道，所以返回TURE
    }

	if (tMt.GetType() != TYPE_MT)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[ChgMtFormatInMpu] dstmt.%d is not mt. type.%d manu.%d\n",
			tMt.GetMtId(), tMt.GetType(), m_ptMtTable->GetManuId(tMt.GetMtId()));
        return FALSE;
	}

	BOOL32 bConsiderVmpBrd = tExInfoForInVmpRes.m_bConsiderVmpBrd;
	BOOL32 bNonKeda = tExInfoForInVmpRes.m_bNonKeda;
	u8 byMemberType = tExInfoForInVmpRes.m_byMemberType;
	u8 byPos		= tExInfoForInVmpRes.m_byPos; //要调整的通道
	u8 byVmpId		= tExInfoForInVmpRes.m_byVmpId;
	u8 byChnnlType = LOGCHL_VIDEO;
	if (VMP_MEMBERTYPE_DSTREAM == byMemberType)
	{
		byChnnlType = LOGCHL_SECVIDEO;
	}
	TMt tLocalMt = GetLocalMtFromOtherMcuMt( tMt );
	TLogicalChannel tLogicChannel;
    if ( !m_tConfAllMtInfo.MtJoinedConf( tMt ) ||
		!m_ptMtTable->GetMtLogicChnnl( tLocalMt.GetMtId()/*tMt*/, byChnnlType, &tLogicChannel, FALSE ) )
    {
        return FALSE;
    }

	TVmpChnnlInfo tVmpChnnlInfo;
	u8 byMtStandardFormat = tLogicChannel.GetVideoFormat(); // 查找原来建立的分辨率
	CVmpChgFormatResult cVmpChgResult;

	if (!GetMtFormatInMpu(tMt, ptVmpParam, byNewFormat, cVmpChgResult, bStart, bConsiderVmpBrd, bNonKeda, FALSE, byMemberType))
	{
		//抢占提示
		if (cVmpChgResult.IsSeizePromt())
		{
			u8 bySeizeCount = 0; //要抢占的前适配个数
			GetChlOfMtInVmpParam(*ptVmpParam, tMt, bySeizeCount);
			if (MAXNUM_VMP_MEMBER == byPos)
			{
				byPos = ptVmpParam->GetChlOfMtInMember(tMt);
				// 双流跟随时,取双流跟随通道位置
				if (VMP_MEMBERTYPE_DSTREAM == byMemberType)
				{
					byPos = ptVmpParam->GetChlOfMemberType(byMemberType);
				}
			}
			LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChgMtFormatInMpu]MaxHdChnnlNo:%u.\n",
				tVmpChnnlInfo.GetMaxNumHdChnnl());//抢占时,前适配已占满
			LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChgMtFormatInMpu]Mtid:%u,SeizeCount:%u,VmpPos:%d.\n",
					tMt.GetMtId(), bySeizeCount, byPos);
			
			// 通道正常时,做抢占处理
			if (byPos < MAXNUM_VMP_MEMBER)
			{
				SendVmpPriSeizeReq(byVmpId, tMt);
				//记录抢占终端,抢占后调分辨率
				TVmpPriSeizeInfo tPriSeiInfo;
				tPriSeiInfo.m_tPriSeizeMember = *ptVmpParam->GetVmpMember(byPos);
				tPriSeiInfo.m_byChlIdx = byPos;
				g_cMcuVcApp.SetVmpPriSeizeInfo(m_tVmpEqp, tPriSeiInfo);
				//m_tVmpAdaptChnSeizeOpr.m_tMt = tMt;
				//m_atVMPTmpMember[byPos] = *ptVmpParam->GetVmpMember(byPos);
			}
		}
		return FALSE;
	}

	if(!cVmpChgResult.IsSendMsg2Mt())
	{
		return TRUE;
	}

	if( !tMt.IsLocal() ||
		m_ptMtTable->GetMtType( tMt.GetMtId() ) == MT_TYPE_SMCU
		)
	{
		u8 byVmpStyle = ptVmpParam->GetVMPStyle();
		
		TMt tRealSmcuMt = tMt;
		//直接进行级联调分辨率
		if( tMt.IsLocal() && m_ptMtTable->GetMtType( tMt.GetMtId() ) == MT_TYPE_SMCU )
		{
			TConfMcInfo *ptInfo = m_ptConfOtherMcTable->GetMcInfo( GetMcuIdxFromMcuId(tMt.GetMtId()) );
			if(ptInfo != NULL)
			{
                if(ptInfo->m_tMMcuViewMt.IsNull())
                {
                    return TRUE;
                }
				tRealSmcuMt = ptInfo->m_tMMcuViewMt;
                
			}
			else
			{
             			
				if (g_cMcuVcApp.GetVMPMode(m_tVmpEqp) == CONF_VMPMODE_AUTO)
				{
                    //songkun,20110628,级联多回传自动画面合成时，呼入下级MCU，下级MCU作为本地终端参与画面合成，由于此时下级
                    //MCU还没有加入本地会议（OpenLogicalRsp时加入AddMcu），所以取不到其信息
                    ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChgMtFormatInMpu] cascade adj res fail because GetMcInfo is NULL\n");
                    return TRUE;
				}
                else
                {
                    ConfPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[ChgMtFormatInMpu] cascade adj res fail because GetMcInfo is NULL\n");
                    return FALSE;
                }
                
			}

		}

		// byPos为MAXNUM_VMP_MEMBER时表示只调分辨率不做之后的Setvmpchnl处理
		CascadeAdjMtRes( tRealSmcuMt, byNewFormat, bStart, byVmpStyle, byPos, 0, 0, byVmpId);

		//save res 
		TSimCapSet tSpyDstCap;
		if( m_cSMcuSpyMana.GetSpySimCap(tRealSmcuMt, tSpyDstCap) )
		{
			tSpyDstCap.SetVideoResolution(byNewFormat);
			m_cSMcuSpyMana.SaveSpySimCap( tRealSmcuMt, tSpyDstCap);
		}

		return FALSE;
	}
	else
	{
		
		// [pengjie 2010/9/13] 多回传调分辨率逻辑调整
        SendChgMtVidFormat( tMt.GetMtId(), byChnnlType, byNewFormat,FALSE,bStart);
		
		ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP,  "[ChgMtFormatInMpu] chnnl type: %d, send videoformat<%d>(%s) change msg to mt<%d>!\n",
			tLogicChannel.GetChannelType(), byNewFormat, GetResStr(byNewFormat), tMt.GetMtId() );

		// [1/19/2011 xliang] 调帧率独立出去
		/*
		// [pengjie 2010/4/21] 二代高清终端1080p/i，50/60帧，画面合成调整帧率
		if( !bStart )
		{
			// 恢复帧率
			if( IsNeedChangeFpsMt(tMt.GetMtId()) )
			{
				// [pengjie 2010/9/8] 取会议帧率修改，对于非264的要把MPI值转下
				u8 byNewFps = 0;
				if( m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H264 )
				{
					byNewFps = m_tConf.GetMainVidUsrDefFPS();
				}
				else
				{
					byNewFps = m_tConf.GetMainVidFrameRate();
					byNewFps = FrameRateMac2Real(byNewFps);
				}

				SendChangeMtFps( tMt.GetMtId(), byChnnlType, byNewFps );
				
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ChgMtFormatInMpu] Recover Fps for mt: %d, chnnl type: %d, Fps: %d !\n",
					tMt.GetMtId(), byChnnlType, byNewFps );
			}
		}
		else
		{
			// 降帧率
			u8 byChannlVidFPS = tLogicChannel.GetChanVidFPS();
			
			if( byMtStandardFormat == VIDEO_FORMAT_HD1080 
				&& byNewFormat == byMtStandardFormat
				&& byChannlVidFPS >= 50 && IsNeedChangeFpsMt(tMt.GetMtId()) )
			{
				u8 byNewFps = 30; // 降为30帧
				SendChangeMtFps( tMt.GetMtId(), byChnnlType, byNewFps );
				
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[ChgMtFormatInMpu] Change Fps for mt: %d, chnnl type: %d, Fps: %d !\n",
					tMt.GetMtId(), byChnnlType, byNewFps );
			}
		}
		// End*/
		
	}
	
    return TRUE;
}

/*==============================================================================
函数名    :  RecoverMtResInMpu
功能      :  恢复终端的分辨率，同时考虑该Mt在画面合成器中的情况
算法实现  :  
参数说明  :  TMt	tMt	[in]: 要恢复分辨率的终端
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2010-07-19	 4.6           陆昆朋                          修改tmt非local化处理
==============================================================================*/
BOOL32 CMcuVcInst::RecoverMtResInMpu(TMt tMt)
{
	// 此接口未被使用，废除
	if( tMt.IsNull())
	{
		return FALSE;
	}

	if (tMt.GetType() != TYPE_MT)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[RecoverMtResInMpu] dstmt.%d is not mt. type.%d manu.%d\n",
			tMt.GetMtId(), tMt.GetType(), m_ptMtTable->GetManuId(tMt.GetMtId()));
        return FALSE;
	}

	u8 byMtId = tMt.IsLocal() ? tMt.GetMtId() : GetFstMcuIdFromMcuIdx( tMt.GetMcuId() );
	u8 byChnnlType = LOGCHL_VIDEO;
	
    TLogicalChannel tLogicChannel;
    if ( !m_tConfAllMtInfo.MtJoinedConf( byMtId )
		|| !m_ptMtTable->GetMtLogicChnnl( byMtId, byChnnlType, &tLogicChannel, FALSE )
		|| MEDIA_TYPE_H264 != tLogicChannel.GetChannelType()	//目前的调整分辨率均是针对h264
		)
    {
        return FALSE;
    }

	u8 byLogicChannlType = tLogicChannel.GetChannelType();	// 信道类型
    u8 byMtStandardFormat = tLogicChannel.GetVideoFormat(); // 原始分辨率
    u8 byNewFormat = 0;										// 要恢复到的分辨率
	
	//原始分辨率就是CIF，则不用恢复了
	if( VIDEO_FORMAT_CIF == byMtStandardFormat )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[RecoverMtResInMpu] The original resolution is Cif, so no need to recover resolution!\n");
		return FALSE;
	}
	
	BOOL32 bRecoverToOrg = FALSE;
	TVMPParam tVmpParam;
	//该终端是否是在VMP中
	TVMPParam tTempVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
	if(m_tConf.m_tStatus.GetVMPMode() != CONF_VMPMODE_NONE && tTempVmpParam.IsMtInMember(tMt))
	{
		tVmpParam = m_tConf.m_tStatus.GetVmpParam();
		u8 byVmpStyle = tVmpParam.GetVMPStyle();
		u8 byMaxMemberNum = tVmpParam.GetMaxMemberNum();
		u8 byVmpSubType = GetVmpSubType(m_tVmpEqp.GetEqpId());
		//u8 byMaxHdNum = m_tVmpChnnlInfo.GetMaxNumHdChnnl();
		u8 byMaxStyleNum = 0;//m_tVmpChnnlInfo.GetMaxStyleNum();
		/*if ((MPU_SVMP == byVmpSubType /*|| Is8khVmpInConf1080p30fps(m_tConf, m_tVmpEqp.GetEqpId())/) && //MPU处理
			(VMP_STYLE_ONE <= byVmpStyle && byVmpStyle <= VMP_STYLE_FOUR 
			|| VMP_STYLE_SPECFOUR == byVmpStyle) )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[RecoverMtResInMpu] vmp style equal and below to 4 need not adjust resolution further, so recover to its original resolution!\n");
			bRecoverToOrg = TRUE;
		}//MPU2与8kh处理
		else*/ if (byMaxStyleNum >= byMaxMemberNum)
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[RecoverMtResInMpu] vmp style equal and below to %u need not adjust resolution further, so recover to its original resolution!\n",
				byMaxStyleNum);
			bRecoverToOrg = TRUE;
		}
	}
	else
	{
		bRecoverToOrg = TRUE;
	}

	if( bRecoverToOrg )
	{
		byNewFormat = byMtStandardFormat;

		//lukunpeng 2010/07/19 本函数调整加入如果tMt是非本机终端的处理逻辑
		if (!tMt.IsLocal())
		{
			CascadeAdjMtRes( tMt, byNewFormat, FALSE);
		}
		else if (MT_TYPE_SMCU == m_ptMtTable->GetMtType(tMt.GetMtId()))
		{
			//级联调分辨率
			TConfMcInfo* ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(tMt.GetMtId()));
			
			if (ptMcInfo != NULL &&
				!ptMcInfo->m_tMMcuViewMt.IsNull())
			{
				TMt tSrcMt = ptMcInfo->m_tMMcuViewMt;
				CascadeAdjMtRes( tSrcMt, byNewFormat, FALSE);

				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[RecoverMtResInMpu] Cascade change Mt.(%d,%d)'s resolution to it's origin!\n", 
					tSrcMt.GetMcuId(), tSrcMt.GetMtId() );
			}
		}
		else
		{
			// [pengjie 2010/9/13] 多回传调分辨率逻辑调整
            SendChgMtVidFormat( byMtId, byChnnlType, byNewFormat );
// 			CServMsg cServMsg;
// 			cServMsg.SetEventId( MCU_MT_VIDEOPARAMCHANGE_CMD );
// 			cServMsg.SetMsgBody( &byChnnlType, sizeof(u8) );
// 			cServMsg.CatMsgBody( &byNewFormat, sizeof(u8) );
// 			SendMsgToMt( byMtId, cServMsg.GetEventId(), cServMsg );
			
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[RecoverMtResInMpu] chnnl type: %d, send videoformat<%d>(%s) change msg to mt<%d>!\n",
				tLogicChannel.GetChannelType(), byNewFormat, GetResStr(byNewFormat), byMtId );
		}
		
	}
	else
	{
		//ChangeMtVideoFormat( tMt, &tVmpParam, TRUE, FALSE );接口废除
	}

	return TRUE;
}

/*==============================================================================
函数名    :  AddToVmpNeglected
功能      :  把某终端ID加入到VMP成员忽略列表
算法实现  :  
参数说明  :  u8 byMtId	[in]
返回值说明:  void
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2008-12-17					薛亮							创建
==============================================================================*/
void CMcuVcInst::AddToVmpNeglected( u8 byMtId)
{
	if( byMtId == 0 || byMtId > MAXNUM_CONF_MT)return;
	m_abyMtNeglectedByVmp[(byMtId-1) / 8] |= 1 << ( (byMtId-1) % 8 );
}

/*==============================================================================
函数名    :  IsMtNeglectedbyVmp
功能      :  判断某个终端是否在VMP成员忽略列表中
算法实现  :  
参数说明  :  u8 byMtId	[in]
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2008-12-17					薛亮							create
==============================================================================*/
BOOL32 CMcuVcInst::IsMtNeglectedbyVmp( u8 byMtId)
{
	if( byMtId == 0 || byMtId > MAXNUM_CONF_MT)
	{
		return FALSE;
	}
	return ( ( m_abyMtNeglectedByVmp[(byMtId-1) / 8] & ( 1 << ( (byMtId-1) % 8 ) ) ) != 0 );
}

/*====================================================================
    函数名		AdjustVmpParamMember
    功能        ：画面合成成员批量转换
    算法实现    ：
    引用全局变量：
    输入参数说明：TVMPMember *ptVmpMember	[in]画面合成参数
				  u8 byMaxMemberNum			[in]最大成员数
				  TVMPMember *ptVmpMember	[in/out]画面合成扩展参数
				  u8 byMaxMemberExNum		[in]最大成员数
    返回值说明  ：u8 返回真正的画面合成成员数
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/16  4.6			陆昆朋		   Create
====================================================================*/
u8 CMcuVcInst::BatchTransVmpMemberToTVMPMemberEx(TVMPMember *ptVmpMemberArray,  
												   u8 byMaxMemberNum, 
												   TVMPMemberEx *ptVmpMemberExArray, 
												   u8 byMaxMemberExNum)
{
	s8 achAlias[VALIDLEN_ALIAS+1] = {0};

	if (ptVmpMemberArray == NULL || ptVmpMemberExArray == NULL)
	{
		return 0;
	}

	// 取发言人
	TMt tSpeakerMt = m_tConf.GetSpeaker(); 
	
	//只允许终端进入通道，不允许放像设备
	if (tSpeakerMt.GetType() == TYPE_MCUPERI)
	{
		memset(&tSpeakerMt, 0, sizeof(TMt));
	}
	
	// 取主席
	TMt tChairMt = m_tConf.GetChairman();
	
	TVMPMember* ptVmpMember = NULL;
	
	TVMPMemberEx *ptVMPMemberEx = NULL;

	u8 byMember = 0;
	
	for (u8 byLoop = 0; byLoop < byMaxMemberNum && byLoop < byMaxMemberExNum; byLoop++)
	{
		//获取VMP画面合成成员
		ptVmpMember = &ptVmpMemberArray[byLoop];
		
		if (ptVmpMember == NULL /*|| ptVmpMember->IsNull()*/) // 2011-11-10 add by pgf: 非本地终端在VMP前排位置的话，即使是空成员也要算在计数里
		{
			continue;
		}
		
		//获取KDV画面合成成员
		ptVMPMemberEx = &ptVmpMemberExArray[byLoop];
		
		if (ptVMPMemberEx == NULL)
		{
			break;
		}
		
		// 2011-9-20 add by pgf:如果成员是下级终端，设置参数的时候，应该把本地化的终端设过去ptVmpMemberExArray
		// 传出的参数会被ConstructMsgToVmp,　如果设置的还是非本地化的，若是其MTID超过本级现在的最大MTID,导致VPU下参数不成功。
// 		if ( !ptVmpMember->IsLocal())
// 		{
// 			TMt tTmpMt = GetLocalMtFromOtherMcuMt(*ptVmpMember);
// 			ptVMPMemberEx->SetMemberTMt(tTmpMt);
// 		}
// 		else
		{
			ptVMPMemberEx->SetMember(*ptVmpMember); 
		}

		if (tChairMt == *ptVmpMember && ptVmpMember->GetMemberType() != VMP_MEMBERTYPE_SPEAKER )
		{
			ptVMPMemberEx->SetMemStatus(MT_STATUS_CHAIRMAN);
		}
		else if (tSpeakerMt == *ptVmpMember)
		{
			ptVMPMemberEx->SetMemStatus(MT_STATUS_SPEAKER);
		}
		else
		{
			ptVMPMemberEx->SetMemStatus(MT_STATUS_AUDIENCE);
		}
		memset(achAlias, 0, sizeof(achAlias));
		if( GetMtAliasInVmp(*ptVmpMember, achAlias) )
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "vmp member.%d info: mt(%d,%d), alias is %s!\n", byMember, ptVmpMember->GetMcuId(), ptVmpMember->GetMtId(), achAlias);
			ptVMPMemberEx->SetMbAlias( achAlias );
		}
		
		byMember ++;
	}

	return byMember;
}

/*====================================================================
    函数名		AdjustVmpParamMember
    功能        ：画面合成成员根据业务组合做相应的调整
    算法实现    ：
    引用全局变量：
    输入参数说明：TVMPParam *ptVMPParam	[in]画面合成参数
				  u8 byVmpSubType		[in] 画面合成器子类型
				  BOOL32 bStart			[in]是否是开始画面合成
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	2010/07/19	4.6			陆昆朋			created
	2012/01/31	4.7			杨怀志		重整mcs自动合成成员调整
====================================================================*/
void CMcuVcInst::AdjustVmpParamMember(u8 byVmpId, TVMPParam_25Mem *ptVMPParam, u8 byVmpSubType, BOOL32 bStart)
{
	//zhouyiliang 20110106 非法参数处理
	if (NULL == ptVMPParam) 
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[AdjustVmpParamMember] ptVMPParam is null!\n");
		return;
	}
	switch (byVmpSubType)
	{
	case VMP:
	case MPU_SVMP:
	case MPU2_VMP_ENHACED:
	case MPU2_VMP_BASIC:
	default:
		{
			// 取发言人
			TMt tSpeakerMt = m_tConf.GetSpeaker(); 
			TMt tLocalSpeakerMt = GetLocalMtFromOtherMcuMt(tSpeakerMt);

			//只允许终端进入通道，不允许放像设备
			if (tSpeakerMt.GetType() == TYPE_MCUPERI)
			{
				memset(&tSpeakerMt, 0, sizeof(TMt));
			}

			// 取主席
			TMt tChairMt = m_tConf.GetChairman();
			TMt tLocalChairMt = GetLocalMtFromOtherMcuMt(tChairMt);

			u8	byMemberNum = ptVMPParam->GetMaxMemberNum();	//当前风格下能够参加的最大成员数
			u8 byMember = 0;								//实际参加VMP的成员数

			TVMPMember* ptVmpMember = NULL;
            LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpParamMember]line:%d, Vmp(%d),MaxMemberNum:%u\n"
                                ,__LINE__, byVmpId, byMemberNum);
			// 对于VCS会议画面合成成员选定
			if (VCS_CONF == m_tConf.GetConfSource())
			{
				TMt atVmpMember[MAXNUM_VMP_MEMBER];
				memset(atVmpMember, 0, sizeof(TMt) * MAXNUM_VMP_MEMBER);
				if (ptVMPParam->IsVMPAuto())
				{
					u8 byStyle = GetVCSAutoVmpMember(byVmpId, atVmpMember);
					if (byStyle != VMP_STYLE_NONE)
					{
						ptVMPParam->SetVMPStyle(byStyle);
						byMemberNum = ptVMPParam->GetMaxMemberNum();//可能改变风格了
					}
				}
				else
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[AdjustVmpParamMember]only auto vmp to vcs currently");
					return;
				}
				
				for (u8 byLoop = 0; byLoop < byMemberNum; byLoop++)
				{
					if (!atVmpMember[byLoop].IsNull() &&
						m_tConfAllMtInfo.MtJoinedConf(atVmpMember[byLoop].GetMcuId(), atVmpMember[byLoop].GetMtId()))
					{
						ptVmpMember = ptVMPParam->GetVmpMember(byMember);

						if (ptVmpMember == NULL)
						{
							continue;
						}
						ptVmpMember->SetMemberTMt(atVmpMember[byLoop]);
						ptVmpMember->SetMemStatus(MT_STATUS_AUDIENCE);
						byMember ++;
					}
					else if ( atVmpMember[byLoop].IsNull() ) 
					{
						//清空调整后本来这个位置为空，ptVMPParam不为空的情况
						ptVMPParam->ClearVmpMember( byLoop );
					}
					
				}
			}
			else
			{
				if(ptVMPParam->IsVMPAuto())
				{
				/*  场景:单级会议,有5个非科达终端,开启自动画面合成,
					若抢占的是MPU2BASIC,显示6画面,前4个通道有终端,后两个无终端.
					若抢占的是MPU,显示6画面,前3个通道有终端,后3个无终端.
					目的:找到最恰当的合成风格,避免vmp通道浪费.
					方法:
					1.20终端以上,20画面前适配不足情况下,踢出最后一个需调分辨率的非科达终端,补入后面终端,重新判断.
					2.不足20终端时,前适配不足情况下,踢出最后一个需调分辨率非科达终端,调整风格后重新判断.*/
					BOOL32 bMemberOverFlow = FALSE;
					//u8 byMtNum = m_tConfAllMtInfo.GetLocalJoinedMtNum(); //本级终端个数
					u8 byMtNum = 0; //yhz终端在线但后向通道未开时不进vmp,取本级终端个数不妥
					u8 byAdjustStyle = VMP_STYLE_NONE;	//要调整的风格
					u8 byMtNumInVmp	= 0;				//记录进入vmp的终端个数
					u8 abyMtIdList[MAXNUM_CONF_MT+1];	//以链表形式记录会议中mtid
					BOOL32 bAdjustOver = FALSE;			//记录调整是否结束
					u8 byOldStyle = VMP_STYLE_NONE;		//记录旧的风格,用于风格切换
					u8 byChnnlType = LOGCHL_VIDEO;   
					TLogicalChannel tLogicChannel;
					// 获得超然终端是否可以进vmp,仅在auto时用,默认不进vmp
					BOOL32 bIsChaoRanMTAllowInVmp = g_cMcuVcApp.IsChaoRanMtAllowInVmpChnnl();
					// 调整终端占前适配时，判断是否忽略画面合成广播,除非是开启带广播的vmp时才不忽略
					BOOL32 bConsiderVmpBrd = FALSE;
					if (bStart && ptVMPParam->IsVMPBrdst())
					{
						bConsiderVmpBrd = TRUE;
					}

					// 创建MtId链表,用于按顺序将Mt加入Vmp,及20终端以上踢出不合适终端并将后续终端补入处理
					u8 byTmpMtId = 0;
					u8 byMtId = 0;
					memset(abyMtIdList, 0, sizeof(abyMtIdList));
					for (byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
					{
						// 跳过vrs新录播实体
						if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
						{
							continue;
						}
						if (m_tConfAllMtInfo.MtJoinedConf(byMtId)
							&& (m_ptMtTable->GetMtLogicChnnl( byMtId, byChnnlType, &tLogicChannel, FALSE ) || IsPhoneMt(m_ptMtTable->GetMt(byMtId)))
							&& (bIsChaoRanMTAllowInVmp || MT_MANU_CHAORAN != m_ptMtTable->GetManuId(byMtId))
							)
						{
							// 将前一个元素指向此元素
							abyMtIdList[byTmpMtId] = byMtId;
							byTmpMtId = byMtId;

							byMtNum++;//记录进入vmp终端个数
						}
					}
					
					// 发言人是超然Mt
					BOOL32 bIsSpeakerChaoRan = FALSE;
					if( !tSpeakerMt.IsNull() && !bIsChaoRanMTAllowInVmp)
					{
						u8 byManuID = MT_MANU_KDC;
						if(tSpeakerMt.IsLocal())
						{
							byManuID = m_ptMtTable->GetManuId(tSpeakerMt.GetMtId());
						}
						else
						{
							TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tSpeakerMt.GetMcuIdx());
							if (NULL != ptMcInfo)
							{
								if (ptMcInfo->GetMtExt(tSpeakerMt))
								{
									byManuID = ptMcInfo->GetMtExt(tSpeakerMt)->GetManuId(); 
								}
							}
						}
						bIsSpeakerChaoRan = (byManuID == MT_MANU_CHAORAN);
					}

					// [7/2/2010 xliang] 区分单回传/多回传, 确定是否要将下级发言终端算进此次合成成员
					if( !tSpeakerMt.IsNull() && m_tConfAllMtInfo.MtJoinedConf(tSpeakerMt)
						&& (m_ptMtTable->GetMtLogicChnnl( tLocalSpeakerMt.GetMtId(), byChnnlType, &tLogicChannel, FALSE ) || IsPhoneMt(tSpeakerMt))
						&& !tSpeakerMt.IsLocal() 
						&& !bIsSpeakerChaoRan)
					{
						if( IsLocalAndSMcuSupMultSpy(tSpeakerMt.GetMcuId()) )
						{
							byMtNum ++;
							if( byMtNum > MAXNUM_VMP_MEMBER )
							{
								bMemberOverFlow = TRUE;
							}
						}
					}
					
					//大于20终端场景:按20画面风格,取前20个终端(包含发言人、主席),
					//小于等于20终端场景:按终端个数n取画面风格
					if (!bStart)
					{
						byAdjustStyle = GetVmpDynStyle(byVmpId, byMtNum);
						if(byAdjustStyle != VMP_STYLE_NONE)
						{
							ptVMPParam->SetVMPStyle( byAdjustStyle );
							byMemberNum = ptVMPParam->GetMaxMemberNum();
						}
						else
						{
							ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[AdjustVmpParamMember] GetVmpDynStyle error. byMtNum is %u!\n", byMtNum);
							return;
						}
					}
					else if (byMtNum < byMemberNum)//开启时,如果有终端后向通道未开,根据终端个数算的风格可能有误,需要刷新下
					{
						byAdjustStyle = GetVmpStylebyMtNum(byMtNum);
						if(byAdjustStyle != VMP_STYLE_NONE)
						{
							ptVMPParam->SetVMPStyle( byAdjustStyle );
							byMemberNum = ptVMPParam->GetMaxMemberNum();
						}
					}
					//记录进入vmp的终端个数
					byMtNumInVmp = byMtNum > byMemberNum ? byMemberNum : byMtNum;
					
					//先清理成员
					for (u8 byMemberLoop=0; byMemberLoop<MAXNUM_VMP_MEMBER; byMemberLoop++)
					{
						ptVMPParam->ClearVmpMember(byMemberLoop);
					}

					//先填发言人，再填主席，再填观众
					if(!tSpeakerMt.IsNull() && m_tConfAllMtInfo.MtJoinedConf(tSpeakerMt)
						&& (m_ptMtTable->GetMtLogicChnnl( tLocalSpeakerMt.GetMtId(), byChnnlType, &tLogicChannel, FALSE ) || IsPhoneMt(tSpeakerMt))
						&& !bIsSpeakerChaoRan)
					{
						ptVmpMember = ptVMPParam->GetVmpMember(byMember);
                        LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpParamMember]line:%d, ptVmpMember GetMtId()=%u,GetMemberType()=%u\n"
                                ,__LINE__,ptVmpMember->GetMtId(),ptVmpMember->GetMemberType());
						if (ptVmpMember != NULL)
						{
							ptVmpMember->SetMemberTMt(tSpeakerMt);
							ptVmpMember->SetMemStatus(MT_STATUS_SPEAKER);
							ptVmpMember->SetMemberType(VMP_MEMBERTYPE_SPEAKER);
							byMember ++;
						}
					}
					if(!tChairMt.IsNull() &&
						!(tChairMt == tSpeakerMt) &&
						m_tConfAllMtInfo.MtJoinedConf(tChairMt) 
						&& (m_ptMtTable->GetMtLogicChnnl( tChairMt.GetMtId(), byChnnlType, &tLogicChannel, FALSE ) || IsPhoneMt(tChairMt))
						&& (bIsChaoRanMTAllowInVmp || MT_MANU_CHAORAN != m_ptMtTable->GetManuId(tChairMt.GetMtId()))
						)
					{
						ptVmpMember = ptVMPParam->GetVmpMember(byMember);
                        LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpParamMember]line:%d, ptVmpMember GetMtId()=%u,GetMemberType()=%u\n"
                                ,__LINE__,ptVmpMember->GetMtId(),ptVmpMember->GetMemberType());
						if (ptVmpMember != NULL)
						{
							ptVmpMember->SetMemberTMt(tChairMt);
							ptVmpMember->SetMemStatus(MT_STATUS_CHAIRMAN);
							ptVmpMember->SetMemberType(VMP_MEMBERTYPE_CHAIRMAN);
							byMember ++;
						}
					}
					// 根据MtId链表,填入Vmp成员
					BOOL32 bAddMember = FALSE;
					u8 byRes = VIDEO_FORMAT_INVALID;
					CVmpChgFormatResult cVmpChgFormatResult;
					u8 byChlNum = 0;
					TVMPMember tTmpMember;
					tTmpMember.SetNull();
					TMt tLocalTmpMt;
					TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
					//TVmpChnnlInfo tVmpChnnlInfo = g_cMcuVcApp.GetVmpChnnlInfo(tVmpEqp);
					for (byMtId=abyMtIdList[0]; byMtId!=0; byMtId=abyMtIdList[byMtId])
					{
                        //20110531,songkun,自动画面合成模式，新呼入终端时，需自动进入画面合成，风格改变
						// 2011-11-10 add by pgf;极限值要考虑，最多只能0~19通道
                        if (byMember > byMemberNum || byMember >= MAXNUM_VMP_MEMBER)
                        {
                            //数量溢出
                            break;
						}
						//if (m_ptMtTable->GetMtLogicChnnl( byMtId, byChnnlType, &tLogicChannel, FALSE ))
						{
							bAddMember = TRUE;
							if (byMtId == tLocalChairMt.GetMtId())
							{
								// 主席在前面
								bAddMember = FALSE;
							}

							// [pengjie 2010/3/31] 多回传支持,如果发言人是本地的话才做此判断
							//zhouyiliang 20100928 不区分单回传/多回传,不做本地化
							if( !tSpeakerMt.IsLocal() &&
								!IsLocalAndSMcuSupMultSpy(tSpeakerMt.GetMcuId()) 
								)
							{
								if (byMtId == GetLocalSpeaker().GetMtId() &&
									GetLocalSpeaker().GetType() != TYPE_MCUPERI)
								{
									// 发言人在前面
									bAddMember = FALSE;
								}
							}
							
							// [7/2/2010 xliang] 多回传情况下：当在线终端数超过实际风格承受的数目时,
							// 下级做全局发言人的终端所在的MCU将不参与合成成员。
							if( bMemberOverFlow &&
								( !tSpeakerMt.IsNull() && !tSpeakerMt.IsLocal() ) &&
								(m_ptMtTable->GetMt( byMtId ) == tLocalSpeakerMt) 
								)
							{
								bAddMember = FALSE;
							}

							//zhouyiliang 20100930 切换mcu做全局发言人，该mcu不应该再进画面合成
							if ( !tSpeakerMt.IsNull() && tSpeakerMt.IsLocal() 
								&& m_ptMtTable->GetMt( byMtId ) == tSpeakerMt ) 
							{
								bAddMember = FALSE;
							}

							if (bAddMember)
							{
								ptVmpMember = ptVMPParam->GetVmpMember(byMember);
								LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpParamMember]line:%d, ptVmpMember GetMtId()=%u,GetMemberType()=%u\n"
									,__LINE__,ptVmpMember->GetMtId(),ptVmpMember->GetMemberType());
								if (ptVmpMember != NULL)
								{
									ptVmpMember->SetMemberTMt(m_ptMtTable->GetMt(byMtId));
									ptVmpMember->SetMemStatus(MT_STATUS_AUDIENCE);
									ptVmpMember->SetMemberType(VMP_MEMBERTYPE_VAC);
									LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpParamMember]line:%d, Set %u ptVmpMember GetMtId()=%u,GetMemberType()=%u\n"
										,__LINE__,byMember,ptVmpMember->GetMtId(),ptVmpMember->GetMemberType());
									byMember ++;
								}
							}

							// 填好成员后,如果所有成员都能正常显示,结束调整.不然就继续调整,直到满足
							// 可能最后一个Mt是主席或其它需要忽略的Mt,导致byMember提前满足byMtNumInVmp,
							// 但abyMtIdList[byMtId]又不为0,不能执行do-while处理,用bAddMember规避.
							if (byMember == byMtNumInVmp &&
								((bAddMember && byMtNum > byMtNumInVmp) || 0==abyMtIdList[byMtId]))
							{
								do 
								{
									//初始化前适配信息
									//tVmpChnnlInfo.clearHdChnnl();
									g_cMcuVcApp.ClearVmpAdpHdChl(tVmpEqp);
									// 前适配个数大于等于当前风格通道数,调整结束
									if (g_cMcuVcApp.GetVmpAdpMaxStyleNum(tVmpEqp) >= byMemberNum //MPU四画面及以下不用进前适配
										|| VMP_8KE == byVmpSubType)// 8kgVMP无前适配
									{
										bAdjustOver = TRUE;
										break;
									} 
									else
									{
										//小于当前风格通道数,从前向后查找需进前适配成员
										for (byChlNum=0; byChlNum<byMemberNum; byChlNum++)
										{
											// 加保护,防止返回指针为空
											if (NULL == ptVMPParam->GetVmpMember(byChlNum)) {
												tTmpMember.SetNull();
											} else {
												tTmpMember = *ptVMPParam->GetVmpMember(byChlNum);
											}
											if (!tTmpMember.IsNull())
											{
												GetMtFormat(byVmpId, tTmpMember, ptVMPParam, byRes, bConsiderVmpBrd);
												//前适配已满,停止查找
												//if (tVmpChnnlInfo.GetHDChnnlNum() == tVmpChnnlInfo.GetMaxNumHdChnnl())
												if (g_cMcuVcApp.GetVmpAdpHDChlNum(tVmpEqp) == g_cMcuVcApp.GetVmpAdpMaxNumHdChl(tVmpEqp))
												{
													break;
												}
											}
										}
										//前适配未满,调整结束
										//if (tVmpChnnlInfo.GetHDChnnlNum() < tVmpChnnlInfo.GetMaxNumHdChnnl())
										if (g_cMcuVcApp.GetVmpAdpHDChlNum(tVmpEqp) < g_cMcuVcApp.GetVmpAdpMaxNumHdChl(tVmpEqp))
										{
											bAdjustOver = TRUE;
											break;
										}
										
										do
										{
											//从后向前查找,找到第一个非科达终端/PU终端,若其在前适配中,调整结束
											for (byChlNum=byMemberNum-1; byChlNum>0; byChlNum--)
											{
												// 加保护,防止返回指针为空
												if (NULL == ptVMPParam->GetVmpMember(byChlNum)) {
													tTmpMember.SetNull();
												} else {
													tTmpMember = *ptVMPParam->GetVmpMember(byChlNum);
												}
												tLocalTmpMt = GetLocalMtFromOtherMcuMt(tTmpMember); //可能是发言人，下级终端
												if (!tTmpMember.IsNull() && (!IsKedaMt(tTmpMember, TRUE) || IsG400IPCMt(tTmpMember))
													&& m_ptMtTable->GetMtLogicChnnl( tLocalTmpMt.GetMtId(), byChnnlType, &tLogicChannel, FALSE )
													&& !GetMtFormat(byVmpId, tTmpMember, ptVMPParam, byRes))
												{
													break;
												}
											}
											if (byChlNum == 0 || 
												//tVmpChnnlInfo.GetChnlCountByMt(tTmpMember) > 0)
												g_cMcuVcApp.GetVmpAdpChnlCountByMt(tVmpEqp, tTmpMember) > 0)
											{
												bAdjustOver = TRUE;
												break;
											}
											//如果此非科达终端不在前适配中,需将其剔除并调整vmp成员
											ptVMPParam->ClearVmpMember(byChlNum);
											for ( ; byChlNum<byMemberNum; byChlNum++)
											{
												//将byChlNum之后的成员全都向前移动一个位置
												ptVMPParam->SetVmpMember(byChlNum, *ptVMPParam->GetVmpMember(byChlNum+1));
											}
											//空出最后一个位置
											ptVMPParam->ClearVmpMember(byChlNum);
											byMember--;

											//MtId链表之后无成员,无需后续补入
											if (0 == abyMtIdList[byMtId])
											{
												byMtNumInVmp--; //进入vmp的成员个数减一
												//更新vmp合成风格,
												byOldStyle = byAdjustStyle;
												byAdjustStyle = GetVmpStylebyMtNum(byMtNumInVmp);
												if(byAdjustStyle != VMP_STYLE_NONE)
												{
													ptVMPParam->SetVMPStyle( byAdjustStyle );
													byMemberNum = ptVMPParam->GetMaxMemberNum();
												}
											}
											else
											{
												// MtId链表之后有成员,需要将后续终端补入,继续for循环添加新的mt.
											}
										// 新旧风格相同,且未调整结束时,继续从后向前找非科达终端
										} while(!bAdjustOver && 0 == abyMtIdList[byMtId] && byOldStyle == byAdjustStyle);
									}
								// 风格改变后,需要继续调整.
								} while (!bAdjustOver && 0 == abyMtIdList[byMtId]);
							}
							//调整结束
							if (bAdjustOver)
							{
								break;
							}
						}
					}
					/*20100729 zhouyiliang 自动画面合成的情况，取消发言人的时，style还是会保持原来的
					//此时应该再设置一下，保证style正确
					if ( byMember > MAXNUM_VMP_MEMBER )//加个保护 
					{
						byMember = MAXNUM_VMP_MEMBER;
					}
					u8 byStyle = GetVmpDynStyle( byMember );
					if( byStyle != VMP_STYLE_NONE )
					{
						ptVMPParam->SetVMPStyle( byStyle );
					}
					//zhouyiliang 20100915保护从6画面到5画面,13到12等，style不变的情况下，清掉上次残留的最后的合成成员
					for ( u8 byMemberLoop = byMember; byMemberLoop < ptVMPParam->GetMaxMemberNum(); byMemberLoop++ ) 
					{
						ptVMPParam->ClearVmpMember( byMemberLoop );                                
					}*/
					
				}
				else
				{
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[AdjustVmpParamMember] no need to adjust for mcs custom vmp\n");
					return;
				}
			}
		}
		break;
	}
}

/*====================================================================
    函数名      AdjustVmpParam
    功能        ：画面合成参数改变
    算法实现    ：
    引用全局变量：
    输入参数说明：TVMPParam *ptVMPParam	[in]画面合成参数
				  BOOL32 bStart			[in]是否是开始画面合成, default: FALSE
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
05/18/2009		4.6			薛亮			create				
10/02/28		            薛亮			支持8000E			
====================================================================*/
void CMcuVcInst::AdjustVmpParam(u8 byVmpId, TVMPParam_25Mem *ptVMPParam, BOOL32 bStart, BOOL32 bNeedPreSetIn)

{
	if (!IsValidVmpId(byVmpId))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[AdjustVmpParam] it hasn't assign correct vmp(id:%d) yet\n", byVmpId);
		return;
	}
	u8 byVmpTimerIdx = byVmpId - VMPID_MIN;

	if (ptVMPParam == NULL)
	{
		return;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	TPeriEqpStatus tPeriEqpStatus; 
	BOOL32 bGetStatus = g_cMcuVcApp.GetPeriEqpStatus( byVmpId, &tPeriEqpStatus );
	if( bGetStatus 
		&& ( TVmpStatus::WAIT_STOP == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState ||
			 TVmpStatus::IDLE == tPeriEqpStatus.m_tStatus.tVmp.m_byUseState)
			 )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[AdjustVmpParam] vmp[%d] state.%d is not correct, so return here\n",
			byVmpId, tPeriEqpStatus.m_tStatus.tVmp.m_byUseState);
		return;
	}
	//获取画面合成器子类型
	u8 byVmpSubType = GetVmpSubType(byVmpId);

	if (bNeedPreSetIn)
	{
		//根据类型做相应的成员调整
		AdjustVmpParamMember(byVmpId, ptVMPParam, byVmpSubType, bStart);
		
		//画面合成级联多回传处理
		BOOL32 bSendPreSetIn = FALSE;
		if (!SendPreSetInReqForVmp(tVmpEqp, ptVMPParam, bStart, bSendPreSetIn))
		{
			// 可能发送异常，不继续处理
			return;
		}
		
		//如果有新的VMP成员，下级回PreSetInACK时候再操作
		if (bSendPreSetIn)
		{
			//zhouyiliang20100910 先不保存到会议vmpparam中，将合成成员更新到TPeriEqpStatus中
			//presetinAck成功取TPeriEqpStatus中的vmpparam调整好后设置会议vmpparam，避免时序问题
			g_cMcuVcApp.GetPeriEqpStatus( tVmpEqp.GetEqpId(), &tPeriEqpStatus );
			tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(*ptVMPParam);
			g_cMcuVcApp.SetPeriEqpStatus( tVmpEqp.GetEqpId(), &tPeriEqpStatus );
			//zhouyiliang 20110613 判断是否本次请求只有下级发presetinreq的终端,开启全下级成员时使用此timer
			if ( ptVMPParam->GetVMPMemberNum() == 0 && bStart) 
			{
				SetTimer(MCUVC_WAIT_ALLVMPPRESETIN_ACK_TIMER+byVmpTimerIdx,TIMESPACE_WAIT_ALLVMPPRESETIN_ACK);
				return;
			}
			
			//change时等PresetinAck调整vmp
			if (!bStart)
			{
				return;
			}
		}
	}

	KillTimer(MCUVC_WAIT_ALLVMPPRESETIN_ACK_TIMER+byVmpTimerIdx);

	// 给合成器外设下参
	ChangeVmpParam(byVmpId, ptVMPParam, bStart);
}


BOOL32 CMcuVcInst::VidResAdjust(u8 byVmpId, u8 byVmpStyle, u8 byPos, u8 byMtStandardFormat, u8 &byReqRes)
{
	if (!IsValidVmpId(byVmpId))
	{
		return FALSE;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );

	u16 wBR = 0;		//bitrate
	s32 nResCmpRst = 3;	//3 indicate no meaning for comparing resolution
	BOOL32 bNeedAdjRst = FALSE;
	u8	byVmpSubtype = GetVmpSubType(tVmpEqp.GetEqpId());
	
	BOOL32 bHdBaseMap =		( m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 
							|| m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD720 );
	// mpu2只用1080底图，标清会议同样走1080底图
	if (MPU2_VMP_BASIC == byVmpSubtype || MPU2_VMP_ENHACED == byVmpSubtype)
	{
		bHdBaseMap = TRUE;
	}
	if(bHdBaseMap)
	{
		g_cMcuVcApp.m_cVmpMemVidLmt.GetMtVidLmtForHd(byVmpStyle, byPos, byReqRes, wBR);
		//高清会议,mpu与mpu2第0通道按VIDEO_FORMAT_HD1080分辨率,媒控占用
		if (0 == byPos)
		{
			if (MPU_SVMP == byVmpSubtype ||
				MPU2_VMP_BASIC == byVmpSubtype ||
				MPU2_VMP_ENHACED == byVmpSubtype)
			{
				byReqRes = VIDEO_FORMAT_HD1080;
			}

			// 8khvmp 由于之前版本8风格0通道是按720分辨率，此处仍保持不变，下版测试通过后再恢复1440x816
			// 8kivmp 按照规格1440x816分辨率设置
			if(VMP_8KH == byVmpSubtype && byVmpStyle == VMP_STYLE_EIGHT)
			{
				byReqRes = VIDEO_FORMAT_HD720;
			}
		}
	}
	else
	{
		g_cMcuVcApp.m_cVmpMemVidLmt.GetMtVidLmtForStd(byVmpStyle, byPos, byReqRes, wBR);
	}

	if( byReqRes == 0 )
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[VidResAdjust] byReqRes is unexpected 0, let's change it to cif!");
		byReqRes = VIDEO_FORMAT_CIF;
	}
	nResCmpRst = ResWHCmp(byMtStandardFormat,byReqRes);
	
	if( nResCmpRst == 2		//value 2 indicates the former resolution is bigger than the latter both in width and height.
		|| nResCmpRst == -1 //value -1 indicates the former resolution is only bigger in height
		|| nResCmpRst == 1	//value 1 indicates the former is only bigger in width
		)
	{
		bNeedAdjRst = TRUE;
	}

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "Original Res :%s,",GetResStr(byMtStandardFormat));
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "require Res: %s,", GetResStr(byReqRes));
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "Compare result(1/0) is: %d \n", bNeedAdjRst);

	return bNeedAdjRst;
}
/*==============================================================================
函数名    :  AdjustVmpParambyMemberType
功能      :  VMP发言人跟随，轮询跟随调整
算法实现  :  新的发言人已经在vmp某个不是发言人跟随的通道里，则将其挪位到发言人跟随通道，
		     原来占的通道位置清空,并做历史记录，待下次又有新发言人做恢复
参数说明  :  
返回值说明:  void
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2009-3-20					薛亮							create
==============================================================================*/
void CMcuVcInst::AdjustVmpParambyMemberType(u8 byVmpId, const TMt *ptSpeaker, TVMPParam_25Mem &tVmpParam, const u8& byMemberType ,const TMt *ptOldSrc)
{
	// 此函数仅用于不支持终端进vmp多通道时的发言人跟随特殊处理,终端能进vmp多通道无需此处理
	if (IsAllowVmpMemRepeated(byVmpId))
	{
		return;
	}
	
	TMt tMt;
	//只允许终端进入通道，不允许放像设备
	if (ptSpeaker == NULL || ptSpeaker->GetType() == TYPE_MCUPERI || IsVrsRecMt(*ptSpeaker))
	{ 
		tMt.SetNull();
	}
	else
	{
		tMt = *ptSpeaker;
	}
	// 获得旧发言人
	TMt tOldSrc;
	if (NULL != ptOldSrc && !ptOldSrc->IsNull() && TYPE_MCUPERI != ptOldSrc->GetType())
	{
		tOldSrc = *ptOldSrc;
	}
	// 新旧发言人相同时,不做处理
	if (tMt == tOldSrc)
	{
		LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[AdjustVmpParambyMemberType]OldSpeaker[%d,%d] is equal to NewSpeaker[%d,%d], vmp need not update.\n",
			tOldSrc.GetMcuIdx(), tOldSrc.GetMtId(), tMt.GetMcuIdx(), tMt.GetMtId());
		return;
	}

	u8 bytmpLastSpeakerVmpChnnl = ~0; //初始化为无意义值
	u8 bytmpLastVmpMemberType	= 0;
	//新的发言人已经在vmp某个不是发言人跟随的通道里，则将其挪位到发言人跟随通道
	//原来占的通道位置清空,并做历史记录，待下次又有新发言人做恢复
	u8 bySpeakerVmpChl = ~0;
	if (!tMt.IsNull())
	{
		// 直接取新发言人在vmp中的位置
		bySpeakerVmpChl = tVmpParam.GetChlOfMtInMember(tMt);
		if (MAXNUM_VMP_MEMBER != bySpeakerVmpChl)
		{
			if (tVmpParam.GetVmpMember(bySpeakerVmpChl)->GetMemberType() != byMemberType)
			{
				bytmpLastSpeakerVmpChnnl = bySpeakerVmpChl;
			}
		}
		else
		{
			// 发言人可能是mcu,需查找其上传终端位置,直接清理,不做恢复
			u8 byChlCount = 0;
			u8 abyChnlNo[MAXNUM_VMP_MEMBER];
			GetChlOfMtInVmpParam(tVmpParam, tMt, byChlCount, abyChnlNo);
			for (u8 byIdx=0; byIdx<byChlCount; byIdx++)
			{
				if (tVmpParam.GetVmpMember(abyChnlNo[byIdx])->GetMemberType() != byMemberType)
				{
					// 要调整vmp,在ChangeVmpSwitch处理中自会清交换,此处无需清
					//StopSwitchToPeriEqp(m_tVmpEqp.GetEqpId(), abyChnlNo[byIdx], TRUE, MODE_VIDEO);
					tVmpParam.ClearVmpMember(abyChnlNo[byIdx]);
				}
			}
		}
	}
	
	// 20120604 yhz 标记
	//若后续MPU与8khvmp也支持vmp单通道轮询,改变发言人时,若新发言人是vmp通道当前轮询Mt,不做关通道记录处理,
	//立即找下一个要轮询终端,更新轮询终端,若找不到,则停止vmp单通道轮询.
	//此处不通过Timer触发（因Timer会单独调AdjustVmpParam），直接找到成员，更新当前轮询终端与vmp通道成员。

	// bytmpLastSpeakerVmpChnnl有效时,原来占的通道位置清空,并做历史记录，待下次又有新发言人做恢复
	if (bytmpLastSpeakerVmpChnnl < MAXNUM_VMP_MEMBER)
	{
		TVMPMember tTmpMember = *tVmpParam.GetVmpMember(bytmpLastSpeakerVmpChnnl);
		StopSwitchToPeriEqp(m_tVmpEqp.GetEqpId(), bytmpLastSpeakerVmpChnnl, TRUE, MODE_VIDEO);
		tVmpParam.ClearVmpMember(bytmpLastSpeakerVmpChnnl);
		bytmpLastVmpMemberType = tTmpMember.GetMemberType();
	}

	// 处理发言人跟随通道MEMBERTYPE_SPEAKER
	u8 byMemTypeSpeakerChl = tVmpParam.GetChlOfMemberType(byMemberType);
	if (MAXNUM_VMP_MEMBER != byMemTypeSpeakerChl)
	{
		TVMPMember tVmpMember;
		//发言人跟随通道先清空
		//StopSwitchToPeriEqp(byVmpId, byMemTypeSpeakerChl, TRUE, MODE_VIDEO);
		tVmpParam.ClearVmpMember(byMemTypeSpeakerChl);
		
		/*之前存在该让位MT的历史通道记录，则让该MT恢复到历史通道中
		if(m_tLastVmpChnnlMemInfo.GetLastVmpMemChnnl() < MAXNUM_MPUSVMP_MEMBER) 
		{
			//历史通道中成员为空才恢复
			if( (tVmpParam.GetVmpMember(m_tLastVmpChnnlMemInfo.GetLastVmpMemChnnl())->IsNull())
				&& (!tOldSrc.IsNull())
				&& (!tVmpParam.IsMtInMember(tOldSrc)) //也不能与其他通道里的重复
				)
			{
				u8 byLastVmpMemType = m_tLastVmpChnnlMemInfo.GetLastVmpMemType();
				u8 byChlOfMemberType = MAXNUM_VMP_MEMBER;
				if (VMP_MEMBERTYPE_MCSSPEC != byLastVmpMemType)
				{
					byChlOfMemberType = tVmpParam.GetChlOfMemberType(byLastVmpMemType);
				}
				// [2/5/2010 xliang] 放开下面限制
				// [11/25/2009 xliang] 单回传，不允许2个下级终端同时回传，所以此处恢复对此进行限制
				// 若旧发言人是mcu,新发言人是该mcu下级终端,且不支持多回传,也不要恢复
				if (tOldSrc.IsLocal() && IsMcu(tOldSrc) && IsMtInMcu(tOldSrc, tMt) && !IsLocalAndSMcuSupMultSpy(tOldSrc.GetMtId()))
				{
					// 不做恢复
				}
				// 若要恢复的通道是跟随通道,且当前vmpparam中已有此跟随通道,不能再恢复
				else if (MAXNUM_VMP_MEMBER != byChlOfMemberType)
				{
					// 不做恢复
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[AdjustVmpParambyMemberType] LastVmpMemType:%d, byChlOfMemberType:%d, Cannot be restored.\n",
						byLastVmpMemType, byChlOfMemberType);
				}
				else if ((!tOldSrc.IsLocal() && IsLocalAndSMcuSupMultSpy(tOldSrc.GetMcuId()))
					|| tOldSrc.IsLocal() || tMt.IsLocal())
				{
					tVmpMember.SetMemberTMt(tOldSrc); //恢复的就只可能是旧发言人
					tVmpMember.SetMemberType(m_tLastVmpChnnlMemInfo.GetLastVmpMemType());
					tVmpParam.SetVmpMember(m_tLastVmpChnnlMemInfo.GetLastVmpMemChnnl(), tVmpMember);
				}
			}
		}*/
		
		// 新发言人放到发言人跟随通道中
		tVmpMember.SetMemberTMt(tMt);
		tVmpMember.SetMemberType(byMemberType);
		tVmpParam.SetVmpMember(byMemTypeSpeakerChl, tVmpMember);
	}

	/*for (u8 byLoop = 0; byLoop < tVmpParam.GetMaxMemberNum(); byLoop++)
	{
		//新的发言人已经在vmp某个不是发言人跟随的通道里，则将其挪位到发言人跟随通道
		//原来占的通道位置清空,并做历史记录，待下次又有新发言人做恢复
		TVMPMember tVmpMember = *tVmpParam.GetVmpMember(byLoop);
		if( !tMt.IsNull()
			&& ( tMt == (TMt)tVmpMember )
			&& (tVmpMember.GetMemberType() != byMemberType)
			)
		{
			
			StopSwitchToPeriEqp(m_tVmpEqp.GetEqpId(), byLoop, TRUE, MODE_VIDEO);
			tVmpParam.ClearVmpMember(byLoop);
			bytmpLastSpeakerVmpChnnl = byLoop;	//因为时序不定，先存于临时变量
			bytmpLastVmpMemberType = tVmpMember.GetMemberType(); //membertype 也保留
		}
		
		if ( tVmpMember.GetMemberType() == byMemberType )
		{
			//发言人跟随通道先清空
			StopSwitchToPeriEqp(m_tVmpEqp.GetEqpId(), byLoop, TRUE, MODE_VIDEO);
			tVmpParam.ClearVmpMember(byLoop);
			
			//之前存在该让位MT的历史通道记录，则让该MT恢复到历史通道中
			if(m_tLastVmpChnnlMemInfo.GetLastVmpMemChnnl() < MAXNUM_MPUSVMP_MEMBER) 
			{
				//历史通道中成员为空才恢复
				if( (tVmpParam.GetVmpMember(m_tLastVmpChnnlMemInfo.GetLastVmpMemChnnl())->IsNull())
					&& (ptOldSrc != NULL && !ptOldSrc->IsNull())
					&& (!tVmpParam.IsMtInMember(*ptOldSrc)) //也不能与其他通道里的重复
					)
				{
					// [2/5/2010 xliang] 放开下面限制
					// [11/25/2009 xliang] 单回传，不允许2个下级终端同时回传，所以此处恢复对此进行限制
					if ( ( (!ptOldSrc->IsLocal()) && IsLocalAndSMcuSupMultSpy( ptOldSrc->GetMcuId()) ) 
						|| ( ptOldSrc->IsLocal() || tMt.IsLocal() )
						)
					//if ( ptOldSrc->IsLocal() || tMt.IsLocal() )
					{
						tVmpMember.SetMemberTMt(*ptOldSrc); //恢复的就只可能是旧发言人
						tVmpMember.SetMemberType(m_tLastVmpChnnlMemInfo.GetLastVmpMemType());
						tVmpParam.SetVmpMember(m_tLastVmpChnnlMemInfo.GetLastVmpMemChnnl(), tVmpMember);
					}
				}
			}
			
			// 新发言人放到发言人跟随通道中
			tVmpMember.SetMemberTMt(tMt);
			tVmpMember.SetMemberType(byMemberType);
			tVmpParam.SetVmpMember(byLoop, tVmpMember);

		}
	}*/

	// 支持多画面合成后，不再记录原通道，不再做之后的恢复通道处理
	//m_tLastVmpChnnlMemInfo.SetLastVmpMemChnnl(bytmpLastSpeakerVmpChnnl);
	//m_tLastVmpChnnlMemInfo.SetLastVmpMemType(bytmpLastVmpMemberType);

	ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[AdjustVmpParambyMemberType] m_byLastVmpMemInChnnl:%u\n",bytmpLastSpeakerVmpChnnl);

}

/*==============================================================================
函数名    :  AssignPrsChnnl4Conf
功能      :  分配PRS资源(开启会议保证音视频双流三路占用)
算法实现  :  
参数说明  :  
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2009-4-30	4.6				薛亮							create
2011-4-18   4.6            周嘉麟							prs整合
==============================================================================*/
BOOL32 CMcuVcInst::AssignPrsChnnl4Conf()
{
	if (!IsBrdPrsAssigned())
	{
		u8 byNeedPrsChls = DEFAULT_PRS_CHANNELS;
		u8 abyPrsId[DEFAULT_PRS_CHANNELS] = {0};
		u8 abyPrsChnId[DEFAULT_PRS_CHANNELS] = {0};
		
		if (!g_cMcuVcApp.GetIdlePrsChls(byNeedPrsChls, abyPrsId, abyPrsChnId))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[AssignPrsChnnl4Conf] GetIdlePrsChls failed!\n");
			return FALSE;
		}
		for (u8 byIdx = 0; byIdx < byNeedPrsChls; byIdx++)
		{
			//占用prs通道
			OccupyPrsChnl(abyPrsId[byIdx], abyPrsChnId[byIdx]);	
		}
		//音视频双流
		AssignPrsChn(abyPrsId[0], abyPrsChnId[0], MODE_VIDEO, TRUE);
		AssignPrsChn(abyPrsId[1], abyPrsChnId[1], MODE_SECVIDEO, TRUE);
		AssignPrsChn(abyPrsId[2], abyPrsChnId[2], MODE_AUDIO, TRUE);
	}
	
	return TRUE;
}

/*=============================================================================
函 数 名： GetMtCurSrc
功    能： 获取终端当前的实际源(目前用于平滑策略获取前一个源信息，仅视频)
算法实现： 
全局变量： 
参    数：
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
20110630    4.0	        周嘉麟					  创建
=============================================================================*/
BOOL32 CMcuVcInst::GetMtCurVidSrc(u8 byMtId, TMt& tMtSrc, u8& byOutChnl)
{
	tMtSrc.SetNull();
	byOutChnl = 0;

	TMt tDstMt = m_ptMtTable->GetMt(byMtId);

	if (m_ptMtTable->GetMtSrc(byMtId, &tMtSrc, MODE_VIDEO) &&
		!tMtSrc.IsNull() &&
		 (!tMtSrc.IsLocal() || 
			(tMtSrc.IsLocal() && 
			    (tMtSrc.GetEqpType() == MT_TYPE_SMCU || tMtSrc.GetMtId() != byMtId))))
	{
		u8 bySrcType = tMtSrc.GetType();

		//终端广播或放像
		if (TYPE_MT == bySrcType 
				|| (TYPE_MCUPERI == bySrcType && EQP_TYPE_RECORDER == tMtSrc.GetEqpType()))
		{
			TMtStatus tMtStatus;
			m_ptMtTable->GetMtStatus(byMtId, &tMtStatus);
			TMt tSelSrc = tMtStatus.GetSelectMt(MODE_VIDEO);
			if (!tSelSrc.IsNull() && tSelSrc == tMtSrc)
			{
				if(IsNeedSelAdpt(tSelSrc, tDstMt, MODE_VIDEO))
				{
					TBasOutInfo tOutInfo;
					if(FindBasChn2SelForMt(tSelSrc, tDstMt, MODE_VIDEO,tOutInfo))
					{
						tOutInfo.m_tBasEqp.SetConfIdx(m_byConfIdx);
						tMtSrc = tOutInfo.m_tBasEqp;
						byOutChnl = tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx;
						return TRUE;
					}
					else
					{
						return FALSE;
					}
				}
				else
				{
					tMtSrc = tSelSrc;
					byOutChnl = 0;
					return TRUE;
				}	
			}
			else
			{
				if (IsNeedAdapt(tMtSrc, tDstMt, MODE_VIDEO))
				{
					TBasOutInfo tOutInfo;		
					if(FindBasChn2BrdForMt(byMtId, MODE_VIDEO, tOutInfo))
					{
						tMtSrc = tOutInfo.m_tBasEqp;
					    tMtSrc.SetConfIdx(m_byConfIdx);
						byOutChnl = tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx;
						return TRUE;
					}
					else
					{
						return FALSE;
					}
				}
				else
				{
					if (TYPE_MCUPERI == bySrcType && EQP_TYPE_RECORDER == tMtSrc.GetEqpType())
					{
						byOutChnl = m_byPlayChnnl;
					}
					else
					{
						byOutChnl = 0;
					}
					return TRUE;
				}					
			}
		}
		//画面合成广播
		else if (TYPE_MCUPERI == bySrcType && tMtSrc == m_tVmpEqp)
		{
			if (VMP == GetVmpSubType(m_tVmpEqp.GetEqpId()))
			{	
				TSimCapSet tDstCap = m_ptMtTable->GetDstSCS(byMtId);
				if (MEDIA_TYPE_NULL != tDstCap.GetVideoMediaType() &&
					m_tConf.GetMainVideoMediaType() == tDstCap.GetVideoMediaType())
				{
					byOutChnl =  0;
					return TRUE;
				}
				else if (MEDIA_TYPE_NULL != tDstCap.GetVideoMediaType() &&
					m_tConf.GetSecVideoMediaType() == tDstCap.GetVideoMediaType())
				{
					byOutChnl =  1;
					return TRUE;
				}
				else
				{
					return FALSE;
				}					
			}
			else
			{
				TLogicalChannel tDstLogicalChannel;
				if (m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_VIDEO, &tDstLogicalChannel, TRUE))
				{	
					byOutChnl = GetVmpOutChnnlByRes(m_tVmpEqp.GetEqpId(), 
						tDstLogicalChannel.GetVideoFormat(), 
						tDstLogicalChannel.GetChannelType(), 
						tDstLogicalChannel.GetChanVidFPS(),
						tDstLogicalChannel.GetProfileAttrb()); 
					return TRUE;
				}
			}	
		}			
	}
	return FALSE;
}
/*=============================================================================
函 数 名： GetMtRealSrc
功    能： 获取指定终端的实际接收源
算法实现： 
全局变量： 
参    数：
返 回 值： BOOL32 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
090423      4.0	        fxh					  创建
=============================================================================*/
BOOL32 CMcuVcInst::GetMtRealSrc(u8 byMtId, u8 byMode, TMt& tMtSrc, u8& byOutChnl)
{
	TMt tMt = m_ptMtTable->GetMt(byMtId);
	tMtSrc.SetNull();
	byOutChnl = 0;

	//[liu lijiu][2010/11/03]增加双流的判断情况
	if(MODE_SECVIDEO == byMode)
	{
		if(m_tDoubleStreamSrc.GetMtId() != byMtId)
		{
			if(IsNeedAdapt(m_tDoubleStreamSrc, tMt, MODE_SECVIDEO))
			{
				TBasOutInfo tOutInfo;	
				if(!FindBasChn2BrdForMt(byMtId, MODE_SECVIDEO, tOutInfo))
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[GetMtRealSrc] FindAcceptBasChnForMt%d failed!\n", byMtId);
					return FALSE;
				}
				else
				{
					tMtSrc = tOutInfo.m_tBasEqp;					
					byOutChnl = tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx;
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[GetMtRealSrc] Find bas--<EqpId:%d, ChnId:%d, OutId:%d> for mt:%d!\n",
										 	 tMtSrc.GetEqpId(), tOutInfo.m_byChnId, tOutInfo.m_byOutIdx,byMtId );
					return TRUE;
				}
			}
			else
			{
				tMtSrc = m_tDoubleStreamSrc;
				if (TYPE_MCUPERI == m_tDoubleStreamSrc.GetType() &&
					EQP_TYPE_RECORDER == m_tDoubleStreamSrc.GetEqpType())
				{
					byOutChnl = m_byPlayChnnl;
				}
				else
				{
					byOutChnl = 0;
				}				
				return TRUE;
			}
		}
		return FALSE;
	}

	if(MODE_VIDEO2SECOND == byMode)
	{
		//是否在双选看
		tMtSrc = m_ptMtTable->GetMtSelMtByMode(byMtId, MODE_VIDEO2SECOND);
		if (!(tMtSrc.IsNull()))
		{
			if(IsNeedSelAdpt(tMtSrc, tMt, byMode))
			{
				TBasOutInfo tOutInfo;
				if(FindBasChn2SelForMt(tMtSrc, tMt, byMode, tOutInfo))
				{
					tMtSrc = tOutInfo.m_tBasEqp;
					byOutChnl = tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx;
					return TRUE;
				}
			}
			else
			{
				byOutChnl = 0;
				return TRUE;
			}
			return FALSE;
		}
		
		if(m_tSecVidBrdSrc.GetMtId() == byMtId)
		{
			return FALSE;
		}
		
		if(IsNeedAdapt(m_tSecVidBrdSrc, tMt, MODE_VIDEO2SECOND))
		{
			return FALSE;
		}
		tMtSrc = m_tSecVidBrdSrc;
		byOutChnl = 0;
		return TRUE;
	}

	//本级终端做广播源，不建它到PRS的rtcp交换
	//下级mcu做广播源，建立它到PRS的rtcp交换
	//下级终端做广播源，建立它所属mcu到PRS的rtcp交换
	//[2011/08/16/zhangli]"TYPE_MCUPERI == tMtSrc.GetType()"add by zhangli,src=mix,byMtId=1,mixeqpid=1，这种情况下被跳过了
	if (m_ptMtTable->GetMtSrc(byMtId, &tMtSrc, byMode) && !tMtSrc.IsNull()
		&& (!tMtSrc.IsLocal() 
			|| (tMtSrc.IsLocal() && (tMtSrc.GetEqpType() == MT_TYPE_SMCU || !(tMtSrc == tMt)))))
	{
		u8 byType = tMtSrc.GetType();
		u8 byEqpType = tMtSrc.GetEqpType();

		if (TYPE_MT == byType ||
			 (TYPE_MCUPERI == byType && EQP_TYPE_RECORDER == byEqpType))
		{
			//[nizhijun 2010/12/13] m_ptMtTable获得的tMtSrc需要本地化
			TMt tTempSrc = GetLocalMtFromOtherMcuMt(tMtSrc);

			TMt tLocalBrdSrc;
			if (MODE_AUDIO == byMode)
			{
			    tLocalBrdSrc = GetLocalAudBrdSrc();
			}
			else if (MODE_VIDEO == byMode)
			{
				tLocalBrdSrc = GetLocalVidBrdSrc();
			}
			else
			{
				return FALSE;
			}

			if (tTempSrc == tLocalBrdSrc)
			{
				TBasOutInfo tOutInfo;
				if (IsNeedAdapt(tLocalBrdSrc, tMt, byMode))
				{
					if(!FindBasChn2BrdForMt(byMtId, byMode, tOutInfo))
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[GetMtRealSrc] FindBasChn2BrdForMt%d Mode.%d failed!\n", byMtId, byMode);
						return FALSE;
					}
					else
					{
						tMtSrc = tOutInfo.m_tBasEqp;						
						byOutChnl = tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx;
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_PRS, "[GetMtRealSrc] Find bas--<Mode:%d, EqpId:%d, ChnId:%d, OutId:%d> for mt:%d!\n",
												byMode, tMtSrc.GetEqpId(), tOutInfo.m_byChnId, tOutInfo.m_byOutIdx,byMtId);
						return TRUE;
					}
				}
				else
				{
					if (TYPE_MCUPERI == byType &&	EQP_TYPE_RECORDER == byEqpType)
					{
						byOutChnl = m_byPlayChnnl;
					}
					else
					{
						byOutChnl = 0;
					}
					return TRUE;
				}
			}
			else
			{
				TMtStatus tDstStatus;
				if (m_ptMtTable->GetMtStatus(byMtId, &tDstStatus) &&
					!tDstStatus.GetSelectMt(byMode).IsNull())
				{
					if(IsNeedSelAdpt(tDstStatus.GetSelectMt(byMode), tMt, byMode))
					{
						TBasOutInfo tOutInfo;
						if(FindBasChn2SelForMt(tDstStatus.GetSelectMt(byMode), tMt, byMode, tOutInfo))
						{
							tMtSrc = tOutInfo.m_tBasEqp;
							byOutChnl = tOutInfo.m_byFrontOutNum + tOutInfo.m_byOutIdx;
							return TRUE;
						}
					}
					else
					{
						tMtSrc = tDstStatus.GetSelectMt(byMode);
						byOutChnl = 0;
						return TRUE;
					}					
				}				
			}
		}
		else if (TYPE_MCUPERI == byType)
		{
			if (tMtSrc == m_tVmpEqp)
			{
				if (GetVmpSubType(m_tVmpEqp.GetEqpId()) == VMP)
				{	
					TSimCapSet tDstCap = m_ptMtTable->GetDstSCS(byMtId);
					if (MEDIA_TYPE_NULL != tDstCap.GetVideoMediaType() &&
						m_tConf.GetMainVideoMediaType() == tDstCap.GetVideoMediaType())
					{
						byOutChnl =  0;
						return TRUE;
					}
					else if (MEDIA_TYPE_NULL != tDstCap.GetVideoMediaType() &&
						m_tConf.GetSecVideoMediaType() == tDstCap.GetVideoMediaType())
					{
						byOutChnl =  1;
						return TRUE;
					}
					else
					{
						return FALSE;
					}
				}
				else//MPU OR mpu2
				{
					TLogicalChannel tDstLogicalChannel;
					if (m_ptMtTable->GetMtLogicChnnl(byMtId, LOGCHL_VIDEO, &tDstLogicalChannel, TRUE))
					{	
						byOutChnl = GetVmpOutChnnlByRes(m_tVmpEqp.GetEqpId(), 
							tDstLogicalChannel.GetVideoFormat(), 
							tDstLogicalChannel.GetChannelType(), 
							tDstLogicalChannel.GetChanVidFPS(), 
							tDstLogicalChannel.GetProfileAttrb()); 
						return TRUE;
					}
				}				
			}
			else if (tMtSrc == m_tMixEqp)
			{
				if (m_ptMtTable->IsMtInMixGrp(byMtId))
				{
					byOutChnl = GetMixChnPos(tMt);
				}
				else
				{
					TLogicalChannel tLogicalChannel;
					TAudioTypeDesc tAudTypeInfo;
					if ( m_ptMtTable->GetMtLogicChnnl(tMt.GetMtId(), LOGCHL_AUDIO, &tLogicalChannel, TRUE) )
					{
						tAudTypeInfo.SetAudioMediaType(tLogicalChannel.GetChannelType());
						tAudTypeInfo.SetAudioTrackNum(tLogicalChannel.GetAudioTrackNum());
					}
					u8 byMtMixNChnl = m_tConfEx.GetPosInConfByAudioCap(tAudTypeInfo);
					if (byMtMixNChnl == 0xFF)
					{
						ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER, "[GetMtRealSrc] Mt.%d's MediaType.%d_TrackNum.%d Is Error!Not in AudioTypeInfo\n", 
							tMt.GetMtId(), tAudTypeInfo.GetAudioMediaType(), tAudTypeInfo.GetAudioTrackNum());
						byMtMixNChnl = 0;
					}
					byOutChnl = GetMixerNModeChn() + byMtMixNChnl;
				}
				return TRUE;
			}
		}
		else
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[GetMtRealSrc]unproc src type(%d)\n", byType);
		}
	}
	else
	{
		//打印去除，因为如果很多终端没有源，会刷很多打印
// 		ConfPrint(LOG_LVL_ERROR, MID_MCU_PRS, "[GetMtRealSrc]byMode:%d GetMtSrc failed! Mt<Id:%d>'s src is Mt<Id:%d>\n", 
// 						byMode, byMtId, tMtSrc.GetMtId());
	}
	return FALSE;

}
/*=============================================================================
函 数 名： ProcMixStopSucRsp
功    能： 
算法实现： 
全局变量： 
参    数：
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
090423      4.0	        fxh					  提取停止混音成功业务响应函数
=============================================================================*/
void CMcuVcInst::ProcMixStopSucRsp( BOOL32 bIsSendToMMcuNotify )
{
	if( m_tMixEqp.IsNull() )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER,  "[ProcMixStopSucRsp] MixEqp is null.So return back!\n" );
		return;
	}

	CServMsg cServMsg;
	BOOL32 byOldIsDiscuss = m_tConf.m_tStatus.IsAutoMixing();

	if( m_tConf.m_tStatus.IsVACing() ) //语音激励
	{
        m_tConf.m_tStatus.SetVACing(FALSE); 
		
		//通知主席及所有会控
		SendMsgToAllMcs( MCU_MCS_STOPVAC_NOTIF, cServMsg );
		if (HasJoinedChairman())
		{
			SendMsgToMt( m_tConf.GetChairman().GetMtId(), MCU_MT_STOPVAC_NOTIF, cServMsg );
		}

		//停止向混音器交换数据，并恢复收听广播源
		TMt tmt;
		for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
		{
			if (m_tConfAllMtInfo.MtJoinedConf(byMtId))            
			{
				tmt = m_ptMtTable->GetMt( byMtId );
				StopSwitchToPeriEqp(m_tMixEqp.GetEqpId(), 
					(MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+GetMixChnPos(tmt)), FALSE, MODE_AUDIO );
                m_ptMtTable->SetMtInMixGrp(byMtId, FALSE);
            }
		}
	}

	if( m_tConf.m_tStatus.IsMixing() ) //定制混音(或会议讨论)
	{       
		//停止向混音器交换数据，并恢复收听广播源
		TMt atDstMt[MAXNUM_CONF_MT];
		memset(atDstMt, 0, sizeof(atDstMt));
		u8 byDstMtNum = 0;
		TMt tSMcu;
		CServMsg cMsg;
		TMtStatus tStatus;
		for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
		{
			if (m_tConfAllMtInfo.MtJoinedConf(byMtId))
			{
				TMt tmt = m_ptMtTable->GetMt( byMtId );

				if( byOldIsDiscuss )
				{
					StopSwitchToPeriEqp( m_tMixEqp.GetEqpId(), 
						(MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+GetMixChnPos(tmt)), FALSE, MODE_AUDIO );
				}
				else
				{
					if( m_ptMtTable->IsMtInMixing(byMtId) )
					{
						StopSwitchToPeriEqp( m_tMixEqp.GetEqpId(), 
							(MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+GetMixChnPos(tmt)), FALSE, MODE_AUDIO);
					}
				}
				
				
                
                // xsl [9/21/2006] 恢复从组播地址接收
                /*if (m_tConf.GetConfAttrb().IsSatDCastMode() && m_ptMtTable->IsMtInMixGrp(byMtId))
                {
                    ChangeSatDConfMtRcvAddr(byMtId, LOGCHL_AUDIO);
                }*/

				if ( m_ptMtTable->GetMtType( byMtId ) == MT_TYPE_SMCU && m_ptMtTable->IsMtInMixing(byMtId) )
				{
 					tSMcu.SetMcu( byMtId );
					cMsg.SetMsgBody((u8*)&tSMcu, sizeof(TMt));
					OnStopMixToSMcu( &cMsg );
					ClearSMcuAllMtMixStatusToAuto(GetMcuIdxFromMcuId(byMtId));
				}

				if( //m_tConf.GetChairman() == tmt &&
					m_ptMtTable->GetMtStatus( byMtId,&tStatus ) &&
					!tStatus.GetSelectMt(MODE_AUDIO).IsNull() )
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_MIXER,  "[ProcMixStopSucRsp] mt.%d has audio select.not stop audio switch\n",byMtId );
				}
				else if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
				{
					//过滤vrs新录播
				}
				else
				{
					atDstMt[byDstMtNum] = tmt;
					byDstMtNum++;
				}
				
			}
			
			//20101110_tzy 无论终端是否在会议中，只要混音器停止了，那么就将该终端踢出混音器
            m_ptMtTable->SetMtInMixGrp(byMtId, FALSE);
            m_ptMtTable->SetMtInMixing(byMtId, FALSE, TRUE); 
		}
        m_tConf.m_tStatus.SetNoMixing();
		
		TMcu tMcu;
		tMcu.SetMcuId(LOCAL_MCUID);
		cServMsg.SetMsgBody((u8 *)&tMcu, sizeof(tMcu));
		
		if (!m_tCascadeMMCU.IsNull() && bIsSendToMMcuNotify)
		{
			cServMsg.SetDstMtId( m_tCascadeMMCU.GetMtId() );
			SendMsgToMt(m_tCascadeMMCU.GetMtId(), MCU_MCU_STOPMIXER_NOTIF, cServMsg);
		}
		
		if (HasJoinedChairman())
		{
            u8 byMixMode = m_tConf.m_tStatus.GetMixerMode();
            cServMsg.SetMsgBody(&byMixMode, sizeof(byMixMode));
			SendMsgToMt( m_tConf.GetChairman().GetMtId(), MCU_MT_STOPDISCUSS_NOTIF, cServMsg );
		}
		
		if( byDstMtNum > 0  )
		{
			StopSwitchToSubMt( byDstMtNum, atDstMt, MODE_AUDIO, FALSE );
		}

		// zbq [11/22/2007] 实时刷终端状态
        MtStatusChange(NULL, TRUE);
        
        // guzh [5/12/2007] 清除映射表(防止残留)
        memset( m_abyMixMtId, 0, sizeof(m_abyMixMtId) );
		memset(m_atMixMt,0,sizeof(m_atMixMt));

		//改变视频源
		if (HasJoinedSpeaker())
		{
			TMt tSpeakerMt = m_tConf.GetSpeaker();
			ChangeAudBrdSrc(&tSpeakerMt);

			//zjj20090925 补建唇音同步状态下bas到各个终端的音频交换
			StartSwitchAud3MtNeedAdp();

			if( m_tCascadeMMCU.IsNull() )
			{
				NotifyAllSMcuMediaInfo( 0,MODE_AUDIO );
			}			
		}
		else
		{
			ChangeAudBrdSrc( NULL );
		}

		//通知混音器停止向终端发码流
		NotifyMixerSendToMt( FALSE );

		//向上级MCU发终端声音
		//zjj20101011 vcs会议是否向上级发声音完全由上级决定,混音结束时不要自动向上级建音频交换
		if ( !m_tCascadeMMCU.IsNull() )
		{
			if (m_tConf.m_tStatus.GetPollState() != POLL_STATE_NONE && m_tConf.m_tStatus.GetPollMode() == CONF_POLLMODE_VIDEO_SPY)
			{
				ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_VCS,  "[ProcMixStopSucRsp] m_tConf.m_tStatus.GetPollState(%d),GetPollMode(%d),So Don't Restore Audio Switch To Mmcu!!\n",
					m_tConf.m_tStatus.GetPollState(), m_tConf.m_tStatus.GetPollMode());
			} 
			else
			{
				TConfMcInfo *ptInfo = m_ptConfOtherMcTable->GetMcInfo(GetMcuIdxFromMcuId(m_tCascadeMMCU.GetMtId()));
				if ( NULL != ptInfo && 
					 m_tConfAllMtInfo.MtJoinedConf(ptInfo->m_tSpyMt.GetMcuId(), ptInfo->m_tSpyMt.GetMtId()) )
				{
					OnSetOutView( ptInfo->m_tSpyMt,MODE_AUDIO );
					//[2011/09/28/zhangli] 如果需要适配，走音频选看适配；如果是下级终端，建交换传入参数wSpyPort
					/*if (IsNeedSelAdpt(ptInfo->m_tSpyMt, m_tCascadeMMCU, MODE_AUDIO))
					{
						StartSelAdapt(ptInfo->m_tSpyMt, m_tCascadeMMCU, MODE_AUDIO);
					}
					else
					{
						u16 wSpyPort = SPY_CHANNL_NULL;	
						CRecvSpy tSpyResource;
						if(m_cSMcuSpyMana.GetRecvSpy(ptInfo->m_tSpyMt, tSpyResource))
						{
							wSpyPort = tSpyResource.m_tSpyAddr.GetPort();
						}

						TSwitchGrp tSwitchGrp;
						tSwitchGrp.SetSrcChnl(0);
						tSwitchGrp.SetDstMtNum(1);
						tSwitchGrp.SetDstMt(&m_tCascadeMMCU);
						StartSwitchToAll(ptInfo->m_tSpyMt, 1, &tSwitchGrp, MODE_AUDIO, SWITCH_MODE_SELECT, TRUE, TRUE, wSpyPort);

						//[2011/09/28/zhangli]Bug00065583恢复上级MCU到上传终端的RTCP交换
						BuildRtcpSwitchForSrcToDst(m_tCascadeMMCU, ptInfo->m_tSpyMt, MODE_AUDIO);
					}*/
				}
			}
		}
	}

    //通知主席及所有会控 
    MixerStatusChange();

    //zbq[11/29/2007] 通知上级MCU当前终端状态
    if( !m_tCascadeMMCU.IsNull() )
    {
        OnNtfMtStatusToMMcu(m_tCascadeMMCU.GetMtId());
    }

	TPeriEqpStatus tPeriEqpStatus;
	g_cMcuVcApp.GetPeriEqpStatus( m_tMixEqp.GetEqpId(), &tPeriEqpStatus );
	
	//放弃混音组
	ConfPrint(LOG_LVL_DETAIL, MID_MCU_MIXER, "[ProcMixStopSucRsp] give up mixer group.%u!\n",m_byMixGrpId);
	tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpState = TMixerGrpStatus::READY;
	memset((void*)m_atMixMt,0,sizeof(m_atMixMt));
	tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byConfId = 0;
	g_cMcuVcApp.SetPeriEqpStatus( m_tMixEqp.GetEqpId(), &tPeriEqpStatus );
	cServMsg.SetMsgBody((u8 *)&tPeriEqpStatus, sizeof(tPeriEqpStatus));
    SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
    
	TMixParam tMixParam;
	m_tConf.m_tStatus.SetMixerParam(tMixParam);
	m_tVacLastSpeaker.SetNull();
	
    if( HasJoinedChairman() )
    {
        CServMsg cServMsgToChairMan;
        cServMsgToChairMan.SetMsgBody((u8 *)&m_tConf, sizeof(TConfInfo));
        SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_CONF_NOTIF, cServMsgToChairMan);

		// [11/25/2010 xliang] 对T3，R3-full终端还需发下面的消息
		CServMsg cServMsgToT3Chairman;
		cServMsgToT3Chairman.SetMsgBody((u8 *)&tMixParam, sizeof(tMixParam));
		SendMsgToMt(m_tConf.GetChairman().GetMtId(), MCU_MT_DISCUSSPARAM_NOTIF, cServMsgToT3Chairman );
    }
    
	//如果是自动切换讨论-->混音
    if( !m_tConf.IsDiscussAutoStop() && m_tConfInStatus.IsSwitchDiscuss2Mix() )
    {
        SwitchDiscuss2SpecMix();
    }
    else //非切换模式，将相关信息清空
    {
        m_tMixEqp.SetNull();
        m_byLastMixMode = mcuNoMix;
    }

	if( m_tConf.GetConfSource() == VCS_CONF &&
		VCS_SINGLE_MODE == m_cVCSConfStatus.GetCurVCMode() )
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_VCS,  "[ProcMixStopSucRsp] now vcs conf mode is VCS_SINGLE_MODE,stop mixing in tvwall\n" );
		VCSChangeTvWallMtMixStatus( FALSE );
	}
	
	//停止讨论，若存在主席，自动开启主席定制混音
	if ( g_cMcuVcApp.IsChairAutoSpecMix() && byOldIsDiscuss )
	{
		ChairmanAutoSpecMix();
	}
}

/*=============================================================================
函 数 名： ProcUnfinishedChangeVmpCmd
功    能： 执行给外设发送changvmpcmd之后的处理
算法实现： 
全局变量： 
参    数：
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
130305      4.7	        yanghuaizhi			
=============================================================================*/
void CMcuVcInst::ProcUnfinishedChangeVmpCmd(u8 byVmpId)
{
	TPeriEqpStatus tPeriEqpStatus;
	g_cMcuVcApp.GetPeriEqpStatus(byVmpId , &tPeriEqpStatus);
	// 只有合成器正常运行时，才需要做后续处理
	if (!IsValidVmpId(byVmpId) ||
		tPeriEqpStatus.GetConfIdx() != m_byConfIdx ||
		TVmpStatus::START != tPeriEqpStatus.m_tStatus.tVmp.m_byUseState)
	{
		LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[ProcUnfinishedChangeVmpCmd]VmpEqpId(%d), ConfIdx(%d), Vmpstatus:%d! return.\n", 
			byVmpId, tPeriEqpStatus.GetConfIdx(), tPeriEqpStatus.m_tStatus.tVmp.m_byUseState);
		return;
	}
	
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	TVMPParam_25Mem tConfVMPParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
	TVMPParam_25Mem tPeriVmpParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();
	
	// vmp处理中对下级单回传新成员执行OnMMcuSetIn
	OnMMcuSetInForVmp(tConfVMPParam, tPeriVmpParam);

	// 主席调整合成信息时，MODE传过来是空，必须重刷
	tPeriVmpParam.SetVMPMode(tPeriVmpParam.IsVMPAuto() ? CONF_VMPMODE_AUTO : CONF_VMPMODE_CTRL);
	tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(tPeriVmpParam);
	g_cMcuVcApp.SetPeriEqpStatus( byVmpId, &tPeriEqpStatus );
	
    LogPrint(LOG_LVL_KEYSTATUS, MID_MCU_VMP, "[ProcUnfinishedChangeVmpCmd]tVMPParam is");
    tPeriVmpParam.Print(LOG_LVL_KEYSTATUS);
	//改变数据交换
	ChangeVmpSwitch(byVmpId, VMP_STATE_CHANGE );            
	
	tConfVMPParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
	// xliang [12/23/2008] 批量轮询定时t.
	if(tConfVMPParam.IsVMPBatchPoll())
	{
		u32 dwTimert = 0;
		if(m_tVmpBatchPollInfo.GetTmpt() != 0)//非与会终端基本定时为0
		{
			dwTimert = m_tVmpBatchPollInfo.GetTmpt();
		}
		else
		{
			dwTimert = m_tVmpBatchPollInfo.GetPollt();
		}
		SetTimer(MCUVC_VMPBATCHPOLL_TIMER,dwTimert);
	}

	if ( m_tConf.m_tStatus.GetRollCallMode() == ROLLCALL_MODE_VMP )
	{
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_EQP,"[ProcVmpMcuNotif]Recover Rollcall finish Mark!\n");
		SetLastMultiSpyRollCallFinish(TRUE);
	}
	
	// 对于VCS会议在组呼画面合成的模式下,混音成员与画面合成成员绑定
	//zjj20091102 多画面模式下只要上线的终端就进画面合成进混音
	//本来是全体混音没什么问题，但现在改成定制混音了，所以现在手动将上线的终端加入混音
	if (VCS_CONF == m_tConf.GetConfSource() && 
		(VCS_GROUPVMP_MODE == m_cVCSConfStatus.GetCurVCMode() ||
		VCS_MULVMP_MODE == m_cVCSConfStatus.GetCurVCMode() ) &&
		m_tConf.m_tStatus.IsMixing())
	{
		u8 byMemNum = tConfVMPParam.GetMaxMemberNum();
		TMt tMt;
		TMt atMixMember[MAXNUM_CONF_MT];
		u8  byMixMemNum = 0;
		for (u8 byVMPMemIdx = 0; byVMPMemIdx < byMemNum; byVMPMemIdx++)
		{
			tMt = (TMt)(*tConfVMPParam.GetVmpMember(byVMPMemIdx));
			if (!tMt.IsNull())
			{
				atMixMember[byMixMemNum++] = tMt;				
			}
			
		}
		ChangeSpecMixMember(atMixMember, byMixMemNum);
	}
	
	//n+1备份更新vmp信息
	if (MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
	{
		ProcNPlusVmpUpdate();
	}
}

/*=============================================================================
函 数 名： OnMMcuSetInForVmp
功    能： vmp处理中对下级单回传新成员执行OnMMcuSetIn
算法实现： 
全局变量： 
参    数：
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
130531      4.7	        yanghuaizhi			
=============================================================================*/
void CMcuVcInst::OnMMcuSetInForVmp(TVMPParam_25Mem &tConfVMPParam, TVMPParam_25Mem &tPeriVmpParam)
{
	TVMPMember tLastVmpMember;	// m_tLastVmpParam中对应通道成员.
	TVMPMember tCurVmpMember;
	TMt tMcu;
	for( u8 byLoop = 0; byLoop < tPeriVmpParam.GetMaxMemberNum(); byLoop++ )
	{
		tCurVmpMember = *tPeriVmpParam.GetVmpMember( byLoop );
		if( !tCurVmpMember.IsNull() && !tCurVmpMember.IsLocal() &&
			(byLoop == tPeriVmpParam.GetChlOfMtInMember(tCurVmpMember)) && //Mt进多通道,只针对第一个SetIn
			!IsLocalAndSMcuSupMultSpy( tCurVmpMember.GetMcuId() )
			)
		{
			// 如果通道成员没变,无需发SetIn消息
			tLastVmpMember = *tConfVMPParam.GetVmpMember(byLoop);
			if (tLastVmpMember == tCurVmpMember)
			{
				continue;
			}
			// 如果该成员已是smcu的上传通道终端,也无需发送SetIn消息
			tMcu = GetLocalMtFromOtherMcuMt(tCurVmpMember);
			if (tCurVmpMember == GetSMcuViewMt(tMcu, TRUE))
			{
				continue;
			}
			
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ProcVmpMcuNotif]Send SetInReq to <%d %d> in VMP chnnl:%d\n",
				tCurVmpMember.GetMcuIdx(),tCurVmpMember.GetMtId(), byLoop);
			OnMMcuSetIn((TMt)tCurVmpMember, 0, SWITCH_MODE_SELECT);
		}
	}

	return;
}

/*=============================================================================
函 数 名： ProcVMPStopSucRsp
功    能： 
算法实现： 
全局变量： 
参    数：
返 回 值： void 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
090423      4.0	        fxh					  提取停止画面合成业务处理
=============================================================================*/
void CMcuVcInst::ProcVMPStopSucRsp( u8 byVmpId )
{
	if (!IsValidVmpId(byVmpId))
	{
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_EQP,"[ProcVMPStopSucRsp]VmpId:%d is not valid!\n", byVmpId);
		return;
	}
	LogPrint(LOG_LVL_DETAIL,MID_MCU_EQP,"[ProcVMPStopSucRsp]VmpId:%d stop!\n", byVmpId);
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	//设置状态
	TPeriEqpStatus tPeriEqpStatus;
	g_cMcuVcApp.GetPeriEqpStatus(tVmpEqp.GetEqpId(), &tPeriEqpStatus);
	tPeriEqpStatus.m_tStatus.tVmp.m_byUseState = TVmpStatus::IDLE;

	g_cMcuVcApp.SetVMPMode(tVmpEqp, CONF_VMPMODE_NONE);

	//停止vmp单通道轮询
	ProcStopVmpPoll();

//	m_byModuleAutoVmp = 0;

	// xliang [12/23/2008] 显式设置一下
	//m_tConf.m_tStatus.m_tVMPParam.SetVMPBatchPoll(0);

	//停止vmp占用的prs通道
	//StopPrsForVmp();
	//停止交换数据
	ChangeVmpSwitch(byVmpId, VMP_STATE_STOP );

	TVMPParam_25Mem tVMPParam;
	//memset(&tVMPParam, 0, sizeof(tVMPParam));
	//m_tConf.m_tStatus.SetVmpParam( tVMPParam );
	//g_cMcuVcApp.SetConfVmpParam(tVmpEqp, tVMPParam);
	g_cMcuVcApp.ClearVmpInfo(tVmpEqp);
	RemoveVmpIdFromVmpList(byVmpId);

	//同步外设复合状态
	tPeriEqpStatus.m_tStatus.tVmp.SetVmpParam(tVMPParam);
	tPeriEqpStatus.SetConfIdx(0);
	g_cMcuVcApp.SetPeriEqpStatus( tVmpEqp.GetEqpId(), &tPeriEqpStatus );

	// xliang [5/4/2009] 外设复合状态上报会控
	CServMsg cServMsg;
	cServMsg.SetMsgBody( ( u8 * )&tPeriEqpStatus, sizeof( tPeriEqpStatus ) );
	SendMsgToAllMcs( MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg );

	//通知主席及所有会控
	cServMsg.SetEqpId(tVmpEqp.GetEqpId());
	cServMsg.SetMsgBody();
	SendMsgToAllMcs( MCU_MCS_STOPVMP_NOTIF, cServMsg );//MCS依据该消息停止画面合成，不需要再发VMPPARAM_NOTIFY
	if( HasJoinedChairman() )
	{
		// 仅剩1个合成器时，告知主席终端
		if (GetVmpCountInVmpList() == 1)
		{
			SendVmpParamToChairMan();
		}
		else
		{
			SendMsgToMt( m_tConf.GetChairman().GetMtId(), MCU_MT_STOPVMP_NOTIF, cServMsg );
		}
	}
	
	if (0 == GetVmpCountInVmpList())
	{
		m_tConfInStatus.SetVmpNotify(FALSE);//合成器全部停止后将vmpnotify置FALSE
	}
	if ( m_tConf.m_tStatus.GetRollCallMode() == ROLLCALL_MODE_VMP )
	{
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_EQP,"[ProcVMPStopSucRsp]Recover Rollcall finish Mark!\n");
		SetLastMultiSpyRollCallFinish(TRUE);
	}

	m_byVmpOperating = 0;

    // guzh [6/9/2007] 清除记录
    //memcpy(&m_tLastVmpParam, &tVMPParam, sizeof(TVMPParam));
	//g_cMcuVcApp.SetLastVmpParam(tVmpEqp, tVMPParam);

	// xliang [12/16/2008] 清空vmp channel所有信息。(对于老vmp，没有这个channel概念，这里一并清空)
	//m_tVmpChnnlInfo.clear(); changevmpswitch会做清理,此处无需做清理
	memset(m_abyMtNeglectedByVmp,0,sizeof(m_abyMtNeglectedByVmp));
	memset(&m_tVmpPollParam,0,sizeof(m_tVmpPollParam));
	memset(&m_tVmpBatchPollInfo,0,sizeof(m_tVmpBatchPollInfo));
	//m_tLastVmpChnnlMemInfo.Init();
	//m_byLastVmpMemInChnnl = ~0;
	//memset(m_atVMPTmpMember,0,sizeof(m_atVMPTmpMember));
	//m_tVmpAdaptChnSeizeOpr.Clear(); 
	//TVmpPriSeizeInfo tPriSeiInfo;
	//g_cMcuVcApp.SetVmpPriSeizeInfo(m_tVmpEqp, tPriSeiInfo);
	//m_tVmpChnnlInfo.clear();

	// [4/21/2011 tzy] 后面还需要使用
	//memset(&m_tVmpEqp, 0, sizeof(m_tVmpEqp));

    //n+1备份更新vmp信息
    if (MCU_NPLUS_MASTER_CONNECTED == g_cNPlusApp.GetLocalNPlusState())
    {
        ProcNPlusVmpUpdate();
    }

	//关闭选看该vmp的hdu通道
    TPeriEqpStatus tHduStatus;
    u8 byHduId = HDUID_MIN;
    while( byHduId >= HDUID_MIN && byHduId <= HDUID_MAX )
	{
		if (g_cMcuVcApp.IsPeriEqpValid(byHduId))
		{
			g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus);
            if (tHduStatus.m_byOnline == 1)
			{
                //u8 byTmpMtId = 0;
                u8 byMtConfIdx = 0;
                u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduId));
				if (0 == byHduChnNum)
				{
					byHduId++;
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[ProcVMPStopSucRsp] GetHduChnNumAcd2Eqp failed!\n");
					continue;
				}

				for(u8 byLoop = 0; byLoop < byHduChnNum; byLoop++)
				{
                    //byTmpMtId = tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop].GetMtId();
                    byMtConfIdx = tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop].GetConfIdx();
					TMt tHduMemb = tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop];
						
					// 20110421_tzy Bug00052257开启再关闭画面合成会清除电视墙通道的一些状态,
					// 增加该通道是否是选看画面合成条件

					// [7/21/2011 liuxu] 直接判断Mt id不够全面
					if (/*m_tVmpEqp.GetEqpId() == byTmpMtId */
						tHduMemb == tVmpEqp
						&& m_byConfIdx == byMtConfIdx
						&& tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop].byMemberType == TW_MEMBERTYPE_SWITCHVMP)
					{
						StopSwitchToPeriEqp(byHduId, byLoop);
						g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus);
                        tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop].byMemberType = 0;
                        tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop].SetNull();
                        tHduStatus.m_tStatus.tHdu.atVideoMt[byLoop].SetConfIdx(0);
						g_cMcuVcApp.SetPeriEqpStatus(byHduId, &tHduStatus);
						
						cServMsg.SetMsgBody((u8 *)&tHduStatus, sizeof(tHduStatus));
						SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
                    }
               	}
			}
		}
        byHduId++;
	}	

	if (byVmpId == m_tVmpEqp.GetEqpId())
	{
		memset(&m_tVmpEqp, 0, sizeof(m_tVmpEqp));
	}
}

/*=============================================================================
函 数 名： RestoreMixingByOtherMixer
功    能： 混音器断链后用在线的其它混音器作混音，
算法实现： 
全局变量： 
参    数：
返 回 值： BOOL32 如果没有可用的混音器返回false 
----------------------------------------------------------------------
修改记录    ：
日  期		版本		修改人		走读人    修改内容
091014      4.0	        zjj					  
=============================================================================*/
BOOL32 CMcuVcInst::RestoreMixingByOtherMixer( u8 byMixMode )
{
	if( mcuNoMix == byMixMode )
	{
		return FALSE;
	}
	TMixParam tMixParam = m_tConf.m_tStatus.GetMixerParam();

	u8 byMixMemberNum = tMixParam.GetMemberNum();

	u8 byIndex = 0;

	if( 0 == byMixMemberNum )
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[RestoreMixingByOtherMixer]  mixMember is zero byMixMode(%d)\n",byMixMode );
		//return FALSE;
	}


	//得到空闲的混音器
	//tianzhiyong 2010/03/21 区分自动还是手动
	u8 byEqpId = 0;
	TAudioTypeDesc atAudioTypeDesc[MAXNUM_CONF_AUDIOTYPE];
	memset(atAudioTypeDesc, 0, sizeof(atAudioTypeDesc));
	u8 byAudioCapNum = m_tConfEx.GetAudioTypeDesc(atAudioTypeDesc);

	byEqpId = g_cMcuVcApp.GetIdleMixer(m_tConf.m_tStatus.GetMixerParam().GetMtMaxNum(), byAudioCapNum, atAudioTypeDesc);
	if( byEqpId == 0 )//未找到空闲混音器
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[RestoreMixingByOtherMixer] can't find idle mixer member(%d)!!\n",
			m_tConf.m_tStatus.GetMixerParam().GetMtMaxNum());
		return FALSE;//无可用的混音器
	}
	if (!CheckMixerIsValide(byEqpId))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[RestoreMixingByOtherMixer] mediatype[%d] not support!!\n",m_tConf.GetMainAudioMediaType());
		return FALSE;
	}
	//zjj20091014获得新的混音器成功后
	//重新将本来在定制混音中的成员再设置成在定制混音状态中
	//在MIXER_MCU_STARTMIX_ACK中再将它们建交换
	if (mcuPartMix == byMixMode) 
	{
		for( byIndex = 0;byIndex <byMixMemberNum;byIndex++ )
		{		
			m_ptMtTable->SetMtInMixing( tMixParam.GetMemberByIdx( byIndex ),TRUE, m_ptMtTable->IsMtAutoInSpec(tMixParam.GetMemberByIdx( byIndex )) );		
		}
	}
	u8 byMixerSubtype = UNKONW_MIXER;
	g_cMcuAgent.GetMixerSubTypeByEqpId(byEqpId,byMixerSubtype);
    if ((byMixerSubtype == EAPU_MIXER || byMixerSubtype == APU2_MIXER) && byMixMode == mcuVacMix)
    {
		StartEmixerVac(byEqpId);
		return TRUE;
    }
	memset( m_abyMixMtId, 0, sizeof(m_abyMixMtId) );
	memset(m_atMixMt,0,sizeof(m_atMixMt));
	if( !StartMixing(byMixMode,byEqpId) )
	{
		for( byIndex = 0;byIndex <byMixMemberNum;byIndex++ )
		{		
			m_ptMtTable->SetMtInMixing( tMixParam.GetMemberByIdx( byIndex ),FALSE, TRUE );		
		}
		return FALSE;
	}
	return TRUE;
}

/*====================================================================
    函数名      : GetCurMixerNum
    功能        : 得到当前混音成员数量
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    20091202                pengjie         创建
====================================================================*/
u8 CMcuVcInst::GetCurMixerNum( void )
{
	u8 byCurMixerNum = 0;
	for( u8 byLoop = 1; byLoop < MAXNUM_MIXER_CHNNL+1; byLoop++ )
    {
		if( !m_atMixMt[byLoop].IsNull() )
		{
			byCurMixerNum++;
		}
	}
	return byCurMixerNum;
}
/*====================================================================
函数名      ：CheckMixerIsValide
功能        ：获取混音器某种格式N模式混音通道号
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：u8: byAudioType （多格式时某种音频格式的全混通道，暂时未用）
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/03/17    4.0         田志勇        创建
13/0./18	4.7			国大卫		  支持多格式
====================================================================*/
BOOL32  CMcuVcInst::CheckMixerIsValide(u8 byMixerId)
{
	if (byMixerId < MIXERID_MIN || byMixerId > MIXERID_MAX)
	{
		return FALSE;
	}
#if defined(_8KE_) || defined(_8KH_)
	return TRUE;
#endif 
	u8 byMixerSubtype = UNKONW_MIXER;
	g_cMcuAgent.GetMixerSubTypeByEqpId(byMixerId,byMixerSubtype);
	TAudioTypeDesc atAudioTypeDesc[MAXNUM_CONF_AUDIOTYPE];
	memset(atAudioTypeDesc, 0, sizeof(atAudioTypeDesc));
	u8 byAudioCapNum = m_tConfEx.GetAudioTypeDesc(atAudioTypeDesc);

	if ( byAudioCapNum > 1	/*多音频格式会议*/
		|| (atAudioTypeDesc[0].GetAudioMediaType() == MEDIA_TYPE_AACLC && atAudioTypeDesc[0].GetAudioTrackNum() > 1) /*双声道*/
		|| (atAudioTypeDesc[0].GetAudioMediaType() == MEDIA_TYPE_AACLD && atAudioTypeDesc[0].GetAudioTrackNum() > 1) )
	{
		if (byMixerSubtype == APU2_MIXER || byMixerSubtype == MIXER_8KI)
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

	//只有APU混音器才进行音频类型检查
	if ( byMixerSubtype == APU_MIXER && 
		( atAudioTypeDesc[0].GetAudioMediaType() == MEDIA_TYPE_G719 || 
		  atAudioTypeDesc[0].GetAudioMediaType() == MEDIA_TYPE_AACLD||
		  atAudioTypeDesc[0].GetAudioMediaType() == MEDIA_TYPE_G729 ))
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[CheckMixerIsValide] MediaType[%d] IS NOT SURPPORTED BY Mixer[%d]!\n",
			atAudioTypeDesc[0].GetAudioMediaType(),byMixerId);
		return FALSE;
	}
	return TRUE;
}
/*====================================================================
函数名      ：GetMixerNModeChn
功能        ：获取混音器某种格式N模式混音通道起始号
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：u8: byAudioType （多格式时某种音频格式的全混通道，暂时未用）
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/03/17    4.0         田志勇        创建
====================================================================*/
u8  CMcuVcInst::GetMixerNModeChn()
{
	u8 byDstPos = 0;
	TPeriEqpStatus tEqpStatus ;
	if (!g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tEqpStatus))
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetMixerNModeChn] GetPeriEqpStatus.%d failed!\n", m_tMixEqp.GetEqpId());
		return 0;
	}
	u8 byMixerSubtype = UNKONW_MIXER;
	g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetEqpId(),byMixerSubtype);
	switch (byMixerSubtype)
	{
		case APU_MIXER:
		case MIXER_8KG:
		case MIXER_8KH:
			byDstPos = 0;
			break;
		case EAPU_MIXER:
		case APU2_MIXER:
		case MIXER_8KI:
		{
			byDstPos = tEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byMixGrpChnNum;
		}
			break; 
		default:
			byDstPos = 0;
			break;
	}
	return byDstPos;
}

/*====================================================================
函数名      CheckHduAbility
功能        ：根据终端能力校验hdu通道是否支持
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/05/5    4.0         周嘉麟          创建
====================================================================*/
BOOL32 CMcuVcInst::CheckHduAbility(TMt tSrc, const u8 byHduId, const u8 byChnId, u8 *pbyVmpOutChl,BOOL32 bIsSecVideo)
{
	if (tSrc.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckHduAbility] tSrc is null!\n");
		return FALSE;
	}
	
	if (byHduId < HDUID_MIN || byHduId > HDUID_MAX)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckHduAbility] HduId :%d is unexpected!\n", byHduId);
		return FALSE;
	}	

	BOOL32 bSrcVmp = FALSE;
	//区分终端进hdu和hdu选看vmp
	if (TYPE_MCUPERI == tSrc.GetType())
	{
		if (EQP_TYPE_VMP == tSrc.GetEqpType())
		{	
			bSrcVmp = TRUE;
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckHduAbility] Hdu select to see vmp!\n");
		}
		else
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckHduAbility] unexpect EqpTypeM<%d>!\n", tSrc.GetEqpType());
			return FALSE;
		}
	}
	else
	{	
		if (!tSrc.IsLocal())
		{
			tSrc = GetLocalMtFromOtherMcuMt(tSrc);
		}
	}	
	
	u8 bySrcMediaType = MEDIA_TYPE_NULL;
	u8 bySrcRes       = VIDEO_FORMAT_INVALID;
	u8 byFrame		  = 0;
	BOOL32 bVmpOutParam = FALSE;//是否依赖VmpOutParam，目前mpu2与8ki外设依赖
	emProfileAttrb emPattrb = emBpAttrb;

	//如果源是终端则通过逻辑通道获取发送能力
	if (!bSrcVmp)
	{
		TLogicalChannel tLogicalChnl;
		if (!bIsSecVideo)
		{
			if (!m_ptMtTable->GetMtLogicChnnl(tSrc.GetMtId(), LOGCHL_VIDEO, &tLogicalChnl, FALSE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckHduAbility]MainVideo GetMtLogicChnnl<MtId:%d> failed!\n",tSrc.GetMtId());
				return FALSE;
			}
		}
		else
		{
			if (!m_ptMtTable->GetMtLogicChnnl(tSrc.GetMtId(), LOGCHL_SECVIDEO, &tLogicalChnl, FALSE))
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckHduAbility]SecVideo GetMtLogicChnnl<MtId:%d> failed!\n",tSrc.GetMtId());
				return FALSE;
			}
		}
		
		bySrcMediaType = tLogicalChnl.GetChannelType();
		bySrcRes       = tLogicalChnl.GetVideoFormat();
		byFrame		   = tLogicalChnl.GetChanVidFPS();
		emPattrb       = tLogicalChnl.GetProfileAttrb();
	}
	//如果源是vmp则获取会议主能力力
	else
	{
		// 判断是否是MPU2、8KI合成器yhz-
		u8 byVmpSubType = GetVmpSubType(tSrc.GetEqpId());
		if (MPU2_VMP_ENHACED == byVmpSubType ||
			MPU2_VMP_BASIC == byVmpSubType ||
			VMP_8KI == byVmpSubType)
		{
			if (NULL == pbyVmpOutChl)
			{
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckHduAbility]Err, In Mpu2 Case, pbyVmpOutChl is Null!\n");
				return FALSE;
			}
			bVmpOutParam = TRUE;
		}

		bySrcMediaType = m_tConf.GetMainVideoMediaType();
		bySrcRes	   = m_tConf.GetMainVideoFormat();
		if (MEDIA_TYPE_H264 == bySrcMediaType)
		{
			byFrame = m_tConf.GetMainVidUsrDefFPS();
		}
		else
		{
			byFrame = m_tConf.GetMainVidFrameRate();
		}		
		emPattrb = m_tConf.GetProfileAttrb();
	}
	
	TPeriEqpStatus tHduStatus;
	if (!g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckHduAbility] GetPeriEqpStatus <HduId:%d> failed!\n", byHduId);
		return FALSE;
	}

	BOOL32 bRet = TRUE;
	if (bVmpOutParam)//mpu2、8kivmp有后适配能力列表,不依赖会议主格式
	{
		// 默认4CIF
		u8 byOnlyAttrb = 0XFF;
		TVideoStreamCap tHduStrCap;
		tHduStrCap.SetMediaType(MEDIA_TYPE_H264);
		tHduStrCap.SetMaxBitRate(m_tConf.GetBitRate());

		u8 bySubType = HDU_SUBTYPE_HDU_M;
		if(g_cMcuAgent.GetHduSubTypeByEqpId(byHduId,bySubType))
		{
			switch (bySubType)
			{// 获得hdu对应能力集
			case HDU_SUBTYPE_HDU2:
			case HDU_SUBTYPE_HDU2_S:
				{
					tHduStrCap.SetResolution(VIDEO_FORMAT_HD1080);
					tHduStrCap.SetUserDefFrameRate(60);
					tHduStrCap.SetH264ProfileAttrb(emHpAttrb);
				}
				break;
			case HDU_SUBTYPE_HDU_H:
				{
					byOnlyAttrb = emBpAttrb;	//只能解BP码流
					tHduStrCap.SetResolution(VIDEO_FORMAT_HD1080);
					tHduStrCap.SetUserDefFrameRate(60);
					tHduStrCap.SetH264ProfileAttrb(emBpAttrb);
				}
				break;
			case HDU_SUBTYPE_HDU_M:
				{
					byOnlyAttrb = emBpAttrb;	//只能解BP码流
					tHduStrCap.SetResolution(VIDEO_FORMAT_HD1080);
					tHduStrCap.SetUserDefFrameRate(30);
					tHduStrCap.SetH264ProfileAttrb(emBpAttrb);
				}
				break;
			case HDU_SUBTYPE_HDU_L:
			case HDU_SUBTYPE_HDU2_L:
				{
					byOnlyAttrb = emBpAttrb;	//只能解BP码流
					tHduStrCap.SetResolution(VIDEO_FORMAT_4CIF);
					tHduStrCap.SetUserDefFrameRate(30);
					tHduStrCap.SetH264ProfileAttrb(emBpAttrb);
				}
				break;
			default:
				{
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckHduAbility]Hdu type is wrong!\n");
					bRet =FALSE;
				}
				break;
			}
		}
		else
		{
			bRet =FALSE;
		}

		TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tSrc);
		*pbyVmpOutChl = tVMPOutParam.GetCorrectChnnlByStrCap(tHduStrCap, byOnlyAttrb);
		if (0XFF == *pbyVmpOutChl)
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[CheckHduAbility] Can't find correct chnnl for hdu in MPU2 out param!\n",
				tSrc.GetMcuId(), tSrc.GetMtId(), byFrame, bySrcRes);
			bRet = FALSE;
		}
	}
	else if (MEDIA_TYPE_H264 == bySrcMediaType)
	{
		u8 bySubType = HDU_SUBTYPE_HDU_M;
		if(g_cMcuAgent.GetHduSubTypeByEqpId(byHduId,bySubType))
		{
			switch(bySubType)
			{
			case HDU_SUBTYPE_HDU_M:
				if (emPattrb == emHpAttrb || ((byFrame > 30 &&  bySrcRes == VIDEO_FORMAT_HD1080) || IsResG(bySrcRes, VIDEO_FORMAT_HD1080)))
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[CheckHduAbility] src(%d, %d) Frame.%d or Res.%d ProfileAttrb.%d is too larger for Hdu_M to support!\n",
						tSrc.GetMcuId(), tSrc.GetMtId(), byFrame, bySrcRes,emPattrb);
					bRet = FALSE;
				}
				break;
			case HDU_SUBTYPE_HDU_H:
				if (emPattrb == emHpAttrb || (byFrame > 60 || IsResG(bySrcRes, VIDEO_FORMAT_HD1080)))
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[CheckHduAbility] src(%d, %d) Frame %d or Res.%d ProfileAttrb.%d is too larger for Hdu_H to support!\n",
						tSrc.GetMcuId(), tSrc.GetMtId(), byFrame, bySrcRes,emPattrb);
					bRet = FALSE;
				}
				break;
			case HDU_SUBTYPE_HDU_L://标清不做帧率校验
				if (emPattrb == emHpAttrb || (IsResG(bySrcRes, VIDEO_FORMAT_4CIF)))
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[CheckHduAbility] src(%d, %d) Frame %d or Res.%d ProfileAttrb.%d is too larger for Hdu_L to support!\n",
						tSrc.GetMcuId(), tSrc.GetMtId(), byFrame, bySrcRes,emPattrb);
					bRet = FALSE;
				}
				break;
			case HDU_SUBTYPE_HDU2_L:
				if (emPattrb == emHpAttrb || 
					(IsResG(bySrcRes, VIDEO_FORMAT_4CIF) && bySrcRes != VIDEO_FORMAT_SVGA && 
					bySrcRes != VIDEO_FORMAT_XGA && bySrcRes != VIDEO_FORMAT_SXGA))
				{
					ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[CheckHduAbility] src(%d, %d) Frame %d or Res.%d ProfileAttrb.%d is too larger for Hdu2_L to support!\n",
						tSrc.GetMcuId(), tSrc.GetMtId(), byFrame, bySrcRes,emPattrb);
					bRet = FALSE;
				}
				break;
			case HDU_SUBTYPE_HDU2:
			case HDU_SUBTYPE_HDU2_S:
				//HDU2能力最强,目前无限制
				break;
			default:
				ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckHduAbility] unexpected HduType:%d!\n", tHduStatus.GetEqpType());
				bRet = FALSE;
			}
		}
		else
		{
			bRet = FALSE;
		}
	}		

	//如果能力限制则通告界面
	if (!bRet)
	{
		if(POLL_STATE_NONE == m_tHduBatchPollInfo.GetStatus()
			&& POLL_STATE_NONE == m_tConf.m_tStatus.GethduPollState()
			&& VCS_TVWALLMANAGE_REVIEW_MODE != m_cVCSConfStatus.GetTVWallManageMode()
			&& TW_MEMBERTYPE_POLL != tHduStatus.m_tStatus.tHdu.atVideoMt[byChnId].byMemberType)
		{
			NotifyMcsAlarmInfo(0, ERR_HDU_CHNDECABILITYNOTMATCHED);
		}
		else
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[CheckHduAbility] HduBathPollStat.%d, HduPollStat.%d, VcsTWMode.%d, MemberType.%d!\n",
										m_tHduBatchPollInfo.GetStatus(), 
										m_tConf.m_tStatus.GethduPollState(), 
										m_cVCSConfStatus.GetTVWallManageMode(),
										tHduStatus.m_tStatus.tHdu.atVideoMt[byChnId].byMemberType);
		}
		
	}

    return bRet;
}

/*====================================================================
函数名        GetHduChnSupportCap
功能        ：获取HDU通道支持的能力集,默认获取HDU2多画面通道能力
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/11   4.7.2       陈兵         修改(HDU多画面支持)
====================================================================*/
TSimCapSet CMcuVcInst::GetHduChnSupportCap(TMt tSrc, u8 byHduId, u8 byMode /* = MODE_BOTH */)
{
	TMt tUnLocalTMt = tSrc;
	if (!tUnLocalTMt.IsLocal())
	{
		tUnLocalTMt = GetLocalMtFromOtherMcuMt(tUnLocalTMt);
	}

	TSimCapSet tSimCapSet;
	//获取源发送能力
	TLogicalChannel tLogicalChnl;
	if (byMode == MODE_VIDEO || byMode == MODE_BOTH)
	{
		if (!m_ptMtTable->GetMtLogicChnnl(tUnLocalTMt.GetMtId(), LOGCHL_VIDEO, &tLogicalChnl, FALSE))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetHduChnSupportCap]MainVideo GetMtLogicChnnl<MtId:%d> failed!\n",tUnLocalTMt.GetMtId());
			return tSimCapSet;
		}
	}
	else if (byMode == MODE_SECVIDEO)
	{
		if (!m_ptMtTable->GetMtLogicChnnl(tUnLocalTMt.GetMtId(), LOGCHL_SECVIDEO, &tLogicalChnl, FALSE))
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetHduChnSupportCap]Secvideo GetMtLogicChnnl<MtId:%d> failed!\n",tUnLocalTMt.GetMtId());
			return tSimCapSet;
		}
	}

	//源能力集
	u8 bySrcMediaType   = tLogicalChnl.GetChannelType();
	tSimCapSet.SetVideoMediaType( bySrcMediaType );
	tSimCapSet.SetVideoMaxBitRate( m_ptMtTable->GetSndBandWidth(tUnLocalTMt.GetMtId()) );
	tSimCapSet.SetVideoProfileType( tLogicalChnl.GetProfileAttrb() );

	
	u8 bySubEqpType = 0;
	if (byHduId >= HDUID_MIN && byHduId <= HDUID_MAX)
	{
		g_cMcuAgent.GetHduSubTypeByEqpId(byHduId, bySubEqpType);
	}
	else
	{
		bySubEqpType = HDU_SUBTYPE_HDU2;
	}
	
	switch( bySubEqpType )
	{
	case HDU_SUBTYPE_HDU2:
	case HDU_SUBTYPE_HDU2_S:
		{
			switch (bySrcMediaType)
			{
			case MEDIA_TYPE_H264: 
				{
					tSimCapSet.SetUserDefFrameRate(tLogicalChnl.GetChanVidFPS());
					tSimCapSet.SetVideoResolution(tLogicalChnl.GetVideoFormat());
					if (IsSrcResThanDst(tSimCapSet.GetVideoResolution(), VIDEO_FORMAT_HD720))
					{
						tSimCapSet.SetVideoResolution( VIDEO_FORMAT_HD720 );
					}
					
					if ( tSimCapSet.GetUserDefFrameRate() > 30 )
					{
						tSimCapSet.SetUserDefFrameRate( 30 );
					}
				}
				break;
				
			case MEDIA_TYPE_MP4:
				{
					tSimCapSet.SetVideoResolution( VIDEO_FORMAT_CIF );
					tSimCapSet.SetVideoFrameRate( 25 );
				}
				break;

			default:
				tSimCapSet.SetVideoResolution( VIDEO_FORMAT_CIF );
				tSimCapSet.SetVideoFrameRate( 25 );
				break;
			}
			break;
		}
	default:
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetHduChnSupportCap]bySubEqpType (%d) error!\n", bySubEqpType);
		break;
	}

	return tSimCapSet;
}

/*====================================================================
函数名        IsViewMtInHduVmp
功能        ：当前上传源Mt是否在HDU其他多画面中
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/11   4.7.2       陈兵         修改(HDU多画面支持)
====================================================================*/
BOOL32 CMcuVcInst::IsViewMtInHduVmp(TMt tNewTMt, TMt *ptOldTMt, BOOL32 bIsNewViewMt)
{
	TPeriEqpStatus tHduStatus;
	TMt tMtInHduVmp;

	BOOL32 bIsMtInHduVmp = FALSE;
	for(u8 byEqpId = HDUID_MIN; byEqpId <= HDUID_MAX; byEqpId++)
	{
		u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpId));
		if (0 == byHduChnNum)
		{
			continue;
		}
		
		g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tHduStatus);
		if( !tHduStatus.m_byOnline )
		{
			continue;
		}

		for(u8 byChnId = 0; byChnId < min(byHduChnNum, MAXNUM_HDU_CHANNEL); byChnId++)
		{
			// [2013/03/11 chenbing] 四风格下子通道遍历
			if (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnId) )
			{
				for (u8 bySubChnId=0; bySubChnId<HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnId++)
				{
					tMtInHduVmp = (TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnId, bySubChnId);
					if( tMtInHduVmp.GetConfIdx() == m_byConfIdx )
					{
						if ( bIsNewViewMt )
						{
							if ( tMtInHduVmp == tNewTMt )
							{
								return FALSE;
							}

							if ( (NULL != ptOldTMt && tMtInHduVmp == *ptOldTMt)
							 || (IsMcu(tMtInHduVmp) && IsSmcuViewMtInMcu(tNewTMt, tMtInHduVmp))
							   )
							{
								bIsMtInHduVmp = TRUE;
							}
						}
						else
						{
							//当前上传源已经在通道中
							if ( (tMtInHduVmp == tNewTMt)
							  || (IsMcu(tMtInHduVmp) && IsSmcuViewMtInMcu(tNewTMt, tMtInHduVmp))
							   )
							{
								return TRUE;
							}
						}
					}
				}
			}
		}
	}

	return bIsMtInHduVmp;
}

/*====================================================================
函数名        IsOldMtAndNewMtSame
功能        ：老终端与新终端是否相同
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/11   4.7.2       陈兵         修改(HDU多画面支持)
====================================================================*/
BOOL32 CMcuVcInst::IsOldViewMtAndNewViewMtSame(TMt tNewtMt, TMt tOldtMt)
{
	//1、新源为Mt， 旧通道成员为Mt，Mt不相同
	//2、新源为Mcu，旧通道成员为Mt, Mcu上传源与旧Mt不相同
	//3、新源为Mt， 旧通道成员为Mcu, Mt与旧Mcu上传源不相同
	//4、新源为Mcu，旧通道成员为Mcu, 新Mcu上传源与旧Mcu上传源不相同
	if((( tNewtMt == tOldtMt) && !IsMcu(tNewtMt) && !IsMcu(tOldtMt) )
	 ||( IsMcu(tNewtMt) && !IsMcu(tOldtMt) && GetSMcuViewMt(tNewtMt, TRUE) == tOldtMt )
	 ||(!IsMcu(tNewtMt) &&  IsMcu(tOldtMt) && GetSMcuViewMt(tOldtMt, TRUE) == tNewtMt )
	 ||( IsMcu(tNewtMt) &&  IsMcu(tOldtMt) && GetSMcuViewMt(tNewtMt, TRUE) == GetSMcuViewMt(tOldtMt, TRUE) )
	  )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

/*====================================================================
函数名        IsMtInHduVmp
功能        ：当前Mt是否在HDU其他多画面中
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/11   4.7.2       陈兵         修改(HDU多画面支持)
====================================================================*/
BOOL32 CMcuVcInst::IsMtInHduVmp(TMt tMt, 
								u8 byHduId,
								u8 byHduChnId, 
								u8 byHduSubChnId,
								BOOL32 bIsIgnoreCurChn, 
								BOOL32 bIsIgnoreCurEqpId,
								BOOL32 bIsIgnoreCurState/* = FALSE*/)
{
	TPeriEqpStatus tHduStatus;
	TMt tMtInHduVmp;

	for(u8 byEqpId = HDUID_MIN; byEqpId <= HDUID_MAX; byEqpId++)
	{
		u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpId));
		if (0 == byHduChnNum)
		{
			continue;
		}
		
		g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tHduStatus);
		if( !tHduStatus.m_byOnline )
		{
			continue;
		}

		if (byEqpId == byHduId && bIsIgnoreCurEqpId)
		{
			continue;
		}

		for(u8 byChnId = 0; byChnId < min(byHduChnNum, MAXNUM_HDU_CHANNEL); byChnId++)
		{
			// [2013/03/11 chenbing] 四风格下子通道遍历
			if (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnId) )
			{
				for (u8 bySubChnId=0; bySubChnId<HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnId++)
				{
					tMtInHduVmp = (TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnId, bySubChnId);
					if( ( tMtInHduVmp.GetConfIdx() == m_byConfIdx )
					 && ( bIsIgnoreCurState || THduChnStatus::eRUNNING == tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnId, bySubChnId) ) 
					 && ( (tMtInHduVmp == tMt)
					    || (IsMcu(tMtInHduVmp) && IsSmcuViewMtInMcu(tMt, tMtInHduVmp))
						|| (IsMcu(tMt) && IsSmcuViewMtInMcu(tMtInHduVmp, tMt)) 
						)
					  )
					{
						//除去当前外设的子通道
						if ( bIsIgnoreCurChn && byEqpId == byHduId && byChnId == byHduChnId && bySubChnId == byHduSubChnId )
						{
							continue;
						}
						else
						{
							return TRUE;
						}
					}
				}
			}
		}
	}

	return FALSE;
}

/*====================================================================
函数名        IsBatchPollMtInHduVmp
功能        ：批量轮询的Mt是否在HDU其他多画面中
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/11   4.7.2       陈兵         修改(HDU多画面支持)
====================================================================*/
BOOL32 CMcuVcInst::IsBatchPollMtInHduVmp(TMt tMt,BOOL32 bIsIgnoreCurState/* = FALSE*/)
{
	TPeriEqpStatus tHduStatus;
	THduChnlPollInfo *ptHduChnlPollInfo = m_tHduBatchPollInfo.m_tChnlBatchPollInfo;
	if (NULL == ptHduChnlPollInfo)
	{
		return FALSE;
	}

	u8 abyHduId[MAXNUM_HDUBRD][MAXNUM_HDU_CHANNEL];
	memset(abyHduId, 0xff, sizeof(abyHduId));
	for (u8 byChnId = 0; byChnId < MAXNUM_HDUCFG_CHNLNUM; byChnId++)
	{
		u8 byHduId = ptHduChnlPollInfo[byChnId].GetEqpId();
		if ( byHduId < HDUID_MIN || byHduId > HDUID_MAX )
		{
			continue;
		}

		g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus);
		if (!tHduStatus.m_byOnline)
		{
			continue;
		}
		
		abyHduId[byHduId-HDUID_MIN][ptHduChnlPollInfo[byChnId].GetChnlIdx()] = ptHduChnlPollInfo[byChnId].GetChnlIdx();
	}
	
	TMt tMtInHduVmp;
	for(u8 byEqpId = HDUID_MIN; byEqpId <= HDUID_MAX; byEqpId++)
	{
		u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpId));
		if (0 == byHduChnNum)
		{
			continue;
		}
		
		g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tHduStatus);
		if( !tHduStatus.m_byOnline )
		{
			continue;
		}

		for(u8 byChnId = 0; byChnId < min(byHduChnNum, MAXNUM_HDU_CHANNEL); byChnId++)
		{
			if (byChnId == abyHduId[byEqpId-HDUID_MIN][byChnId])
			{
				continue;
			}

			// [2013/03/11 chenbing] 四风格下子通道遍历
			if (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnId) )
			{
				for (u8 bySubChnId=0; bySubChnId<HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnId++)
				{
					tMtInHduVmp = (TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byChnId, bySubChnId);
					if( ( tMtInHduVmp.GetConfIdx() == m_byConfIdx )
					 && ( bIsIgnoreCurState || THduChnStatus::eRUNNING == tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnId, bySubChnId) ) 
					 && ( (tMtInHduVmp == tMt)
					    || (IsMcu(tMtInHduVmp) && IsSmcuViewMtInMcu(tMt, tMtInHduVmp))
						|| (IsMcu(tMt) && IsSmcuViewMtInMcu(tMtInHduVmp, tMt)) 
						)
					  )
					{
						return TRUE;
					}
				}
			}
		}
	}

	return FALSE;
}

/*====================================================================
函数名        StopViewToAllHduVmpSwitch
功能        ：拆除上传源到所有HDU多画面通道的交换
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2013/03/11   4.7.2       陈兵         修改(HDU多画面支持)
====================================================================*/
void CMcuVcInst::StopViewToAllHduVmpSwitch(TMt tMt)
{
	TPeriEqpStatus tHduStatus;
	TMt tMtInHduVmp;
	
	//查询所有电视墙
    for(u8 byHduId = HDUID_MIN; byHduId <= HDUID_MAX; byHduId++)
    {
		u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduId));
		if (0 == byHduChnNum)
		{
			continue;
		}
		
        g_cMcuVcApp.GetPeriEqpStatus(byHduId, &tHduStatus);
        if( tHduStatus.m_byOnline )
        {
            for(u8 byHduChnId = 0; byHduChnId < min(byHduChnNum, MAXNUM_HDU_CHANNEL); byHduChnId++)
            {
				// [2013/03/11 chenbing] 四风格下子通道遍历
				if (HDUCHN_MODE_FOUR == tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byHduChnId) )
				{
					for (u8 bySubChnId=0; bySubChnId<HDU_MODEFOUR_MAX_SUBCHNNUM; bySubChnId++)
					{
						tMtInHduVmp = (TMt)tHduStatus.m_tStatus.tHdu.GetChnMt(byHduChnId, bySubChnId);
						if( (tMtInHduVmp.GetConfIdx() == m_byConfIdx)
						 && (  (tMtInHduVmp == tMt)
						    || (tMtInHduVmp == GetLocalMtFromOtherMcuMt(tMt) )
							)
						  )
						{
							ChangeHduSwitch(NULL, byHduId, byHduChnId, bySubChnId, TW_MEMBERTYPE_MCSSPEC, 
												TW_STATE_STOP, MODE_VIDEO, FALSE, TRUE, TRUE, HDUCHN_MODE_FOUR);
						}
					}
				}
            }
        }
    }
}


/*====================================================================
函数名      CheckTwAbility
功能        ：根据终端能力校验Tw通道是否支持(目前仅判断终端是否是HP码流) DEC5不能接受HP码流
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
12/05/30    4.7          田志勇          创建
====================================================================*/
BOOL32 CMcuVcInst::CheckTwAbility(TMt tSrc, const u8 byTwId, const u8 byChnId)
{
	if (tSrc.IsNull())
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckTwAbility] tSrc is null!\n");
		return FALSE;
	}
	
	if (byTwId < TVWALLID_MIN || byTwId > TVWALLID_MAX)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckTwAbility] HduId :%d is unexpected!\n", byTwId);
		return FALSE;
	}
	if (byChnId >= MAXNUM_PERIEQP_CHNNL)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,"[CheckTwAbility]byChnlIdx(%d) >= MAXNUM_PERIEQP_CHNNL(%d)\n",
			byChnId , MAXNUM_PERIEQP_CHNNL );
		return FALSE;
	}
	TMt tLocalMt = tSrc;
	if (!tSrc.IsLocal())
	{
		tLocalMt = GetLocalMtFromOtherMcuMt(tSrc);
	}
	TLogicalChannel tLogicalChnl;
	if (!m_ptMtTable->GetMtLogicChnnl(tLocalMt.GetMtId(), LOGCHL_VIDEO, &tLogicalChnl, FALSE))
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckTwAbility]MainVideo GetMtLogicChnnl<MtId:%d> failed!\n",tLocalMt.GetMtId());
		return FALSE;
	}
	if (tLogicalChnl.GetProfileAttrb() == emHpAttrb)
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[CheckTwAbility]tLogicalChnl.GetProfileAttrb() == emHpAttrb So Return False!\n");
		NotifyMcsAlarmInfo(0, ERR_HDU_CHNDECABILITYNOTMATCHED);
		return FALSE;
	}
	return TRUE;
}

/*====================================================================
函数名      ：GetConfHduChnnl
功能        ：根据索引(会议中配置的hdu通道的索引)获取hdu通道状态
算法实现    ：
引用全局变量：
输入参数说明：[in]byChnnlIdx,		会议中配置的hdu通道的索引
              [out]cChnnl,			hdu通道
返回值说明  ：true,获取成功; 否则失败
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
BOOL32 CMcuVcInst::GetConfHduChnnl( const u8 byChnnlIdx, CConfTvwChnnl& cChnnl)
{
	// 先主动清空
	cChnnl.Clear();
	
	// 通道索引不合法,直接返回
	BOOL32 bVcsConf = (m_tConf.GetConfSource() == VCS_CONF) ? TRUE:FALSE;
	if ( byChnnlIdx >= m_tConfEqpModule.m_tHduModule.GetHduChnlNum( bVcsConf ) )
	{
		return FALSE;
	}
	
	// 根据索引获取它在此会议中配置的通道信息
	THduModChnlInfo tChnlInfo    = m_tConfEqpModule.m_tHduModule.GetOneHduChnlInfo(byChnnlIdx);
	// 验证它的设备号和通道号是否合法
	if (!tChnlInfo.IsValid())
	{
		return FALSE;
	}

	cChnnl.SetConfMember(tChnlInfo.GetHduChnlMember());
	cChnnl.SetConfMemberType(tChnlInfo.GetMemberType());
	
	return GetTvwChnnl(tChnlInfo.GetHduID(), tChnlInfo.GetHduChnlIdx(), /*(CTvwChnnl)*/cChnnl);
}


/*====================================================================
函数名      ：GetConfTvwChnnl
功能        ：根据索引(会议中配置的tvw通道的索引)获取tvw通道状态
算法实现    ：
引用全局变量：
输入参数说明：[in]byChnnlIdx,		会议中配置的Tvwall通道的索引
              [out]cChnnl,			tvw通道
返回值说明  ：true,获取成功; 否则失败
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
BOOL32 CMcuVcInst::GetConfTvwChnnl( const u8 byChnnlIdx, CConfTvwChnnl& cChnnl)
{
	// 先主动清空
	cChnnl.Clear();

	// 会议中是否配置了tvwall设备
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	if( tConfAttrb.IsHasTvWallModule() )
	{
		TMultiTvWallModule tMultiTvWallModule;
		m_tConfEqpModule.GetMultiTvWallModule( tMultiTvWallModule );
		
		BOOL32 bVcsConf = (  VCS_CONF == m_tConf.GetConfSource() )?TRUE:FALSE;
		if ( byChnnlIdx >= tMultiTvWallModule.GetChnnlNum(bVcsConf) )
		{
			return FALSE;			
		}

		// 换算, 将会议中配置的全局通道号转为具体的设备索引和这个设备中对应的通道号
		u8 byTvwIdx = byChnnlIdx / MAXNUM_MAP;					// 转为设备索引
		u8 byActChnnlIdx = byChnnlIdx % MAXNUM_MAP;				// 转为通道索引

		TTvWallModule tTvWallModule;
		if(!tMultiTvWallModule.GetTvModuleByIdx(byTvwIdx, tTvWallModule))
		{
			return FALSE;
		}
		if (byActChnnlIdx >= MAXNUM_TVWALL_CHNNL_INSMOUDLE)
		{
			return FALSE;
		}
		cChnnl.SetConfMember(tTvWallModule.m_abyTvWallMember[byActChnnlIdx]);
		cChnnl.SetConfMemberType(tTvWallModule.m_abyMemberType[byActChnnlIdx]);

		return GetTvwChnnl(tTvWallModule.m_tTvWall.GetEqpId(), byActChnnlIdx, /*(CTvwChnnl)*/cChnnl);
	}

	return FALSE;
}

/*====================================================================
函数名      ：GetCfgTvwChnnl
功能        ：根据会议配置的电视墙编号获取对应的电视墙通道(hdu or tvwall)
算法实现    ：
引用全局变量：
输入参数说明：[in]byChnnlIdx,		会议中配置的Tvw通道的索引
              [out]cChnnl,			tvw通道
返回值说明  ：true,获取成功; 否则失败
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
BOOL32 CMcuVcInst::GetCfgTvwChnnl( const u8 byChnnlIdx, CConfTvwChnnl& cChnnl)
{
	// 会议总共配置的HDU通道数量
	BOOL32 bVcsConf = ( m_tConf.GetConfSource() == VCS_CONF ) ? TRUE : FALSE;
	const u16 wConfCfgedHduChnNum = m_tConfEqpModule.m_tHduModule.GetHduChnlNum( bVcsConf );
	
	if ( byChnnlIdx <= wConfCfgedHduChnNum )
	{
		return GetConfHduChnnl((u8)byChnnlIdx - 1, cChnnl );
	}else
	{
		return GetConfTvwChnnl( (u8)(byChnnlIdx - wConfCfgedHduChnNum - 1), cChnnl );
	}
}

/*====================================================================
函数名      ：GetConfCfgedTvwIdx
功能        ：根据设备号和通道号找该电视墙通道在会议中对应的通道号, 支持hdu和tvwall
算法实现    ：
引用全局变量：
输入参数说明：[in]byEqpId, 电视墙设备id
              [in]byTvwIdx, 电视墙通道号
返回值说明  ：返回找到的索引号(范围[1， 配置的电视墙通道数]), 没找到返回0
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
u8 CMcuVcInst::GetConfCfgedTvwIdx( const u8 byEqpId, const u8 byTvwChnnlIdx )
{
	// 会议配置的hdu通道数量
	BOOL32 bVcsConf = ( m_tConf.GetConfSource() == VCS_CONF ) ? TRUE : FALSE;
	const u8 byHduChnnlNum = m_tConfEqpModule.m_tHduModule.GetHduChnlNum( bVcsConf );

	if (IsValidHduChn(byEqpId, byTvwChnnlIdx))
	{		
		THduModChnlInfo tChnlInfo;
		for( u8 byLoop = 0; byLoop < byHduChnnlNum; ++byLoop )
		{
			// 根据索引获取它在此会议中配置的通道信息
			tChnlInfo    = m_tConfEqpModule.m_tHduModule.GetOneHduChnlInfo(byLoop);
			
			if (byEqpId == tChnlInfo.GetHduID() && byTvwChnnlIdx == tChnlInfo.GetHduChnlIdx())
			{
				return ++byLoop;
			}
		}
	}else if (IsValidTvw(byEqpId, byTvwChnnlIdx))
	{
		// 会议中是否配置了tvwall设备
		TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
		if( tConfAttrb.IsHasTvWallModule() )
		{
			TMultiTvWallModule tMultiTvWallModule;
			m_tConfEqpModule.GetMultiTvWallModule( tMultiTvWallModule );
			const u8 byTvwChnnlNum = tMultiTvWallModule.GetChnnlNum( bVcsConf ) ;
			
			CConfTvwChnnl cTvwChnnl;
			for ( u8 byLoop = 0; byLoop < byTvwChnnlNum; ++byLoop )
			{
				if (!GetConfTvwChnnl( byLoop, cTvwChnnl ))
				{
					continue;	
				}

				if (cTvwChnnl.GetEqpId() == byEqpId && cTvwChnnl.GetChnnlIdx() == byTvwChnnlIdx)
				{
					return byHduChnnlNum + byLoop + 1;
				}
			}
		}
	}

	return 0;
}

/*====================================================================
函数名      ：FindHduChnnlByMcu
功能        ：寻找为某个下级mcu服务的hdu通道
算法实现    ：
引用全局变量：
输入参数说明：[in]tSubMcu, 下级mcu或下级终端
              [out]pacChnnl, 数组, 存储搜索得到的tvw通道(根据搜索顺序依次存储).
			  [out]byChnnlNum, 将要搜索得到的通道数目
返回值说明  ：如果pacChnnl为null且byChnnlNum为0，或者实际数目小于byChnnlNum, 则返回实际搜索得到的通道数;
			  如果pacChnnl和byChnnlNum之一为0, 返回0;
			  如果实际数目大于byChnnlNum, 返回byChnnlNum;
			  否则返回实际搜索的数目
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
u8 CMcuVcInst::FindHduChnnlByMcu( const TMt& tSubMt, CConfTvwChnnl* pacChnnl /*= NULL*/, const u8 byChnnlNum /*= 0*/)
{
	// 先主动清空缓冲区
	if (pacChnnl && byChnnlNum)
	{
		memset(pacChnnl, 0, sizeof(CConfTvwChnnl) * byChnnlNum );
	}

	// 如果tSubMt非法, 返回0
	if (tSubMt.IsNull() || tSubMt.IsLocal())
	{
		return 0;
	}

	// 获取直属下级Mcu在本级表示的Mcu Id
	const u8 bySubMcuIdx = GetFstMcuIdFromMcuIdx( tSubMt.GetMcuId() ); 
	if (!bySubMcuIdx)
	{
		return 0;
	}

	// 已经找到的数量
	u8	byFindNum = 0;
	CConfTvwChnnl cFindChnnl;
	
	// 优先搜索HDU
	BOOL32 bVcsConf = ( m_tConf.GetConfSource() == VCS_CONF ) ? TRUE : FALSE;
	const u8 byHduChnnlNum = m_tConfEqpModule.m_tHduModule.GetHduChnlNum( bVcsConf );
	for ( u8 byLoop = 0; byLoop < byHduChnnlNum; ++byLoop )
	{
		GetConfHduChnnl( byLoop, cFindChnnl);

		if (!cFindChnnl.IsNull())
		{
			// 成为为本级, 直接返回
			if (cFindChnnl.GetMember().IsNull() || cFindChnnl.GetMember().IsLocal())
			{
				continue;
			}

			// 判断是否是属于同一个下级mcu
			if ( GetFstMcuIdFromMcuIdx( cFindChnnl.GetMember().GetMcuId() ) != bySubMcuIdx )
			{
				continue;
			}

			// 如果能写入, 先写入缓冲区
			if (pacChnnl && byFindNum < byChnnlNum)
			{
				pacChnnl[byFindNum] = cFindChnnl;
			}

			// 累加已经找到的数目
			byFindNum++;

			// 已经找到需要的数目, 直接返回
			if (pacChnnl && byChnnlNum && byFindNum >= byChnnlNum)
			{
				return byChnnlNum;
			}
		}
	}

	return byFindNum;
}

/*====================================================================
函数名      ：FindTvwChnnlByMcu
功能        ：寻找为某个下级mcu服务的tvw通道
算法实现    ：
引用全局变量：
输入参数说明：[in]tSubMcu, 下级mcu或下级终端
              [out]pacChnnl, 数组, 存储搜索得到的tvw通道(根据搜索顺序依次存储).
			  [out]byChnnlNum, 将要搜索得到的通道数目
返回值说明  ：如果pacChnnl为null且byChnnlNum为0，或者实际数目小于byChnnlNum, 则返回实际搜索得到的通道数;
			  如果pacChnnl和byChnnlNum之一为0, 返回0;
			  如果实际数目大于byChnnlNum, 返回byChnnlNum;
			  否则返回实际搜索的数目
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
u8 CMcuVcInst::FindTvwChnnlByMcu( const TMt& tSubMt, CConfTvwChnnl* pacChnnl /*= NULL*/, const u8 byChnnlNum /*= 0*/)
{
	// 先主动清空缓冲区
	if (pacChnnl && byChnnlNum)
	{
		memset(pacChnnl, 0, sizeof(CConfTvwChnnl) * byChnnlNum );
	}
	
	// 如果tSubMt非法, 返回0
	if (tSubMt.IsNull() || tSubMt.IsLocal())
	{
		return 0;
	}

	// 如果没有启用tvwall, 直接返回0
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	if( !tConfAttrb.IsHasTvWallModule() )
	{
		return 0;
	}
	
	// 获取直属下级Mcu在本级表示的Mcu Id
	const u8 bySubMcuIdx = GetFstMcuIdFromMcuIdx( tSubMt.GetMcuId() ); 
	
	// 获取tvwall配置
	TMultiTvWallModule tMultiTvWallModule;
	m_tConfEqpModule.GetMultiTvWallModule( tMultiTvWallModule );

	// 已经找到的数量
	u8	byFindNum = 0;
	CConfTvwChnnl cFindChnnl;
	
	BOOL32 bVcsConf = ( VCS_CONF == m_tConf.GetConfSource() ) ? TRUE : FALSE;
	const u8 byTvwChnnlNum = tMultiTvWallModule.GetChnnlNum( bVcsConf );
	for ( u8 byLoop = 0; byLoop < byTvwChnnlNum; ++byLoop )
	{
		GetConfTvwChnnl( byLoop, cFindChnnl);		
		if (!cFindChnnl.IsNull())
		{
			// 成为为本级, 直接返回
			if (cFindChnnl.GetMember().IsNull() || cFindChnnl.GetMember().IsLocal())
			{
				continue;
			}

			// 判断是否是属于同一个下级mcu
			if ( GetFstMcuIdFromMcuIdx( cFindChnnl.GetMember().GetMcuId() ) != bySubMcuIdx )
			{
				continue;
			}
			
			// 如果能写入, 先写入缓冲区
			if (pacChnnl && byFindNum < byChnnlNum)
			{
				pacChnnl[byFindNum] = cFindChnnl;
			}
			
			// 累加已经找到的数目
			byFindNum++;
			
			// 已经找到需要的数目, 直接返回
			if (pacChnnl && byChnnlNum && byFindNum >= byChnnlNum)
			{
				return byChnnlNum;
			}
		}
	}
	
	return byFindNum;
}

/*====================================================================
函数名      ：FindAllTvwChnnlByMcu
功能        ：寻找为某个下级mcu服务的电视墙通道, 搜索顺序是hdu->tvwall->hdtvall
算法实现    ：
引用全局变量：
输入参数说明：[in]tSubMcu, 下级mcu或下级终端
              [out]pacChnnl, 数组, 存储搜索得到的tvw通道(根据搜索顺序依次存储).
			  [out]byChnnlNum, 将要搜索得到的通道数目
返回值说明  ：如果pacChnnl为null且byChnnlNum为0，或者实际数目小于byChnnlNum, 则返回实际搜索得到的通道数;
			  如果pacChnnl和byChnnlNum之一为0, 返回0;
			  如果实际数目大于byChnnlNum, 返回byChnnlNum;
			  否则返回实际搜索的数目
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
u8 CMcuVcInst::FindAllTvwChnnlByMcu( const TMt& tSubMt, CConfTvwChnnl* pacChnnl/* = NULL*/, const u8 byChnnlNum /*= 0*/)
{
	// 优先搜索HDU电视墙
	u8 byFindNum = FindHduChnnlByMcu(tSubMt, pacChnnl, byChnnlNum);
	
	// 接着搜索Tvw电视墙
	if (byFindNum < byChnnlNum)
	{
		byFindNum += FindTvwChnnlByMcu(tSubMt, pacChnnl + byFindNum, byChnnlNum - byFindNum );
	}
	
	return byFindNum;	
}

/*====================================================================
函数名      ：FindHduChnnl
功能        ：寻找TvMember为tSrc的电视墙通道
算法实现    ：
引用全局变量：
输入参数说明：[in]tSrc, 电视墙通道成员
              [out]pacChnnl, 数组, 存储搜索得到的tvw通道(根据搜索顺序依次存储).
			  [in]byChnnlNum, 将要搜索得到的通道数目
返回值说明  ：如果pacChnnl为null且byChnnlNum为0，或者实际数目小于byChnnlNum, 则返回实际搜索得到的通道数;
			  如果pacChnnl和byChnnlNum之一为0, 返回0;
			  如果实际数目大于byChnnlNum, 返回byChnnlNum;
			  否则返回实际搜索的数目
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
u8 CMcuVcInst::FindHduChnnl( const TMt& tSrc, CConfTvwChnnl* pacChnnl, const u8 byChnnlNum )
{
	// 先主动清空缓冲区
	if (pacChnnl && byChnnlNum)
	{
		memset(pacChnnl, 0, sizeof(CConfTvwChnnl) * byChnnlNum );
	}
	
	// 如果tSrc非法, 返回0
	if ( tSrc.IsNull() )
	{
		return 0;
	}

	// 如果是mcu, 则返回它下面终端所在的电视墙数目
	if (IsMcu( tSrc ))
	{
		return FindHduChnnlByMcu(tSrc, pacChnnl, byChnnlNum);
	}
	
	// 已经找到的数量
	u8	byFindNum = 0;
	CConfTvwChnnl cFindChnnl;
	
	// 优先搜索HDU
	BOOL32 bVcsConf =  ( m_tConf.GetConfSource() == VCS_CONF ) ? TRUE : FALSE;
	const u8 byHduChnnlNum = m_tConfEqpModule.m_tHduModule.GetHduChnlNum( bVcsConf );
	for ( u8 byLoop = 0; byLoop < byHduChnnlNum; ++byLoop )
	{
		GetConfHduChnnl( byLoop, cFindChnnl);
		
		if (!cFindChnnl.IsNull())
		{
			// 判断通道成员是否与目标相等
			if ( !(tSrc == (TMt)(cFindChnnl.GetMember())) )
			{
				continue;
			}
			
			// 如果能写入, 先写入缓冲区
			if (pacChnnl && byFindNum < byChnnlNum)
			{
				pacChnnl[byFindNum] = cFindChnnl;
			}
			
			// 累加已经找到的数目
			byFindNum++;
			
			// 已经找到需要的数目, 直接返回
			if (pacChnnl && byChnnlNum && byFindNum >= byChnnlNum)
			{
				return byChnnlNum;
			}
		}
	}
	
	return byFindNum;
}

/*====================================================================
函数名      ：FindTvwChnnl
功能        ：寻找TvMember为tSrc的电视墙通道
算法实现    ：
引用全局变量：
输入参数说明：[in]tSrc, 电视墙通道成员
              [out]pacChnnl, 数组, 存储搜索得到的tvw通道(根据搜索顺序依次存储).
			  [in]byChnnlNum, 将要搜索得到的通道数目
返回值说明  ：如果pacChnnl为null且byChnnlNum为0，或者实际数目小于byChnnlNum, 则返回实际搜索得到的通道数;
			  如果pacChnnl和byChnnlNum之一为0, 返回0;
			  如果实际数目大于byChnnlNum, 返回byChnnlNum;
			  否则返回实际搜索的数目
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
u8 CMcuVcInst::FindTvwChnnl( const TMt& tSrc, CConfTvwChnnl* pacChnnl, const u8 byChnnlNum )
{
	// 先主动清空缓冲区
	if (pacChnnl && byChnnlNum)
	{
		memset(pacChnnl, 0, sizeof(CConfTvwChnnl) * byChnnlNum );
	}
	
	// 如果tSubMt非法, 返回0
	if (tSrc.IsNull())
	{
		return 0;
	}

	// 如果没有启用tvwall, 直接返回0
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	if( !tConfAttrb.IsHasTvWallModule() )
	{
		return 0;
	}

	// 如果是mcu, 则返回它下面终端所在的电视墙数目
	if (IsMcu( tSrc ))
	{
		return FindTvwChnnlByMcu(tSrc, pacChnnl, byChnnlNum);
	}
	
	// 获取tvwall配置
	TMultiTvWallModule tMultiTvWallModule;
	m_tConfEqpModule.GetMultiTvWallModule( tMultiTvWallModule );
	
	// 已经找到的数量
	u8	byFindNum = 0;
	CConfTvwChnnl cFindChnnl;
	BOOL32 bVcsConf = (VCS_CONF == m_tConf.GetConfSource()) ? TRUE : FALSE;
	const u8 byHduChnnlNum = tMultiTvWallModule.GetChnnlNum( bVcsConf );
	for ( u8 byLoop = 0; byLoop < byHduChnnlNum; ++byLoop )
	{
		GetConfTvwChnnl( byLoop, cFindChnnl);		
		if (!cFindChnnl.IsNull())
		{
			// 判断通道成员是否与目标相等
			if ( !(tSrc == (TMt)(cFindChnnl.GetMember())) )
			{
				continue;
			}
			
			// 如果能写入, 先写入缓冲区
			if (pacChnnl && byFindNum < byChnnlNum)
			{
				pacChnnl[byFindNum] = cFindChnnl;
			}
			
			// 累加已经找到的数目
			byFindNum++;
			
			// 已经找到需要的数目, 直接返回
			if (pacChnnl && byChnnlNum && byFindNum >= byChnnlNum)
			{
				return byChnnlNum;
			}
		}
	}
	
	return byFindNum;
}

/*====================================================================
函数名      ：FindAllTvwChnnl
功能        ：寻找源为tSrc的所有电视墙通道
算法实现    ：
引用全局变量：
输入参数说明：[in]tSrc, 电视墙通道成员
              [out]pacChnnl, 数组, 存储搜索得到的tvw通道(根据搜索顺序依次存储).
			  [in]byChnnlNum, 将要搜索得到的通道数目
返回值说明  ：如果pacChnnl为null且byChnnlNum为0，或者实际数目小于byChnnlNum, 则返回实际搜索得到的通道数;
			  如果pacChnnl和byChnnlNum之一为0, 返回0;
			  如果实际数目大于byChnnlNum, 返回byChnnlNum;
			  否则返回实际搜索的数目
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
u8 CMcuVcInst::FindAllTvwChnnl( const TMt& tSrc, CConfTvwChnnl* pacChnnl, const u8 byChnnlNum )
{
	// 优先搜索HDU电视墙
	u8 byFindNum = FindHduChnnl(tSrc, pacChnnl, byChnnlNum);

	// 接着搜索Tvw电视墙
	if (byFindNum < byChnnlNum)
	{
		byFindNum += FindTvwChnnl(tSrc, pacChnnl + byFindNum, byChnnlNum - byFindNum );
	}

	return byFindNum;	
}

/*====================================================================
函数名      ：RefreshMtStatusInTw
功能        ：刷新某终端的电视墙状态，支持刷新各类电视墙
算法实现    ：
引用全局变量：
输入参数说明：[in]const TMt tMt 终端
              [in]BOOL32 bInTw 是进墙还是出墙
			  [in]BOOL32 bTypeHdu 是hdu还是dec5电
返回值说明  ：void
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
20110921    4.0         pengjie        create
====================================================================*/
void CMcuVcInst::RefreshMtStatusInTw( TMt tMt, BOOL32 bInTw, BOOL32 bTypeHdu, u8 byHduMemberType /*= TW_MEMBERTYPE_NULL*/ )
{
	if( tMt.IsNull() || tMt.GetType() == TYPE_MCUPERI )
	{
		return;
	}

	// [10/12/2011 liuxu] 在清空电视墙标志时, 需要考虑该终端是否是其它电视墙通道的上传通道成员
	if (!bInTw)
	{
		// 是另一个电视墙通道成员的上传通道成员
		if(IsSMcuViewMtAndInTw( tMt, bTypeHdu ))
		{
			return;
		}

		// hdu时, 如果此终端还在墙中, 则不应该出墙
		if( bTypeHdu && !IsMtNotInOtherHduChnnl(tMt, 0, 255 ) )
		{
			return;
		}

		// tvwall时, 如果此终端还在墙中, 则不应该出墙
		if (!bTypeHdu && !IsMtNotInOtherTvWallChnnl(tMt, 0, 255))
		{
			return;
		}
	}

	TMtStatus tStatus;
	if( GetMtStatus( tMt, tStatus ) )
	{
		if( bInTw )
		{
			if( bTypeHdu )
			{
				tStatus.SetInHdu(TRUE);
			}
			else
			{
				tStatus.SetInTvWall(TRUE);
				// 降终端分辨率
				//DecreaseMtVFormatInTw( tMt );
				ChangeMtResFpsInTW(tMt, TRUE);
			}
		}
		else
		{
			if( bTypeHdu )
			{
				tStatus.SetInHdu(FALSE);
			}
			else
			{
				tStatus.SetInTvWall(FALSE);
				// 调用新接口恢复分辨率
				ChangeMtResFpsInTW(tMt, FALSE);
				/*BOOL32 bIsInVmp = FALSE;
				TVMPParam_25Mem tConfVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
				if (CONF_VMPMODE_NONE != m_tConf.m_tStatus.GetVMPMode())
				{
					u8 byPosNum = 0;
					GetChlOfMtInVmpParam(tConfVmpParam, tMt, byPosNum);
					if (byPosNum > 0)
					{
						bIsInVmp = TRUE;
					}
				}
				// 恢复终端分辨率
				if (bIsInVmp)
				{
					ChangeMtVideoFormat(tMt, FALSE);
				}
				else
				{
					RecoverMtVFormat(tMt);
				}*/
			}
		}

		SetMtStatus(tMt, tStatus);
		MtStatusChange(&tMt, TRUE);
	}

	if (IsMcu(tMt))
	{
		TMt tSMcuViewMt = GetSMcuViewMt( tMt );
		//yrl20131101下级通道成员双流选看时不加图标
		if(TW_MEMBERTYPE_DOUBLESTREAM != byHduMemberType)
		{
			RefreshMtStatusInTw( tSMcuViewMt, bInTw, bTypeHdu );	
		}
	}

	return;
}

/*====================================================================
函数名      ：IsSMcuViewMtAndInTw
功能        ：判断下级终端是否是电视墙通道的mcu成员的上传成员
算法实现    ：
引用全局变量：
输入参数说明：[in]const TMt tMt 终端
              [in]BOOL32 bIsHdu 是不是Hdu, false为Tvwall
返回值说明  ：true, 是某个电视墙通道的mcu终端的上传终端
			  false, 不是
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
20111012    4.6         liuxu         create
====================================================================*/
BOOL32 CMcuVcInst::IsSMcuViewMtAndInTw( const TMt& tSMt, const BOOL32 bIsHdu )
{
	// 只判断下级终端
	if ( tSMt.IsNull() || tSMt.IsLocal() )
	{
		return FALSE;
	}
	
	TPeriEqpStatus tEqpStatus;					// 外设状态
	TMt tMtInTv;								// 外设通道成员
	u8 byEqpChnNum = 0;							// 外设通道数量

	u8 byTwMin = bIsHdu ? HDUID_MIN : TVWALLID_MIN;
	u8 byTwMax = bIsHdu ? HDUID_MAX : TVWALLID_MAX;

    for(u8 byEqpId = byTwMin; byEqpId <= byTwMax; byEqpId++)
    {
		tEqpStatus.SetNull();
        if ( !g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tEqpStatus) )
		{
			continue;
		}

        if( !tEqpStatus.m_byOnline )
		{
			continue;
		}

		if (bIsHdu)
		{
			byEqpChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpId));
		}
		else
		{
			byEqpChnNum = tEqpStatus.m_tStatus.tTvWall.byChnnlNum;
		}

        for(u8 byLp = 0; byLp < min(byEqpChnNum,MAXNUM_HDU_CHANNEL); byLp++)
        {
			// [2013/03/11 chenbing]  四风格下遍历子通道
			if (HDUCHN_MODE_FOUR == tEqpStatus.m_tStatus.tHdu.GetChnCurVmpMode(byLp))
			{
				for (u8 byIndex=0; byIndex<HDU_MODEFOUR_MAX_SUBCHNNUM; byIndex++)
				{
					if (bIsHdu)
					{
						tMtInTv = (TMt)tEqpStatus.m_tStatus.tHdu.GetChnMt(byLp, byIndex);
					}
					else
					{
						tMtInTv = (TMt)tEqpStatus.m_tStatus.tTvWall.atVideoMt[byLp];
					}

					// 过滤非法值
					if( (tMtInTv.GetConfIdx() != m_byConfIdx || tMtInTv.IsNull())
					  || (!IsMcu(tMtInTv)/*只考虑mcu成员情况*/)
					  || (tSMt == tMtInTv/*过滤自己*/)
					  )
					{
						continue;
					}

					// 判断tSMt是否是mcu tMtInTv的上传通道成员
					if (IsSmcuViewMtInMcu( tSMt, tMtInTv ))
					{
						return TRUE;
					}
				}
			}

			if (bIsHdu)
			{
				tMtInTv = (TMt)tEqpStatus.m_tStatus.tHdu.GetChnMt(byLp);
			}
			else
			{
				tMtInTv = (TMt)tEqpStatus.m_tStatus.tTvWall.atVideoMt[byLp];
			}
 
			// 只考虑mcu成员情况
			if ( tMtInTv.GetConfIdx() != m_byConfIdx /*过滤非相同会议成员*/
				|| tMtInTv.IsNull()/*过滤通道成员为空*/
				|| !IsMcu(tMtInTv) /*过滤非mcu*/
				|| tSMt == tMtInTv /*过滤自己*/)
			{
				continue;
			}

			// [2013/10/11 chenbing] 当前通道在选看下级双流，下级终端出墙需要跳过该通道
			// 作用：HDU通道在选看双流的情况下，下级Mt出墙需要刷掉上传源的图标
			if ( IsMcu(tMtInTv)
				&& TW_MEMBERTYPE_DOUBLESTREAM == tEqpStatus.m_tStatus.tHdu.atVideoMt[byLp].byMemberType )
			{
				continue;
			}
			
			// 判断tSMt是否是mcu tMtInTv的上传通道成员
			if (IsSmcuViewMtInMcu( tSMt, tMtInTv ))
			{
				return TRUE;
			}
        }
    }

	return FALSE;
}


/*====================================================================
函数名      ：UpdateTvwOnSMcuViewMtChg
功能        ：单回传模式时, 上传终端改变时更新其它电视墙通道状态
算法实现    ：
引用全局变量：
输入参数说明：[in]tNewSMcuViewMt -- 新上来的上传终端
			  [in]bHduEqp -- TRUE, 是HDU设备; FALSE, Tvwall设备
返回值说明  ：无
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/10/17  4.6         刘  旭         创建
====================================================================*/
void CMcuVcInst::UpdateTvwOnSMcuViewMtChg( const TMt& tNewSMcuViewMt, const BOOL32 bHduEqp, const TMt* ptOldViewMt/* = NULL*/ )
{
	// VCS预览电视墙时, 不处理
	if( m_tConf.GetConfSource() == VCS_CONF 
		&& VCS_TVWALLMANAGE_REVIEW_MODE == m_cVCSConfStatus.GetTVWallManageMode() )
	{
		return;
	}

	if ( tNewSMcuViewMt.GetConfIdx() != m_byConfIdx )
	{
		return;
	}

	// 只处理单回传下级上传通道改变的情况
	if (/*tNewSMcuViewMt.IsNull() ||*/ tNewSMcuViewMt.IsLocal() )
	{
		return;
	}

	// 获取电视墙设备号范围
	const u8 byTvwMinIdx = bHduEqp ? HDUID_MIN : TVWALLID_MIN;
	const u8 byTvwMaxIdx = bHduEqp ? HDUID_MAX : TVWALLID_MAX;

	TPeriEqpStatus tTvwStatus;				// 设备状态

	// 获取tNewSMcuViewMt所在的最顶层SMcu表示
	TMt tTopSMcu = m_ptMtTable->GetMt(GetFstMcuIdFromMcuIdx(tNewSMcuViewMt.GetMcuIdx()));
	TMt tTempTvwMbr;
	for (u8 byEqpIdx = byTvwMinIdx; byEqpIdx <= byTvwMaxIdx; byEqpIdx++)
	{
		if (!g_cMcuVcApp.GetPeriEqpStatus( byEqpIdx, &tTvwStatus))
		{
			continue;
		}
		
		if( tTvwStatus.m_byOnline != 1 )
		{
			continue;
		}
		
		u8 byTvwChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpIdx));
		if (!bHduEqp)						// Tv wall 设备处理
		{
			byTvwChnNum = tTvwStatus.m_tStatus.tTvWall.byChnnlNum;
		}

		// 没取到正确的通道数量, continue
		if ( 0 == byTvwChnNum )
		{
			continue;
		}
		
		for (u8 byTempChnnlIdx = 0; byTempChnnlIdx < byTvwChnNum; byTempChnnlIdx++)
		{
			// [2013/03/11 chenbing] 四风格通道更新
			if (HDUCHN_MODE_FOUR == tTvwStatus.m_tStatus.tHdu.GetChnCurVmpMode(byTempChnnlIdx))
			{
				for (u8 byHduSubChnId=0; byHduSubChnId<HDU_MODEFOUR_MAX_SUBCHNNUM; byHduSubChnId++)
				{
					tTempTvwMbr = (TMt)tTvwStatus.m_tStatus.tHdu.GetChnMt(byTempChnnlIdx, byHduSubChnId);
					// 是否是本会议所占通道
					if (   tTempTvwMbr.IsNull()
						|| (tTempTvwMbr.GetConfIdx() != m_byConfIdx)//非同一个会议下, 不需更改	
						|| (IsMtInMcu(tNewSMcuViewMt, tTempTvwMbr))	//通道成员是本上传终端的下级, 不需更改
						|| (!IsMtInMcu(tTopSMcu, tTempTvwMbr))		//不在在同一个mcu下, 不需更改
						|| ( tTempTvwMbr == tNewSMcuViewMt )		//成员一样, 不需更改
						|| ( tTempTvwMbr.IsLocal() )				//本级成员, 不需要更改
					   )
					{
						continue;
					}

					// 通道成员是本上传终端的上级, 重现刷一遍进墙标志
					// 作用: 
					// MCU A(19200,1)进墙, A下的MCU B(0,1)上传, B下a(1,1)上传
					// 若A下mcu D(0,2)下终端b(2,1)进另外墙, D的进墙标志会显示不正确      
					if (IsMtInMcu(tTempTvwMbr, tNewSMcuViewMt) 
						|| (ptOldViewMt && !ptOldViewMt->IsNull() && IsMtInMcu(tTempTvwMbr, *ptOldViewMt)))
					{
						RefreshMtStatusInTw( tTempTvwMbr, TRUE, bHduEqp);
						continue;
					}
					
					// 单回传下更新通道和终端进墙标志
					if (!IsLocalAndSMcuSupMultSpy(tTempTvwMbr.GetMcuIdx()))
					{	
						tTvwStatus.m_tStatus.tHdu.SetChnMt(tNewSMcuViewMt, byTempChnnlIdx, byHduSubChnId);
													
						g_cMcuVcApp.SetPeriEqpStatus(byEqpIdx, &tTvwStatus);
	
						// 其它情况下需将旧终端踢出去, 本上传终端代替入墙
						RefreshMtStatusInTw( tNewSMcuViewMt, TRUE, bHduEqp);
						
						// 旧终端出墙, 它必须在新终端入墙之后操作
						RefreshMtStatusInTw( tTempTvwMbr, FALSE, bHduEqp);
					}
				}//for(u8 bySubChnId=0) over

				CServMsg cTempServMsg;
				cTempServMsg.SetMsgBody((u8 *)&tTvwStatus, sizeof(tTvwStatus));
				SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cTempServMsg);
				continue;
			}//HDUCHN_MODE_FOUR over

			// 获取通道成员
			if(bHduEqp)
			{ 
				tTempTvwMbr = (TMt)tTvwStatus.m_tStatus.tHdu.atVideoMt[byTempChnnlIdx];
			}
			else
			{
				tTempTvwMbr = (TMt)tTvwStatus.m_tStatus.tTvWall.atVideoMt[byTempChnnlIdx];
			}
			
			// 是否是本会议所占通道
			if (tTempTvwMbr.IsNull() || tTempTvwMbr.GetConfIdx() != m_byConfIdx)
			{
				continue;
			}
			
			// 通道成员是本上传终端的上级, 重现刷一遍进墙标志
			// 作用: 
			// MCU A(19200,1)进墙, A下的MCU B(0,1)上传, B下a(1,1)上传
			// 若A下mcu D(0,2)下终端b(2,1)进另外墙, D的进墙标志会显示不正确      
			if ( ( IsMtInMcu(tTempTvwMbr,tNewSMcuViewMt)
				  || (ptOldViewMt && !ptOldViewMt->IsNull() && IsMtInMcu(tTempTvwMbr, *ptOldViewMt))
				 )
				&& TW_MEMBERTYPE_DOUBLESTREAM != tTvwStatus.m_tStatus.tHdu.atVideoMt[byTempChnnlIdx].byMemberType
			   )
			{
				RefreshMtStatusInTw( tTempTvwMbr, TRUE, bHduEqp);
				continue;
			}

			// 其它情况下, 本级成员, 不需要更改
			if ( tTempTvwMbr.IsLocal() )
			{
				continue;
			}

			// 成员一样, 不需更改
			if ( tTempTvwMbr == tNewSMcuViewMt )
			{
				continue;
			}
			
			// 不在在同一个mcu下, 不需更改
			if (!IsMtInMcu(tTopSMcu, tTempTvwMbr))
			{
				continue;
			}

			// 通道成员是本上传终端的下级, 不更改状态
			if (IsMtInMcu(tNewSMcuViewMt, tTempTvwMbr))
			{
				continue;
			}

			// 单回传下更新通道和终端进墙标志
			if ( !IsLocalAndSMcuSupMultSpy(tTempTvwMbr.GetMcuIdx()))
			{	
				// 新源必须先进墙, 目的是先将旧终端剔除墙, 否则RefreshMtStatusInTw会出错
				if(bHduEqp)
				{
					if (!tNewSMcuViewMt.IsNull())
					{
						tTvwStatus.m_tStatus.tHdu.atVideoMt[byTempChnnlIdx].SetMt(tNewSMcuViewMt);
					}
				}
				else
				{
					tTvwStatus.m_tStatus.tTvWall.atVideoMt[byTempChnnlIdx].SetMt(tNewSMcuViewMt);
				}
				
				g_cMcuVcApp.SetPeriEqpStatus(byEqpIdx, &tTvwStatus);
				
				CServMsg cTempServMsg;
				cTempServMsg.SetMsgBody((u8 *)&tTvwStatus, sizeof(tTvwStatus));
				SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cTempServMsg);

				// 其它情况下需将旧终端踢出去, 本上传终端代替入墙
				RefreshMtStatusInTw( tNewSMcuViewMt, TRUE, bHduEqp);
				
				// 旧终端出墙, 它必须在新终端入墙之后操作
				RefreshMtStatusInTw( tTempTvwMbr, FALSE, bHduEqp);

				//VCS会议开启一键混音功能，需要将原来电视墙终端踢出混音，并将新上传终端进混音
				if (VCS_CONF == m_tConf.GetConfSource() && m_cVCSConfStatus.GetMtInTvWallCanMixing())
				{
					RemoveSpecMixMember( &tTempTvwMbr, 1, FALSE );
					AddSpecMixMember(&tNewSMcuViewMt, 1, FALSE);
				}
			}
		}
	}

	// tNewSMcuViewMt在电视墙内终端的上传通道中, 显示入墙
	if( IsSMcuViewMtAndInTw( tNewSMcuViewMt, bHduEqp ))
	{
		RefreshMtStatusInTw( tNewSMcuViewMt, TRUE, bHduEqp);
	}	

	if ( ptOldViewMt 
		&& !ptOldViewMt->IsNull() 
		&& !ptOldViewMt->IsLocal() 
		&& !(*ptOldViewMt == tNewSMcuViewMt) )
	{
		// ptOldViewMt已经不在电视墙中
		if ( (bHduEqp && IsMtNotInOtherHduChnnl(*ptOldViewMt, 0, 255) )
			|| (!bHduEqp && IsMtNotInOtherTvWallChnnl(*ptOldViewMt, 0, 255) ))
		{
			// ptOldViewMt也不是电视墙中终端的上传通道成员, 则显示出墙
			if (!IsSMcuViewMtAndInTw(*ptOldViewMt, bHduEqp))
			{
				RefreshMtStatusInTw( *ptOldViewMt, FALSE, bHduEqp);
			}
		}
	}
}


/*====================================================================
函数名      ：GetAllCfgedTvwChnnl
功能        ：获取会议中配置的所有电视墙通道. 请确保pacChnnl和byChnnlNum足够大, 以便能容下所有通道
算法实现    ：
引用全局变量：
输入参数说明：[out]pacChnnl, 数组, 存储搜索得到的tvw通道(根据搜索顺序依次存储).
			  [in]byChnnlNum, 将要搜索得到的通道数目
返回值说明  ：如果pacChnnl为null且byChnnlNum为0，或者实际数目小于byChnnlNum, 则返回实际搜索得到的通道数;
			  如果pacChnnl和byChnnlNum之一为0, 返回0;
			  如果实际数目大于byChnnlNum, 返回byChnnlNum;
			  否则返回实际搜索的数目
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
u8 CMcuVcInst::GetAllCfgedTvwChnnl( CConfTvwChnnl* pacChnnl, const u8 byChnnlNum )
{
	if (!pacChnnl || !byChnnlNum)
	{
		return 0;
	}

	// 已经获取得到的数目
	u8 byFindNum = 0;

	// 获取会议中配置的hdu通道总数
	BOOL32 bVcsConf = ( m_tConf.GetConfSource() == VCS_CONF ) ? TRUE : FALSE;
	const u8 byHduChnlNum = m_tConfEqpModule.m_tHduModule.GetHduChnlNum( bVcsConf );
	for ( u8 byHduLoop = 0; byHduLoop < byHduChnlNum && byFindNum < byChnnlNum; ++byHduLoop )
	{
		if ( !GetConfHduChnnl( byHduLoop, pacChnnl[byFindNum]) )
		{
			continue;
		}

		++byFindNum;
	}

	// 获取会议中配置的普通Tvw通道总数
	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
	if( tConfAttrb.IsHasTvWallModule() )
	{
		TMultiTvWallModule tMultiTvWallModule;
		m_tConfEqpModule.GetMultiTvWallModule( tMultiTvWallModule );
		
		// 获取会议中配置的普通Tvw通道总数
		const u8 byTvwChnlNum = tMultiTvWallModule.GetChnnlNum( bVcsConf );
		for ( u8 byTvwLoop = 0; byTvwLoop < byTvwChnlNum && byFindNum < byChnnlNum; ++byTvwLoop )
		{
			if ( !GetConfTvwChnnl( byTvwLoop, pacChnnl[byFindNum]) )
			{
				continue;
			}
			
			++byFindNum;
		}
	}
	
	return byFindNum;	
}

/*====================================================================
函数名      ：GetTvwChnnl
功能        ：根据设备号和通道号获取通道
算法实现    ：
引用全局变量：
输入参数说明：[in]byTvwEqpId, 电视墙设备索引
			  [in]byChnnlIdx, 电视墙通道索引
返回值说明  ：CTvwChnnl
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
2011/05/25  4.0         刘  旭         创建
====================================================================*/
BOOL32 CMcuVcInst::GetTvwChnnl( const u8 byTvwEqpId, const u8 byChnnlIdx, CTvwChnnl& cTvwChnnlRet )
{
	// 先主动清空
	cTvwChnnlRet.Clear();

	// 根据设备号找hdu状态
	TPeriEqpStatus tStatus;
	if( !g_cMcuVcApp.GetPeriEqpStatus(byTvwEqpId, &tStatus) )
	{
		return FALSE;
	}

	// 是HDU设备
	if (IsValidHduChn(byTvwEqpId, byChnnlIdx))
	{
		if (byChnnlIdx >= MAXNUM_HDU_CHANNEL)
		{
			return FALSE;
		}
		cTvwChnnlRet.SetEqpId(byTvwEqpId);
		cTvwChnnlRet.SetChnnlIdx(byChnnlIdx);
		cTvwChnnlRet.SetMember(tStatus.m_tStatus.tHdu.atVideoMt[byChnnlIdx]);
		cTvwChnnlRet.SetConfIdx(cTvwChnnlRet.GetMember().GetConfIdx());
		cTvwChnnlRet.SetMute(tStatus.m_tStatus.tHdu.atHduChnStatus[byChnnlIdx].GetIsMute());
		cTvwChnnlRet.SetStatus(tStatus.m_tStatus.tHdu.atHduChnStatus[byChnnlIdx].GetStatus());
		cTvwChnnlRet.SetVolume(tStatus.m_tStatus.tHdu.atHduChnStatus[byChnnlIdx].GetVolume());

		return TRUE;
	}
	else if (IsValidTvw(byTvwEqpId, byChnnlIdx ))
	{
		if (byChnnlIdx >= MAXNUM_PERIEQP_CHNNL)
		{
			return FALSE;
		}
		cTvwChnnlRet.SetMember(tStatus.m_tStatus.tTvWall.atVideoMt[byChnnlIdx]);
		cTvwChnnlRet.SetEqpId(byTvwEqpId);
		cTvwChnnlRet.SetChnnlIdx( byChnnlIdx );
		cTvwChnnlRet.SetConfIdx(tStatus.m_tStatus.tTvWall.atVideoMt[byChnnlIdx].GetConfIdx());
		cTvwChnnlRet.SetMute(FALSE);
		// tvwall不支持通道状态和volume, 这里不设置

		return TRUE;
	}else
	{
		return FALSE;
	}
}

/*====================================================================
    函数名      ：NeedChangeVFormat
    功能        ：终端是否需要改变分辨率
    算法实现    ：
    引用全局变量：
    输入参数说明：[in]tMt, 带判断的终端
    返回值说明  ：需要, 返回true; 不需要, 返回false
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    11/05/28    4.6         刘旭          创建
====================================================================*/
BOOL32 CMcuVcInst::NeedChangeVFormat( const TMt& tDstMt  )
{
	// 参数判断
	if ( tDstMt.IsNull() || tDstMt.GetConfIdx() != m_byConfIdx )
	{
		return FALSE;
	}
	
	// 非终端类型, 不需要降分辨率
	if (tDstMt.GetMtType() != MT_TYPE_MMCU 
		&& tDstMt.GetMtType() != MT_TYPE_SMCU 
		&& tDstMt.GetMtType() != MT_TYPE_MT 
		// 某些时候tDstMt的mttype是0
		&& tDstMt.GetMtType() != 0)
	{
		return FALSE;
	}

	// 获取tDstMt在本地的MtId
	u8 byLocalMtId = 0;
	if (!tDstMt.IsLocal())
	{
		byLocalMtId = GetLocalMtFromOtherMcuMt(tDstMt).GetMtId();
	}else
	{
		byLocalMtId = tDstMt.GetMtId();
		
		// 非Keda终端, 不能降分辨率
		if ( m_ptMtTable &&
			MT_MANU_KDC != m_ptMtTable->GetManuId(tDstMt.GetMtId()) &&
			MT_MANU_KDCMCU != m_ptMtTable->GetManuId(tDstMt.GetMtId()) 
			)
		{
			ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[NeedChangeVFormat] Mt<McuId:%d, MtId:%d, ManuId:%d> is not kedaMt!\n",
				tDstMt.GetMcuId(), 
				tDstMt.GetMtId(),
				m_ptMtTable->GetManuId(tDstMt.GetMtId()));
			return FALSE;
		}
	}
	
	// 获取后向视频通道
	TLogicalChannel tLogicChannel;
	if ( !m_tConfAllMtInfo.MtJoinedConf(byLocalMtId )
		|| !m_ptMtTable 
		|| !m_ptMtTable->GetMtLogicChnnl( byLocalMtId, LOGCHL_VIDEO, &tLogicChannel, FALSE ))
	{
		return FALSE;
	}
	
	u8 byFormat = tLogicChannel.GetVideoFormat();

	// 既不是h264格式, 也不是h264的高清格式, 不需要调分辨率
	if ( MEDIA_TYPE_H264 != tLogicChannel.GetChannelType()
		|| !(IsVidFormatHD( byFormat ) || byFormat == VIDEO_FORMAT_4CIF ))
	{
		return FALSE;
	}
	
	// 其它情况下, 在tvwall中时, 需要调整分辨率
	if ( IsSMcuViewMtAndInTw(tDstMt, FALSE)					// 是tvwall通道成员的上传终端
		|| !IsMtNotInOtherTvWallChnnl(tDstMt, 0, 255))		// 在tvwall设备中
	{
		return TRUE;
	}
	
	// 其它情况下, 与vmp需求格式不匹配时, 需要调整分辨率
	TVMPParam_25Mem tVmpParam = g_cMcuVcApp.GetConfVmpParam(m_tVmpEqp);
	if( ( tVmpParam.IsVMPBrdst() && tVmpParam.IsMtInMember(tDstMt)) )
	{
		CVmpChgFormatResult cVmpChgResult;
		u8 byMtInVmpRes = 0;
		u8 byVmpSubType = GetVmpSubType(m_tVmpEqp.GetEqpId());
		
		if(byVmpSubType == VMP)
		{
			GetMtFormatInSdVmp(tDstMt, &tVmpParam, byMtInVmpRes, TRUE);
		}
		else
		{
			GetMtFormatInMpu(tDstMt, &tVmpParam, byMtInVmpRes, cVmpChgResult, TRUE, TRUE, FALSE);
		}
		
		byFormat = GetSuitableRes(byMtInVmpRes, byFormat);
		if( tLogicChannel.GetVideoFormat() != byFormat && 0 != byFormat)
		{
			return TRUE;
		}
	}

	// 其它情况下不需要调整分辨率
	return FALSE;
}

/*====================================================================
    函数名      ：GetMixChnPos
    功能        ：多回传支持，记录的是一个未被local的tmt信息
    算法实现    ：
    引用全局变量：
    输入参数说明：u8     byMtId
                  BOOL32 bRemove
    返回值说明  ：u8: pos
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    07/03/19    4.0         张宝卿         创建
====================================================================*/
u8 CMcuVcInst::GetMixChnPos(const TMt &tSrc, BOOL32 bRemove )
{
    u8 byDstPos = 0;
    if ( tSrc.IsNull() )
    {
        ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetMixChnPos] param err: byMtId.%d \n", tSrc.GetMtId() );
        return byDstPos;
    }
    
    if ( !bRemove )
    {
		if( !m_tConf.m_tStatus.IsSpecMixing() &&
			m_ptMtTable->GetManuId(tSrc.GetMtId()) == MT_MANU_CHAORAN)
		{
			ConfPrint(LOG_LVL_WARNING, MID_MCU_EQP, "[GetMixChnPos]ChaoRan Mt(%d,%d) Can't Joined Mixer,So Return!\n",
				tSrc.GetMcuId(), tSrc.GetMtId());
			return 0xFF;
		}
        BOOL32 bExist = FALSE;
        u8     byFirstIdle = 0xFF;

        u8 byPos = 0;
        
        for( byPos = 1; byPos < MAXNUM_MIXER_CHNNL+1; byPos++ )
        {
            // guzh [5/12/2007] Find the old one
            if ( tSrc == m_atMixMt[byPos])
            {
                bExist = TRUE;
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[GetMixChnPos] Mt.%d already exist at byPos.%d !\n", tSrc.GetMtId(), byPos );
                byDstPos = byPos;
                break;
            }
            else if ( m_atMixMt[byPos].IsNull() && 0xFF == byFirstIdle ) 
            {
                byFirstIdle = byPos;
            }
        }
        if ( !bExist )
        {
            if ( 0xFF != byFirstIdle )
            {
                m_atMixMt[byFirstIdle] = tSrc;
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[GetMixChnPos] Mt.%d set succeed, byPos.%d !\n", tSrc.GetMtId(), byFirstIdle );
                byDstPos = byFirstIdle;
            }
            else
            {
                ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetMixChnPos] Mt.%d set to m_abyMixMtId failed !\n", tSrc.GetMtId() );
				return 0xFF;
            }
        }
    }
    else
    {
        BOOL32 bExist = FALSE;
        u8 byPos = 1;
        for( ; byPos < MAXNUM_MIXER_CHNNL+1; byPos++ )
        {
            if ( tSrc == m_atMixMt[byPos] )
            {
                m_atMixMt[byPos].SetNull();
                bExist = TRUE;
				byDstPos = byPos;
                ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,  "[GetMixChnPos] Mt.%d remve m_abyMixMtId succeed, byPos.%d !\n", tSrc.GetMtId(), byPos );
                break;
            }
        }
        if ( !bExist )
        {
            ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetMixChnPos] Mt.%d remve m_abyMixMtId failed !\n", tSrc.GetMtId() );
			return 0xFF;
        }
    }
	u8 byMixerSubtype = UNKONW_MIXER;
	g_cMcuAgent.GetMixerSubTypeByEqpId(m_tMixEqp.GetEqpId(),byMixerSubtype);
	if ((byMixerSubtype == EAPU_MIXER || byMixerSubtype == APU2_MIXER || byMixerSubtype == MIXER_8KI) && byDstPos > 0)
	{
		byDstPos -= 1;
	}
    return byDstPos;
}

/*====================================================================
    函数名      ：IsMtInMixChn
    功能        ：判断混音成员是否在混音通道中
    算法实现    ：
    引用全局变量：
    输入参数说明：const TMt &tMixMem 混音成员
    返回值说明  ：TRUE  在混音通道
	              FALSE 不在混音通道
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    11/11/29    4.6         苗庆松         创建
====================================================================*/
BOOL32 CMcuVcInst::IsMtInMixChn(const TMt &tMixMem)
{
	if ( tMixMem.IsNull() )
	{
		ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[IsMtInMixChn] tMixMem is Null, so return!\n" );
		return FALSE;
	}
	
	for( u8 byPos = 1; byPos < MAXNUM_MIXER_CHNNL+1; byPos++ )
	{
		if ( tMixMem == m_atMixMt[byPos])
		{
			ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[IsMtInMixChn] Mt.%d already exist at byPos.%d !\n", tMixMem.GetMtId(), byPos );
			return TRUE;
		}
	}
	
	return FALSE;
}

/*====================================================================
    函数名      : FreeMixChn
    功能        : 释放某个终端所占用的混音通道
    算法实现    ：
    引用全局变量：
    输入参数说明：bForce = TRUE 释放所有混音通道，默认为FALSE
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    20091202                pengjie         创建
====================================================================*/
/*
BOOL32 CMcuVcInst::FreeMixChn( TMt &tSrc, BOOL32 bForce )
{
	u8 byLoop = 0;
	if( TRUE == bForce )
	{
		for( byLoop = 0; byLoop < MAXNUM_MIXER_CHNNL + 1; byLoop++ )
		{
			m_atMixMt[byLoop].SetNull();
		}
		return TRUE;
	}
	else
	{
		for( byLoop = 0; byLoop < MAXNUM_MIXER_CHNNL + 1; byLoop++ )
		{
			if( m_atMixMt[byLoop] == tSrc )
			{
				m_atMixMt[byLoop].SetNull();
				return TRUE;
			}
		}
		return FALSE;
	}
	return FALSE;
}
*/

/*====================================================================
    函数名      : FreeSpyMixerMember
    功能        : 释放某个多回传终端占用的混音资源,bForce = TRUE 释放所有多回传混音成员
    算法实现    ：
    引用全局变量：
    输入参数说明：
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    20091202                pengjie         创建
====================================================================*/
/*
BOOL32 CMcuVcInst::FreeSpyMixerMember( TMt &tSrc )
{
	for( u8 bySpyIndx = 0; bySpyIndx < MAXNUM_CONF_SPY; bySpyIndx++ )
	{
		if( !(m_cMMcuSpy.GetSpyMemberInfo(bySpyIndx).m_tSpy.IsNull()) )
		{
			if( m_cMMcuSpy.GetSpyMemberInfo(bySpyIndx).m_tSpy == tSrc )
			{
				FreeRecvSpy( tSrc, MODE_AUDIO );
				break;
			}
		}
	}
	// 停交换
	StopSwitchToPeriEqp(m_tMixEqp.GetEqpId(), 
		(MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+GetMixChnPos(tSrc)),
		FALSE, MODE_AUDIO );

	FreeMixChn( tSrc );	 

	return TRUE;
}
*/

/*====================================================================
    函数名      : GetMtStatus
    功能        : 获取终端的状态信息，上下级都可
    算法实现    ：
    引用全局变量：
    输入参数说明：IN const TMt& tMt 终端
				  OUT TMtStatus& tMtStatus 返回的终端信息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/07/14                陆昆朋         创建
====================================================================*/
BOOL32 CMcuVcInst::GetMtStatus(const TMt& tMt, TMtStatus& tMtStatus)
{
	if (tMt.IsLocal())
	{
		return m_ptMtTable->GetMtStatus(tMt.GetMtId(), &tMtStatus);
	}
	else
	{
		
		TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tMt.GetMcuId());
		
		if (ptMcInfo == NULL)
		{
			return FALSE;
		}
		
		TMcMtStatus *ptMcMtStatus = ptMcInfo->GetMtStatus(tMt);
		
		if (ptMcMtStatus == NULL)
		{
			return FALSE;
		}
		
		tMtStatus = ptMcMtStatus->GetMtStatus();
	}

	return TRUE;
}


/*====================================================================
    函数名      : SetMtStatus
    功能        : 设置终端的状态信息，上下级都可
    算法实现    ：
    引用全局变量：
	输入参数说明：IN const TMt& tMt 终端
				  IN TMtStatus& tMtStatus 设置的终端信息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/07/14                陆昆朋         创建
====================================================================*/
void CMcuVcInst::SetMtStatus(const TMt& tMt,  const TMtStatus& tMtStatus)
{
	if (tMt.IsLocal())
	{
		m_ptMtTable->SetMtStatus(tMt.GetMtId(), &tMtStatus);
		return;
	}
	else
	{
		TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tMt.GetMcuId());
		
		if (ptMcInfo == NULL)
		{
			return;
		}
		
		TMcMtStatus *ptMcMtStatus = ptMcInfo->GetMtStatus(tMt);
		
		if (ptMcMtStatus == NULL)
		{
			return;
		}
		
		ptMcMtStatus->SetMtStatus(tMtStatus);
		return;
	}
}

/*====================================================================
    函数名      : GetMtAliasInVmp
    功能        : vmp获得终端别名，用于外设显示台标或通道图片
    算法实现    ：
    引用全局变量：
	输入参数说明：IN const TMt& tMt 终端
				  OUT s8 *pchAlias 终端别名信息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/04/25            yanghuaizhi         创建
====================================================================*/
BOOL32 CMcuVcInst::GetMtAliasInVmp(TMt tMt, s8 *pchAlias, u8 byMaxAliasLen/* = VALIDLEN_ALIAS*/)
{
	// 画面合成外设会根据终端别名来显示默认图片，主要针对电话终端，电话终端因不同呼入方式别名有所不同
	// 获取方式需做特殊处理
	BOOL32 bRet = TRUE;
	if(tMt.IsNull())
	{
		bRet = FALSE;
	}
	else
	{
		if( tMt.IsLocal())
		{
			TMtAlias tMtAlias;
			// 如果是电话终端，先取E164号，没有时再取323ID，普通终端先取323ID，无323ID时再尝试取E164号
			if (IsPhoneMt(tMt))
			{
				m_ptMtTable->GetMtAlias(tMt.GetMtId(), mtAliasTypeE164, &tMtAlias);
				// E164号为空时，取其323ID
				if (tMtAlias.IsAliasNull())
				{
					m_ptMtTable->GetMtAlias(tMt.GetMtId(), mtAliasTypeH323ID, &tMtAlias);
				}
			}
			else
			{
				m_ptMtTable->GetMtAlias(tMt.GetMtId(), mtAliasTypeH323ID, &tMtAlias);
				// 323别名为空时，取其E164号
				if (tMtAlias.IsAliasNull() || 0 == strcmp(tMtAlias.m_achAlias, "(none)"))
				{
					tMtAlias.SetH323Alias("");
					m_ptMtTable->GetMtAlias(tMt.GetMtId(), mtAliasTypeE164, &tMtAlias);
				}
			}
			//strncpy(pchAlias, tMtAlias.m_achAlias, VALIDLEN_ALIAS);
            strncpy(pchAlias, tMtAlias.m_achAlias, min(strlen(tMtAlias.m_achAlias)+1, byMaxAliasLen));//长度包含结束符
		}
		else
		{
			TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tMt.GetMcuId());
			if( ptMcInfo != NULL)
			{
				TMtExt *pchMtExt = ptMcInfo->GetMtExt(tMt);
				if(pchMtExt != NULL)
				{
					//strncpy(pchAlias, pchMtExt->GetAlias(), VALIDLEN_ALIAS-1);
                    strncpy(pchAlias, pchMtExt->GetAlias(), min(strlen(pchMtExt->GetAlias()), byMaxAliasLen));
					if( 0 == strcmp("",pchAlias) || 0 == strcmp(pchAlias, "(none)") )
					{						
						strcpy( pchAlias,"" );
					}				
					
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetMtAlias] tmt.(%d,%d)'s alias is %s!\n", 
						tMt.GetMcuId(), tMt.GetMtId(), pchAlias);
				}
				else
				{
					bRet = FALSE;
				}
			}
			else
			{
				bRet = FALSE;
			}
			
		}
	}
	
	return bRet;
				
}

/*====================================================================
    函数名      : GetMtAliasToVmp
    功能        : vmp获得终端别名扩容，用于外设显示台标或通道图片
    算法实现    ：
    引用全局变量：
	输入参数说明：IN const TMt& tMt 终端
				  OUT s8 *pchAlias 终端别名信息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    13/07/04                liaokang        创建
====================================================================*/
BOOL32 CMcuVcInst::GetMtAliasToVmp(TMt tMt, s8 *pchAlias)
{   
    return GetMtAliasInVmp(tMt, pchAlias, MAXLEN_ALIAS);
}

/*====================================================================
    函数名      : GetMtAlias
    功能        : 获取终端的别名，包括下级
    算法实现    ：
    引用全局变量：
	输入参数说明：IN const TMt& tMt 终端
				  OUT s8 *pchAlias 终端别名信息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
    10/07/14                陆昆朋         创建
====================================================================*/
BOOL32 CMcuVcInst::GetMtAlias(TMt tMt, s8 *pchAlias)
{
	BOOL32 bRet = TRUE;
	if(tMt.IsNull())
	{
		bRet = FALSE;
	}
	else
	{
		if( tMt.IsLocal())
		{
			TMtAlias tMtAlias;
			m_ptMtTable->GetMtAlias(tMt.GetMtId(), mtAliasTypeH323ID, &tMtAlias);
			//strncpy(pchAlias, m_ptMtTable->GetMtAliasFromExt(tMt.GetMtId()), VALIDLEN_ALIAS);
			strncpy(pchAlias, tMtAlias.m_achAlias, VALIDLEN_ALIAS);
		}
		else
		{
			TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tMt.GetMcuId());
			if( ptMcInfo != NULL)
			{
				TMtExt *pchMtExt = ptMcInfo->GetMtExt(tMt);
				if(pchMtExt != NULL)
				{
					strncpy(pchAlias, pchMtExt->GetAlias(), VALIDLEN_ALIAS-1);
					if( 0 == strcmp("",pchAlias) &&
						pchMtExt->GetIPAddr() != 0 )
					{
						
						strcpy( pchAlias,StrOfIP(pchMtExt->GetIPAddr()) );
					}
					
					ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, "[GetMtAlias] tmt.(%d,%d)'s alias is %s!\n", 
						tMt.GetMcuId(), tMt.GetMtId(), pchAlias);
				}
				else
				{
					bRet = FALSE;
				}
			}
			else
			{
				bRet = FALSE;
			}
			
		}
	}
	
	return bRet;
				
}
/*====================================================================
函数名      StartEmixerVac
功能        ：开启EAPU混音器语音激励功能
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/09/03    4.6         田志勇          创建
====================================================================*/
BOOL32 CMcuVcInst::StartEmixerVac( u8 byEmixerId )
{
	ConfPrint(LOG_LVL_KEYSTATUS, MID_MCU_MIXER, "[MixerVACReq] Send MCU_MIXER_STARTVAC_CMD To EMixer[%d]!\n",byEmixerId);
    
	u8 byAudioType = m_tConf.GetMainAudioMediaType();
    u8 byAudioType2 = m_tConf.GetSecAudioMediaType();
    TMixerStart tMixer;
    tMixer.SetAudioEncrypt(m_tConf.GetMediaKey());
    tMixer.SetAudioMode(byAudioType);
    tMixer.SetSecAudioMode(byAudioType2);
    tMixer.SetIsAllMix(TRUE); 
    tMixer.SetMixGroupId(0);
    tMixer.SetMixDepth(GetMaxMixerDepth(m_tMixEqp.GetEqpId()));

	TConfAttrb tConfAttrb = m_tConf.GetConfAttrb();
    if (tConfAttrb.IsResendLosePack())
    {
        tMixer.SetIsNeedByPrs(TRUE);
    }
    else
    {
        tMixer.SetIsNeedByPrs(FALSE);
    }

    TDoublePayload tDPayload;
    tDPayload.SetRealPayLoad(byAudioType);
    tDPayload.SetActivePayload(GetActivePayload(m_tConf, byAudioType));

    CServMsg cServMsgToEmixer;
    cServMsgToEmixer.SetConfId( m_tConf.GetConfId() );
    cServMsgToEmixer.SetMsgBody( (u8*)&tMixer, sizeof(tMixer) );
    cServMsgToEmixer.CatMsgBody( (u8*)&tDPayload, sizeof(tDPayload));

    TCapSupportEx tCapSupportEx = m_tConf.GetCapSupportEx();
    cServMsgToEmixer.CatMsgBody( (u8*)&tCapSupportEx, sizeof(tCapSupportEx) );

	TAudioTypeDesc atAudioTypeDesc[MAXNUM_CONF_AUDIOTYPE];//音频能力
	//从会议属性中取出会议支持的音频类型
	u8   byAudioCapNum = m_tConfEx.GetAudioTypeDesc(atAudioTypeDesc);
	cServMsgToEmixer.CatMsgBody( (u8 *)&byAudioCapNum, sizeof(u8) );
	TAudioCapInfo tAudioCapInfo[MAXNUM_CONF_AUDIOTYPE];
	for (u8 byLoop = 0; byLoop < byAudioCapNum;byLoop++)
	{
		tAudioCapInfo[byLoop].SetAudioMediaType(atAudioTypeDesc[byLoop].GetAudioMediaType());
		tAudioCapInfo[byLoop].SetAudioTrackNum(atAudioTypeDesc[byLoop].GetAudioTrackNum());
		tAudioCapInfo[byLoop].SetActivePayLoad(GetActivePayload(m_tConf, atAudioTypeDesc[byLoop].GetAudioMediaType()));
	}
	cServMsgToEmixer.CatMsgBody((u8*)&tAudioCapInfo[0], sizeof(TAudioCapInfo)* byAudioCapNum);

    SendMsgToEqp(byEmixerId,MCU_MIXER_STARTVAC_CMD,cServMsgToEmixer);
    m_tMixEqp = g_cMcuVcApp.GetEqp( byEmixerId );
	m_tMixEqp.SetConfIdx( m_byConfIdx );
	TPeriEqpStatus tPeriEqpStatus;
    g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
    tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[0].m_byGrpState = TMixerGrpStatus::MIXING;
	tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byGrpId = 0;
	tPeriEqpStatus.m_tStatus.tMixer.m_atGrpStatus[m_byMixGrpId].m_byConfId = m_byConfIdx;
    g_cMcuVcApp.SetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
    m_tConf.m_tStatus.SetVACing();
    //通知主席及所有会控
	CServMsg  cServMsg;
    SendMsgToAllMcs(MCU_MCS_STARTVAC_NOTIF, cServMsg);
    //混音状态通知,通知主席及所有会控
    MixerStatusChange(); 
	//设置延时保护时长
    SetMixerSensitivity(m_tConf.GetTalkHoldTime());
    NotifyChairmanMixMode();
    //添加混音成员, 交换码流给混音器
    TMt            tMt;
    u8             byMixMtNum = 0;
    for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
    {
        memset(&tMt,0,sizeof(TMt));
        if (m_tConfAllMtInfo.MtJoinedConf(byMtId))
        {
			if (m_ptMtTable->GetMtType(byMtId) == MT_TYPE_VRSREC)
			{
				continue;
			}
            tMt = m_ptMtTable->GetMt(byMtId);    
            if (byMixMtNum < GetMaxMixNum(m_tMixEqp.GetEqpId()))
            {             
				m_ptMtTable->SetMtInMixing( byMtId,FALSE ,FALSE);
                AddMixMember(&tMt, DEFAULT_MIXER_VOLUME, FALSE);
				StartSwitchToPeriEqp(tMt, 0, m_tMixEqp.GetEqpId(), 
								 (MAXPORTSPAN_MIXER_GROUP*m_byMixGrpId/PORTSPAN+GetMixChnPos(tMt)), 
								 MODE_AUDIO, SWITCH_MODE_SELECT);
                byMixMtNum++;
            }
        }    
    }
	g_cMcuVcApp.GetPeriEqpStatus(m_tMixEqp.GetEqpId(), &tPeriEqpStatus);
	cServMsg.SetMsgBody((u8 *)&tPeriEqpStatus, sizeof(tPeriEqpStatus));
	SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cServMsg);
	return TRUE;
}

/*====================================================================
函数名      ShowConfMc
功能        ：打印会议连接所有mc信息
算法实现    ：
引用全局变量：
输入参数说明：
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
10/12/16    4.6         周翼亮          创建
====================================================================*/
void CMcuVcInst::ShowConfMc()
{


	TLogicalChannel tLogicalChannel;
	StaticLog("\nConf all MC info:\n");
	for(u8 byIndex = 1; byIndex <= (MAXNUM_MCU_MC + MAXNUM_MCU_VC); byIndex++ )
	{
		if( !g_cMcuVcApp.IsMcConnected( byIndex ) )
			continue;
        
		u8      byChannelNum = 0;
		TMt		tCurSrc;
		tCurSrc.SetNull();
		g_cMcuVcApp.GetMcLogicChnnl( byIndex, MODE_VIDEO, &byChannelNum, &tLogicalChannel );
		for( u8 byChannel = 0; byChannel < byChannelNum; byChannel++ )
		{
			if(  g_cMcuVcApp.GetMcSrc( byIndex, &tCurSrc, byChannel, MODE_VIDEO )
				&& tCurSrc.GetConfIdx() == m_byConfIdx
				)
			{
				StaticLog(" McInst:%d,McSrcMt:(McuId.%d,MtId.%d),channelindex:%d,Mode:%d \n",
					byIndex,tCurSrc.GetMcuId(),tCurSrc.GetMtId(),byChannel,MODE_VIDEO);
			}
			
			if(  g_cMcuVcApp.GetMcSrc( byIndex, &tCurSrc, byChannel, MODE_AUDIO )
				&& tCurSrc.GetConfIdx() == m_byConfIdx
				)
			{
					StaticLog(" McInst:%d,McSrcMt:(McuId.%d,MtId.%d),channelindex:%d,Mode:%d \n",
					byIndex,tCurSrc.GetMcuId(),tCurSrc.GetMtId(),byChannel,MODE_AUDIO);
			}
		}
	}
}



/*==============================================================================
函数名    :  GetVmpOutChnnlByRes
功能      :  获取VMP对应某分辨率的输出通道
算法实现  :  
参数说明  :  u8 byRes			[in]
			 u8 byMediaType		[in] 媒体格式，默认值：MEDIA_TYPE_H264
			 u8 byFrameRate		[in] 帧率，默认值：0
			 u8 byProfileType	[in] BP/HP格式，默认值：VIDEO_PROFILE_BP
			 
返回值说明:  u8 VMP输出通道号
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2009-5-07                  薛亮                            创建
2010-02-29				   薛亮							   增加8000E-vmp支持
2011-1-5                   周翼亮							修改
2011-12-2                  杨怀志							增加MPU2支持
2012-2-15                  杨怀志							增加8kh-vmp支持
==============================================================================*/
u8 CMcuVcInst::GetVmpOutChnnlByRes(u8 byVmpId, u8 byRes,  u8 byMediaType, u8 byFrameRate, emProfileAttrb emAttrb/*=emBpAttrb*/)
{
	u8 byChnnlIdx = 0XFF;
	if (!IsValidVmpId(byVmpId))
	{
		return byChnnlIdx;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	TPeriEqpStatus tPeriEqpStatus;	
	g_cMcuVcApp.GetPeriEqpStatus( byVmpId , &tPeriEqpStatus );
	u8 byVmpSubType = tPeriEqpStatus.m_tStatus.tVmp.m_bySubType;	
	u8 byBoardVer	= tPeriEqpStatus.m_tStatus.tVmp.m_byBoardVer;
	if (g_cMcuVcApp.IsSVmpOutput1080i())
	{
		if (VIDEO_FORMAT_HD720 == byRes)
		{
			byRes = VIDEO_FORMAT_4CIF;
		}
	}

	switch (byVmpSubType)
	{
	case VMP:
		{
			byChnnlIdx = 0;	//标清VMP只有一路输出
			break;
		}
	case VMP_8KE:
		{
			byChnnlIdx = Get8KEVmpOutChnnlByRes(byRes, byMediaType);
			break;
		}
	case VMP_8KH:
		{
			byChnnlIdx = Get8KHVmpOutChnnlByRes(tVmpEqp, byRes, byMediaType, byFrameRate, emAttrb);
			break;
		}
	case MPU_SVMP:
		{
			byChnnlIdx = GetMpuOutChnnlByRes(byRes, byMediaType, byBoardVer);
			break;
		}
	case MPU2_VMP_BASIC:
	case MPU2_VMP_ENHACED:
		{
			TVideoStreamCap tStrCap;
			tStrCap.SetMediaType(byMediaType);	//设置媒体类型
			//设置帧率
			MEDIA_TYPE_H264 == byMediaType ? tStrCap.SetUserDefFrameRate(byFrameRate) : tStrCap.SetFrameRate(byFrameRate);
			tStrCap.SetResolution(byRes);	//设置分辨率
			tStrCap.SetH264ProfileAttrb(emAttrb); //设置HP/BP
			
			TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
			byChnnlIdx = tVMPOutParam.GetVmpOutChnnlByStrCap(tStrCap);
			// 针对VCS单方调度主席前向通道可能不在会议勾选之列,匹配不到对应通道,此时查找一路合适的通道返回
			if (0XFF == byChnnlIdx)
			{
				ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP, 
					"[GetVmpOutChnnlByRes] Can't find right channel for the StrCap[Res:%d,HP:%d]! try to get a correct channel!\n",
					byRes, emAttrb);
				// 针对BP终端,只查找BP能力
				u8 byOnlyAttb = (emAttrb == emBpAttrb ? emBpAttrb : 0XFF);
				byChnnlIdx = tVMPOutParam.GetCorrectChnnlByStrCap(tStrCap, byOnlyAttb);
				// 只匹配相同视频类型,H264不匹配非H264格式
				if (0XFF != byChnnlIdx &&
					tVMPOutParam.GetVmpOutCapIdx(byChnnlIdx).GetMediaType() != byMediaType)
				{
					byChnnlIdx = 0XFF;
				}
			}
		}
		break;
	case VMP_8KI:
		{
			TVideoStreamCap tStrCap;
			tStrCap.SetMediaType(byMediaType);	//设置媒体类型
			//设置帧率
			MEDIA_TYPE_H264 == byMediaType ? tStrCap.SetUserDefFrameRate(byFrameRate) : tStrCap.SetFrameRate(byFrameRate);
			tStrCap.SetResolution(byRes);	//设置分辨率
			tStrCap.SetH264ProfileAttrb(emAttrb); //设置HP/BP
			
			TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
			if (MEDIA_TYPE_H264 == byMediaType)
			{
				// 针对BP终端,只查找BP能力
				u8 byOnlyAttb = (emAttrb == emBpAttrb ? emBpAttrb : 0XFF);
				// 找合适能力通道
				byChnnlIdx = tVMPOutParam.GetCorrectChnnlByStrCap(tStrCap, byOnlyAttb);
				// 适配非广播1080 30/25 或 720P 50/60fps会议不编第0路，从第1路收
				if (!g_cMcuVcApp.IsBrdstVMP(tVmpEqp) && //非广播
					IsConfExcludeDDSUseAdapt() && //适配会议
					0 == byChnnlIdx) //收第0通道
				{
					if ((m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 && m_tConf.GetMainVidUsrDefFPS() <= 30) ||
						(m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD720 && m_tConf.GetMainVidUsrDefFPS() > 30))
					{
						TVideoStreamCap tTmpStrCap = tVMPOutParam.GetVmpOutCapIdx(1);
						// 720/4cif/cif都未勾选时,是不允许非广播的
						if (MEDIA_TYPE_H264 == tTmpStrCap.GetMediaType())
						{
							byChnnlIdx = 1;
						}
						else
						{
							byChnnlIdx = 0XFF;
						}
					}
				}
			}
			else
			{
				// 精确匹配
				byChnnlIdx = tVMPOutParam.GetVmpOutChnnlByStrCap(tStrCap);
			}
		}
		break;
	default:
		break;
	}

	return byChnnlIdx;
}

/*==============================================================================
函数名    :  Get8KEVmpOutChnnlByRes
功能      :  根据分辨率获得8kgvmp对应输出通道
算法实现  :  
参数说明  :  u8 byRes in
			 u8 byMediaType in
返回值说明:  u8 byChnnlIdx
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130529					yanghuaizhi							
==============================================================================*/
u8 CMcuVcInst::Get8KEVmpOutChnnlByRes(u8 byRes,  u8 byMediaType)
{
	u8 byChnnlIdx = 0XFF;
	BOOL32 bDualOther = FALSE;
	if( m_tConf.GetMainVideoMediaType() != MEDIA_TYPE_H264 
		&& (m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_NULL 
		&& m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_H264 )
		)
	{
		bDualOther = TRUE;
	}
	if( bDualOther )
	{
		if( byMediaType == MEDIA_TYPE_MP4 )
		{
			byChnnlIdx = 0;
		}
		else if( byMediaType == MEDIA_TYPE_H263 )
		{
			byChnnlIdx = 1;
		}
	}
	else
	{
		if( byMediaType == MEDIA_TYPE_H264)
		{
			switch (byRes)
			{
			case VIDEO_FORMAT_HD1080:
			case VIDEO_FORMAT_HD720:
				byChnnlIdx = 0;
				break;
			case VIDEO_FORMAT_4CIF:
				byChnnlIdx = 1;
				break;
			case VIDEO_FORMAT_CIF:
				byChnnlIdx = 2;
				break;
			default:
				break;
			}
		}
		else if( byMediaType == MEDIA_TYPE_H263 || byMediaType == MEDIA_TYPE_MP4)
		{
			byChnnlIdx = 3;
		}
	}

	return byChnnlIdx;
}

/*==============================================================================
函数名    :  Get8KHVmpOutChnnlByRes
功能      :  根据分辨率获得8khvmp对应输出通道
算法实现  :  
参数说明  :  u8 byRes in
			 u8 byMediaType in
			 u8 byFrameRate in
			 emProfileAttrb emAttrb in
返回值说明:  u8 byChnnlIdx
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130529					yanghuaizhi							
==============================================================================*/
u8 CMcuVcInst::Get8KHVmpOutChnnlByRes(const TEqp &tVmpEqp, u8 byRes,  u8 byMediaType, u8 byFrameRate, emProfileAttrb emAttrb)
{
	u8 byChnnlIdx = 0XFF;
	BOOL32 bDualOther = FALSE;
	if( m_tConf.GetMainVideoMediaType() != MEDIA_TYPE_H264 
		&& (m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_NULL 
		&& m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_H264 )
		)
	{
		bDualOther = TRUE;
	}
	if( bDualOther )
	{
		if( byMediaType == MEDIA_TYPE_MP4 )
		{
			byChnnlIdx = 0;
		}
		else if( byMediaType == MEDIA_TYPE_H263 )
		{
			byChnnlIdx = 1;
		}
		else if( byMediaType == MEDIA_TYPE_H261 )
		{
			byChnnlIdx = 2;
		}
	}
	else
	{
		if( byMediaType == MEDIA_TYPE_H264)
		{
			switch (byRes)
			{
			case VIDEO_FORMAT_HD1080:
				{
					// HP会议 1080终端一定收第0路
					if (emHpAttrb == emAttrb)
					{
						byChnnlIdx = 0;
					}
					// 适配会议1080p60fps处理
					else if (IsConfExcludeDDSUseAdapt() &&
						m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 &&
						m_tConf.GetMainVidUsrDefFPS() >= 50)
					{
						// 勾选720p60fps时,第0路不出,走第一路收
						if (IsMSSupportCapEx(VIDEO_FORMAT_HD720, m_tConf.GetMainVidUsrDefFPS()))
						{
							byChnnlIdx = 1;
						}
						else//其余走第0路
						{
							byChnnlIdx = 0;
						}
					}
					//适配非广播1080 30/25出720
					else if (!g_cMcuVcApp.IsBrdstVMP(tVmpEqp) &&
						IsConfExcludeDDSUseAdapt() &&
						m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 && 
						m_tConf.GetMainVidUsrDefFPS() < 50
						) 
					{
						// 720/4cif/cif都未勾选时,是不允许非广播的
						if (IsMSSupportCapEx(VIDEO_FORMAT_HD720))
						{
							byChnnlIdx = 1;
						} else if (IsMSSupportCapEx(VIDEO_FORMAT_4CIF))
						{
							byChnnlIdx = 2;
						} else if (IsMSSupportCapEx(VIDEO_FORMAT_CIF))
						{
							byChnnlIdx = 3;
						}
					}
					/* 1080/30/hp,未勾选1080/30/bp时,第0路出720/30/hp.
					// VCS单方调度主席可能开1080/30/bp通道,vmp打第0路hp码流过去解不了,从后面选1路合适的打过去
					else if (IsConfExcludeDDSUseAdapt() &&
						m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 && 
						m_tConf.GetProfileAttrb() == emHpAttrb &&
						!IsMSSupportCapEx(VIDEO_FORMAT_HD1080))//主格式1080hp,未勾选1080bp,0路出hp
					{
						if (IsMSSupportCapEx(VIDEO_FORMAT_HD720,m_tConf.GetMainVidUsrDefFPS(),emBpAttrb))
						{
							byChnnlIdx = 1;
						} else if (IsMSSupportCapEx(VIDEO_FORMAT_4CIF))
						{
							byChnnlIdx = 2;
						} else if (IsMSSupportCapEx(VIDEO_FORMAT_CIF))
						{
							byChnnlIdx = 3;
						}
					}*/
					else
					{
						byChnnlIdx = 0;
					}
					
				}
				break;
			case VIDEO_FORMAT_HD720:
				{
					// 20120327 yhz 720 HP 走第0路
					if (emHpAttrb == emAttrb)
					{
						//适配非广播720 30/25 HP,出720 BP
						if (!g_cMcuVcApp.IsBrdstVMP(tVmpEqp) &&
							IsConfExcludeDDSUseAdapt() &&
							m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD720 && m_tConf.GetMainVidUsrDefFPS() < 50 &&
							m_tConf.GetMainVidUsrDefFPS() >= 25 &&
							m_tConf.GetProfileAttrb() == emHpAttrb) 
						{
							// 720/4cif/cif都未勾选时,是不允许非广播的
							if (IsMSSupportCapEx(VIDEO_FORMAT_HD720))
							{
								byChnnlIdx = 1;
							} else if (IsMSSupportCapEx(VIDEO_FORMAT_4CIF))
							{
								byChnnlIdx = 2;
							} else if (IsMSSupportCapEx(VIDEO_FORMAT_CIF))
							{
								byChnnlIdx = 3;
							}
						}
						else
						{
							byChnnlIdx = 0;
						}
					} 
					else 
					{
						/*u8 byFps = m_tConf.GetMainVidUsrDefFPS();
						if (byFps > 30)
						{
							byFps /= 2;
						}
						// hp会议,未勾选720/30/bp时,第1路不出.
						// VCS单方调度主席可能开720/30/bp通道,从后面选1路合适的打过去
						if (IsConfExcludeDDSUseAdapt() &&
							(m_tConf.GetProfileAttrb() == emHpAttrb || m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD1080) &&
							!IsMSSupportCapEx(VIDEO_FORMAT_HD720,byFps,emBpAttrb))//1080会议或hp会议,未勾选720bp,1路不出
						{
							if (IsMSSupportCapEx(VIDEO_FORMAT_4CIF))
							{
								byChnnlIdx = 2;
							} else if (IsMSSupportCapEx(VIDEO_FORMAT_CIF))
							{
								byChnnlIdx = 3;
							}
						}
						else*/
						{
							// 720 BP 走第1路
							byChnnlIdx = 1;
						}
					}
				}
				break;
			case VIDEO_FORMAT_4CIF:
				byChnnlIdx = 2;
				break;
			case VIDEO_FORMAT_CIF:
				byChnnlIdx = 3;	
				break;
			default:
				break;
			}
		}
		else if( byMediaType == MEDIA_TYPE_H263 || byMediaType == MEDIA_TYPE_MP4 || byMediaType == MEDIA_TYPE_H261)
		{
			byChnnlIdx = 4; //other
		}
	}

	return byChnnlIdx;
}

/*==============================================================================
函数名    :  Get8KEVmpOutChnnlByRes
功能      :  根据分辨率获得mpu对应输出通道
算法实现  :  
参数说明  :  u8 byRes in
			 u8 byMediaType in
			 u8 byBoardVer in
返回值说明:  u8 byChnnlIdx
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130529					yanghuaizhi							
==============================================================================*/
u8 CMcuVcInst::GetMpuOutChnnlByRes(u8 byRes,  u8 byMediaType, u8 byBoardVer)
{
	u8 byChnnlIdx = 0XFF;
	if (MPU_BOARD_A128 == byBoardVer)
	{
		switch (byRes)
		{
		case VIDEO_FORMAT_HD1080:
			byChnnlIdx = 0;
			break;
		case VIDEO_FORMAT_HD720:
			byChnnlIdx = 0;
			break;
		case VIDEO_FORMAT_4CIF:
			byChnnlIdx = 2;
			break;
		case VIDEO_FORMAT_CIF:
			byChnnlIdx = 2;
			break;
		default:
			break;
		}
	}
	else if(MPU_BOARD_B256 == byBoardVer)
	{
		if( m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H264 && IsVidFormatHD(m_tConf.GetMainVideoFormat()) ||
			m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_H264 && IsVidFormatHD(m_tConf.GetSecVideoFormat()) )
		{
			if( byMediaType == MEDIA_TYPE_H264)
			{
				switch (byRes)
				{
				case VIDEO_FORMAT_HD1080:
					byChnnlIdx = 0;
					break;
				case VIDEO_FORMAT_HD720:
					byChnnlIdx = 1;
					break;
				case VIDEO_FORMAT_4CIF:
					byChnnlIdx = 3;
					break;
				case VIDEO_FORMAT_CIF:
					{
						//songkun,20110628,Bug00056785
						//IMAX会议，MPU4开启画面合成，7210/8010A接收不到画面合成图像,不再区分other,2通道cif
						TConfAttrbEx tConfAttrbEx = m_tConf.GetConfAttrbEx();
						if(tConfAttrbEx.IsImaxModeConf())
						{
							byChnnlIdx = 2;
						}
						else
						{
							if( ( m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_H263 || m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_MP4 ) )
							{
								// 新策略:如果会议有other格式，且勾选h264/cif，则出h264/4cif这路改出h264/cif
								if( IsMSSupportCapEx(VIDEO_FORMAT_CIF) )
								{
									byChnnlIdx = 3;
								}
								else
								{
									ConfPrint( LOG_LVL_WARNING, MID_MCU_EQP, \
										"[GetVmpOutChnnlByRes] conf has h264/4cif And has other tpye, so don't has h264/cif\n" );
								}
							}
							else
							{
								byChnnlIdx = 2;
							}
						}

						break;
					}
				default:
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetVmpOutChnnlByRes] MediaType is MEDIA_TYPE_H264, But No \
					Found VmpOutChnnl input Res is %d !\n", byRes );
					break; 
				}
			}
			else
			{
				byChnnlIdx = 2;
			}
		}
		else // 标清情况：（标清下 1 通道不使用 ）
		{
			if( byMediaType == MEDIA_TYPE_H264 )
			{
				switch( byRes )
				{
				case VIDEO_FORMAT_4CIF:
					byChnnlIdx = 0;
					break;
				case VIDEO_FORMAT_CIF:
					byChnnlIdx = 3;
					break;
				default:
					ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetVmpOutChnnlByRes] MediaType is MEDIA_TYPE_H264, But No \
					Found VmpOutChnnl input Res is %d !\n", byRes );
					break;
				}
			}
			else // other 从2通道出
			{
				byChnnlIdx = 2;
			}
		}
	}
	else
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP, "[GetVmpOutChnnlByRes] Unexpected mpu board version!\n");
	}

	return byChnnlIdx;
}

/*==============================================================================
函数名    :  GetResByVmpOutChnnl
功能      :  获取VMP输出通道的媒体类型和分辨率
算法实现  :  此接口不再支持MPU2及以后vmp版本.新vmp通过m_tVMPOutParam获得.
参数说明  :  u8			byChnnl		[in]
			 u8			byMediaType	[out]
			 
返回值说明:  u8			byRes
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2009-5-07                  薛亮                            创建
2010-02-29				   薛亮							   增加8000E-vmp支持
2010-01-05                 周翼亮							修改
2012-02-15                 杨怀志							8kh-vmp支持
2012-03-26				   杨怀志							8kh新需求开发(支持HP)
==============================================================================*/
u8 CMcuVcInst::GetResByVmpOutChnnl(u8 byVmpId, u8 &byMediaType, u8 &byFrameRate, u8 &byAttrb, u8 byChnnl)
{
	u8 byRes = VIDEO_FORMAT_INVALID;
	// 目前byFrameRate与byAttrb仅适用与8kh新需求
	byFrameRate = m_tConf.GetMainVidUsrDefFPS();
	byAttrb = emBpAttrb;
	
	if (!IsValidVmpId(byVmpId))
	{
		return byRes;
	}

	TPeriEqpStatus tPeriEqpStatus;	
	g_cMcuVcApp.GetPeriEqpStatus( byVmpId , &tPeriEqpStatus );
	u8 byVmpSubType = tPeriEqpStatus.m_tStatus.tVmp.m_bySubType;	
	u8 byBoardVer	= tPeriEqpStatus.m_tStatus.tVmp.m_byBoardVer;

	switch (byVmpSubType)
	{
	case VMP:
		{
			byMediaType = m_tConf.GetMainVideoMediaType();	//取会议的主格式
			//这种情况下，该值返回不具备任何参考价值
			break;
		}
	case VMP_8KE:
		{
			byRes = GetResBy8KEVmpOutChnnl(byMediaType, byChnnl);
			break;
		}
	case VMP_8KH:
		{
			byRes = GetResBy8KHVmpOutChnnl(byMediaType, byFrameRate, byAttrb, byChnnl);
			break;
		}
	case MPU_SVMP:
		{
			byRes = GetResByMpuOutChnnl(byMediaType, byBoardVer, byChnnl);
			break;
		}
	default:
		break;
	}

	return byRes;
}

/*==============================================================================
函数名    :  GetResBy8KEVmpOutChnnl
功能      :  获得8kgvmp对应输出信息
算法实现  :  
参数说明  :  u8 &byMediaType out
			 u8 byChnnl in
返回值说明:  u8 byRes
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130529					yanghuaizhi							
==============================================================================*/
u8 CMcuVcInst::GetResBy8KEVmpOutChnnl(u8 &byMediaType, u8 byChnnl)
{
	//8000E-VMP
	// [2/3/2010 xliang] 8000E-vmp-new 4 out (考虑双other情况)
	/*
		no ohter			720		4cif	cif		NULL
		no 2 other			720		4cif	cif		other
		2 other				mp4		263		NULL	NULL		
	*/
	u8 byRes = VIDEO_FORMAT_INVALID;
	BOOL32 bDualOther = FALSE;
	if( m_tConf.GetMainVideoMediaType() != MEDIA_TYPE_H264 
		&& (m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_NULL 
		&& m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_H264 )
		)
	{
		bDualOther = TRUE;
	}
	byMediaType = MEDIA_TYPE_NULL;
	byRes = VIDEO_FORMAT_INVALID;
	switch (byChnnl)
	{
	case 0:
		{
			if( bDualOther )
			{
				byMediaType = MEDIA_TYPE_MP4;
				byRes = (m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_MP4) ?\
					 m_tConf.GetMainVideoFormat() : m_tConf.GetSecVideoFormat();

			}
			else
			{
				// 高清会议出第0路,非高清会议,第0路不出
				if (m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 
					|| m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD720)
				{
					byMediaType = MEDIA_TYPE_H264;
					byRes = VIDEO_FORMAT_HD720;
				}
			}

			break;
		}
	case 1:
		{
			if( bDualOther )
			{
				byMediaType = MEDIA_TYPE_H263;
				byRes = (m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H263) ?\
					m_tConf.GetMainVideoFormat() : m_tConf.GetSecVideoFormat();
			}
			else
			{
				// 主/辅格式是4CIF或有勾选4CIF才出
				if (MEDIA_TYPE_H264 == m_tConf.GetMainVideoMediaType())
				{
					if (VIDEO_FORMAT_4CIF == m_tConf.GetMainVideoFormat()
						|| IsMSSupportCapEx(VIDEO_FORMAT_4CIF))
					{
						byMediaType = MEDIA_TYPE_H264;
						byRes = VIDEO_FORMAT_4CIF;
					}
				}
				else if (MEDIA_TYPE_H264 == m_tConf.GetSecVideoMediaType())
				{
					if (VIDEO_FORMAT_4CIF == m_tConf.GetSecVideoFormat())
					{
						byMediaType = MEDIA_TYPE_H264;
						byRes = VIDEO_FORMAT_4CIF;
					}
				}
			}

			break;
		}
	case 2:
		{
			if( bDualOther )
			{
				byMediaType = MEDIA_TYPE_NULL;
				byRes = VIDEO_FORMAT_INVALID;
			}
			else
			{
				// 主/辅格式是CIF或有勾选CIF才出
				if (MEDIA_TYPE_H264 == m_tConf.GetMainVideoMediaType())
				{
					if (VIDEO_FORMAT_CIF == m_tConf.GetMainVideoFormat()
						|| IsMSSupportCapEx(VIDEO_FORMAT_CIF))
					{
						byMediaType = MEDIA_TYPE_H264;
						byRes = VIDEO_FORMAT_CIF;
					}
				}
				else if (MEDIA_TYPE_H264 == m_tConf.GetSecVideoMediaType())
				{
					if (VIDEO_FORMAT_CIF == m_tConf.GetSecVideoFormat())
					{
						byMediaType = MEDIA_TYPE_H264;
						byRes = VIDEO_FORMAT_CIF;
					}
				}
			}

			break;
		}
	case 3:	
		{	
			if( bDualOther )
			{
				byMediaType = MEDIA_TYPE_NULL;
				byRes = VIDEO_FORMAT_INVALID;
			}
			else if(m_tConf.GetMainVideoMediaType() != MEDIA_TYPE_H264)
			{
				byMediaType = m_tConf.GetMainVideoMediaType();
				byRes = m_tConf.GetMainVideoFormat();
			}
			else if(m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_H264)
			{
				byMediaType = m_tConf.GetSecVideoMediaType();
				byRes = m_tConf.GetSecVideoFormat();
			}
			else
			{
				//conference has no other mediatype
				byMediaType = MEDIA_TYPE_NULL;
				byRes = VIDEO_FORMAT_INVALID;
			}
			break;
		}
	default:
		{
			byMediaType = MEDIA_TYPE_NULL;
			byRes = VIDEO_FORMAT_INVALID;
			break;
		}
	}
	
	//deal with mp4 16cif
	if( VIDEO_FORMAT_16CIF == byRes && MEDIA_TYPE_MP4 == byMediaType)
	{
		byRes = VIDEO_FORMAT_4CIF;
	}

	return byRes;
}

/*==============================================================================
函数名    :  GetResBy8KEVmpOutChnnl
功能      :  获得8khvmp对应输出信息
算法实现  :  
参数说明  :  u8 &byMediaType out
			 u8 &byFrameRate out
			 u8 &byAttrb out
			 u8 byChnnl in
返回值说明:  u8 byRes
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130529					yanghuaizhi							
==============================================================================*/
u8 CMcuVcInst::GetResBy8KHVmpOutChnnl(u8 &byMediaType, u8 &byFrameRate, u8 &byAttrb, u8 byChnnl)
{
	//8000H-VMP
	// [3/30/2011 zhouyiliang] 8000H-vmp-new 5 out (考虑双other情况)
	/*
		no ohter	1080	720		4cif	cif		NULL
		no 2 other	1080	720		4cif	cif		other
		2 other		mp4		263		261	    NULL	NULL
	*/
	u8 byRes = VIDEO_FORMAT_INVALID;
	BOOL32 bDualOther = FALSE;
	u8 byMainMedType = m_tConf.GetMainVideoMediaType();
	u8 byMainRes = m_tConf.GetMainVideoFormat();	//主分辨率
	u8 byMainFps = m_tConf.GetMainVidUsrDefFPS();	//主帧率
	u8 byConfAtb = m_tConf.GetProfileAttrb();		//HP/BP

	if( m_tConf.GetMainVideoMediaType() != MEDIA_TYPE_H264 
		&& (m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_NULL 
		&& m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_H264 )
		)
	{
		bDualOther = TRUE;
	}
	byFrameRate = byMainFps;//默认出主帧率
	switch (byChnnl)
	{
	case 0:
		{
			if( bDualOther )
			{
				byMediaType = MEDIA_TYPE_MP4;
				byRes = (m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_MP4) ?\
					m_tConf.GetMainVideoFormat() : m_tConf.GetSecVideoFormat();
				byFrameRate = (m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_MP4) ?\
					m_tConf.GetMainVidUsrDefFPS() : m_tConf.GetSecVidUsrDefFPS();
			}
			else
			{
				byMediaType = MEDIA_TYPE_H264;
				byRes = VIDEO_FORMAT_HD1080;

				// HP会议
				if (emHpAttrb == m_tConf.GetProfileAttrb())
				{
					byAttrb = emHpAttrb;
					// 除非双流外的适配会议
					if (IsConfExcludeDDSUseAdapt())
					{
						// 1080会议
						if (VIDEO_FORMAT_HD1080 == byMainRes)
						{
							// 60fps会议,0路出720p30fpsHP
							if (byMainFps >= 50)
							{
								byRes = VIDEO_FORMAT_HD720;
							}
							// 30fps会议
							else
							{
								//勾选1080p30fpsBP,出1080p30fpsBP
								if (IsMSSupportCapEx(VIDEO_FORMAT_HD1080))
								{
									byAttrb = emBpAttrb;
								}
								// 其余情况,0路出720p30fpsHP
								else
								{
									byRes = VIDEO_FORMAT_HD720;
								}
							}
						}
						// 720HP会议,0路出720HP
						else if (VIDEO_FORMAT_HD720 == byMainRes)
						{
							byRes = VIDEO_FORMAT_HD720;
						}
					}
					// 单格式会议
					else
					{
						// 1080p/720p 都出720HP
						if (VIDEO_FORMAT_HD1080 == byMainRes ||
							VIDEO_FORMAT_HD720 == byMainRes)
						{
							byRes = VIDEO_FORMAT_HD720;
						}
					}
				}
				// BP会议
				else
				{
					byAttrb = emBpAttrb;
					// 除非双流外的适配会议
					if (IsConfExcludeDDSUseAdapt())
					{
						//1080p会议
						if (VIDEO_FORMAT_HD1080 == byMainRes)
						{
							// 60fps会议
							if (byMainFps >= 50)
							{
								// 勾选720p60fps,第0路不出,其余第0路出1080p30fpsBP
								if (IsMSSupportCapEx(VIDEO_FORMAT_HD720, byMainFps))
								{
									byRes = VIDEO_FORMAT_INVALID;
								}
							}
						}
						else
						{
							byRes = VIDEO_FORMAT_INVALID;
						}
					}
					// 单格式会议
					else
					{
						// 非1080会议,第0路不出
						if (VIDEO_FORMAT_HD1080 != byMainRes)
						{
							byRes = VIDEO_FORMAT_INVALID ;
						}
					}
				}
			}
			break;
		}
	case 1:
		{
			if( bDualOther )
			{
				byMediaType = MEDIA_TYPE_H263;
				byRes = (m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H263) ?\
					m_tConf.GetMainVideoFormat() : m_tConf.GetSecVideoFormat();
				byFrameRate = (m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H263) ?\
					m_tConf.GetMainVidUsrDefFPS() : m_tConf.GetSecVidUsrDefFPS();
			}
			else
			{
				byMediaType = MEDIA_TYPE_H264;
				byRes = VIDEO_FORMAT_HD720;
				// HP会议
				if (emHpAttrb == m_tConf.GetProfileAttrb())
				{
					byAttrb = emBpAttrb;	//HP会议只有第0路出HP,第一路仍出BP
					// 除非双流外的适配会议
					if (IsConfExcludeDDSUseAdapt())
					{
						//1080p会议 720p会议
						if (VIDEO_FORMAT_HD1080 == byMainRes || VIDEO_FORMAT_HD720 == byMainRes)
						{
							u8 byTmpFps = byMainFps >= 50 ? byMainFps/2 : byMainFps;
							// 未勾选720 BP时,第1路不出
							if (!IsMSSupportCapEx(VIDEO_FORMAT_HD720, byMainFps, emBpAttrb) &&
								!IsMSSupportCapEx(VIDEO_FORMAT_HD720, byTmpFps, emBpAttrb))
							{
								byRes = VIDEO_FORMAT_INVALID ;
							}
						}
					}
					// 单格式HP会议,第1路不出
					else
					{
						byRes = VIDEO_FORMAT_INVALID ;
					}
				}
				// BP会议
				else
				{
					byAttrb = emBpAttrb;
					// 除非双流外的适配会议
					if (IsConfExcludeDDSUseAdapt())
					{
						//1080p会议
						if (VIDEO_FORMAT_HD1080 == byMainRes)
						{
							// 未勾选720,不出第一路
							if (!IsMSSupportCapEx(VIDEO_FORMAT_HD720))
							{
								byRes = VIDEO_FORMAT_INVALID;
							}
						}
						else if (VIDEO_FORMAT_HD720 == byMainRes)
						{
							// 60fps会议,有勾选720p30fps时,第一路出720p30fps
							if (byMainFps >= 50 && IsMSSupportCapEx(VIDEO_FORMAT_HD720))
							{
								byFrameRate = byMainFps / 2;
							}
						}
						else //非hd会议,720不出
						{
							byRes = VIDEO_FORMAT_INVALID;
						}
					}
					else // 单格式会议
					{
						// 非720会议,不出720
						if (VIDEO_FORMAT_HD720 != byMainRes)
						{
							byRes = VIDEO_FORMAT_INVALID;
						}
					}
				}
			}
			break;
		}
	case 2:
		{
			if( bDualOther )
			{
					byMediaType = MEDIA_TYPE_H261;
				byRes = (m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H261) ?\
					m_tConf.GetMainVideoFormat() : m_tConf.GetSecVideoFormat();
				byFrameRate = (m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H261) ?\
					m_tConf.GetMainVidUsrDefFPS() : m_tConf.GetSecVidUsrDefFPS();
			}
			else
			{
				byMediaType = MEDIA_TYPE_H264;
				byRes = VIDEO_FORMAT_4CIF ;
				byFrameRate = (m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H264) ?\
					m_tConf.GetMainVidUsrDefFPS() : m_tConf.GetSecVidUsrDefFPS();
				if (byMainFps >= 50)
				{
					byFrameRate = byMainFps / 2;
				}
			}
			break;
		}
	case 3:
		{
			if( bDualOther )
			{
				byMediaType = MEDIA_TYPE_NULL;
				byRes = VIDEO_FORMAT_INVALID;
			}
			else
			{
				byMediaType = MEDIA_TYPE_H264;
				byRes = VIDEO_FORMAT_CIF ;
				byFrameRate = (m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H264) ?\
					m_tConf.GetMainVidUsrDefFPS() : m_tConf.GetSecVidUsrDefFPS();
				if (byMainFps >= 50)
				{
					byFrameRate = byMainFps / 2;
				}
			}
			break;
		}
	case 4:	
		{	
			if( bDualOther )
			{
				byMediaType = MEDIA_TYPE_NULL;
				byRes = VIDEO_FORMAT_INVALID;
			}
			else if(m_tConf.GetMainVideoMediaType() != MEDIA_TYPE_H264)
			{
				byMediaType = m_tConf.GetMainVideoMediaType();
				byRes = m_tConf.GetMainVideoFormat();
				byFrameRate = m_tConf.GetMainVidUsrDefFPS();
			}
			else if(m_tConf.GetSecVideoMediaType() != MEDIA_TYPE_H264)
			{
				byMediaType = m_tConf.GetSecVideoMediaType();
				byRes = m_tConf.GetSecVideoFormat();
				byFrameRate = m_tConf.GetSecVidUsrDefFPS();
			}
			else
			{
				byMediaType = MEDIA_TYPE_NULL;
				byRes = VIDEO_FORMAT_INVALID;
				if (byMainFps >= 50)
				{
					byFrameRate = byMainFps / 2;
				}
			}
			break;
		}
	default:
		{
			byMediaType = MEDIA_TYPE_NULL;
			byRes = VIDEO_FORMAT_INVALID;
			break;
		}
	}
	
	//deal with mp4 16cif
	if( VIDEO_FORMAT_16CIF == byRes && MEDIA_TYPE_MP4 == byMediaType)
	{
		byRes = VIDEO_FORMAT_4CIF;
	}

	return byRes;
}

/*==============================================================================
函数名    :  GetResByMpuOutChnnl
功能      :  获得mpu对应输出信息
算法实现  :  
参数说明  :  u8 &byMediaType out
			 u8 byChnnl in
返回值说明:  u8 byRes
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
130529					yanghuaizhi							
==============================================================================*/
u8 CMcuVcInst::GetResByMpuOutChnnl(u8 &byMediaType, u8 byBoardVer, u8 byChnnl)
{
	u8 byRes = VIDEO_FORMAT_INVALID;
	if (MPU_BOARD_A128 == byBoardVer)
	{
		//MPU 2出版本(A板)  0    1   2
		/*----------------------------
		1080				1080	cif	
		1080/720			720		cif
		1080/4cif			1080	cif
		1080/cif			1080	cif
		720					720		cif
		720/4cif			720		cif
		720/cif				720		cif
		4cif						cif
		4cif/cif					cif
		cif							cif
		xxx/other			*       other
		other				1080	other (HDU 看0路的，也能看到较好的效果)
		------------------------------*/
		if (MEDIA_TYPE_H264 == m_tConf.GetMainVideoMediaType())
		{
			byMediaType = MEDIA_TYPE_H264;
			if( 2 == byChnnl )
			{
				if(m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_H263 || m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_MP4 )
				{
					byMediaType = m_tConf.GetSecVideoMediaType();//出other
					byRes =  VIDEO_FORMAT_CIF;
				}
				else
				{
					byRes =  VIDEO_FORMAT_CIF;
				}
			}
			else if( 0 == byChnnl )
			{
				if( VIDEO_FORMAT_HD720 == m_tConf.GetMainVideoFormat()
					|| ( VIDEO_FORMAT_HD1080 == m_tConf.GetMainVideoFormat()//1080,720的会议第1出出720
					&& IsMSSupportCapEx(VIDEO_FORMAT_HD720) )
					)
				{
					byRes = VIDEO_FORMAT_HD720;
				}
				else if( VIDEO_FORMAT_HD1080 == m_tConf.GetMainVideoFormat() ||
					VIDEO_FORMAT_CIF == m_tConf.GetMainVideoFormat() )
				{
					byRes = VIDEO_FORMAT_HD1080;
				}
				else
				{
					//do nothing
				}
			}
			else
			{
				//do nothing
			}
		}
		else //h263会议和mpeg4会议
		{
			byMediaType = ( 0 == byChnnl )? MEDIA_TYPE_H264: m_tConf.GetMainVideoMediaType();
			byRes = ( 0 == byChnnl )? VIDEO_FORMAT_HD1080 : VIDEO_FORMAT_CIF;  
		}	
	}
	else
	{
		byMediaType = MEDIA_TYPE_NULL;
		byRes = VIDEO_FORMAT_INVALID;
		//songkun,20110628,Bug00056785
		//IMAX会议，MPU4开启画面合成，7210/8010A接收不到画面合成图像,不再区分other,2通道cif  
		// [pengjie 2010/4/20] 画面合成区分高标清会议（对应通道出的分辨率有所改变）
		// 高清情况下 规则如下： 0通道     1通道      2通道      3通道
		//                       1080       720    other/cif     4cif/cif
		if( m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H264 && IsVidFormatHD(m_tConf.GetMainVideoFormat()) ||
			m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_H264 && IsVidFormatHD(m_tConf.GetSecVideoFormat()) )
		{			
			if( 0 == byChnnl )	//0出
			{
				// 会议主格式是1080时,出第0路
				if (VIDEO_FORMAT_HD1080 == m_tConf.GetMainVideoFormat())
				{
					byMediaType = MEDIA_TYPE_H264;
					byRes = VIDEO_FORMAT_HD1080;
				}
			}
			else if (1 == byChnnl)	//1出
			{
				// 主格式是720或有勾选720时,出第1路
				if (VIDEO_FORMAT_HD720 == m_tConf.GetMainVideoFormat()
					|| IsMSSupportCapEx(VIDEO_FORMAT_HD720))
				{
					byMediaType = MEDIA_TYPE_H264;
					byRes = VIDEO_FORMAT_HD720;
				}
			}
			else if (2 == byChnnl)	//2出
			{
				if( m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H263 || m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_MP4 )
				{
					byMediaType = m_tConf.GetMainVideoMediaType(); 
					byRes =  VIDEO_FORMAT_CIF;
				}
				else
				{
					TConfAttrbEx tconfAttrbEx = m_tConf.GetConfAttrbEx();
					if(tconfAttrbEx.IsImaxModeConf())
					{
						//songkun,20110628,Bug00056785
						//IMAX会议，MPU4开启画面合成，7210/8010A接收不到画面合成图像,不再区分other
						byMediaType = MEDIA_TYPE_H264;
						byRes =  VIDEO_FORMAT_CIF;
					}
					else
					{
						if( m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_H263 || m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_MP4 )
						{
							byMediaType = m_tConf.GetSecVideoMediaType(); //出other
							byRes =  VIDEO_FORMAT_CIF;
						}
						else
						{
							// 主/辅格式是CIF或有勾选CIF,出cif
							if (MEDIA_TYPE_H264 == m_tConf.GetMainVideoMediaType())
							{
								if (VIDEO_FORMAT_CIF == m_tConf.GetMainVideoFormat()
									|| IsMSSupportCapEx(VIDEO_FORMAT_CIF))
								{
									byMediaType = MEDIA_TYPE_H264;
									byRes =  VIDEO_FORMAT_CIF;
								}
							}
							else if (MEDIA_TYPE_H264 == m_tConf.GetSecVideoMediaType())
							{
								if (VIDEO_FORMAT_CIF == m_tConf.GetSecVideoFormat())
								{
									byMediaType = MEDIA_TYPE_H264;
									byRes =  VIDEO_FORMAT_CIF;
								}
							}
						}
					}
				}
			}
			else					//3出
			{
				// 会议有勾选h264/cif，且会议有辅格式，那么该通道出的分辨率就由原来的h264/4cif降为cif
				if( ( m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_H263 || m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_MP4 ) &&
					IsMSSupportCapEx(VIDEO_FORMAT_CIF))
				{
					byMediaType = MEDIA_TYPE_H264;
					byRes = VIDEO_FORMAT_CIF;
				}
				else
				{
					// 主/辅格式是4CIF或有勾选4CIF,出4CIF
					if (MEDIA_TYPE_H264 == m_tConf.GetMainVideoMediaType())
					{
						if (VIDEO_FORMAT_4CIF == m_tConf.GetMainVideoFormat()
							|| IsMSSupportCapEx(VIDEO_FORMAT_4CIF))
						{
							byMediaType = MEDIA_TYPE_H264;
							byRes =  VIDEO_FORMAT_4CIF;
						}
					}
					else if (MEDIA_TYPE_H264 == m_tConf.GetSecVideoMediaType())
					{
						if (VIDEO_FORMAT_4CIF == m_tConf.GetSecVideoFormat())
						{
							byMediaType = MEDIA_TYPE_H264;
							byRes =  VIDEO_FORMAT_4CIF;
						}
					}
				}
			}
		}
		// 标清情况下 规则如下：0通道     1通道      2通道      3通道
		//                       4CIF      NULL    other/NULL    cif
		else 
		{
			if( 0 == byChnnl ) // 0 通道
			{
				byMediaType = MEDIA_TYPE_H264;
				byRes       = VIDEO_FORMAT_4CIF;
			}
			else if( 1 == byChnnl ) // 1 通道
			{
				byMediaType = MEDIA_TYPE_NULL;
				byRes       = VIDEO_FORMAT_INVALID;
			}
			else if( 2 == byChnnl ) // 2 通道
			{
				if( m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_H263 ||
					m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_H263 )
				{
					byMediaType = MEDIA_TYPE_H263;
					byRes       = VIDEO_FORMAT_CIF;
				}
				else if( m_tConf.GetMainVideoMediaType() == MEDIA_TYPE_MP4 )
				{
					byMediaType = MEDIA_TYPE_MP4;
					byRes = m_tConf.GetMainVideoFormat();
				}
				else if( m_tConf.GetSecVideoMediaType() == MEDIA_TYPE_MP4 )
				{
					byMediaType = MEDIA_TYPE_MP4;
					byRes = m_tConf.GetSecVideoFormat();
				}
				else
				{
					byMediaType = MEDIA_TYPE_NULL;
					byRes       = VIDEO_FORMAT_INVALID;
				}
			}
			else // 3 通道
			{
				byMediaType = MEDIA_TYPE_H264;
				byRes       = VIDEO_FORMAT_CIF;
			}
		}
	}
	if( VIDEO_FORMAT_16CIF == byRes && MEDIA_TYPE_MP4 == byMediaType)
	{
		byRes = VIDEO_FORMAT_4CIF;
	}

	return byRes;
}

/*==============================================================================
函数名    :  GetVmpOutChnnlByDstMtId
功能      :  获取某个终端对应在VMP中的输出通道
算法实现  :  
参数说明  :  u8 byDstMtId			[in]  终端的mtid
			 追加参数，若传入byVmpId不为0做选看源Check，为0则直接取选看源vmp通道
			 
返回值说明:  u8 VMP输出通道号
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-1-5                   周翼亮							创建
2013-2-27				   杨怀志			
==============================================================================*/
u8 CMcuVcInst::GetVmpOutChnnlByDstMtId(u8 byDstMtId, u8 byVmpId, BOOL32 bNeedCheckSelSrc)
{
	u8 byRet = 0xFF;
	if ( !m_tConfAllMtInfo.MtJoinedConf( byDstMtId ) || !IsValidVmpId(byVmpId))//非法输入参数
	{
		return byRet;
	}
	TLogicalChannel tFwLogicChnnel;
	if (!m_ptMtTable->GetMtLogicChnnl( byDstMtId, LOGCHL_VIDEO, &tFwLogicChnnel, TRUE) ) 
	{
		ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,"[GetVmpOutChnnlByDstMtId]Get DstMt：%d forward logicalchnnl failed \n",byDstMtId );
		return byRet;
	}
	
	TMtStatus tTempMtStatus;
	m_ptMtTable->GetMtStatus(byDstMtId, &tTempMtStatus);
	TEqp tVmpEqp = tTempMtStatus.GetSelectMt(MODE_VIDEO);
	// 选看源不为空时,若选看源不是vmp外设，返回错误通道
	if (!tVmpEqp.IsNull() && bNeedCheckSelSrc)
	{
		if (tVmpEqp.GetEqpType() != EQP_TYPE_VMP || !IsValidVmpId(tVmpEqp.GetEqpId()))
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,"[GetVmpOutChnnlByDstMtId]Get DstMt：%d selectsrc[%d] is not vmp \n",byDstMtId, tVmpEqp.GetEqpId());
			return byRet;
		}
		else if (tVmpEqp.GetEqpId() != byVmpId)//选看源是其它vmp，不是要获得的vmp，返回错误通道
		{
			ConfPrint(LOG_LVL_DETAIL, MID_MCU_EQP,"[GetVmpOutChnnlByDstMtId]Get DstMt：%d selectsrc[%d] is not vmp[%d] \n",byDstMtId, tVmpEqp.GetEqpId(), byVmpId);
			return byRet;
		}
	}
	tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	
	byRet  = GetVmpOutChnnlByRes(tVmpEqp.GetEqpId(), 
		tFwLogicChnnel.GetVideoFormat(), 
		tFwLogicChnnel.GetChannelType(),
		tFwLogicChnnel.GetChanVidFPS(), 
		tFwLogicChnnel.GetProfileAttrb());
	return byRet;
}

/*==============================================================================
函数名    :  GetVmpSpecialOutChnnlByDstMtId
功能      :  获取某个终端对应在VMP中的输出通道,只在8KH特殊情况下使用
算法实现  :  
参数说明  :  u8 byDstMtId			[in]  终端的mtid
			 
返回值说明:  u8 VMP输出通道号
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2012-02-17      4.7             倪志俊							创建
==============================================================================*/
u8 CMcuVcInst::GetVmpSpecialOutChnnlByDstMtId(u8 byDstMtId)
{
	//[nizhijun 2011/07/06]8000H比较特殊，非画面合成广播下，接收能力1080的主席终端选看VMP，收的是720
	//故此时如果切换到VMP广播，需要将720那出的RTCP交换都停掉，因为光掉StopSelectSrc是处理不了的
	u8 byRet = 0xFF;
	if ( !m_tConfAllMtInfo.MtJoinedConf( byDstMtId ) )//非法输入参数
	{
		return byRet;
	}

	TLogicalChannel tFwLogicChnnel;
	if (!m_ptMtTable->GetMtLogicChnnl( byDstMtId, LOGCHL_VIDEO, &tFwLogicChnnel, TRUE) ) 
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_EQP,"[GetVmpSpecialOutChnnlByDstMtId]Get DstMt：%d forward logicalchnnl failed \n",byDstMtId );
		return byRet;
	}
	// 只针对8kh，取当前唯一的vmp
	u8 byVmpId = GetTheOnlyVmpIdFromVmpList();
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp(byVmpId);
	u8 byVmpSubType = GetVmpSubType(byVmpId);
	if (VMP_8KH != byVmpSubType && VMP_8KI != byVmpSubType)
	{
		// 只有8KH 8KI需要做特殊处理
		return byRet;
	}

	TMt tDstMt = m_ptMtTable->GetMt(byDstMtId);
	if ( tDstMt == m_tConf.GetChairman() &&			
		 g_cMcuVcApp.IsBrdstVMP(tVmpEqp)
		)
	{
		u8 byVmpOutChl = GetVmpOutChnnlByDstMtId(byDstMtId, byVmpId);
		TLogicalChannel tCharimanLogic;
		if (IsConfExcludeDDSUseAdapt() &&
			0 == byVmpOutChl)
		{
			// 区分处理8kh与8ki合成
			if (VMP_8KH == byVmpSubType)
			{
				if (VIDEO_FORMAT_HD1080 == m_tConf.GetMainVideoFormat() &&
					m_tConf.GetMainVidUsrDefFPS() <= 30 &&
					m_tConf.GetProfileAttrb() == emBpAttrb)
				{
					// 720/4cif/cif都未勾选时,是不允许非广播的
					if (IsMSSupportCapEx(VIDEO_FORMAT_HD720))
					{
						byRet = 1;
					} 
					else if (IsMSSupportCapEx(VIDEO_FORMAT_4CIF))
					{
						byRet = 2;
					} 
					else if (IsMSSupportCapEx(VIDEO_FORMAT_CIF))
					{
						byRet = 3;
					}
				}
				if (VIDEO_FORMAT_HD720 == tCharimanLogic.GetVideoFormat() && 
					m_tConf.GetMainVidUsrDefFPS() < 50 &&
					tCharimanLogic.GetProfileAttrb() == emHpAttrb)
				{
					if (IsMSSupportCapEx(VIDEO_FORMAT_HD720, m_tConf.GetMainVidUsrDefFPS(), emBpAttrb))
					{
						byRet = 1;
					}
					else if (IsMSSupportCapEx(VIDEO_FORMAT_4CIF))
					{
						byRet = 2;
					}
					else if (IsMSSupportCapEx(VIDEO_FORMAT_CIF))
					{
						byRet = 3;
					}
				}
			}
			else if (VMP_8KI == byVmpSubType)
			{
				// 会议是1080p30fps或720p60fps适配会议时,为避免vmp广播非广播切换时通道改变,取1通道
				if (IsConfExcludeDDSUseAdapt()) //适配会议
				{
					if ((m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD1080 && m_tConf.GetMainVidUsrDefFPS() <= 30) ||
						(m_tConf.GetMainVideoFormat() == VIDEO_FORMAT_HD720 && m_tConf.GetMainVidUsrDefFPS() > 30))
					{
						TKDVVMPOutParam tVMPOutParam = g_cMcuVcApp.GetVMPOutParam(tVmpEqp);
						TVideoStreamCap tTmpStrCap = tVMPOutParam.GetVmpOutCapIdx(1);
						// 720/4cif/cif都未勾选时,是不允许非广播的,
						if (MEDIA_TYPE_H264 == tTmpStrCap.GetMediaType())
						{
							byRet = 1;
						}
						else
						{
							byRet = 0XFF;
						}
					}
				}
			}
		}
	}
	return byRet;
}

/*==============================================================================
函数名    :  ChgSpeakerInMixer
功能      :  混音器切换发言人成员
算法实现  :  
参数说明  :  tOldSpeaker	[in]  原发言人,如果为空,则不处理之
			 ptNewSpeaker	[in]  新发言人,如果为空,则不处理之
			 
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-7-6     4.6           彭国锋						   创建
==============================================================================*/
void CMcuVcInst::ChgSpeakerInMixer(TMt tOldSpeaker, TMt *ptNewSpeaker )
{
	if ( NULL == ptNewSpeaker )
	{
		ConfPrint(LOG_LVL_ERROR, MID_MCU_CONF, "[ChgSpeakerInMixer] the ptNewSpeaker is NULL!" );
		return;
	}
	if (tOldSpeaker == *ptNewSpeaker)
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_CONF, "[ChgSpeakerInMixer]tOldSpeaker(%d,%d) == *ptNewSpeaker!",
			tOldSpeaker.GetMcuId(),tOldSpeaker.GetMtId());
		return;
	}
	// 不在混音状态，退出
	if ( !m_tConf.m_tStatus.IsMixing())
	{
		return;
	}

	// 1 处理新发言人
	if (!ptNewSpeaker->IsNull())
	{
		BOOL32 bIsMixerFull = FALSE;
		TMt tLocalNewSpeaker = GetLocalMtFromOtherMcuMt(*ptNewSpeaker);

		if( m_tConf.m_tStatus.IsSpecMixing() && !m_ptMtTable->IsMtInMixGrp( tLocalNewSpeaker.GetMtId() ) &&
			GetMixMtNumInGrp() >= GetMaxMixNum(m_tMixEqp.GetEqpId()) )
		{
			bIsMixerFull = TRUE;
		}		
		
		//对于本地终端提前释放混音通道，以免新发言人无法进混音器
		if (tOldSpeaker.IsLocal() && m_ptMtTable->GetMtType(tOldSpeaker.GetMtId()) == MT_TYPE_MT && m_ptMtTable->IsMtInMixing(tOldSpeaker.GetMtId()) &&
			((MCS_CONF == m_tConf.GetConfSource() && m_ptMtTable->IsMtAutoInSpec(tOldSpeaker.GetMtId())) ||
			(VCS_CONF == m_tConf.GetConfSource() && m_cVCSConfStatus.GetMtInTvWallCanMixing() && !(tOldSpeaker == m_tConf.GetChairman()) &&
			IsMtNotInOtherTvWallChnnl(tOldSpeaker, 0, 0) && IsMtNotInOtherHduChnnl(tOldSpeaker, 0, 0))))
		{
			RemoveSpecMixMember(&tOldSpeaker, 1, FALSE, FALSE);
			bIsMixerFull = FALSE;
		}		

		// 1.1 加入定制混音
		if (m_tConf.m_tStatus.IsSpecMixing() && !bIsMixerFull )
		{
			if ( ptNewSpeaker->GetType() == TYPE_MT)
			{
				TLogicalChannel tLogicChan;
				if ( m_ptMtTable->GetMtLogicChnnl(tLocalNewSpeaker.GetMtId(), LOGCHL_AUDIO, &tLogicChan, TRUE))
				{
					if (ptNewSpeaker->IsLocal())
					{
						
						if (!m_ptMtTable->IsMtInMixing(ptNewSpeaker->GetMtId()))
						{
							StopSelectSrc( tLocalNewSpeaker,MODE_AUDIO,FALSE );
							AddSpecMixMember(ptNewSpeaker, 1, TRUE);
						}
					}
					else
					{
						TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(ptNewSpeaker->GetMcuId());
						if (ptMcInfo != NULL)
						{
							AddSpecMixMember(ptNewSpeaker, 1, ptMcInfo->GetMtAutoInMix(*ptNewSpeaker));
						}
					}
					if ( ptNewSpeaker->IsLocal())
					{
						if ( m_ptMtTable->GetMtType(ptNewSpeaker->GetMtId()) == MT_TYPE_SMCU)
						{
							TMt tViewMt = GetSMcuViewMt(*ptNewSpeaker,TRUE);
							if ( !tViewMt.IsNull() )
							{
								TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tViewMt.GetMcuId());
								if (ptMcInfo != NULL)
								{
									AddSpecMixMember(&tViewMt, 1, ptMcInfo->GetMtAutoInMix(tViewMt));
								}
							}
						}
					} 
					else
					{
						if (IsMcu(*ptNewSpeaker))
						{
							TMt tViewMt = GetSMcuViewMt(*ptNewSpeaker,TRUE);
							if ( !tViewMt.IsNull())
							{
								TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tViewMt.GetMcuId());
								if (ptMcInfo != NULL)
								{
									AddSpecMixMember(&tViewMt, 1, ptMcInfo->GetMtAutoInMix(tViewMt));
								}
							}
						}
					}
				}
			}
		}
		
		if( !bIsMixerFull )
		{
			// 1.2 加入强制混音
			AddMixMember(&tLocalNewSpeaker/*tOldSpeaker*/, DEFAULT_MIXER_VOLUME, TRUE);
		}		
	}

	// miaoqingsong [2011/07/14] Bug00058581:多点会议，有发言人时开启混音，只有发言人在混音中，取消发言人不停混音
	BOOL32 bIsHaveNewSpeaker = !ptNewSpeaker->IsNull();

	// 2 处理原发言人
	if ( !tOldSpeaker.IsNull())
	{
		// 2.1 取消定制混音
		if ( VCS_CONF == m_tConf.GetConfSource())
		{
			// VCS会议,仅去除非主席终端
			if ( !(tOldSpeaker == m_tConf.GetChairman()))
			{
				BOOL32 bIsCanStopMixing = TRUE;
				
				//zjj20091102 如果开启电视墙一键混音，而且老发言人在电视墙中，就不能退出混音
				if ( m_cVCSConfStatus.GetMtInTvWallCanMixing() &&
					( !IsMtNotInOtherTvWallChnnl(tOldSpeaker, 0, 0) || !IsMtNotInOtherHduChnnl(tOldSpeaker, 0, 0)))
				{
					bIsCanStopMixing = FALSE;
				}
				
				if ( tOldSpeaker.IsLocal())
				{
					if (bIsCanStopMixing)
					{
						// VCS即使混音参数为空也不自动停混音
						//lukunpeng 2010/05/21 vcs老发言人出混音要用强制
						RemoveSpecMixMember(&tOldSpeaker, 1, TRUE, FALSE);
					}
				} 
				else
				{
					if ( IsMtNotInOtherHduChnnl(tOldSpeaker, 0, 0) && IsMtNotInOtherTvWallChnnl(tOldSpeaker, 0, 0))
					{
						BOOL32 bInSameSMcu = bIsHaveNewSpeaker?(tOldSpeaker.GetMcuId() == ptNewSpeaker->GetMcuId()):FALSE;
						BOOL32 bStopMixNoMem = !(bIsHaveNewSpeaker && bInSameSMcu) ? TRUE : FALSE;
						RemoveSpecMixMember(&tOldSpeaker, 1, TRUE, bStopMixNoMem);
					}
					
					//zjj20090911 VCS会议停止对下级终端的调度时，将回传通道也剔除出混音成员组
					if ( (m_cVCSConfStatus.GetCurVCMode() == VCS_GROUPTW_MODE ||
						m_cVCSConfStatus.GetCurVCMode() == VCS_GROUPSPEAK_MODE) &&
						bIsCanStopMixing)
					{
						RemoveSpecMixMember(&tOldSpeaker, 1, TRUE, FALSE);
						
						ConfPrint(LOG_LVL_DETAIL, MID_MCU_VCS,  "[ChgSpeakerInMixer] vcs Cancel smcu Adudio switch\n");
					}
				}
			}
		}
		else
		{
			// 非VCS会议
			if ( tOldSpeaker.IsLocal())
			{
				if ( m_ptMtTable->GetMtType(tOldSpeaker.GetMtId()) == MT_TYPE_SMCU)
				{
					TMt tViewMt = GetSMcuViewMt(tOldSpeaker,TRUE);
					TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo( tViewMt.GetMcuIdx() );
					if ( !tViewMt.IsNull() && NULL != ptMcInfo && 
						 m_ptConfOtherMcTable->IsMtInMixing(tViewMt) &&
						 ptMcInfo->GetMtAutoInMix(tViewMt))
					{
						RemoveSpecMixMember(&tViewMt, 1, FALSE,!bIsHaveNewSpeaker);
						m_tConfInStatus.SetLastSpeakerInMixing(FALSE);
					}
					if (GetMcuIdxFromMcuId(tOldSpeaker.GetMtId()) == INVALID_MCUIDX)
					{
						RemoveSpecMixMember(&tOldSpeaker, 1, FALSE, !bIsHaveNewSpeaker);
						m_tConfInStatus.SetLastSpeakerInMixing(FALSE);
					}
					else
					{
						if (GetLocalMtFromOtherMcuMt(*ptNewSpeaker).GetMtId() != tOldSpeaker.GetMtId() &&
							GetCurConfMixMtNum(GetMcuIdxFromMcuId(tOldSpeaker.GetMtId())) == 0)
						{
							RemoveSpecMixMember(&tOldSpeaker, 1, FALSE, !bIsHaveNewSpeaker);
							m_tConfInStatus.SetLastSpeakerInMixing(FALSE);
						}
					}
				} 
				else
				{
					if ( m_ptMtTable->IsMtAutoInSpec(tOldSpeaker.GetMtId()) )
					{
						RemoveSpecMixMember(&tOldSpeaker, 1, FALSE, !bIsHaveNewSpeaker);
						m_tConfInStatus.SetLastSpeakerInMixing(FALSE);
					}
				}
			} 
			else
			{
				if (IsMcu(tOldSpeaker))
				{
					TMt tViewMt = GetSMcuViewMt(tOldSpeaker,TRUE);
					if ( !tViewMt.IsNull() && m_ptConfOtherMcTable->IsMtInMixing(tViewMt))
					{
						TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tViewMt.GetMcuId());
						if (ptMcInfo != NULL && ptMcInfo->GetMtAutoInMix(tViewMt))
						{
							RemoveSpecMixMember(&tViewMt, 1, FALSE, !bIsHaveNewSpeaker);
							m_tConfInStatus.SetLastSpeakerInMixing(FALSE);
						}
					}
				}
				else
				{
					if ( m_ptConfOtherMcTable->IsMtInMixing(tOldSpeaker))
					{
						TConfMcInfo *ptMcInfo = m_ptConfOtherMcTable->GetMcInfo(tOldSpeaker.GetMcuId());
						if (ptMcInfo != NULL && ptMcInfo->GetMtAutoInMix(tOldSpeaker))
						{
							RemoveSpecMixMember(&tOldSpeaker, 1, FALSE, !bIsHaveNewSpeaker);
							m_tConfInStatus.SetLastSpeakerInMixing(FALSE);
						}
 					}
				}
				TMt tlocalOldSpeaker = GetLocalMtFromOtherMcuMt(tOldSpeaker);
				if (GetLocalMtFromOtherMcuMt(*ptNewSpeaker).GetMtId() != tlocalOldSpeaker.GetMtId() &&
					GetCurConfMixMtNum(GetMcuIdxFromMcuId(tlocalOldSpeaker.GetMtId())) == 0)
				{
					RemoveSpecMixMember(&tlocalOldSpeaker, 1, FALSE, !bIsHaveNewSpeaker);
					m_tConfInStatus.SetLastSpeakerInMixing(FALSE);
				}
			}
		}
		
		// 2.2 取消强制混音
		if (ptNewSpeaker->IsNull() || !m_ptMtTable->IsMtInMixGrp(GetLocalMtFromOtherMcuMt(*ptNewSpeaker).GetMtId()))
		{
			TMt tlocalOldSpeaker = GetLocalMtFromOtherMcuMt(tOldSpeaker);
			RemoveMixMember(&tlocalOldSpeaker, TRUE);
		}
	}
	
}
/*==============================================================================
函数名    :  ChgSpeakerInVmp
功能      :  调整发言人视频显示
算法实现  :  
参数说明  :  tOldSpeaker	[in]  原发言人
			 tNewSpeaker	[in]  新发言人
			 bAddToVmp		[in]  是否加入画面合成
			 
返回值说明:  true:vmp确有调整, false:vmp未调整
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-7-6     4.6           彭国锋						   创建
==============================================================================*/
BOOL32 CMcuVcInst::ChgSpeakerInVmp(TMt tOldSpeaker, TMt tNewSpeaker, BOOL32 bAddToVmp )
{
	BOOL32 bNeedAjsVmp = FALSE;
	//新旧发言人相同时,不做处理
	if (tOldSpeaker == tNewSpeaker)
	{
		LogPrint(LOG_LVL_DETAIL, MID_MCU_VMP, "[ChgSpeakerInVmp]OldSpeaker[%d,%d] is equal to NewSpeaker[%d,%d], vmp need not update.\n",
			tOldSpeaker.GetMcuIdx(), tOldSpeaker.GetMtId(), tNewSpeaker.GetMcuIdx(), tNewSpeaker.GetMtId());
		return bNeedAjsVmp;
	}

	u8 byVmpId = 0;
	TEqp tVmpEqp;
	TVMPParam_25Mem	tVMPParam;
	TVMPMember tVMPMember;
	TMt tNullMt;
	tNullMt.SetNull();
	for (u8 byIdx = 0; byIdx < MAXNUM_CONF_VMP; byIdx++)
	{
		if (!IsValidVmpId(m_abyVmpEqpId[byIdx]))
		{
			continue;
		}
		byVmpId = m_abyVmpEqpId[byIdx];
		tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );

		//调整Vmp参数，无双流源时，清除双流跟随通道中的成员[9/21/2012 chendaiwei]
		tVMPParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
		u8 byDSChnnl = tVMPParam.GetChlOfMemberType(VMP_MEMBERTYPE_DSTREAM);
		if ( byDSChnnl < MAXNUM_VMP_MEMBER )
		{
			tVMPMember = *tVMPParam.GetVmpMember(byDSChnnl);
			if( !tVMPMember.IsNull()
				&& CONF_DUALMODE_SPEAKERONLY == m_tConf.GetConfAttrb().GetDualMode()
				&& m_tDoubleStreamSrc.IsNull())
			{
				ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_VMP,"[ChgSpeakerInVmp] tVmpMember<McuId.%d MtId.%d> is VMP_MEMBERTYPE_DSTREAM,but no dStream src exist,clear!\n",tVMPMember.GetMcuId(),tVMPMember.GetMtId());
				
				tVMPMember.SetMemberTMt( tNullMt );
				tVMPParam.SetVmpMember(byDSChnnl,tVMPMember);
				g_cMcuVcApp.SetConfVmpParam(tVmpEqp, tVMPParam);
			}
		}

	}
	
	// 1.1 改变原发言人的视频显示
	TMt tOldMcu;
	tOldMcu.SetNull();
	u16 wOldMcuIdx = INVALID_MCUIDX;
	if ( !tOldSpeaker.IsNull() )
	{
		if (!tOldSpeaker.IsLocal())
		{
			tOldMcu = GetLocalMtFromOtherMcuMt(tOldSpeaker);
			wOldMcuIdx = tOldSpeaker.GetMcuIdx();
		}
		else if (IsMcu(tOldSpeaker))
		{
			tOldMcu = tOldSpeaker;
			wOldMcuIdx = GetMcuIdxFromMcuId(tOldSpeaker.GetMtId());
		}
		if (ChgMtVidFormatRequired(tOldSpeaker, TRUE))
		{
			if (!tOldMcu.IsNull() 
				&& !IsLocalAndSMcuSupMultSpy(wOldMcuIdx) 
				&& (tOldMcu == tNewSpeaker || IsMtInMcu(tOldMcu, tNewSpeaker)))
			{
				// 单回传导致的改变发言人,vmp中不会再存在旧发言人
			}
			else
			{
				ChangeMtVideoFormat(tOldSpeaker); // 2011-12-2 bConsiderVmpBrd为TRUE会导致把它从前适配通道里清出去
			}
		}
	}
	
	u8 byVmpCount = GetVmpCountInVmpList();
	if (byVmpCount > 0 && bAddToVmp)
	{
		bNeedAjsVmp = TRUE;
		ChangeVmpChannelParam(&tNewSpeaker, VMP_MEMBERTYPE_SPEAKER, &tOldSpeaker);
		// 如果无发言人跟随通道，需单独调整一次发言人分辨率，仅在一个通道时需占前适配
		if (TYPE_MCUPERI != GetVidBrdSrc().GetType() && 0 == GetVmpChnnlNumBySpecMemberType(VMP_MEMBERTYPE_SPEAKER))
		{
			ChangeMtVideoFormat(tNewSpeaker, FALSE, FALSE, TRUE);
		}
	}

	return bNeedAjsVmp;
}
/*==============================================================================
函数名    :  ChgSpeakerInTvWall
功能      :  TvWall切换发言人成员
算法实现  :  
参数说明  :  tNewSpeaker	[in]  新发言人
			 
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-7-6     4.6           彭国锋						   创建
==============================================================================*/
void CMcuVcInst::ChgSpeakerInTvWall(TMt tNewSpeaker )
{
	//　TvWall　发言人跟随时，同步调整电视墙中的图像
	TPeriEqpStatus tTWStatus;
	u8 byChnlIdx;
	u8 byEqpId;
	for (byEqpId = TVWALLID_MIN; byEqpId <= TVWALLID_MAX; byEqpId++)
	{
		if (EQP_TYPE_TVWALL == g_cMcuVcApp.GetEqpType(byEqpId))
		{
			if (g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tTWStatus)
				&& tTWStatus.m_byOnline)
			{
				u8 byMemberType;
				u8 byMtConfIdx;
				for (byChnlIdx = 0; byChnlIdx < MAXNUM_PERIEQP_CHNNL; byChnlIdx++)
				{
					byMemberType = tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].byMemberType;
					byMtConfIdx = tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnlIdx].GetConfIdx();
					if (TW_MEMBERTYPE_SPEAKER == byMemberType && m_byConfIdx == byMtConfIdx)
					{
						//zjl[03/01/2010] 发言人跟随，指定下级终端为发言人时，需要级联调分辨率，所以所传源端必须是非local
						ChangeTvWallSwitch(&tNewSpeaker/*tLocalNewSpeaker*/, byEqpId, byChnlIdx, TW_MEMBERTYPE_SPEAKER, TW_STATE_CHANGE);
					}
				}
			}
		}
	}
}
/*==============================================================================
函数名    :  ChgSpeakerInHdu
功能      :  Hdu切换发言人成员
算法实现  :  
参数说明  :  tNewSpeaker	[in]  新发言人
			 
返回值说明:  
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2011-7-6     4.6           彭国锋						   创建
==============================================================================*/
void CMcuVcInst::ChgSpeakerInHdu(TMt tNewSpeaker )
{
	//发言人跟随时，同步调整HDU中的图像
	TPeriEqpStatus tHduStatus;
	u8 byHduChnlIdx;
	u8 byHduEqpId;
	
	for (byHduEqpId = HDUID_MIN; byHduEqpId <= HDUID_MAX; byHduEqpId++)
	{
		if(IsValidHduEqp(g_cMcuVcApp.GetEqp(byHduEqpId)))
		{
			u8 byHduChnNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byHduEqpId));
			if (0 == byHduChnNum)
			{
				ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU, "[AdjustNewSpeakerSwitch] GetHduChnNumAcd2Eqp failed!\n");
				continue;
			}
			
			if (g_cMcuVcApp.GetPeriEqpStatus(byHduEqpId, &tHduStatus)
				&& tHduStatus.m_byOnline)
			{
				
				u8 byMemberType;
				u8 byMtConfIdx;
				for (byHduChnlIdx = 0; byHduChnlIdx < min(byHduChnNum,MAXNUM_HDU_CHANNEL); byHduChnlIdx++)
				{
					byMemberType = tHduStatus.m_tStatus.tHdu.atVideoMt[byHduChnlIdx].byMemberType;
					byMtConfIdx = tHduStatus.m_tStatus.tHdu.atVideoMt[byHduChnlIdx].GetConfIdx();
					if (TW_MEMBERTYPE_SPEAKER == byMemberType && m_byConfIdx == byMtConfIdx)
					{
						// [2013/03/11 chenbing] HDU多画面目前不支持发言人跟随,子通道置0
						ChangeHduSwitch(&tNewSpeaker, byHduEqpId, byHduChnlIdx, 0, TW_MEMBERTYPE_SPEAKER, TW_STATE_START);
					}
				}
			}
		}
	}	
}
/*====================================================================
函数名      ProcWaitAllVMPPrestInAckTimer
功能        ：MCU等待本次画面合成请求的所有下级presetinack的timer
算法实现    ：
引用全局变量：
输入参数说明：const CMessage * pcMsg, 传入的消息
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/06/13    4.0         周翼亮         创建
====================================================================*/
void CMcuVcInst::ProcWaitAllVMPPrestInAckTimer( const CMessage * pcMsg )
{
	KillTimer(pcMsg->event);
	u8 byVmpIdx = pcMsg->event - MCUVC_WAIT_ALLVMPPRESETIN_ACK_TIMER;
	u8 byVmpId = VMPID_MIN + byVmpIdx;
	if (!IsValidVmpId(byVmpId))
	{
		return;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	TPeriEqpStatus tOldStatus;
	if ( g_cMcuVcApp.GetPeriEqpStatus( tVmpEqp.GetEqpId(), &tOldStatus ) ) 
	{	
		LogPrint(LOG_LVL_KEYSTATUS,MID_MCU_CONF,"[ProcWaitAllVMPPrestInAckTimer] Waiting time out for All vmp presetInAck, vmpstatus:%d!\n", tOldStatus.m_tStatus.tVmp.m_byUseState);
		// vmp已开启状态下,收到Presetin超时处理,应保持其状态,不停vmp
		if (TVmpStatus::START == tOldStatus.m_tStatus.tVmp.m_byUseState)
		{
			/*SetTimer(MCUVC_VMP_WAITVMPRSP_TIMER, 6*1000);
			tOldStatus.m_tStatus.tVmp.m_byUseState = TVmpStatus::WAIT_STOP;
			g_cMcuVcApp.SetPeriEqpStatus(m_tVmpEqp.GetEqpId() , &tOldStatus);*/	
		}
		else
		{
			// 非START状态下,直接停vmp
			CServMsg cTempServ;
			SendMsgToEqp(tVmpEqp.GetEqpId(), MCU_VMP_STOPVIDMIX_REQ, cTempServ); 
			
			// 加保护,非START状态下,将状态置为IDLE
			ProcVMPStopSucRsp(tVmpEqp.GetEqpId());
		}
	}
	
}

/*====================================================================
函数名      ：ProcAgtSvgE1BandWidthNotif
功能        ：处理单板上报E1终端带宽指示
算法实现    ：
引用全局变量：
输入参数说明：const CMessage * pcMsg, 传入的消息
返回值说明  ：
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/12/21    4.0         朱胜泽         创建
====================================================================*/
void CMcuVcInst::ProcAgtSvgE1BandWidthNotif(const CMessage * pcMsg)
{
    //虚端口带宽
    u16 wBandWidthEachPort[MAXNUM_E1PORT];
    memset(wBandWidthEachPort, 0,  sizeof(wBandWidthEachPort));
    memcpy( wBandWidthEachPort, pcMsg->content, sizeof(wBandWidthEachPort));

    //虚端口配置E1对数
    u8 byPortE1Num[MAXNUM_E1PORT];
    memset(byPortE1Num, 0, sizeof(byPortE1Num));
    memcpy( byPortE1Num, pcMsg->content + sizeof(wBandWidthEachPort), sizeof(byPortE1Num));

    //本端Dri2 ip地址
    u32 dwDri2Ip = *(u32*)(pcMsg->content + sizeof(wBandWidthEachPort) + sizeof(byPortE1Num));
    dwDri2Ip = ntohl(dwDri2Ip);
 
    TDri2E1Cfg tDri2E1Cfg[MAXNUM_SUB_MCU];
    g_cMcuVcApp.GetDri2E1CfgTable(tDri2E1Cfg);
    u16 dwMMcuBand = 0; //上级MCU带宽

	CServMsg cServMsg( NULL,0 );
	TLogicalChannel tLogicChan;
	CMessage cMsg;
    for ( u8 byCfgIdx = 0; byCfgIdx < MAXNUM_SUB_MCU; byCfgIdx++)
    {//遍历所有配置项
        if ( tDri2E1Cfg[byCfgIdx].IsInvalid() )
        {
            continue;
        }
        
        u32 dwConIpAddr = tDri2E1Cfg[byCfgIdx].GetIpAddr();               
        BOOL32 bHasMcuInConf = FALSE;
        
        //通过ip找到与当前与会终端
        for (u8 byMtId = 1; byMtId <= MAXNUM_CONF_MT; byMtId++)
        {
			ConfPrint(LOG_LVL_DETAIL,MID_MCU_MT2,"[ProcAgtSvgE1BandWidthNotif] MtId:%d,MtIP:0x%x,DriCfgIp[%d]:0x%x\n",byMtId,m_ptMtTable->GetIPAddr(byMtId),byCfgIdx,tDri2E1Cfg[byCfgIdx].GetIpAddr());
            if ( dwConIpAddr == m_ptMtTable->GetIPAddr(byMtId) &&
                m_tConfAllMtInfo.MtJoinedConf( byMtId )
                )
            {
                u8 byPort = tDri2E1Cfg[byCfgIdx].GetPortNO();

                //级联上级当前带宽
                if ( !m_tCascadeMMCU.IsNull() && 
                     byMtId == m_tCascadeMMCU.GetMtId() && 
                     dwDri2Ip == tDri2E1Cfg[byCfgIdx].GetDriIp())
                {
                    dwMMcuBand = wBandWidthEachPort[byPort];
					m_ptMtTable->SetSndBandWidth(m_tCascadeMMCU.GetMtId(),dwMMcuBand-GetAudioBitrate(m_tConf.GetMainAudioMediaType()));
					m_ptMtTable->SetRcvBandWidth(m_tCascadeMMCU.GetMtId(),dwMMcuBand-GetAudioBitrate(m_tConf.GetMainAudioMediaType()));
                    
					ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MT2,"[ProcAgtSvgE1BandWidthNotif]MMcu BandWidth is %d!\n", dwMMcuBand);

					m_ptMtTable->SetMtTransE1( m_tCascadeMMCU.GetMtId(),TRUE );
					ProcMMcuBandwidthNotify( m_tCascadeMMCU,dwMMcuBand );

					u16 wDialBitRate = m_ptMtTable->GetDialBitrate(byMtId);
					if( dwMMcuBand > wDialBitRate )
					{
						dwMMcuBand = wDialBitRate;
					}
					else if (dwMMcuBand > GetAudioBitrate(m_tConf.GetMainAudioMediaType()))
					{
						dwMMcuBand = dwMMcuBand - GetAudioBitrate(m_tConf.GetMainAudioMediaType());
					}
					else
					{
						ConfPrint(LOG_LVL_WARNING,MID_MCU_MT2,"[ProcAgtSvgE1BandWidthNotif]MMcu<%d> BandWidth is %d, less than audio Bitrate,error!\n",m_tCascadeMMCU.GetMtId(),dwMMcuBand);
						continue;
					}

					//上级MCU做广播源，调整上级MCU发送码率 [10/25/2012 chendaiwei]
					/*TMt tLocalVidBrdSrc = GetLocalVidBrdSrc();*/
                    CServMsg cTmpServMsg;
                    TLogicalChannel tLogicalChannel;
                    if (/*tLocalVidBrdSrc.GetMtId() == m_tCascadeMMCU.GetMtId()
						&&*/ m_ptMtTable->GetMtLogicChnnl(m_tCascadeMMCU.GetMtId(), LOGCHL_VIDEO, &tLogicalChannel, FALSE))
                    {
							u16 wMStremBR = dwMMcuBand;
							if(!m_tDoubleStreamSrc.IsNull())
							{
								wMStremBR = GetDoubleStreamVideoBitrate(dwMMcuBand);
							}

							tLogicalChannel.SetFlowControl(wMStremBR);
							cTmpServMsg.SetMsgBody((u8 *)&tLogicalChannel, sizeof(tLogicalChannel));
							SendMsgToMt(m_tCascadeMMCU.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cTmpServMsg);
							ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MT2,"[ProcAgtSvgE1BandWidthNotif] adjust MMCU sendBandwith to %d!\n", wMStremBR);
                    } 

                    TLogicalChannel tSecLogicalChannel;
                    if (/*tLocalVidBrdSrc.GetMtId() == m_tCascadeMMCU.GetMtId()
						&&*/ m_ptMtTable->GetMtLogicChnnl(m_tCascadeMMCU.GetMtId(), LOGCHL_SECVIDEO, &tSecLogicalChannel, FALSE))
                    {

						u16 wSecBitrate = GetDoubleStreamVideoBitrate(dwMMcuBand,FALSE);
						tSecLogicalChannel.SetFlowControl(wSecBitrate);
						cTmpServMsg.SetMsgBody((u8 *)&tSecLogicalChannel, sizeof(tSecLogicalChannel));
						SendMsgToMt(m_tCascadeMMCU.GetMtId(), MCU_MT_FLOWCONTROL_CMD, cTmpServMsg);
						ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MT2,"[ProcAgtSvgE1BandWidthNotif] adjust MMCU DS sendBandwith to %d!\n", wSecBitrate);
                    }
                }
            	else if ( m_ptMtTable->GetMtType(byMtId) == MT_TYPE_SMCU )
                {
                   	m_ptMtTable->SetMtTransE1(byMtId,TRUE ); 

					if( dwDri2Ip == tDri2E1Cfg[byCfgIdx].GetDriIp() )
					{
						u16 wSMcuVideoBand = 0;
						u16 wDialBitRate = m_ptMtTable->GetDialBitrate(byMtId);
						if( wBandWidthEachPort[byPort] > wDialBitRate )
						{
							wSMcuVideoBand = wDialBitRate;
						}
						else if(wBandWidthEachPort[byPort] > GetAudioBitrate(m_tConf.GetMainAudioMediaType()))
						{
							wSMcuVideoBand = wBandWidthEachPort[byPort] - GetAudioBitrate(m_tConf.GetMainAudioMediaType());
						}
						else
						{
							ConfPrint(LOG_LVL_WARNING,MID_MCU_MT2,"[ProcAgtSvgE1BandWidthNotif]SMcu<%d> BandWidth is %d, less than audio Bitrate,error!\n",byMtId,wBandWidthEachPort[byPort]);
							continue;
						}

						m_ptMtTable->SetSndBandWidth(byMtId,wSMcuVideoBand);
						m_ptMtTable->SetRcvBandWidth(byMtId,wSMcuVideoBand);
						//根据带宽变化调源及下级MCU[10/24/2012 chendaiwei]

						cServMsg.SetSrcMtId( byMtId );
						tLogicChan.SetMediaType(MODE_VIDEO);
						tLogicChan.SetFlowControl(wSMcuVideoBand);
						cServMsg.SetMsgBody((u8*)&tLogicChan, sizeof(TLogicalChannel));
						
						cMsg.content = cServMsg.GetServMsg();
						cMsg.length = cServMsg.GetServMsgLen();
						ProcMtMcuFlowControlCmd(&cMsg, TRUE);
					}
                }
                else
                {
                    ConfPrint(LOG_LVL_KEYSTATUS,MID_MCU_MT2,"[ProcAgtSvgE1BandWidthNotif]mt%d(ip is %u) not mcu, Cfg is wrong!\n", byMtId, dwConIpAddr);
                    continue;
                }   
            }
        }
    }
       	
	return;
}

/*==============================================================================
函数名    :  UpdateConfVmpParam
功能      :  将VmpParam信息从PeriVmpParam中更新到ConfVmpParam
算法实现  :  
参数说明  :  
返回值说明:  void
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2013-03-05                yanghuaizhi
==============================================================================*/
void CMcuVcInst::UpdateConfVmpParam(u8 byVmpId)
{
	if (!IsValidVmpId(byVmpId))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[UpdateConfVmpParam]VmpId is wrong,id:%u.\n", byVmpId);
		return;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );

	// 获得下级终端别名(别名扩容支持)
	GetSmcuMtAliasInVmp(byVmpId);

	TPeriEqpStatus tPeriEqpStatus;
	g_cMcuVcApp.GetPeriEqpStatus(byVmpId , &tPeriEqpStatus);
	TVMPParam_25Mem  tPeriVmpParam = tPeriEqpStatus.m_tStatus.tVmp.GetVmpParam();
	TVMPParam_25Mem  tConfVMPParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
	TVMPMember tVMPMemberOld;
	TVMPMember tVMPMemberNew;
	TMt tMtMember;
	for (u8 byIdx = 0; byIdx < tConfVMPParam.GetMaxMemberNum(); byIdx++)
	{
		tVMPMemberOld = *tConfVMPParam.GetVmpMember(byIdx);
		tVMPMemberNew = *tPeriVmpParam.GetVmpMember(byIdx);
		
		/* 旧通道属性是vmp单通道轮询,新通道属性不是时,需停vmp单通道轮询
		if (VMP_MEMBERTYPE_VMPCHLPOLL == tVMPMemberOld.GetMemberType() &&
			VMP_MEMBERTYPE_VMPCHLPOLL != tVMPMemberNew.GetMemberType())
		{
			ProcStopVmpPoll();
		}*/

		// 如果新旧成员相等,跳过,通道原成员是双流源主流被切成双流跟随时,仍要恢复双流源主流分辨率
		if (tVMPMemberOld.GetMcuIdx() == tVMPMemberNew.GetMcuIdx() &&
			tVMPMemberOld.GetMtId() == tVMPMemberNew.GetMtId() &&
			VMP_MEMBERTYPE_DSTREAM != tVMPMemberNew.GetMemberType())
		{
			continue;
		}
		
		// 针对vcs会议,若是终端移位,因不发送presetin,此处不释放多回传资源
		if (VCS_CONF == m_tConf.GetConfSource() &&
			!tVMPMemberOld.IsNull() &&
			tPeriVmpParam.IsMtInMember(tVMPMemberOld)) 
		{
			continue;
		}
		
		//双流跟随通道,无需释放多回传资源
		if (VMP_MEMBERTYPE_DSTREAM == tVMPMemberOld.GetMemberType())
		{
			continue;
		}
		if (m_tConfAllMtInfo.MtJoinedConf( tVMPMemberOld ))
		{
			//对旧合成成员释放其多回传资源
			FreeRecvSpy( tVMPMemberOld, MODE_VIDEO );
			
			//20100903_tzy VCS会议下自动画面合成模式时，出画面合成器终端也移除出混音器
			if (m_tConf.GetConfSource() == VCS_CONF && tConfVMPParam.IsVMPAuto() &&
				( !m_cVCSConfStatus.GetMtInTvWallCanMixing() || 
				(m_cVCSConfStatus.GetMtInTvWallCanMixing() && 
				IsMtNotInOtherTvWallChnnl((TMt)tVMPMemberOld,0,0) && IsMtNotInOtherHduChnnl((TMt)tVMPMemberOld,0,0)))				
				)
			{
				tMtMember = (TMt)tVMPMemberOld;
				RemoveSpecMixMember(&tMtMember,1,FALSE,TRUE);
				if (!tMtMember.IsLocal() && !IsLocalAndSMcuSupMultSpy(tMtMember.GetMcuIdx()))
				{
					tMtMember = GetLocalMtFromOtherMcuMt(tMtMember);
					RemoveSpecMixMember(&tMtMember,1,FALSE,FALSE);
				}
				
				// miaoqingsong [2010/08/11] 组呼画面合成点名模式下，切换调度终端，老的先出混音新的调度终端再进混音 
				TMt tCurMT = m_cVCSConfStatus.GetCurVCMT() ;
				if (!tCurMT.IsNull())
				{
					AddSpecMixMember(&tCurMT, 1, TRUE);
				}
			}
			
			if( VCS_CONF == m_tConf.GetConfSource() )
			{
				NotifyMtSpeakStatus( (TMt)tVMPMemberOld, emCanceled );
			}
		}
	}

	g_cMcuVcApp.SetConfVmpParam(tVmpEqp, tPeriVmpParam);
}

/*==============================================================================
函数名    :  AdjustMtResInLastVmpParam
功能      :  调整旧通道成员分辨率
算法实现  :  
参数说明  :  
返回值说明:  void
-------------------------------------------------------------------------------
修改记录  :  
日  期       版本          修改人          走读人          修改记录
2013-03-05                yanghuaizhi
==============================================================================*/
void CMcuVcInst::AdjustMtResInLastVmpParam(u8 byVmpId)
{
	if (!IsValidVmpId(byVmpId))
	{
		LogPrint(LOG_LVL_ERROR, MID_MCU_VMP, "[UpdateConfVmpParam]VmpId is wrong,id:%u.\n", byVmpId);
		return;
	}
	TEqp tVmpEqp = g_cMcuVcApp.GetEqp( byVmpId );
	
	TVMPParam_25Mem tConfVMPParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);
	TVMPParam_25Mem tLastVMPParam = g_cMcuVcApp.GetLastVmpParam(tVmpEqp);
	TVmpChnnlInfo tVmpChnnlInfo = g_cMcuVcApp.GetVmpChnnlInfo(tVmpEqp);
	TVMPMember tConfVMPMember;
	TVMPMember tLastVMPMember;
	for (u8 byIdx = 0; byIdx < tLastVMPParam.GetMaxMemberNum(); byIdx++)
	{
		tVmpChnnlInfo = g_cMcuVcApp.GetVmpChnnlInfo(tVmpEqp);
		tConfVMPMember = *tConfVMPParam.GetVmpMember(byIdx);
		tLastVMPMember = *tLastVMPParam.GetVmpMember(byIdx);
		
		// 如果新旧成员相等,跳过,通道原成员是双流源主流被切成双流跟随时,仍要恢复双流源主流分辨率
		if (tLastVMPMember.GetMcuIdx() == tConfVMPMember.GetMcuIdx() &&
			tLastVMPMember.GetMtId() == tConfVMPMember.GetMtId() &&
			tLastVMPMember.GetMemberType() == tConfVMPMember.GetMemberType())
		{
			continue;
		}
		
		// 前后该通道Mt不一致,且新的Member为空,先按通道号清理此通道对应前适配信息
		if (!tLastVMPMember.IsNull()/* && tConfVMPMember.IsNull()*/)
		{
			//清空此通道对应前适配信息
			tVmpChnnlInfo.ClearChnlByVmpPos(byIdx);
			g_cMcuVcApp.SetVmpChnnlInfo(tVmpEqp, tVmpChnnlInfo);
		}
		
		// 针对vcs会议,若是终端移位,之后会调整其分辨率
		if (VCS_CONF == m_tConf.GetConfSource() &&
			!tLastVMPMember.IsNull() &&
			tConfVMPParam.IsMtInMember(tLastVMPMember)) 
		{
			continue;
		}
		
		//双流跟随通道,无需恢复分辨率
		if (VMP_MEMBERTYPE_DSTREAM == tLastVMPMember.GetMemberType())
		{
			continue;
		}

		if (m_tConfAllMtInfo.MtJoinedConf( tLastVMPMember ))
		{
			ChangeMtResFpsInVmp(byVmpId, tLastVMPMember, &tConfVMPParam, FALSE);
			/*GetChlOfMtInVmpParam(tConfVMPParam, tLastVMPMember, byChnlNum, abyChnlNo);
			if (0 == byChnlNum)
			{
				ChangeMtVideoFormat(tLastVMPMember, &tConfVMPParam, FALSE);
			}
			else
			{
				ChangeMtVideoFormat(tLastVMPMember, &tConfVMPParam);
			}*/
		}
	}
}

/*====================================================================
函数名      ：GetVmpChnnlNumbySpecMemberType
功能        ：取VMP某种通道类型的计数
算法实现    ：
引用全局变量：
注意		：
输入参数说明：u8 byMemberType, 传入的通道类型
			　
返回值说明  ：u8
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/11/03    4.6         彭国锋         创建
====================================================================*/
u8 CMcuVcInst::GetVmpChnnlNumBySpecMemberType(u8 byMemberType, TMt* ptMt /*= NULL*/)
{
	TVMPParam_25Mem tVmpParam;
	u8 byRetNum = 0;
	
	TEqp tVmpEqp;
	for (u8 byIdx=0; byIdx<MAXNUM_CONF_VMP; byIdx++)
	{
		if (!IsValidVmpId(m_abyVmpEqpId[byIdx]))
		{
			continue;
		}
		tVmpEqp = g_cMcuVcApp.GetEqp( m_abyVmpEqpId[byIdx] );
		tVmpParam = g_cMcuVcApp.GetConfVmpParam(tVmpEqp);

		for (u8 byChnl = 0; byChnl < MAXNUM_VMP_MEMBER/*tVmpParam.GetVMPMemberNum()*/; byChnl++)
		{
			TVMPMember *ptVmpMem = tVmpParam.GetVmpMember(byChnl);
			
			if ( ptVmpMem == NULL)
			{
				continue;
			}
			
			if ( ptVmpMem->GetMemberType() == byMemberType)
			{
				if (NULL == ptMt)
				{
					byRetNum++;
				}
				else if (!ptMt->IsNull() && (*ptMt) == (*ptVmpMem))
				{
					byRetNum++;
				}
			}
		}
	}
	return byRetNum;
}

/*====================================================================
函数名      ：GetTvWallChnnlNumBySpecMemberType
功能        ：取TvWall某种通道类型的计数
算法实现    ：
引用全局变量：
注意		：
输入参数说明：u8 byMemberType, 传入的通道类型
			　u8 &byVidNum，返回的视频计数
			　u8 &byAudNum，返回的音频计数
			　
返回值说明  ：无
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/11/25    4.6         彭国锋         创建
====================================================================*/
void CMcuVcInst::GetTvWallChnnlNumBySpecMemberType(u8 byMemberType, u8 &byVidNum, u8 &byAudNum)
{
	byVidNum = byAudNum = 0;
	TPeriEqpStatus tTWStatus;

	for ( u8 byEqpIdx = TVWALLID_MIN; byEqpIdx <= TVWALLID_MAX; byEqpIdx++)
	{
		if ( EQP_TYPE_TVWALL == g_cMcuVcApp.GetEqpType(byEqpIdx))
		{
			g_cMcuVcApp.GetPeriEqpStatus(byEqpIdx, &tTWStatus);

			if ( tTWStatus.m_byOnline != 0)
			{
				u8 byChnnlType = 0;
				u8 byConfIdx = 0;
				u8 byMode = MODE_NONE;

				for (u8 byChnnlIdx = 0; byChnnlIdx < MAXNUM_PERIEQP_CHNNL; byChnnlIdx++)
				{
					byChnnlType = tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnnlIdx].byMemberType;
					byConfIdx = tTWStatus.m_tStatus.tTvWall.atVideoMt[byChnnlIdx].GetConfIdx();
					byMode = g_cMcuVcApp.GetChnnlMMode(byEqpIdx, byChnnlIdx);

					if ( byChnnlType == byMemberType && byConfIdx == m_byConfIdx)
					{
						if ( byMode == MODE_BOTH)
						{
							byVidNum++;
							byAudNum++;
						}
						else if ( byMode == MODE_AUDIO)
						{
							byAudNum++;
						}
						else if ( byMode == MODE_VIDEO)
						{
							byVidNum++;
						}
					}
				}
			}
		}
	}
}

/*====================================================================
函数名      ：GetHduChnnlNumBySpecMemberType
功能        ：取Hdu某种通道类型的计数
算法实现    ：
引用全局变量：
注意		：
输入参数说明：u8 byMemberType, 传入的通道类型
			　u8 &byVidNum，返回的视频计数
			　u8 &byAudNum，返回的音频计数
			　
返回值说明  ：无
----------------------------------------------------------------------
修改记录    ：
日  期      版本        修改人        修改内容
11/11/25    4.6         彭国锋         创建
====================================================================*/
void CMcuVcInst::GetHduChnnlNumBySpecMemberType(u8 byMemberType, u8 &byVidNum, u8 &byAudNum)
{
	byVidNum = byAudNum = 0;
	TPeriEqpStatus tHduStatus;
	
	for ( u8 byEqpIdx = HDUID_MIN; byEqpIdx <= HDUID_MAX; byEqpIdx++)
	{
		if(IsValidHduEqp(g_cMcuVcApp.GetEqp(byEqpIdx)))
		{
			u8 byHduChnnlNum = g_cMcuVcApp.GetHduChnNumAcd2Eqp(g_cMcuVcApp.GetEqp(byEqpIdx));

			if ( byHduChnnlNum == 0)
			{
				continue;
			}

			g_cMcuVcApp.GetPeriEqpStatus(byEqpIdx, &tHduStatus);

			if ( tHduStatus.m_byOnline != 0)
			{
				u8 byChnnlType = 0;
				u8 byConfIdx = 0;
				u8 byMode = MODE_NONE;

				for (u8 byChnnlIdx = 0; byChnnlIdx < min(byHduChnnlNum,MAXNUM_HDU_CHANNEL); byChnnlIdx++)
				{
					byChnnlType = tHduStatus.m_tStatus.tHdu.atVideoMt[byChnnlIdx].byMemberType;
					byConfIdx = tHduStatus.m_tStatus.tHdu.atVideoMt[byChnnlIdx].GetConfIdx();
					byMode = g_cMcuVcApp.GetChnnlMMode(byEqpIdx, byChnnlIdx);

					if ( byChnnlType == byMemberType && byConfIdx == m_byConfIdx)
					{
						if ( byMode == MODE_BOTH)
						{
							byVidNum++;
							byAudNum++;
						}
						else if ( byMode == MODE_AUDIO)
						{
							byAudNum++;
						}
						else if ( byMode == MODE_VIDEO)
						{
							byVidNum++;
						}
					}
				}
			}
		}
	}
}
/*====================================================================
    函数名      ProcHduMcuRsp
    功能        ：HDU回应MCU消息处理函数
    算法实现    ：.
    引用全局变量：
    输入参数说明：const CMessage * pcMsg, 传入的消息
    返回值说明  ：
----------------------------------------------------------------------
    修改记录    ：
    日  期      版本        修改人        修改内容
	12/02/21    4.7        田志勇         创建
	2013/03/11  4.7.2       陈兵          修改(HDU多画面支持)
====================================================================*/
void CMcuVcInst::ProcHduMcuRsp( const CMessage * pcMsg )
{
	CServMsg       cServMsg(pcMsg->content, pcMsg->length);	
    THduStartPlay  tHduStartPlay;
	u16 wIndex = 0;
	u8 byHduSubChnId = 0;
	u8 byHduMode = 0;

	u8  byEqpId   = cServMsg.GetEqpId();
	u8  byChnId   = cServMsg.GetChnIndex();
	u8  byEqpType = g_cMcuVcApp.GetEqpType(byEqpId);

	if (CurState() == STATE_SCHEDULED)
	{
		ConfPrint(LOG_LVL_WARNING, MID_MCU_HDU,  "[ProcHduMcuRsp] CurState(%d) != STATE_ONGOING\n",CurState());
		return;
	}

	if (byChnId >= MAXNUM_HDU_CHANNEL)
	{
		return;
	}

	TPeriEqpStatus tHduStatus;
	g_cMcuVcApp.GetPeriEqpStatus(byEqpId, &tHduStatus);

	switch (pcMsg->event)
	{
	case HDU_MCU_START_PLAY_ACK:
	case HDU_MCU_START_PLAY_NACK:
		{
			tHduStartPlay = *(THduStartPlay*)cServMsg.GetMsgBody();
			wIndex += sizeof(THduStartPlay);
			//TDoublePayload  tDoubleVidPayload = *(TDoublePayload*)(cServMsg.GetMsgBody() + wIndex);
			wIndex += sizeof(TDoublePayload);
			//TDoublePayload  tDoubleAudPayload = *(TDoublePayload*)(cServMsg.GetMsgBody() + wIndex);
			wIndex += sizeof(TDoublePayload);
			//THDUExCfgInfo tHDUExCfgInfo = *(THDUExCfgInfo *)(cServMsg.GetMsgBody() + wIndex);
			wIndex += sizeof(THDUExCfgInfo);
			//TTransportAddr tAudRemoteAddr = *(TTransportAddr *)(cServMsg.GetMsgBody() + wIndex);;
			wIndex += sizeof(TTransportAddr);
			//u8 byAudChnNum = *(u8 *)(cServMsg.GetMsgBody() + wIndex);
			wIndex += sizeof(u8);
			
			// [2013/03/11 chenbing] 解析HDU子通道Id与通道模式
			byHduSubChnId = *(u8 *)(cServMsg.GetMsgBody() + wIndex);
			wIndex += sizeof(u8);
			byHduMode = *(u8 *)(cServMsg.GetMsgBody() + wIndex);
			wIndex += sizeof(u8);
		
			if ( HDU_MCU_START_PLAY_ACK == pcMsg->event )
			{
				if ( THduChnStatus::eWAITSTART == tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnId, byHduSubChnId)
					|| THduChnStatus::eWAITCHGMODE == tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnId, byHduSubChnId)
					|| THduChnStatus::eREADY == tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnId, byHduSubChnId)
				   )
				{
					tHduStatus.m_tStatus.tHdu.SetChnStatus(byChnId, byHduSubChnId, THduChnStatus::eRUNNING);
					// 保存切换的风格
					tHduStatus.m_tStatus.tHdu.SetChnCurVmpMode(byChnId, byHduMode);
				}

				ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_EQP,
					"[ProcHduMcuRsp]: StartHduChnnl Success ChnId(%d), SubChnid(%d) Vmp-Mode(%d)\n return HDU_MCU_START_PLAY_ACK OK !!!\n",
					 byChnId, byHduSubChnId, byHduMode);	
			}
			else
			{
				//开启四风格子通道失败不能清除会议号及预案号
				if ( HDUCHN_MODE_ONE == byHduMode )
				{
					tHduStatus.m_tStatus.tHdu.SetConfIdx(0, byChnId);
					tHduStatus.m_tStatus.tHdu.SetSchemeIdx(0, byChnId);
				}

				tHduStatus.m_tStatus.tHdu.SetMemberType(0, byChnId, byHduSubChnId);
				tHduStatus.m_tStatus.tHdu.SetChnNull(byChnId, byHduSubChnId);
				tHduStatus.m_tStatus.tHdu.SetMcuId(0, byChnId, byHduSubChnId);
				tHduStatus.m_tStatus.tHdu.SetMemberType(0, byChnId, byHduSubChnId);
				tHduStatus.m_tStatus.tHdu.SetChnStatus(byChnId, byHduSubChnId, THduChnStatus::eREADY);

				//拆除到通道的交换
				StopSwitchToPeriEqp(byEqpId, byChnId, TRUE, tHduStartPlay.GetMode(), SWITCH_MODE_BROADCAST, byHduSubChnId);
				ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ProcHduMcuRsp]: StartHduChnnl Fail, return NACK!!!\n" );
			}
		}
		break;

	case HDU_MCU_CHGHDUVMPMODE_ACK:
		if (THduChnStatus::eWAITCHGMODE == tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnId)
			|| THduChnStatus::eREADY == tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnId)
			|| THduChnStatus::eWAITSTART == tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnId))
		{
			byHduMode = *(u8 *)(cServMsg.GetMsgBody());

			if (TW_MEMBERTYPE_BATCHPOLL != tHduStatus.m_tStatus.tHdu.GetMemberType(byChnId, byHduSubChnId))
			{
				if ( HDUCHN_MODE_FOUR == byHduMode )
				{
					for (u8 byIndex=0; byIndex<HDU_MODEFOUR_MAX_SUBCHNNUM; byIndex++)
					{
						//清除成员类型
						tHduStatus.m_tStatus.tHdu.SetMemberType(0, byChnId, byIndex);
						//McuId置0
						tHduStatus.m_tStatus.tHdu.SetMcuId(0, byChnId, byIndex);
						//初始化通道状态
						tHduStatus.m_tStatus.tHdu.SetChnStatus(byChnId, byIndex, THduChnStatus::eREADY);
					}
				}
				else
				{
					//清除会议号
					tHduStatus.m_tStatus.tHdu.SetConfIdx(0, byChnId);
					//McuId置0
					tHduStatus.m_tStatus.tHdu.SetMcuId(0, byChnId);
					//初始化通道状态
					tHduStatus.m_tStatus.tHdu.SetChnStatus(byChnId, 0, THduChnStatus::eREADY);
				}
			}
			
			g_cMcuVcApp.SetChnnlMMode(byEqpId, byChnId, MODE_NONE);
			// 保存切换的风格
			tHduStatus.m_tStatus.tHdu.SetChnCurVmpMode(byChnId, byHduMode);
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_EQP,
				"[ProcHduMcuRsp]: ChangeHduMode Success, Chnreturn HDU_MCU_CHGHDUVMPMODE_ACK  OK!!!\n" );
		}
		break;

	case HDU_MCU_CHGHDUVMPMODE_NACK:
		{
			//一风格切换至四风格失败需要清除会议号
			if ( HDUCHN_MODE_FOUR == byHduMode )
			{
				//清除会议号
				tHduStatus.m_tStatus.tHdu.SetConfIdx(0, byChnId);
			}

			//初始化通道状态
			tHduStatus.m_tStatus.tHdu.SetChnStatus(byChnId, 0, THduChnStatus::eREADY);
			// 保存旧风格
			tHduStatus.m_tStatus.tHdu.SetChnCurVmpMode(byChnId, tHduStatus.m_tStatus.tHdu.GetChnCurVmpMode(byChnId));
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_EQP,
					"[ProcHduMcuRsp]: ChangeHduMode Fail, return HDU_MCU_CHGHDUVMPMODE_NACK!!!\n" );
		}
		break;

	case HDU_MCU_STOP_PLAY_ACK:
	case HDU_MCU_STOP_PLAY_NACK:
		{
			// [2013/03/11 chenbing] 解析HDU子通道Id与通道模式
			byHduSubChnId = *(u8 *)(cServMsg.GetMsgBody() + sizeof(TEqp));
			tHduStatus.m_tStatus.tHdu.SetChnStatus(byChnId, byHduSubChnId, THduChnStatus::eREADY);
			ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_EQP, "[ProcHduMcuRsp]: StopHduChnnl %s!!!\n", ::OspEventDesc(pcMsg->event) );
		}
		break;

	default:
		break;
	}

	CServMsg cSMsg;
	cSMsg.SetEqpId(byEqpId);
	cSMsg.SetChnIndex(byChnId);
	cSMsg.SetMsgBody((u8 *)&tHduStatus, sizeof(tHduStatus));
	SendMsgToAllMcs(MCU_MCS_MCUPERIEQPSTATUS_NOTIF, cSMsg);

	ConfPrint( LOG_LVL_DETAIL, MID_MCU_EQP, "[ProcHduMcuRsp]: Send MCU_MCS_MCUPERIEQPSTATUS_NOTIF Success!!!\n");
	ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_EQP, "Mcs HduId(%d) ChnId(%d) HduSubChnId(%d) Vmp-Mode(%d) MeMber:(%d) Status(%d)!!!\n",
				byEqpId, byChnId, byHduSubChnId, byHduMode, tHduStatus.m_tStatus.tHdu.GetMemberType(byChnId),
				tHduStatus.m_tStatus.tHdu.GetChnStatus(byChnId, byHduSubChnId) );

	ConfPrint( LOG_LVL_KEYSTATUS, MID_MCU_EQP, "TMt.McuId(%d), TMt.MtId(%d) TMt.ConfIdx(%d)!!!\n",
		tHduStatus.m_tStatus.tHdu.GetChnMt(byChnId, byHduSubChnId).GetMcuId(),
		tHduStatus.m_tStatus.tHdu.GetChnMt(byChnId, byHduSubChnId).GetMtId(),
		tHduStatus.m_tStatus.tHdu.GetConfIdx(byChnId, byHduSubChnId));

	g_cMcuVcApp.SetPeriEqpStatus(byEqpId, &tHduStatus);
}
// end of file