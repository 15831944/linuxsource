
Dec 14th

		1、支持Linux

11月18日
		1, 为CModemCmdProxy类补充了所有命令的Query接口；
		2，修改MdcomCommand和MdcomCheck两个命令的接口：由int cmd改为const char *cmd。
		　 对于MdcomCommand, CMD为如下格式：set|query mod|dem flag
		   对于MdcomCheck,   CMD为如下格式：mod|dem flag
		   其中，flag可以为bitrate, output, freq, clksrc。

11月11日　
　　完成了编写测试代码。
　　测试代码完全是对模块内部的测试。对模块整体的测试，由于牵涉到MODEM，仍然用原来的测试程序。
　　所有的代码都加入到版本树中，以后直接在版本树上修改，而不再维护一个本地的代码。

11月10日

　　1，命令执行的超时问题：目前的策略是不调超时处理，任何时候，只要接收到响应，就更改对应的状态，以总是反应MODEM的最新状态。也就是说，不需要Set，直接调用Check是可能成功的。或者说，SET一个命令时，返回的包里包含了另一个命令的值，则对另一个命令直接Check，结果也是正确的。
    这样的问题就是：不能保证Set与Check的执行次序与有效期限；除非每个IP对应的状态自从使用就一直存在，否则，若命令表满，而有新的IP时，就不方便决定替换哪些IP了。
    
    2，目前的连发和重发策略是：以顺序号为优先级，总是优先发送顺序号低的命令。可能产生的后果是：如果上层一直在设置一个低序号命令，则高序号命令的连发和重发将不起作用，发送仍然正常。
    对于这种情况，首先，上层应该保证，在重试结束后再设置命令；其次，重新设置高序号命令就可发送出去。因为发送总是比连发和重发的优先级高。
    

11月08日　　增加：可以一次接收多个协议包
    1, DisassemRecvPack的返回值，将不是成功与否，而是一共解析出来了多少个包。另外一个策略是：如果在解析一个包时，只要它的验证通过，就认为是一个正确的包，而不管包里的数据如何。比如说，0x41包含两个设置值：Freq，Output，而Output的返回值为任何值都是正确的，这时，即使Freq为零，仍然认为这个包是正确的。
    
    2, 在test中增加专门测试此函数的过程：testDisassemPack。测试的过程如下：
    　　A，先测试单个正确、完整的包；
    		B，测试任何多个正确、完整的包的合并；
    		C，测试包含不正确的开头；
    		D，测试包含不正确的结尾；
    因为这是一个过程测试，所有的测试只需要一遍即可。所有测试路径都覆盖一遍即可，不要求完全覆盖；
    
    	

11月06日　　调整性能
		目前上层在调用MODEM库时，对于一个IP的几个设置，是一次性发过去的。由于库没有加保护，MODEM会在极短的时间内连续收到几条命令。有一些可能会被MODEM丢弃。但是，往往不会只留有一条，而是多条。这样，就会在极短的时间内回应多条。然而在接收UDP时，会因为这几个回应间隔太短，而一次收到。原来的协议包验证就会出错，将所有的包都丢弃。


11月04日		增加功能

1，调试信息输出
  有两个接口：MdcomReport, MdcomMsgLog(新增)，均为无参
  MdcomReport的功能是统计发送接收包的次数，正确率，其输出如下：
			Mdcom summary:
			Send: 13	Receive: 0
			Success: 0	Fail: 8	Timeout: 13
  其中，Send是指所有正确装配，并且发送出的协议包个数；Receive是指所有接收到的，并且通过验证的协议包的个数。Timeout为两者的差，表示MODEM收到，但没有回应，或者没有正确回应的个数；Success：为首次发送成功总数；Fail为重试总数；
  MdcomMsgLog是一个开关，用于打开或关闭调试信息的输出。系统默认为关闭。它的输出包括三部分：接收的命令；发送出去的包的内容，接收到的包的内容（未验证的）。

2，发送和检查命令MdcomCommand, MdcomCheck
  int  MdcomCommand	(int cmd, const char* ip, u16 port, u32 value);
  只能发送程序已经封装好的几个命令，而且命令代码即参数cmd必须遵循已有的定义：
	#define  MDCOM_SET_MOD_FREQ             0       //设置发送频点
	#define  MDCOM_SET_MOD_OUTPUT           1       //设置发送是否开始
	#define  MDCOM_SET_MOD_BITRATE          2       //设置发送码率
	#define  MDCOM_SET_MOD_CLKSRC           3       //设置发送时钟源

	#define  MDCOM_SET_DEM_FREQ             4       //设置接收频点
	#define  MDCOM_SET_DEM_BITRATE          5       //设置接收码率
	#define  MDCOM_SET_DEM_CLKSRC           6       //设置接收时钟源
	/* 查询命令均是对应的SET命令或上0x100 */
	#define  MDCOM_QUERY_MOD_OUTPUT                 \
            MDCOM_SET_MOD_OUTPUT | 0x100          //查询发送是否开始
  命令代码不在此范围的将以错误处理。
  注意：此函数不对设置值value做任何判断和处理，包括频率转换！
  int  MdcomCheck		(int cmd, const char* ip, u16 port);
  查询已发送的命令，参数同上。返回值即为对应的MODEM的设置值。如果为零，有可能是查询失败。
  
3，设置Modem的接收发送类型
	 void ModemCmdProxy::SetModemIp(u32 nip, u16 nport, enum TModemType type)
　　可以使用的类型已经定义在TModemType中，在使用时，必须设置一个合法类型（虽然此类型只对设置频率有效），否则不能进行任何操作。
   在SetModemIp接口上更改，而不是使用另一个函数，目的是强制每次设置IP时都要设置对应MODEM的类型。目前假设一个IP对应一个MODEM。
    

 
	


10月27日				Mdcom中的时间间隔

1，由于Tonado是基于优先级抢占式的任务调度，而不是时间片轮转的。所以，昨天出现的错误，完全是因为Monitor线程中去掉了taskDelay所致。
   事实上，对于Send和Receive任务，不需要显式地delay的，因为消息队列和SOCKET都是阻塞地接收的。而对于Monitor，事实上，它只要能够保证在命令的超时时限内正确更改命令的状态就可以了。另一方面，完全遍历命令表是非常快的。
   在局域网内，一个命令从发出到返回平均为260ms；若为卫星，估计要700ms。所以，定义了一个宏MONITOR_INTERVAL，用来调节这个时间。
   
2，增加统计：总的发送次数，接收次数，成功率；各个命令的发送次数；成功率；重试次数；对于失败的，记录失败原因；基于每个线程记录。
   

10月23日

1，命令的FLAG标志：如果MODEM的状态未改变，则回应包的FLAG为全零；QUERY命令的回应包也是全零。
   因此，修改以前的策略为：收到回应包的时候，把所有可识别的命令都检索出来。但考虑到，如果FLAG为零， 对应的值可能无意义，所以，对这个值做一个简单的检查，并打印消息，以确认此种情况存在的可能性。




10月22日

1，接收线程
	A，检验收到的数据包是否完整。如果不完整，怎么处理？
	B，拆卸协议包并填入命令表中
		 检索出所有可识别命令，结果填入命令表中，将接收标志置为“已接收”；

2，发送线程
  A，从发送队列中取出一个命令；
  B，装配一个协议包；
  C，发送出去；

3，Monitor线程
	(1) 确定命令的执行状态
		 A，已接收：比较结果，置状态为“一致”，或者“不一致”；
		 B，对于超时，一律置为“无效”；
	注意：执行状态将一直保存，直到再次SET或QUERY命令，才转化。
	(2) 重发指定命令
		 A，对于连发次数不为零，且未接收的：写入发送队列，置“发送”标志；
		 B，对于未超出单次发送时限的，重试次数不为零，已接收，且状态不为“一致”的，写入发送队列，置“发送”标志；

4，命令的执行状态
	A, 发送，接收标志：发送时，置为“已发送，未接收”； 接收时，置为“未发送，已接收”；
	B，执行状态：
		任何状态->发送：        发送时；
		任何状态->接收：        接收时；
		接收->一致，不一致：    Monitor；
		任何状态->无效：				Monitor：超时；









10月21日             实现mdcom模块

1, MdcomInit: 模块初始化
  1A，增设标志，避免重复初始化；
  1B，创建管道：用于应用程序与模块的缓冲，并串行化要发出的命令；创建SOCKET；
  1C，创建命令表：每个IP对应一项，每个IP中包含所有命令的状态。所有命令的执行情况都在这个表中保存。
      共有256项；其中查找、插入、删除的算法均是：以IP的最后一个字节为起始点，循环遍历整个表。
  1D，创建两个线程，一个负责发送，一个负责接收，一个负责扫描命令表中需要删除的值。
      发送线程的任务：从管道中读取待发送命令；装配成协议包；发送出去；
      接收线程的任务：从SOCEK上接收回应命令；拆卸协议包；查找命令表，将命令表内容插入进去；
      扫描线程的任务：定时遍历整个命令表，并按规则修改命令的状态。对于已有回应的，比较命令内容，记录比较结果；对于超时的，修改状态为失败；对于失败次数小于规定(3次)的，将命令重新写入管道中；对于失败次数大于等于3次的，修改状态为失败。


2，管道部分；

3，命令表部分；
   A, 不需要删除命令操作；若表已满，则自动覆盖一项(暂时未实现，以错误返回)。
   B，命令项的保护：接口负责插入；CHECK负责修改状态；接收线程负责修改返回值；所以，目前，并未有冲突。除非在插入中有删除操作，否则，不需要加保护。
   C, 命令项中STATUS的使用：最高位为0表示已发送；为1表示已收到回应；后面几位的用于执行状态；
   D, 对每个命令，也是可以通过一组函数，来封装相应的结构，但是，有必要吗？对于命令表，根据讨论的结果，确实是有必要将其隔离的，所以定义的三个函数以及隐式的类this指针(全局变量)传递，完全就是一个类的实现。协议数据包也是采用这样的形式来实现封装，不过，必须采用显式的this指针了。
   E, 如何定义唯一的命令标识？采用命令项的位置，但同一个命令有读写两种不同的操作，所以高八位来表示读写。采用16位长的命令字。另外，再定义一个命令标识，与命令地址，掩码的映射。
   
4，协议包：
		A, 协议包不再封装，直接写入程序中，因为目前的命令比较简单。如果增加的话，再封装。目前只是由函数隔离开了。
		
5, 同步：
   共有三个线程，系统退出时，只是通知线程退出，并不强制线程退出；
   
6, 接口：
   由于在C接口的基础上增加了一个代理类，因此，对于组合命令，直接在代理类中处理，即分解成两条单个命令。

7, 命令组合
   A, Output与Freq：最好的办法是，当Disable ouput时，要将频率设为最低值。是否需要这样做？这样的话，每次禁止之后，要重新设置频点。